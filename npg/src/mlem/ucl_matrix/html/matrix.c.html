<PRE><LI><H2>FILE: matrix.c</H2>/* @(#)matrix.c	1.11 6/7/93 */
#include	 "<A NAME=2 HREF="matrix.h.html">matrix.h</A>" 

static char sccsid[]="@(#)matrix.c	1.11 6/7/93 Copyright 1989 CTI, Inc.";

static char* magicNumber = "MATRIX";
static int ecat_default_version = 6;

char* datasettype[NumDataSetTypes] =
    {
    "Unknown", "Sinogram", "Image-16", "Attenuation Correction",
    "Normalization", "Polar Map", "Volume-8", "Volume-16", "Projection-8",
    "Projection-16", "Image-8", "3D Sinogram-16", "3D Sinogram-8",
    "3D Normalization"
    };

char* dstypecode[NumDataSetTypes] =
	{ "u","s","i","a","n","pm","v8","v","p8","p","i8","S","S8","N"};

char* scantype[NumScanTypes] =
    {
    "Not Applicable", "Blank <a href="D_subheader.html#Scan">Scan</a>", "Transmission 
    "Static Emission <a href="D_subheader.html#Scan">Scan</a>", "Dynamic Emission", "Gated Emission",
    "Transmission Rectilinear", "Emission Rectilinear"
    };

char* scantypecode[NumScanTypes] =
    { "", "bl", "tx", "se", "de", "ge", "tr", "er"};

int numDisplayUnits = 13;
char* customDisplayUnits[] =
    {"none", "ECAT Counts/Sec", "Bq/ml", "Processed", "microCi/ml",
	"micromole/100g/<a href="lib3d.c.html#min">min</a>", "mg/100g/
	"ml/g", "1/<a href="lib3d.c.html#min">min</a>", "pmole/ml", "nM", NULL};
/* for modelled images :
 * set <a href="matrix.h.html#Main_header">Main_header</a> calibration_units to 2(Processed) and
 * FDG : calibration_units_label to 5("micromole/100g/<a href="lib3d.c.html#min">min</a>") or 6("mg/100g/
 * FLOW : calibration_units_label to 7("ml/100g/<a href="lib3d.c.html#min">min</a>")
 *
 * for other custom units :
 * set <a href="matrix.h.html#Main_header">Main_header</a> calibration_units_label to 0 and data_units to "my units"
 */

float ecfconverter[NumOldUnits] = {1.0, 1.0, 1.0, 3.7e4, 1.0, 1.0, 1.0, 37.0,
    1.0, 1.0, 1.0, 1.0};

char* calstatus[NumCalibrationStatus] =
    {"Uncalibrated", "Calibrated", "Processed"};

char* ecfunits[NumCalibrationStatus] =
    {"ECAT Counts/Sec", "Bq/ml", "Processed"};

char* sexcode = "MFU";
char* dexteritycode = "RLUA";

char* typeFilterLabel[NumDataMasks] =
    {"Sinogram", "Attenuation Correction", "Normalization", "Polar Map",
    "Image", "Volume", "Projection", "3D Sinogram", "Report", "Graph", "ROI",
    "3D Normalization"
    };
<LI><H3><a name="mat_open">FILE *mat_open( fname, fmode)</a></H3>
  char *fname, *fmode;
{
	FILE *fopen(), *fptr;

	fptr = fopen(fname, fmode);
	return (fptr);

}

<LI><H3><a name="mat_close">mat_close( fptr)</a></H3>
  FILE *fptr;
{
	return fclose( fptr);
}

<LI><H3><a name="mat_rblk">int mat_rblk( fptr, blkno, bufr, nblks)</a></H3>
  FILE *fptr;
  int blkno, nblks;
  char *bufr;
{
	int err;

	err = fseek( fptr, (blkno-1)*MatBLKSIZE, 0);
	if (err) return (err);
	err = fread( bufr, 1, nblks*MatBLKSIZE, fptr);
	if (err &lt;= 0) return (-1);
	return (0);
}

<LI><H3><a name="swaw">swaw( from, to, length)</a></H3>
  short int from[], to[];
  int length;
{
	short int temp;
	int i;

	for (i=0;i&lt;length; i+=2)
	{  temp = from[i+1];
	   to[i+1]=from[i];
	   to[i] = temp;
	}
}

<LI><H3><a name="mat_numcod">int mat_numcod( frame, plane, gate, data, bed)</a></H3>
  int frame, plane, gate, data, bed;
{
	return ((frame)|((bed&0xF)&lt;<12)|((plane&0xFF)<<16)|(((plane&0x300)&gt;>8)<<9)|
		   ((gate&0x3F)&lt;<24)|((data&0x3)<<30)|((data&0x4)<<9));
}

<LI><H3><a name="mat_numdoc">int mat_numdoc( matnum, matval)</a></H3>
  int matnum;
  struct <a href="matrix.h.html#Matval">Matval</a> *matval;
{
	matval-&gt;frame = matnum&0x1FF;
	matval-&gt;plane = ((matnum>>16)&0xFF) + (((matnum>>9)&0x3)&lt;<8);
	matval-&gt;gate  = (matnum>>24)&0x3F;
	matval-&gt;data  = ((matnum>>9)&0x4)|(matnum>>30)&0x3;
	matval-&gt;bed   = (matnum>>12)&0xF;
	return 1;
}

<LI><H3><a name="mat_lookup">int mat_lookup(file, matnum, entry)</a></H3>
  MatrixFile *file;
  int matnum;
  struct <a href="matrix.h.html#MatDir">MatDir</a> *entry;
{
	
	int blk, i, err;
	int nfree, nxtblk, prvblk, nused, matnbr, strtblk, endblk, matstat;
	int dirbufr[MatBLKSIZE/4];

	if (file-&gt;mhptr->sw_version &lt; V7)
		return mat_lookup_64(file-&gt;fptr,matnum,entry);
	blk = MatFirstDirBlk;
	while(1) {
		<a href="machine_indep.c.html#read_matrix_data">read_matrix_data</a>(file-&gt;fptr,blk,1,(char*)dirbufr,SunLong);
		nfree  = dirbufr[0];
		nxtblk = dirbufr[1];
		prvblk = dirbufr[2];
		nused  = dirbufr[3];
		for (i=4; i&lt;MatBLKSIZE/4; i+=4)
		{  matnbr  = dirbufr[i];
	   		strtblk = dirbufr[i+1];
	   		endblk  = dirbufr[i+2];
	   		matstat = dirbufr[i+3];
	   		if (matnum == matnbr) {
		  		entry-&gt;matnum  = matnbr;
		  		entry-&gt;strtblk = strtblk;
		  		entry-&gt;endblk  = endblk;
		  		entry-&gt;matstat = matstat;
		  		return (1);
			}
 		}
		blk = nxtblk;
		if (blk == MatFirstDirBlk) break;
	}
	return (0);
}

<LI><H3><a name="unmap_main_header">int unmap_main_header( bufr, header)</a></H3>
  char *bufr;
  <a href="matrix.h.html#Main_header">Main_header</a> *header;
{
	int i = MagicNumLen;			/* skip magic number */
	int j = 0;
	<a href="machine_indep.c.html#bufRead">bufRead</a>(header-&gt;original_file_name, bufr, &i, NameLen);
	header-&gt;original_file_name[NameLen-1] = '\0';
	<a href="machine_indep.c.html#bufRead_s">bufRead_s</a>(&header-&gt;sw_version, bufr, &i);
	<a href="machine_indep.c.html#bufRead_s">bufRead_s</a>(&header-&gt;system_type, bufr, &i);
	<a href="machine_indep.c.html#bufRead_s">bufRead_s</a>(&header-&gt;file_type, bufr, &i);
	<a href="machine_indep.c.html#bufRead">bufRead</a>(header-&gt;serial_number, bufr, &i, 10);
	header-&gt;serial_number[9] = '\0';
	<a href="machine_indep.c.html#bufRead_i">bufRead_i</a>(&header-&gt;scan_start_time, bufr, &i);
	<a href="machine_indep.c.html#bufRead">bufRead</a>(header-&gt;isotope_code, bufr, &i, 8);
	header-&gt;isotope_code[7] = '\0';
	<a href="machine_indep.c.html#bufRead_f">bufRead_f</a>(&header-&gt;isotope_halflife, bufr, &i);
	<a href="machine_indep.c.html#bufRead">bufRead</a>(header-&gt;radiopharmaceutical, bufr, &i, NameLen);
	header-&gt;radiopharmaceutical[NameLen-1] = '\0';
	<a href="machine_indep.c.html#bufRead_f">bufRead_f</a>(&header-&gt;gantry_tilt, bufr, &i);
	<a href="machine_indep.c.html#bufRead_f">bufRead_f</a>(&header-&gt;gantry_rotation, bufr, &i);
	<a href="machine_indep.c.html#bufRead_f">bufRead_f</a>(&header-&gt;bed_elevation, bufr, &i);
	<a href="machine_indep.c.html#bufRead_f">bufRead_f</a>(&header-&gt;intrinsic_tilt, bufr, &i);
	<a href="machine_indep.c.html#bufRead_s">bufRead_s</a>(&header-&gt;wobble_speed, bufr, &i);
	<a href="machine_indep.c.html#bufRead_s">bufRead_s</a>(&header-&gt;transm_source_type, bufr, &i);
	<a href="machine_indep.c.html#bufRead_f">bufRead_f</a>(&header-&gt;distance_scanned, bufr, &i);
	<a href="machine_indep.c.html#bufRead_f">bufRead_f</a>(&header-&gt;transaxial_fov, bufr, &i);
	<a href="machine_indep.c.html#bufRead_s">bufRead_s</a>(&header-&gt;angular_compression, bufr, &i);
	<a href="machine_indep.c.html#bufRead_s">bufRead_s</a>(&header-&gt;coin_samp_mode, bufr, &i);
	<a href="machine_indep.c.html#bufRead_s">bufRead_s</a>(&header-&gt;axial_samp_mode, bufr, &i);
	<a href="machine_indep.c.html#bufRead_f">bufRead_f</a>(&header-&gt;calibration_factor, bufr, &i);
	<a href="machine_indep.c.html#bufRead_s">bufRead_s</a>(&header-&gt;calibration_units, bufr, &i);
	<a href="machine_indep.c.html#bufRead_s">bufRead_s</a>(&header-&gt;calibration_units_label, bufr, &i);
	<a href="machine_indep.c.html#bufRead_s">bufRead_s</a>(&header-&gt;compression_code, bufr, &i);
	<a href="machine_indep.c.html#bufRead">bufRead</a>(header-&gt;study_name, bufr, &i, 12);
	header-&gt;study_name[11] = '\0';
	<a href="machine_indep.c.html#bufRead">bufRead</a>(header-&gt;patient_id, bufr, &i, IDLen);
	header-&gt;patient_id[IDLen-1] = '\0';
	<a href="machine_indep.c.html#bufRead">bufRead</a>(header-&gt;patient_name, bufr, &i, NameLen);
	header-&gt;patient_name[NameLen-1] = '\0';
	<a href="machine_indep.c.html#bufRead">bufRead</a>(header-&gt;patient_sex, bufr, &i, 1);
	<a href="machine_indep.c.html#bufRead">bufRead</a>(header-&gt;patient_dexterity, bufr, &i, 1);
	<a href="machine_indep.c.html#bufRead_f">bufRead_f</a>(&header-&gt;patient_age, bufr, &i);
	<a href="machine_indep.c.html#bufRead_f">bufRead_f</a>(&header-&gt;patient_height, bufr, &i);
	<a href="machine_indep.c.html#bufRead_f">bufRead_f</a>(&header-&gt;patient_weight, bufr, &i);
	<a href="machine_indep.c.html#bufRead_i">bufRead_i</a>(&header-&gt;patient_birth_date, bufr, &i);
	<a href="machine_indep.c.html#bufRead">bufRead</a>(header-&gt;physician_name, bufr, &i, NameLen);
	header-&gt;physician_name[NameLen-1] = '\0';
	<a href="machine_indep.c.html#bufRead">bufRead</a>(header-&gt;operator_name, bufr, &i, NameLen);
	header-&gt;operator_name[NameLen-1] = '\0';
	<a href="machine_indep.c.html#bufRead">bufRead</a>(header-&gt;study_description, bufr, &i, NameLen);
	header-&gt;study_description[NameLen-1] = '\0';
	<a href="machine_indep.c.html#bufRead_s">bufRead_s</a>(&header-&gt;acquisition_type, bufr, &i);
	<a href="machine_indep.c.html#bufRead_s">bufRead_s</a>(&header-&gt;patient_orientation, bufr, &i);
	<a href="machine_indep.c.html#bufRead">bufRead</a>(header-&gt;facility_name, bufr, &i, 20);
	header-&gt;facility_name[19] = '\0';
	<a href="machine_indep.c.html#bufRead_s">bufRead_s</a>(&header-&gt;num_planes, bufr, &i);
	<a href="machine_indep.c.html#bufRead_s">bufRead_s</a>(&header-&gt;num_frames, bufr, &i);
	<a href="machine_indep.c.html#bufRead_s">bufRead_s</a>(&header-&gt;num_gates, bufr, &i);
	<a href="machine_indep.c.html#bufRead_s">bufRead_s</a>(&header-&gt;num_bed_pos, bufr, &i);
	<a href="machine_indep.c.html#bufRead_f">bufRead_f</a>(&header-&gt;init_bed_position, bufr, &i);
	for(j = 0; j &lt; 15; j++)
		<a href="machine_indep.c.html#bufRead_f">bufRead_f</a>(&header-&gt;bed_offset[j], bufr, &i);
	<a href="machine_indep.c.html#bufRead_f">bufRead_f</a>(&header-&gt;plane_separation, bufr, &i);
	<a href="machine_indep.c.html#bufRead_s">bufRead_s</a>(&header-&gt;lwr_sctr_thres, bufr, &i);
	<a href="machine_indep.c.html#bufRead_s">bufRead_s</a>(&header-&gt;lwr_true_thres, bufr, &i);
	<a href="machine_indep.c.html#bufRead_s">bufRead_s</a>(&header-&gt;upr_true_thres, bufr, &i);
	<a href="machine_indep.c.html#bufRead">bufRead</a>(header-&gt;user_process_code, bufr, &i, 10);
	header-&gt;user_process_code[9] = '\0';
	<a href="machine_indep.c.html#bufRead_s">bufRead_s</a>(&header-&gt;acquisition_mode, bufr, &i);
	<a href="machine_indep.c.html#bufRead_f">bufRead_f</a>(&header-&gt;bin_size, bufr, &i);
	<a href="machine_indep.c.html#bufRead_f">bufRead_f</a>(&header-&gt;branching_fraction, bufr, &i);
	<a href="machine_indep.c.html#bufRead_i">bufRead_i</a>(&header-&gt;dose_start_time, bufr, &i);
	<a href="machine_indep.c.html#bufRead_f">bufRead_f</a>(&header-&gt;dosage, bufr, &i);
	<a href="machine_indep.c.html#bufRead_f">bufRead_f</a>(&header-&gt;well_counter_factor, bufr, &i);
	<a href="machine_indep.c.html#bufRead">bufRead</a>(header-&gt;data_units, bufr, &i, 32);
	header-&gt;data_units[31] = '\0';
	<a href="machine_indep.c.html#bufRead_s">bufRead_s</a>(&header-&gt;septa_state, bufr, &i);
	return 0;
}

<LI><H3><a name="mat_read_main_header">int mat_read_main_header( fptr, header)</a></H3>
  FILE *fptr;
  <a href="matrix.h.html#Main_header">Main_header</a> *header;
{
	int i = 0;
	char bufr[MatBLKSIZE];
	/* check magic number */
	<a href="matrix.c.html#mat_rblk">mat_rblk</a>( fptr, 1, bufr, 1);
	<a href="machine_indep.c.html#bufRead">bufRead</a>(header-&gt;magic_number, bufr, &i, MagicNumLen);
	header-&gt;magic_number[MagicNumLen-1] = '\0';
	if(strncmp(header-&gt;magic_number, magicNumber, strlen(magicNumber)))
		return	unmap64_main_header(bufr, header);
	else return <a href="matrix.c.html#unmap_main_header">unmap_main_header</a>(bufr, header);
}

<LI><H3><a name="mat_read_matrix_data">int mat_read_matrix_data(file, blk, nblks, bufr)</a></H3>
  MatrixFile *file;
  int blk, nblks;
  short *bufr;
{
	if (file-&gt;mhptr->sw_version &lt; V7) 
		return <a href="machine_indep.c.html#read_matrix_data">read_matrix_data</a>(file-&gt;fptr, blk,nblks, (char*)bufr, VAX_Ix2);
	else return <a href="machine_indep.c.html#read_matrix_data">read_matrix_data</a>(file-&gt;fptr, blk,nblks, (char*)bufr, SunShort);
}

<LI><H3><a name="unmap_scan_header">int unmap_scan_header(buf,header) </a></H3>
char *buf;
<a href="matrix.h.html#Scan_subheader">Scan_subheader</a> *header;
{
	int i = 0 , j = 0;

	<a href="machine_indep.c.html#bufRead_s">bufRead_s</a>(&header-&gt;data_type, buf, &i);
	<a href="machine_indep.c.html#bufRead_s">bufRead_s</a>(&header-&gt;num_dimensions, buf, &i);
	<a href="machine_indep.c.html#bufRead_s">bufRead_s</a>(&header-&gt;num_r_elements, buf, &i);
	<a href="machine_indep.c.html#bufRead_s">bufRead_s</a>(&header-&gt;num_angles, buf, &i);
	<a href="machine_indep.c.html#bufRead_s">bufRead_s</a>(&header-&gt;corrections_applied, buf, &i);
	<a href="machine_indep.c.html#bufRead_s">bufRead_s</a>(&header-&gt;num_z_elements, buf, &i);
	<a href="machine_indep.c.html#bufRead_s">bufRead_s</a>(&header-&gt;ring_difference, buf, &i);
	<a href="machine_indep.c.html#bufRead_f">bufRead_f</a>(&header-&gt;x_resolution, buf, &i);
	<a href="machine_indep.c.html#bufRead_f">bufRead_f</a>(&header-&gt;y_resolution, buf, &i);
	<a href="machine_indep.c.html#bufRead_f">bufRead_f</a>(&header-&gt;z_resolution, buf, &i);
	<a href="machine_indep.c.html#bufRead_f">bufRead_f</a>(&header-&gt;w_resolution, buf, &i);
	i += 6 * sizeof(short);		/* space reserved for future gating info */
	<a href="machine_indep.c.html#bufRead_i">bufRead_i</a>(&header-&gt;gate_duration, buf, &i);
	<a href="machine_indep.c.html#bufRead_i">bufRead_i</a>(&header-&gt;r_wave_offset, buf, &i);
	<a href="machine_indep.c.html#bufRead_i">bufRead_i</a>(&header-&gt;num_accepted_beats, buf, &i);
	<a href="machine_indep.c.html#bufRead_f">bufRead_f</a>(&header-&gt;scale_factor, buf, &i);
	<a href="machine_indep.c.html#bufRead_s">bufRead_s</a>(&header-&gt;scan_min, buf, &i);
	<a href="machine_indep.c.html#bufRead_s">bufRead_s</a>(&header-&gt;scan_max, buf, &i);
	<a href="machine_indep.c.html#bufRead_i">bufRead_i</a>(&header-&gt;prompts, buf, &i);
	<a href="machine_indep.c.html#bufRead_i">bufRead_i</a>(&header-&gt;delayed, buf, &i);
	<a href="machine_indep.c.html#bufRead_i">bufRead_i</a>(&header-&gt;multiples, buf, &i);
	<a href="machine_indep.c.html#bufRead_i">bufRead_i</a>(&header-&gt;net_trues, buf, &i);
	for(j = 0; j &lt; 16; j++)
		<a href="machine_indep.c.html#bufRead_f">bufRead_f</a>(&header-&gt;cor_singles[j], buf, &i);
	for(j = 0; j &lt; 16; j++)
		<a href="machine_indep.c.html#bufRead_f">bufRead_f</a>(&header-&gt;uncor_singles[j], buf, &i);
	<a href="machine_indep.c.html#bufRead_f">bufRead_f</a>(&header-&gt;tot_avg_cor, buf, &i);
	<a href="machine_indep.c.html#bufRead_f">bufRead_f</a>(&header-&gt;tot_avg_uncor, buf, &i);
	<a href="machine_indep.c.html#bufRead_i">bufRead_i</a>(&header-&gt;total_coin_rate, buf, &i);
	<a href="machine_indep.c.html#bufRead_i">bufRead_i</a>(&header-&gt;frame_start_time, buf, &i);
	<a href="machine_indep.c.html#bufRead_i">bufRead_i</a>(&header-&gt;frame_duration, buf, &i);
	<a href="machine_indep.c.html#bufRead_f">bufRead_f</a>(&header-&gt;loss_correction_fctr, buf, &i);
	for(j = 0; j &lt; 8; j++)
		<a href="machine_indep.c.html#bufRead_s">bufRead_s</a>(&header-&gt;phy_planes[j], buf, &i);
	return 0;
}

int unmap_Scan3D_header(buf,header)
char *buf;
Scan3D_subheader *header;
{
	int i = 0;
	int j;
	<a href="machine_indep.c.html#bufRead_s">bufRead_s</a>(&header-&gt;data_type, buf, &i);
	<a href="machine_indep.c.html#bufRead_s">bufRead_s</a>(&header-&gt;num_dimensions, buf, &i);
	<a href="machine_indep.c.html#bufRead_s">bufRead_s</a>(&header-&gt;num_r_elements, buf, &i);
	<a href="machine_indep.c.html#bufRead_s">bufRead_s</a>(&header-&gt;num_angles, buf, &i);
	<a href="machine_indep.c.html#bufRead_s">bufRead_s</a>(&header-&gt;corrections_applied, buf, &i);
	for(j = 0; j &lt; 64; j++)
		<a href="machine_indep.c.html#bufRead_s">bufRead_s</a>(&header-&gt;num_z_elements[j], buf, &i);
	<a href="machine_indep.c.html#bufRead_s">bufRead_s</a>(&header-&gt;ring_difference, buf, &i);
	<a href="machine_indep.c.html#bufRead_s">bufRead_s</a>(&header-&gt;storage_order, buf, &i);
	<a href="machine_indep.c.html#bufRead_s">bufRead_s</a>(&header-&gt;axial_compression, buf, &i);
	<a href="machine_indep.c.html#bufRead_f">bufRead_f</a>(&header-&gt;x_resolution, buf, &i);
	<a href="machine_indep.c.html#bufRead_f">bufRead_f</a>(&header-&gt;v_resolution, buf, &i);
	<a href="machine_indep.c.html#bufRead_f">bufRead_f</a>(&header-&gt;z_resolution, buf, &i);
	<a href="machine_indep.c.html#bufRead_f">bufRead_f</a>(&header-&gt;w_resolution, buf, &i);
	i += 6 * sizeof(short);	 /* space reserved for future gating info */
	<a href="machine_indep.c.html#bufRead_i">bufRead_i</a>(&header-&gt;gate_duration, buf, &i);
	<a href="machine_indep.c.html#bufRead_i">bufRead_i</a>(&header-&gt;r_wave_offset, buf, &i);
	<a href="machine_indep.c.html#bufRead_i">bufRead_i</a>(&header-&gt;num_accepted_beats, buf, &i);
	<a href="machine_indep.c.html#bufRead_f">bufRead_f</a>(&header-&gt;scale_factor, buf, &i);
	<a href="machine_indep.c.html#bufRead_s">bufRead_s</a>(&header-&gt;scan_min, buf, &i);
	<a href="machine_indep.c.html#bufRead_s">bufRead_s</a>(&header-&gt;scan_max, buf, &i);
	<a href="machine_indep.c.html#bufRead_i">bufRead_i</a>(&header-&gt;prompts, buf, &i);
	<a href="machine_indep.c.html#bufRead_i">bufRead_i</a>(&header-&gt;delayed, buf, &i);
	<a href="machine_indep.c.html#bufRead_i">bufRead_i</a>(&header-&gt;multiples, buf, &i);
	<a href="machine_indep.c.html#bufRead_i">bufRead_i</a>(&header-&gt;net_trues, buf, &i);
	<a href="machine_indep.c.html#bufRead_f">bufRead_f</a>(&header-&gt;tot_avg_cor, buf, &i);
	<a href="machine_indep.c.html#bufRead_f">bufRead_f</a>(&header-&gt;tot_avg_uncor, buf, &i);
	<a href="machine_indep.c.html#bufRead_i">bufRead_i</a>(&header-&gt;total_coin_rate, buf, &i);
	<a href="machine_indep.c.html#bufRead_i">bufRead_i</a>(&header-&gt;frame_start_time, buf, &i);
	<a href="machine_indep.c.html#bufRead_i">bufRead_i</a>(&header-&gt;frame_duration, buf, &i);
	<a href="machine_indep.c.html#bufRead_f">bufRead_f</a>(&header-&gt;loss_correction_fctr, buf, &i);
	i += 90 * sizeof(short);	/* CTI reserved space */
	i += 50 * sizeof(short);	/* user reserved space */
	for(j = 0; j &lt; 128; j++)
		<a href="machine_indep.c.html#bufRead_f">bufRead_f</a>(&header-&gt;uncor_singles[j], buf, &i);
	return 0;
}

int map_Scan3D_header(buf,header)
char *buf;
Scan3D_subheader *header;
{
	int i = 0;
	int j;
	<a href="machine_indep.c.html#bufWrite_s">bufWrite_s</a>(header-&gt;data_type, buf, &i);
	<a href="machine_indep.c.html#bufWrite_s">bufWrite_s</a>(header-&gt;num_dimensions, buf, &i);
	<a href="machine_indep.c.html#bufWrite_s">bufWrite_s</a>(header-&gt;num_r_elements, buf, &i);
	<a href="machine_indep.c.html#bufWrite_s">bufWrite_s</a>(header-&gt;num_angles, buf, &i);
	<a href="machine_indep.c.html#bufWrite_s">bufWrite_s</a>(header-&gt;corrections_applied, buf, &i);
	for(j = 0; j &lt; 64; j++)
		<a href="machine_indep.c.html#bufWrite_s">bufWrite_s</a>(header-&gt;num_z_elements[j], buf, &i);
	<a href="machine_indep.c.html#bufWrite_s">bufWrite_s</a>(header-&gt;ring_difference, buf, &i);
	<a href="machine_indep.c.html#bufWrite_s">bufWrite_s</a>(header-&gt;storage_order, buf, &i);
	<a href="machine_indep.c.html#bufWrite_s">bufWrite_s</a>(header-&gt;axial_compression, buf, &i);
	<a href="machine_indep.c.html#bufWrite_f">bufWrite_f</a>(header-&gt;x_resolution, buf, &i);
	<a href="machine_indep.c.html#bufWrite_f">bufWrite_f</a>(header-&gt;v_resolution, buf, &i);
	<a href="machine_indep.c.html#bufWrite_f">bufWrite_f</a>(header-&gt;z_resolution, buf, &i);
	<a href="machine_indep.c.html#bufWrite_f">bufWrite_f</a>(header-&gt;w_resolution, buf, &i);
	i += 6 * sizeof(short);	 /* space reserved for future gating info */
	<a href="machine_indep.c.html#bufWrite_i">bufWrite_i</a>(header-&gt;gate_duration, buf, &i);
	<a href="machine_indep.c.html#bufWrite_i">bufWrite_i</a>(header-&gt;r_wave_offset, buf, &i);
	<a href="machine_indep.c.html#bufWrite_i">bufWrite_i</a>(header-&gt;num_accepted_beats, buf, &i);
	<a href="machine_indep.c.html#bufWrite_f">bufWrite_f</a>(header-&gt;scale_factor, buf, &i);
	<a href="machine_indep.c.html#bufWrite_s">bufWrite_s</a>(header-&gt;scan_min, buf, &i);
	<a href="machine_indep.c.html#bufWrite_s">bufWrite_s</a>(header-&gt;scan_max, buf, &i);
	<a href="machine_indep.c.html#bufWrite_i">bufWrite_i</a>(header-&gt;prompts, buf, &i);
	<a href="machine_indep.c.html#bufWrite_i">bufWrite_i</a>(header-&gt;delayed, buf, &i);
	<a href="machine_indep.c.html#bufWrite_i">bufWrite_i</a>(header-&gt;multiples, buf, &i);
	<a href="machine_indep.c.html#bufWrite_i">bufWrite_i</a>(header-&gt;net_trues, buf, &i);
	<a href="machine_indep.c.html#bufWrite_f">bufWrite_f</a>(header-&gt;tot_avg_cor, buf, &i);
	<a href="machine_indep.c.html#bufWrite_f">bufWrite_f</a>(header-&gt;tot_avg_uncor, buf, &i);
	<a href="machine_indep.c.html#bufWrite_i">bufWrite_i</a>(header-&gt;total_coin_rate, buf, &i);
	<a href="machine_indep.c.html#bufWrite_i">bufWrite_i</a>(header-&gt;frame_start_time, buf, &i);
	<a href="machine_indep.c.html#bufWrite_i">bufWrite_i</a>(header-&gt;frame_duration, buf, &i);
	<a href="machine_indep.c.html#bufWrite_f">bufWrite_f</a>(header-&gt;loss_correction_fctr, buf, &i);
	i += 90 * sizeof(short);	/* CTI reserved space */
	i += 50 * sizeof(short);	/* user reserved space */
	for(j = 0; j &lt; 128; j++)
		<a href="machine_indep.c.html#bufWrite_f">bufWrite_f</a>(header-&gt;uncor_singles[j], buf, &i);
	return 0;
}

int mat_read_Scan3D_subheader( file, blknum, header)
  MatrixFile *file;
  int blknum;
  Scan3D_subheader *header;
{
	char buf[2*MatBLKSIZE];
	if (file-&gt;acs) {
		<a href="rts_cmd.c.html#rtsRblk">rtsRblk</a>(file-&gt;fname, blknum, buf);
		<a href="rts_cmd.c.html#rtsRblk">rtsRblk</a>(file-&gt;fname, blknum+1, buf+MatBLKSIZE);
	} else <a href="matrix.c.html#mat_rblk">mat_rblk</a>( file-&gt;fptr, blknum, buf, 2);
	return unmap_Scan3D_header(buf,header);
}

<LI><H3><a name="mat_read_scan_subheader">int mat_read_scan_subheader( file, blknum, header)</a></H3>
  MatrixFile *file;
  int blknum;
  <a href="matrix.h.html#Scan_subheader">Scan_subheader</a> *header;
{
	char buf[MatBLKSIZE];
	if (file-&gt;acs) <a href="rts_cmd.c.html#rtsRblk">rtsRblk</a>(file->fname, blknum, buf);
	else <a href="matrix.c.html#mat_rblk">mat_rblk</a>( file-&gt;fptr, blknum, buf, 1);
	if (file-&gt;mhptr->sw_version &lt; V7)
		return unmap64_scan_header(buf,header, file-&gt;mhptr);
	return <a href="matrix.c.html#unmap_scan_header">unmap_scan_header</a>(buf,header);
}

<LI><H3><a name="unmap_image_header">int unmap_image_header(buf,header)</a></H3>
char *buf;
<a href="matrix.h.html#Image_subheader">Image_subheader</a> *header;
{
	int i = 0;

	<a href="machine_indep.c.html#bufRead_s">bufRead_s</a>(&header-&gt;data_type, buf, &i);
	<a href="machine_indep.c.html#bufRead_s">bufRead_s</a>(&header-&gt;num_dimensions, buf, &i);
	<a href="machine_indep.c.html#bufRead_s">bufRead_s</a>(&header-&gt;x_dimension, buf, &i);
	<a href="machine_indep.c.html#bufRead_s">bufRead_s</a>(&header-&gt;y_dimension, buf, &i);
	<a href="machine_indep.c.html#bufRead_s">bufRead_s</a>(&header-&gt;z_dimension, buf, &i);
	<a href="machine_indep.c.html#bufRead_f">bufRead_f</a>(&header-&gt;z_offset, buf, &i);
	<a href="machine_indep.c.html#bufRead_f">bufRead_f</a>(&header-&gt;x_offset, buf, &i);
	<a href="machine_indep.c.html#bufRead_f">bufRead_f</a>(&header-&gt;y_offset, buf, &i);
	<a href="machine_indep.c.html#bufRead_f">bufRead_f</a>(&header-&gt;recon_zoom, buf, &i);
	<a href="machine_indep.c.html#bufRead_f">bufRead_f</a>(&header-&gt;scale_factor, buf, &i);
	<a href="machine_indep.c.html#bufRead_s">bufRead_s</a>(&header-&gt;image_min, buf, &i);
	<a href="machine_indep.c.html#bufRead_s">bufRead_s</a>(&header-&gt;image_max, buf, &i);
	<a href="machine_indep.c.html#bufRead_f">bufRead_f</a>(&header-&gt;x_pixel_size, buf, &i);
	<a href="machine_indep.c.html#bufRead_f">bufRead_f</a>(&header-&gt;y_pixel_size, buf, &i);
	<a href="machine_indep.c.html#bufRead_f">bufRead_f</a>(&header-&gt;z_pixel_size, buf, &i);
	<a href="machine_indep.c.html#bufRead_i">bufRead_i</a>(&header-&gt;frame_duration, buf, &i);
	<a href="machine_indep.c.html#bufRead_i">bufRead_i</a>(&header-&gt;frame_start_time, buf, &i);
	<a href="machine_indep.c.html#bufRead_s">bufRead_s</a>(&header-&gt;filter_code, buf, &i);
	<a href="machine_indep.c.html#bufRead_f">bufRead_f</a>(&header-&gt;x_resolution, buf, &i);
	<a href="machine_indep.c.html#bufRead_f">bufRead_f</a>(&header-&gt;y_resolution, buf, &i);
	<a href="machine_indep.c.html#bufRead_f">bufRead_f</a>(&header-&gt;z_resolution, buf, &i);
	<a href="machine_indep.c.html#bufRead_f">bufRead_f</a>(&header-&gt;num_r_elements, buf, &i);
	<a href="machine_indep.c.html#bufRead_f">bufRead_f</a>(&header-&gt;num_angles, buf, &i);
	<a href="machine_indep.c.html#bufRead_f">bufRead_f</a>(&header-&gt;z_rotation_angle, buf, &i);
	<a href="machine_indep.c.html#bufRead_f">bufRead_f</a>(&header-&gt;decay_corr_fctr, buf, &i);
	<a href="machine_indep.c.html#bufRead_i">bufRead_i</a>(&header-&gt;processing_code, buf, &i);
	<a href="machine_indep.c.html#bufRead_i">bufRead_i</a>(&header-&gt;gate_duration, buf, &i);
	<a href="machine_indep.c.html#bufRead_i">bufRead_i</a>(&header-&gt;r_wave_offset, buf, &i);
	<a href="machine_indep.c.html#bufRead_i">bufRead_i</a>(&header-&gt;num_accepted_beats, buf, &i);
	<a href="machine_indep.c.html#bufRead_f">bufRead_f</a>(&header-&gt;filter_cutoff_frequency, buf, &i);
	<a href="machine_indep.c.html#bufRead_f">bufRead_f</a>(&header-&gt;filter_resolution, buf, &i);
	<a href="machine_indep.c.html#bufRead_f">bufRead_f</a>(&header-&gt;filter_ramp_slope, buf, &i);
	<a href="machine_indep.c.html#bufRead_s">bufRead_s</a>(&header-&gt;filter_order, buf, &i);
	<a href="machine_indep.c.html#bufRead_f">bufRead_f</a>(&header-&gt;filter_scatter_fraction, buf, &i);
	<a href="machine_indep.c.html#bufRead_f">bufRead_f</a>(&header-&gt;filter_scatter_slope, buf, &i);
	<a href="machine_indep.c.html#bufRead">bufRead</a>(header-&gt;annotation, buf, &i, 40);
	<a href="machine_indep.c.html#bufRead_f">bufRead_f</a>(&header-&gt;mt_1_1, buf, &i);
	<a href="machine_indep.c.html#bufRead_f">bufRead_f</a>(&header-&gt;mt_1_2, buf, &i);
	<a href="machine_indep.c.html#bufRead_f">bufRead_f</a>(&header-&gt;mt_1_3, buf, &i);
	<a href="machine_indep.c.html#bufRead_f">bufRead_f</a>(&header-&gt;mt_2_1, buf, &i);
	<a href="machine_indep.c.html#bufRead_f">bufRead_f</a>(&header-&gt;mt_2_2, buf, &i);
	<a href="machine_indep.c.html#bufRead_f">bufRead_f</a>(&header-&gt;mt_2_3, buf, &i);
	<a href="machine_indep.c.html#bufRead_f">bufRead_f</a>(&header-&gt;mt_3_1, buf, &i);
	<a href="machine_indep.c.html#bufRead_f">bufRead_f</a>(&header-&gt;mt_3_2, buf, &i);
	<a href="machine_indep.c.html#bufRead_f">bufRead_f</a>(&header-&gt;mt_3_3, buf, &i);
	<a href="machine_indep.c.html#bufRead_f">bufRead_f</a>(&header-&gt;rfilter_cutoff, buf, &i);
	<a href="machine_indep.c.html#bufRead_f">bufRead_f</a>(&header-&gt;rfilter_resolution, buf, &i);
	<a href="machine_indep.c.html#bufRead_s">bufRead_s</a>(&header-&gt;rfilter_code, buf, &i);
	<a href="machine_indep.c.html#bufRead_s">bufRead_s</a>(&header-&gt;rfilter_order, buf, &i);
	<a href="machine_indep.c.html#bufRead_f">bufRead_f</a>(&header-&gt;zfilter_cutoff, buf, &i);
	<a href="machine_indep.c.html#bufRead_f">bufRead_f</a>(&header-&gt;zfilter_resolution, buf, &i);
	<a href="machine_indep.c.html#bufRead_s">bufRead_s</a>(&header-&gt;zfilter_code, buf, &i);
	<a href="machine_indep.c.html#bufRead_s">bufRead_s</a>(&header-&gt;zfilter_order, buf, &i);
	<a href="machine_indep.c.html#bufRead_f">bufRead_f</a>(&header-&gt;mt_1_4, buf, &i);
	<a href="machine_indep.c.html#bufRead_f">bufRead_f</a>(&header-&gt;mt_2_4, buf, &i);
	<a href="machine_indep.c.html#bufRead_f">bufRead_f</a>(&header-&gt;mt_3_4, buf, &i);
	<a href="machine_indep.c.html#bufRead_s">bufRead_s</a>(&header-&gt;scatter_type, buf, &i);
	<a href="machine_indep.c.html#bufRead_s">bufRead_s</a>(&header-&gt;recon_type, buf, &i);
	<a href="machine_indep.c.html#bufRead_s">bufRead_s</a>(&header-&gt;recon_views, buf, &i);
	return 0;
}

<LI><H3><a name="mat_read_image_subheader">int mat_read_image_subheader( file, blknum, header)</a></H3>
  MatrixFile *file;
  int blknum;
  <a href="matrix.h.html#Image_subheader">Image_subheader</a> *header;
{
	char buf[MatBLKSIZE];
	if (file-&gt;acs) <a href="rts_cmd.c.html#rtsRblk">rtsRblk</a>( file->fname, blknum, buf);
	else <a href="matrix.c.html#mat_rblk">mat_rblk</a>( file-&gt;fptr, blknum, buf, 1);
	if (file-&gt;mhptr->sw_version &lt; V7)
		return unmap64_image_header(buf,header, file-&gt;mhptr);
	return <a href="matrix.c.html#unmap_image_header">unmap_image_header</a>(buf,header);
}

<LI><H3><a name="mat_read_dir">Mat_dir mat_read_dir( file, selector)</a></H3>
  MatrixFile* file;
  char *selector;
{	int i, n, blk, nxtblk, ndblks, bufr[128];
	Mat_dir dir;
	FILE* fptr =  file-&gt;fptr;

	blk = MatFirstDirBlk;
	nxtblk = 0;
	for (ndblks=0; nxtblk != MatFirstDirBlk; ndblks++)
	{
		if (file-&gt;mhptr->sw_version &lt; V7)
			<a href="machine_indep.c.html#read_matrix_data">read_matrix_data</a>(fptr,blk,1,(char*)bufr,VAX_Ix4);
		else <a href="machine_indep.c.html#read_matrix_data">read_matrix_data</a>(fptr,blk,1,(char*)bufr,SunLong);
	  nxtblk = bufr[1];
	  blk = nxtblk;
	}
	dir = (Mat_dir) malloc( sizeof(struct <a href="matrix.h.html#matdir">matdir</a>));
	dir-&gt;nmats = 0;
	dir-&gt;nmax = 31 * ndblks;
	dir-&gt;entry = (struct <a href="matrix.h.html#MatDir">MatDir</a> *) malloc( 31*ndblks*sizeof( struct 
	for (n=0, nxtblk=0, blk=MatFirstDirBlk; nxtblk != MatFirstDirBlk; blk = nxtblk)
	{
	  if (file-&gt;mhptr->sw_version &lt; V7)
		<a href="machine_indep.c.html#read_matrix_data">read_matrix_data</a>(fptr,blk,1,(char*)bufr,VAX_Ix4);
	  else <a href="machine_indep.c.html#read_matrix_data">read_matrix_data</a>(fptr,blk,1,(char*)bufr,SunLong);
	  nxtblk = bufr[1];
	  for (i=4; i&lt;MatBLKSIZE/4; n++)
	  { dir-&gt;entry[n].matnum = bufr[i++];
		dir-&gt;entry[n].strtblk = bufr[i++];
		dir-&gt;entry[n].endblk = bufr[i++];
		dir-&gt;entry[n].matstat = bufr[i++];
		if (dir-&gt;entry[n].matnum != 0) dir->nmats++;
	  }
	}
	return dir;
}


<LI><H3><a name="mat_wblk">int mat_wblk( fptr, blkno, bufr, nblks)</a></H3>
  FILE *fptr;
  int blkno, nblks;
  char *bufr;
{
	  int err;
	
	  /* seek to position in file */
	  err = fseek( fptr, (blkno-1)*MatBLKSIZE, 0);
	  if (err) return (err);
	
	  /* write matrix data */
	  err = fwrite( bufr, 1, nblks*MatBLKSIZE, fptr);
	  if (err != nblks*MatBLKSIZE) return (-1);
	  return (0);
}

FILE *<a href="matpkg2.c.html#mat_create">mat_create</a>( fname, mhead)
  char *fname;
  <a href="matrix.h.html#Main_header">Main_header</a> *mhead;
{
	FILE *fptr;
	int i, bufr[MatBLKSIZE/sizeof(int)];

	fptr = <a href="matrix.c.html#mat_open">mat_open</a>( fname, "w+");
	if (!fptr) return fptr;
	<a href="matrix.c.html#mat_write_main_header">mat_write_main_header</a>( fptr, mhead);
	memset(bufr,0,MatBLKSIZE);
	bufr[0] = 31;
	bufr[1] = 2;
	if (mhead-&gt;sw_version &lt; V7)
		<a href="machine_indep.c.html#write_matrix_data">write_matrix_data</a>(fptr,MatFirstDirBlk,1,(char*)bufr,VAX_Ix4);
	else <a href="machine_indep.c.html#write_matrix_data">write_matrix_data</a>(fptr,MatFirstDirBlk,1,(char*)bufr,SunLong);
	return (fptr);
}

<LI><H3><a name="mat_enter">int mat_enter( file, matnum, nblks)</a></H3>
  MatrixFile *file;
  int matnum, nblks;
{

	struct <a href="matrix.h.html#MatDir">MatDir</a> entry;
	int dirblk, dirbufr[128], i, nxtblk, busy, oldsize;
	FILE *fptr = file-&gt;fptr;
	short sw_version = file-&gt;mhptr->sw_version;

	dirblk = MatFirstDirBlk;
	fseek( fptr, 0, 0);
/* nfs locks are very time consuming 
	lockf( fileno(fptr), F_LOCK, 0);
*/
	if (sw_version &lt; V7)
		<a href="machine_indep.c.html#read_matrix_data">read_matrix_data</a>( fptr,dirblk,1,(char*)dirbufr,VAX_Ix4);
	else <a href="machine_indep.c.html#read_matrix_data">read_matrix_data</a>( fptr,dirblk,1,(char*)dirbufr,SunLong);
	busy = 1;
	while (busy) {
	nxtblk = dirblk+1;
	for (i=4; i&lt;128; i+=4)
	{
	  if (dirbufr[i] == 0) 
	  { busy = 0;
		break;
	  }
	  else if (dirbufr[i] == matnum)
	  { oldsize = dirbufr[i+2]-dirbufr[i+1]+1;
		if (oldsize &lt; nblks)
		{ dirbufr[i] = 0xFFFFFFFF;
			if (sw_version &lt; V7)
		  		<a href="machine_indep.c.html#write_matrix_data">write_matrix_data</a>( fptr,dirblk,1,dirbufr,VAX_Ix4);
		  	else <a href="machine_indep.c.html#write_matrix_data">write_matrix_data</a>( fptr,dirblk,1,dirbufr,SunLong);
		  nxtblk = dirbufr[i+2]+1;
		}
		else
		{ nxtblk = dirbufr[i+1];
		  dirbufr[0]++;
		  dirbufr[3]--;
		  busy = 0;
		  break;
		}
	  }
	  else nxtblk = dirbufr[i+2]+1;
	}
	if (!busy) break;
	if (dirbufr[1] != MatFirstDirBlk)
	{ dirblk = dirbufr[1];
		if (sw_version &lt; V7)
	  		<a href="machine_indep.c.html#read_matrix_data">read_matrix_data</a>( fptr,dirblk,1,(char*)dirbufr,VAX_Ix4);
	  	else <a href="machine_indep.c.html#read_matrix_data">read_matrix_data</a>( fptr,dirblk,1,(char*)dirbufr,SunLong);
	} else
	{ dirbufr[1] = nxtblk;
		if (sw_version &lt; V7)
	  		<a href="machine_indep.c.html#write_matrix_data">write_matrix_data</a>( fptr,dirblk,1,(char*)dirbufr,VAX_Ix4);
	  	else <a href="machine_indep.c.html#write_matrix_data">write_matrix_data</a>( fptr,dirblk,1,(char*)dirbufr,SunLong);
	  dirbufr[0] = 31;
	  dirbufr[1] = MatFirstDirBlk;
	  dirbufr[2] = dirblk;
	  dirbufr[3] = 0;
	  dirblk = nxtblk;
	  for (i=4; i&lt;128; i++) dirbufr[i] = 0;
	 }
	}
	dirbufr[i] = matnum;
	dirbufr[i+1] = nxtblk;
	dirbufr[i+2] = nxtblk + nblks;
	dirbufr[i+3] = 1;
	dirbufr[0]--;
	dirbufr[3]++;
	if (sw_version &lt; V7) <a href="machine_indep.c.html#write_matrix_data">write_matrix_data</a>( fptr,dirblk,1,dirbufr,VAX_Ix4);
	else <a href="machine_indep.c.html#write_matrix_data">write_matrix_data</a>( fptr,dirblk,1,dirbufr,SunLong);
	fseek( fptr, 0, 0);
/* nfs locks are very time consuming 
	lockf( fileno(fptr), F_UNLOCK, 0);
*/
	return (nxtblk);
}

<LI><H3><a name="mat_write_data">int mat_write_data( fptr, blk, nbytes, data, dtype)</a></H3>
  FILE *fptr;
  int blk, nbytes, dtype;
  char *data;
{
	int nblks;

	nblks = (511+nbytes)/512;
	return <a href="machine_indep.c.html#write_matrix_data">write_matrix_data</a>( fptr, blk, nblks, data, dtype);
}

<LI><H3><a name="mat_read_data">int mat_read_data( fptr, blk, nbytes, data, dtype)</a></H3>
  FILE *fptr;
  int blk, nbytes, dtype;
  char *data;
{
	int nblks;

	nblks = (511+nbytes)/512;
	return <a href="machine_indep.c.html#read_matrix_data">read_matrix_data</a>( fptr, blk, nblks, data, dtype);
}

<LI><H3><a name="matrix_selector">int matrix_selector( matnum, ranges)</a></H3>
  int matnum, ranges[2][5];
{
	struct <a href="matrix.h.html#Matval">Matval</a> m;

	<a href="matrix.c.html#mat_numdoc">mat_numdoc</a>( matnum, &m);
	if (ranges[0][0] != -1)
	  if (m.frame &lt; ranges[0][0] || m.frame &gt; ranges[1][0]) return (0);
	if (ranges[0][1] != -1)
	  if (m.plane &lt; ranges[0][1] || m.plane &gt; ranges[1][1]) return (0);
	if (ranges[0][2] != -1)
	  if (m.gate  &lt; ranges[0][2] || m.gate  &gt; ranges[1][2]) return (0);
	if (ranges[0][3] != -1)
	  if (m.data  &lt; ranges[0][3] || m.data  &gt; ranges[1][3]) return (0);
	if (ranges[0][4] != -1)
	  if (m.bed   &lt; ranges[0][4] || m.bed   &gt; ranges[1][4]) return (0);
	return (matnum);
}

<LI><H3><a name="decode_selector">decode_selector( s1, ranges)</a></H3>
  char *s1; int ranges[2][5];
{	char xword[16], *<a href="matrix.c.html#next_word">next_word</a>();
	int i;

	<a href="matrix.c.html#fix_selector">fix_selector</a>( s1, s1);
	for (i=0;i&lt;5;i++)	/* set all ranges to all (-1) */
	{
	  ranges[0][i]=ranges[1][i] = -1;
	  s1 = <a href="matrix.c.html#next_word">next_word</a>( s1, xword);
	  if (xword[0] == '*') continue;
	  else if (strchr(xword,':'))
		sscanf(xword,"%d:%d",&ranges[0][i],&ranges[1][i]);
	  else
	  {
		sscanf(xword,"%d",&ranges[0][i]);
		ranges[1][i]=ranges[0][i];
	  }
	}
}

<LI><H3><a name="str_find">str_find( s1, s2)</a></H3>
  char *s1, *s2;
{
	int i, j, k;

	for (i=0;s1[i];i++) {
	  for (j=i,k=0; s2[k]!='\0' && s1[j]==s2[k]; j++, k++) ;
	  if (s2[k]=='\0') return (i);
	} return (-1);
}

<LI><H3><a name="str_replace">str_replace( s1, s2, s3, s4)</a></H3>
  char *s1, *s2, *s3, *s4;
{
	int nf=0, n;

	*s1 = '\0';
	while (1)
	{ if ((n=<a href="matrix.c.html#str_find">str_find</a>(s2, s3))==-1)
	  { strcat(s1, s2);
		return (nf);
	  } else
	  { strncat(s1, s2, n);
		strcat(s1, s4);
		s2+= n+strlen(s3);
		nf++;
	  }
	}
}

<LI><H3><a name="string_replace">string_replace( s1, s2, s3, s4)</a></H3>
  char *s1, *s2, *s3, *s4;
{
	char temp[256];

	strcpy(temp, s2);
	while (<a href="matrix.c.html#str_replace">str_replace</a>(s1, temp, s3, s4) &gt; 0)
	  strcpy(temp, s1);
}	

<LI><H3><a name="fix_selector">fix_selector( s1, s2)</a></H3>
  char *s1, *s2;
{
	char temp[256];
	<a href="matrix.c.html#string_replace">string_replace</a>(temp, s2, "," , " ");
	<a href="matrix.c.html#string_replace">string_replace</a>(s1, temp, "..", ":");
	<a href="matrix.c.html#string_replace">string_replace</a>(temp, s1, ".", ":");
	<a href="matrix.c.html#string_replace">string_replace</a>(s1, temp, "-", ":");
	<a href="matrix.c.html#string_replace">string_replace</a>(temp, s1, "**", "*");
	<a href="matrix.c.html#string_replace">string_replace</a>(s1, temp, "  ", " ");
	<a href="matrix.c.html#string_replace">string_replace</a>(temp, s1, " :", ":");
	<a href="matrix.c.html#string_replace">string_replace</a>(s1, temp, ": ", ":");
}

<LI><H3><a name="next_word">char* next_word(s, w)</a></H3>
  char *s, *w;
{
	while (*s && *s!=' ') *w++ = *s++;
	*w='\0';
	if (*s) s++;
	return (s);
}

<LI><H3><a name="map_main_header">int map_main_header(bufr,header)</a></H3>
char *bufr;
<a href="matrix.h.html#Main_header">Main_header</a> *header;
{

  int i = 0, j = 0;
  char mn[20];
  /* set magic number */
  sprintf(mn,"%s%d%s\n", magicNumber,header-&gt;sw_version,
	dstypecode[header-&gt;file_type]);
  <a href="machine_indep.c.html#bufWrite">bufWrite</a>(mn, bufr, &i, 14);
	
	/* copy buffer into struct */
  <a href="machine_indep.c.html#bufWrite">bufWrite</a>(header-&gt;original_file_name, bufr, &i, NameLen);
  <a href="machine_indep.c.html#bufWrite_s">bufWrite_s</a>(header-&gt;sw_version, bufr, &i);
  <a href="machine_indep.c.html#bufWrite_s">bufWrite_s</a>(header-&gt;system_type, bufr, &i);
  <a href="machine_indep.c.html#bufWrite_s">bufWrite_s</a>(header-&gt;file_type, bufr, &i);
  <a href="machine_indep.c.html#bufWrite">bufWrite</a>(header-&gt;serial_number, bufr, &i, 10);
  <a href="machine_indep.c.html#bufWrite_i">bufWrite_i</a>(header-&gt;scan_start_time, bufr, &i);
  <a href="machine_indep.c.html#bufWrite">bufWrite</a>(header-&gt;isotope_code, bufr, &i, 8);
  <a href="machine_indep.c.html#bufWrite_f">bufWrite_f</a>(header-&gt;isotope_halflife, bufr, &i);
  <a href="machine_indep.c.html#bufWrite">bufWrite</a>(header-&gt;radiopharmaceutical, bufr, &i, NameLen);
  <a href="machine_indep.c.html#bufWrite_f">bufWrite_f</a>(header-&gt;gantry_tilt, bufr, &i);
  <a href="machine_indep.c.html#bufWrite_f">bufWrite_f</a>(header-&gt;gantry_rotation, bufr, &i);
  <a href="machine_indep.c.html#bufWrite_f">bufWrite_f</a>(header-&gt;bed_elevation, bufr, &i);
  <a href="machine_indep.c.html#bufWrite_f">bufWrite_f</a>(header-&gt;intrinsic_tilt, bufr, &i);
  <a href="machine_indep.c.html#bufWrite_s">bufWrite_s</a>(header-&gt;wobble_speed, bufr, &i);
  <a href="machine_indep.c.html#bufWrite_s">bufWrite_s</a>(header-&gt;transm_source_type, bufr, &i);
  <a href="machine_indep.c.html#bufWrite_f">bufWrite_f</a>(header-&gt;distance_scanned, bufr, &i);
  <a href="machine_indep.c.html#bufWrite_f">bufWrite_f</a>(header-&gt;transaxial_fov, bufr, &i);
  <a href="machine_indep.c.html#bufWrite_s">bufWrite_s</a>(header-&gt;angular_compression, bufr, &i);
  <a href="machine_indep.c.html#bufWrite_s">bufWrite_s</a>(header-&gt;coin_samp_mode, bufr, &i);
  <a href="machine_indep.c.html#bufWrite_s">bufWrite_s</a>(header-&gt;axial_samp_mode, bufr, &i);
  <a href="machine_indep.c.html#bufWrite_f">bufWrite_f</a>(header-&gt;calibration_factor, bufr, &i);
  <a href="machine_indep.c.html#bufWrite_s">bufWrite_s</a>(header-&gt;calibration_units, bufr, &i);
  <a href="machine_indep.c.html#bufWrite_s">bufWrite_s</a>(header-&gt;calibration_units_label, bufr, &i);
  <a href="machine_indep.c.html#bufWrite_s">bufWrite_s</a>(header-&gt;compression_code, bufr, &i);
  <a href="machine_indep.c.html#bufWrite">bufWrite</a>(header-&gt;study_name, bufr, &i, 12);
  <a href="machine_indep.c.html#bufWrite">bufWrite</a>(header-&gt;patient_id, bufr, &i, IDLen);
  <a href="machine_indep.c.html#bufWrite">bufWrite</a>(header-&gt;patient_name, bufr, &i, NameLen);
  <a href="machine_indep.c.html#bufWrite">bufWrite</a>(header-&gt;patient_sex, bufr, &i, 1);
  <a href="machine_indep.c.html#bufWrite">bufWrite</a>(header-&gt;patient_dexterity, bufr, &i, 1);
  <a href="machine_indep.c.html#bufWrite_f">bufWrite_f</a>(header-&gt;patient_age, bufr, &i);
  <a href="machine_indep.c.html#bufWrite_f">bufWrite_f</a>(header-&gt;patient_height, bufr, &i);
  <a href="machine_indep.c.html#bufWrite_f">bufWrite_f</a>(header-&gt;patient_weight, bufr, &i);
  <a href="machine_indep.c.html#bufWrite_i">bufWrite_i</a>(header-&gt;patient_birth_date, bufr, &i);
  <a href="machine_indep.c.html#bufWrite">bufWrite</a>(header-&gt;physician_name, bufr, &i, NameLen);
  <a href="machine_indep.c.html#bufWrite">bufWrite</a>(header-&gt;operator_name, bufr, &i, NameLen);
  <a href="machine_indep.c.html#bufWrite">bufWrite</a>(header-&gt;study_description, bufr, &i, NameLen);
  <a href="machine_indep.c.html#bufWrite_s">bufWrite_s</a>(header-&gt;acquisition_type, bufr, &i);
  <a href="machine_indep.c.html#bufWrite_s">bufWrite_s</a>(header-&gt;patient_orientation, bufr, &i);
  <a href="machine_indep.c.html#bufWrite">bufWrite</a>(header-&gt;facility_name, bufr, &i, 20);
  <a href="machine_indep.c.html#bufWrite_s">bufWrite_s</a>(header-&gt;num_planes, bufr, &i);
  <a href="machine_indep.c.html#bufWrite_s">bufWrite_s</a>(header-&gt;num_frames, bufr, &i);
  <a href="machine_indep.c.html#bufWrite_s">bufWrite_s</a>(header-&gt;num_gates, bufr, &i);
  <a href="machine_indep.c.html#bufWrite_s">bufWrite_s</a>(header-&gt;num_bed_pos, bufr, &i);
  <a href="machine_indep.c.html#bufWrite_f">bufWrite_f</a>(header-&gt;init_bed_position, bufr, &i);
  for(j = 0; j &lt; 15; j++)
  	<a href="machine_indep.c.html#bufWrite_f">bufWrite_f</a>(header-&gt;bed_offset[j], bufr, &i);
  <a href="machine_indep.c.html#bufWrite_f">bufWrite_f</a>(header-&gt;plane_separation, bufr, &i);
  <a href="machine_indep.c.html#bufWrite_s">bufWrite_s</a>(header-&gt;lwr_sctr_thres, bufr, &i);
  <a href="machine_indep.c.html#bufWrite_s">bufWrite_s</a>(header-&gt;lwr_true_thres, bufr, &i);
  <a href="machine_indep.c.html#bufWrite_s">bufWrite_s</a>(header-&gt;upr_true_thres, bufr, &i);
  <a href="machine_indep.c.html#bufWrite">bufWrite</a>(header-&gt;user_process_code, bufr, &i, 10);
  <a href="machine_indep.c.html#bufWrite_s">bufWrite_s</a>(header-&gt;acquisition_mode, bufr, &i);
  <a href="machine_indep.c.html#bufWrite_f">bufWrite_f</a>(header-&gt;bin_size, bufr, &i);
  <a href="machine_indep.c.html#bufWrite_f">bufWrite_f</a>(header-&gt;branching_fraction, bufr, &i);
  <a href="machine_indep.c.html#bufWrite_i">bufWrite_i</a>(header-&gt;dose_start_time, bufr, &i);
  <a href="machine_indep.c.html#bufWrite_f">bufWrite_f</a>(header-&gt;dosage, bufr, &i);
  <a href="machine_indep.c.html#bufWrite_f">bufWrite_f</a>(header-&gt;well_counter_factor, bufr, &i);
  <a href="machine_indep.c.html#bufWrite">bufWrite</a>(header-&gt;data_units, bufr, &i, 32);
  <a href="machine_indep.c.html#bufWrite_s">bufWrite_s</a>(header-&gt;septa_state, bufr, &i);
  return 1;
}

<LI><H3><a name="mat_write_main_header">int mat_write_main_header( fptr , header)</a></H3>
  FILE *fptr;
  <a href="matrix.h.html#Main_header">Main_header</a> *header;
{
  char bufr[MatBLKSIZE];
  if (header-&gt;sw_version &lt; V7) map64_main_header(bufr,header);
  else <a href="matrix.c.html#map_main_header">map_main_header</a>(bufr,header);
  return <a href="matrix.c.html#mat_wblk">mat_wblk</a>( fptr, 1, bufr, 1);   /* write main header at block 1 */
}

<LI><H3><a name="map_image_header">int map_image_header(buf,header)</a></H3>
char *buf;
<a href="matrix.h.html#Image_subheader">Image_subheader</a> *header;
{
	int i = 0;
	<a href="machine_indep.c.html#bufWrite_s">bufWrite_s</a>(header-&gt;data_type, buf, &i);
	<a href="machine_indep.c.html#bufWrite_s">bufWrite_s</a>(header-&gt;num_dimensions, buf, &i);
	<a href="machine_indep.c.html#bufWrite_s">bufWrite_s</a>(header-&gt;x_dimension, buf, &i);
	<a href="machine_indep.c.html#bufWrite_s">bufWrite_s</a>(header-&gt;y_dimension, buf, &i);
	<a href="machine_indep.c.html#bufWrite_s">bufWrite_s</a>(header-&gt;z_dimension, buf, &i);
	<a href="machine_indep.c.html#bufWrite_f">bufWrite_f</a>(header-&gt;z_offset, buf, &i);
	<a href="machine_indep.c.html#bufWrite_f">bufWrite_f</a>(header-&gt;x_offset, buf, &i);
	<a href="machine_indep.c.html#bufWrite_f">bufWrite_f</a>(header-&gt;y_offset, buf, &i);
	<a href="machine_indep.c.html#bufWrite_f">bufWrite_f</a>(header-&gt;recon_zoom, buf, &i);
	<a href="machine_indep.c.html#bufWrite_f">bufWrite_f</a>(header-&gt;scale_factor, buf, &i);
	<a href="machine_indep.c.html#bufWrite_s">bufWrite_s</a>(header-&gt;image_min, buf, &i);
	<a href="machine_indep.c.html#bufWrite_s">bufWrite_s</a>(header-&gt;image_max, buf, &i);
	<a href="machine_indep.c.html#bufWrite_f">bufWrite_f</a>(header-&gt;x_pixel_size, buf, &i);
	<a href="machine_indep.c.html#bufWrite_f">bufWrite_f</a>(header-&gt;y_pixel_size, buf, &i);
	<a href="machine_indep.c.html#bufWrite_f">bufWrite_f</a>(header-&gt;z_pixel_size, buf, &i);
	<a href="machine_indep.c.html#bufWrite_i">bufWrite_i</a>(header-&gt;frame_duration, buf, &i);
	<a href="machine_indep.c.html#bufWrite_i">bufWrite_i</a>(header-&gt;frame_start_time, buf, &i);
	<a href="machine_indep.c.html#bufWrite_s">bufWrite_s</a>(header-&gt;filter_code, buf, &i);
	<a href="machine_indep.c.html#bufWrite_f">bufWrite_f</a>(header-&gt;x_resolution, buf, &i);
	<a href="machine_indep.c.html#bufWrite_f">bufWrite_f</a>(header-&gt;y_resolution, buf, &i);
	<a href="machine_indep.c.html#bufWrite_f">bufWrite_f</a>(header-&gt;z_resolution, buf, &i);
	<a href="machine_indep.c.html#bufWrite_f">bufWrite_f</a>(header-&gt;num_r_elements, buf, &i);
	<a href="machine_indep.c.html#bufWrite_f">bufWrite_f</a>(header-&gt;num_angles, buf, &i);
	<a href="machine_indep.c.html#bufWrite_f">bufWrite_f</a>(header-&gt;z_rotation_angle, buf, &i);
	<a href="machine_indep.c.html#bufWrite_f">bufWrite_f</a>(header-&gt;decay_corr_fctr, buf, &i);
	<a href="machine_indep.c.html#bufWrite_i">bufWrite_i</a>(header-&gt;processing_code, buf, &i);
	<a href="machine_indep.c.html#bufWrite_i">bufWrite_i</a>(header-&gt;gate_duration, buf, &i);
	<a href="machine_indep.c.html#bufWrite_i">bufWrite_i</a>(header-&gt;r_wave_offset, buf, &i);
	<a href="machine_indep.c.html#bufWrite_i">bufWrite_i</a>(header-&gt;num_accepted_beats, buf, &i);
	<a href="machine_indep.c.html#bufWrite_f">bufWrite_f</a>(header-&gt;filter_cutoff_frequency, buf, &i);
	<a href="machine_indep.c.html#bufWrite_f">bufWrite_f</a>(header-&gt;filter_resolution, buf, &i);
	<a href="machine_indep.c.html#bufWrite_f">bufWrite_f</a>(header-&gt;filter_ramp_slope, buf, &i);
	<a href="machine_indep.c.html#bufWrite_s">bufWrite_s</a>(header-&gt;filter_order, buf, &i);
	<a href="machine_indep.c.html#bufWrite_f">bufWrite_f</a>(header-&gt;filter_scatter_fraction, buf, &i);
	<a href="machine_indep.c.html#bufWrite_f">bufWrite_f</a>(header-&gt;filter_scatter_slope, buf, &i);
	<a href="machine_indep.c.html#bufWrite">bufWrite</a>(header-&gt;annotation, buf, &i, 40);
	<a href="machine_indep.c.html#bufWrite_f">bufWrite_f</a>(header-&gt;mt_1_1, buf, &i);
	<a href="machine_indep.c.html#bufWrite_f">bufWrite_f</a>(header-&gt;mt_1_2, buf, &i);
	<a href="machine_indep.c.html#bufWrite_f">bufWrite_f</a>(header-&gt;mt_1_3, buf, &i);
	<a href="machine_indep.c.html#bufWrite_f">bufWrite_f</a>(header-&gt;mt_2_1, buf, &i);
	<a href="machine_indep.c.html#bufWrite_f">bufWrite_f</a>(header-&gt;mt_2_2, buf, &i);
	<a href="machine_indep.c.html#bufWrite_f">bufWrite_f</a>(header-&gt;mt_2_3, buf, &i);
	<a href="machine_indep.c.html#bufWrite_f">bufWrite_f</a>(header-&gt;mt_3_1, buf, &i);
	<a href="machine_indep.c.html#bufWrite_f">bufWrite_f</a>(header-&gt;mt_3_2, buf, &i);
	<a href="machine_indep.c.html#bufWrite_f">bufWrite_f</a>(header-&gt;mt_3_3, buf, &i);
	<a href="machine_indep.c.html#bufWrite_f">bufWrite_f</a>(header-&gt;rfilter_cutoff, buf, &i);
	<a href="machine_indep.c.html#bufWrite_f">bufWrite_f</a>(header-&gt;rfilter_resolution, buf, &i);
	<a href="machine_indep.c.html#bufWrite_s">bufWrite_s</a>(header-&gt;rfilter_code, buf, &i);
	<a href="machine_indep.c.html#bufWrite_s">bufWrite_s</a>(header-&gt;rfilter_order, buf, &i);
	<a href="machine_indep.c.html#bufWrite_f">bufWrite_f</a>(header-&gt;zfilter_cutoff, buf, &i);
	<a href="machine_indep.c.html#bufWrite_f">bufWrite_f</a>(header-&gt;zfilter_resolution, buf, &i);
	<a href="machine_indep.c.html#bufWrite_s">bufWrite_s</a>(header-&gt;zfilter_code, buf, &i);
	<a href="machine_indep.c.html#bufWrite_s">bufWrite_s</a>(header-&gt;zfilter_order, buf, &i);
	<a href="machine_indep.c.html#bufWrite_f">bufWrite_f</a>(header-&gt;mt_1_4, buf, &i);
	<a href="machine_indep.c.html#bufWrite_f">bufWrite_f</a>(header-&gt;mt_2_4, buf, &i);
	<a href="machine_indep.c.html#bufWrite_f">bufWrite_f</a>(header-&gt;mt_3_4, buf, &i);
	<a href="machine_indep.c.html#bufWrite_s">bufWrite_s</a>(header-&gt;scatter_type, buf, &i);
	<a href="machine_indep.c.html#bufWrite_s">bufWrite_s</a>(header-&gt;recon_type, buf, &i);
	<a href="machine_indep.c.html#bufWrite_s">bufWrite_s</a>(header-&gt;recon_views, buf, &i);
	return 1;
}

<LI><H3><a name="mat_write_image_subheader">int mat_write_image_subheader( file, blknum, header)</a></H3>
  MatrixFile *file;
  int blknum;
  <a href="matrix.h.html#Image_subheader">Image_subheader</a> *header;
{
	char buf[MatBLKSIZE];
	if (file-&gt;mhptr->sw_version &lt; V7)
		map64_image_header(buf,header,file-&gt;mhptr);
	else <a href="matrix.c.html#map_image_header">map_image_header</a>(buf,header);
	return <a href="matrix.c.html#mat_wblk">mat_wblk</a>( file-&gt;fptr, blknum, buf, 1);
}

<LI><H3><a name="map_scan_header">int map_scan_header(buf,header)</a></H3>
char *buf;
<a href="matrix.h.html#Scan_subheader">Scan_subheader</a> *header;
{
	int i = 0, j= 0;
	<a href="machine_indep.c.html#bufWrite_s">bufWrite_s</a>(header-&gt;data_type, buf, &i);
	<a href="machine_indep.c.html#bufWrite_s">bufWrite_s</a>(header-&gt;num_dimensions, buf, &i);
	<a href="machine_indep.c.html#bufWrite_s">bufWrite_s</a>(header-&gt;num_r_elements, buf, &i);
	<a href="machine_indep.c.html#bufWrite_s">bufWrite_s</a>(header-&gt;num_angles, buf, &i);
	<a href="machine_indep.c.html#bufWrite_s">bufWrite_s</a>(header-&gt;corrections_applied, buf, &i);
	<a href="machine_indep.c.html#bufWrite_s">bufWrite_s</a>(header-&gt;num_z_elements, buf, &i);
	<a href="machine_indep.c.html#bufWrite_s">bufWrite_s</a>(header-&gt;ring_difference, buf, &i);
	<a href="machine_indep.c.html#bufWrite_f">bufWrite_f</a>(header-&gt;x_resolution, buf, &i);
	<a href="machine_indep.c.html#bufWrite_f">bufWrite_f</a>(header-&gt;y_resolution, buf, &i);
	<a href="machine_indep.c.html#bufWrite_f">bufWrite_f</a>(header-&gt;z_resolution, buf, &i);
	<a href="machine_indep.c.html#bufWrite_f">bufWrite_f</a>(header-&gt;w_resolution, buf, &i);
	i += 6 * sizeof(short);		/* space reserved for future gating info */
	<a href="machine_indep.c.html#bufWrite_i">bufWrite_i</a>(header-&gt;gate_duration, buf, &i);
	<a href="machine_indep.c.html#bufWrite_i">bufWrite_i</a>(header-&gt;r_wave_offset, buf, &i);
	<a href="machine_indep.c.html#bufWrite_i">bufWrite_i</a>(header-&gt;num_accepted_beats, buf, &i);
	<a href="machine_indep.c.html#bufWrite_f">bufWrite_f</a>(header-&gt;scale_factor, buf, &i);
	<a href="machine_indep.c.html#bufWrite_s">bufWrite_s</a>(header-&gt;scan_min, buf, &i);
	<a href="machine_indep.c.html#bufWrite_s">bufWrite_s</a>(header-&gt;scan_max, buf, &i);
	<a href="machine_indep.c.html#bufWrite_i">bufWrite_i</a>(header-&gt;prompts, buf, &i);
	<a href="machine_indep.c.html#bufWrite_i">bufWrite_i</a>(header-&gt;delayed, buf, &i);
	<a href="machine_indep.c.html#bufWrite_i">bufWrite_i</a>(header-&gt;multiples, buf, &i);
	<a href="machine_indep.c.html#bufWrite_i">bufWrite_i</a>(header-&gt;net_trues, buf, &i);
	for(j = 0; j &lt; 16; j++)
		<a href="machine_indep.c.html#bufWrite_f">bufWrite_f</a>(header-&gt;cor_singles[j], buf, &i);
	for(j = 0; j &lt; 16; j++)
		<a href="machine_indep.c.html#bufWrite_f">bufWrite_f</a>(header-&gt;uncor_singles[j], buf, &i);
	<a href="machine_indep.c.html#bufWrite_f">bufWrite_f</a>(header-&gt;tot_avg_cor, buf, &i);
	<a href="machine_indep.c.html#bufWrite_f">bufWrite_f</a>(header-&gt;tot_avg_uncor, buf, &i);
	<a href="machine_indep.c.html#bufWrite_i">bufWrite_i</a>(header-&gt;total_coin_rate, buf, &i);
	<a href="machine_indep.c.html#bufWrite_i">bufWrite_i</a>(header-&gt;frame_start_time, buf, &i);
	<a href="machine_indep.c.html#bufWrite_i">bufWrite_i</a>(header-&gt;frame_duration, buf, &i);
	<a href="machine_indep.c.html#bufWrite_f">bufWrite_f</a>(header-&gt;loss_correction_fctr, buf, &i);
	for(j = 0; j &lt; 8; j++)
		<a href="machine_indep.c.html#bufWrite_s">bufWrite_s</a>(header-&gt;phy_planes[j], buf, &i);

}

<LI><H3><a name="mat_write_scan_subheader">int mat_write_scan_subheader( file, blknum, header)</a></H3>
  MatrixFile *file;
  int blknum; 
  <a href="matrix.h.html#Scan_subheader">Scan_subheader</a> *header;
{
	char buf[MatBLKSIZE];
	if (file-&gt;mhptr->sw_version &lt; V7)
		map64_scan_header(buf,header,file-&gt;mhptr);
	else <a href="matrix.c.html#map_scan_header">map_scan_header</a>(buf,header);
	return <a href="matrix.c.html#mat_wblk">mat_wblk</a>( file-&gt;fptr, blknum, buf, 1);
}

<LI><H3><a name="map_attn_header">int map_attn_header(buf,header)</a></H3>
char *buf;
<a href="matrix.h.html#Attn_subheader">Attn_subheader</a> *header;
{
	int i = 0, j = 0;
	<a href="machine_indep.c.html#bufWrite_s">bufWrite_s</a>(header-&gt;data_type, buf, &i);
	<a href="machine_indep.c.html#bufWrite_s">bufWrite_s</a>(header-&gt;num_dimensions, buf, &i);
	<a href="machine_indep.c.html#bufWrite_s">bufWrite_s</a>(header-&gt;attenuation_type, buf, &i);
	<a href="machine_indep.c.html#bufWrite_s">bufWrite_s</a>(header-&gt;num_r_elements, buf, &i);
	<a href="machine_indep.c.html#bufWrite_s">bufWrite_s</a>(header-&gt;num_angles, buf, &i);
	<a href="machine_indep.c.html#bufWrite_s">bufWrite_s</a>(header-&gt;num_z_elements, buf, &i);
	<a href="machine_indep.c.html#bufWrite_s">bufWrite_s</a>(header-&gt;ring_difference, buf, &i);
	<a href="machine_indep.c.html#bufWrite_f">bufWrite_f</a>(header-&gt;x_resolution, buf, &i);
	<a href="machine_indep.c.html#bufWrite_f">bufWrite_f</a>(header-&gt;y_resolution, buf, &i);
	<a href="machine_indep.c.html#bufWrite_f">bufWrite_f</a>(header-&gt;z_resolution, buf, &i);
	<a href="machine_indep.c.html#bufWrite_f">bufWrite_f</a>(header-&gt;w_resolution, buf, &i);
	<a href="machine_indep.c.html#bufWrite_f">bufWrite_f</a>(header-&gt;scale_factor, buf, &i);
	<a href="machine_indep.c.html#bufWrite_f">bufWrite_f</a>(header-&gt;x_offset, buf, &i);
	<a href="machine_indep.c.html#bufWrite_f">bufWrite_f</a>(header-&gt;y_offset, buf, &i);
	<a href="machine_indep.c.html#bufWrite_f">bufWrite_f</a>(header-&gt;x_radius, buf, &i);
	<a href="machine_indep.c.html#bufWrite_f">bufWrite_f</a>(header-&gt;y_radius, buf, &i);
	<a href="machine_indep.c.html#bufWrite_f">bufWrite_f</a>(header-&gt;tilt_angle, buf, &i);
	<a href="machine_indep.c.html#bufWrite_f">bufWrite_f</a>(header-&gt;attenuation_coeff, buf, &i);
	<a href="machine_indep.c.html#bufWrite_f">bufWrite_f</a>(header-&gt;attenuation_min, buf, &i);
	<a href="machine_indep.c.html#bufWrite_f">bufWrite_f</a>(header-&gt;attenuation_max, buf, &i);
	<a href="machine_indep.c.html#bufWrite_f">bufWrite_f</a>(header-&gt;skull_thickness, buf, &i);
	<a href="machine_indep.c.html#bufWrite_s">bufWrite_s</a>(header-&gt;num_additional_atten_coeff, buf, &i);
	for(j = 0; j &lt; 8; j++)
		<a href="machine_indep.c.html#bufWrite_f">bufWrite_f</a>(header-&gt;additional_atten_coeff[j], buf, &i);
	<a href="machine_indep.c.html#bufWrite_f">bufWrite_f</a>(header-&gt;edge_finding_threshold, buf, &i);
	<a href="machine_indep.c.html#bufWrite_s">bufWrite_s</a>(header-&gt;storage_order, buf, &i);
	<a href="machine_indep.c.html#bufWrite_s">bufWrite_s</a>(header-&gt;span, buf, &i);
	for(j = 0; j &lt; 64; j++)
		<a href="machine_indep.c.html#bufWrite_s">bufWrite_s</a>(header-&gt;z_elements[j], buf, &i);

	return 1;
}

<LI><H3><a name="mat_write_attn_subheader">int mat_write_attn_subheader( file, blknum, header)</a></H3>
  MatrixFile *file;
  int blknum;
  <a href="matrix.h.html#Attn_subheader">Attn_subheader</a> *header;
{
	char buf[MatBLKSIZE];
	if (file-&gt;mhptr->sw_version &lt; V7)
		map64_attn_header(buf,header,file-&gt;mhptr);
	else <a href="matrix.c.html#map_attn_header">map_attn_header</a>(buf,header);
	return <a href="matrix.c.html#mat_wblk">mat_wblk</a>( file-&gt;fptr, blknum, buf, 1);
}

<LI><H3><a name="map_norm_header">int map_norm_header(buf,header)</a></H3>
char *buf;
<a href="matrix.h.html#Norm_subheader">Norm_subheader</a> *header;
{
	int i = 0, j = 0;
	<a href="machine_indep.c.html#bufWrite_s">bufWrite_s</a>(header-&gt;data_type, buf, &i);
	<a href="machine_indep.c.html#bufWrite_s">bufWrite_s</a>(header-&gt;num_dimensions, buf, &i);
	<a href="machine_indep.c.html#bufWrite_s">bufWrite_s</a>(header-&gt;num_r_elements, buf, &i);
	<a href="machine_indep.c.html#bufWrite_s">bufWrite_s</a>(header-&gt;num_angles, buf, &i);
	<a href="machine_indep.c.html#bufWrite_s">bufWrite_s</a>(header-&gt;num_z_elements, buf, &i);
	<a href="machine_indep.c.html#bufWrite_s">bufWrite_s</a>(header-&gt;ring_difference, buf, &i);
	<a href="machine_indep.c.html#bufWrite_f">bufWrite_f</a>(header-&gt;scale_factor, buf, &i);
	<a href="machine_indep.c.html#bufWrite_f">bufWrite_f</a>(header-&gt;norm_min, buf, &i);
	<a href="machine_indep.c.html#bufWrite_f">bufWrite_f</a>(header-&gt;norm_max, buf, &i);
	<a href="machine_indep.c.html#bufWrite_f">bufWrite_f</a>(header-&gt;fov_source_width, buf, &i);
	<a href="machine_indep.c.html#bufWrite_f">bufWrite_f</a>(header-&gt;norm_quality_factor, buf, &i);
	<a href="machine_indep.c.html#bufWrite_s">bufWrite_s</a>(header-&gt;norm_quality_factor_code, buf, &i);
	<a href="machine_indep.c.html#bufWrite_s">bufWrite_s</a>(header-&gt;storage_order, buf, &i);
	<a href="machine_indep.c.html#bufWrite_s">bufWrite_s</a>(header-&gt;span, buf, &i);
	for(j = 0; j &lt; 64; j++)
		<a href="machine_indep.c.html#bufWrite_s">bufWrite_s</a>(header-&gt;z_elements[j], buf, &i);
	return 1;
}

<LI><H3><a name="mat_write_norm_subheader">int mat_write_norm_subheader( file, blknum, header)</a></H3>
  MatrixFile *file;
  int blknum;
  <a href="matrix.h.html#Norm_subheader">Norm_subheader</a> *header;
{
	char buf[MatBLKSIZE];
	if (file-&gt;mhptr->sw_version &lt; V7)
		map64_norm_header(buf,header,file-&gt;mhptr);
	else <a href="matrix.c.html#map_norm_header">map_norm_header</a>(buf,header);
	return <a href="matrix.c.html#mat_wblk">mat_wblk</a>( file-&gt;fptr, blknum, buf, 1);
}

int mat_write_Scan3D_subheader( file, blknum, header)
  MatrixFile *file;
  int blknum;
  Scan3D_subheader *header;
{
	char buf[2*MatBLKSIZE];
	if (file-&gt;mhptr->sw_version &lt; V7)
		<a href="crash.c.html#crash">crash</a>("Short3dSinogram : not supported by ecat version 6.x\n");
	map_Scan3D_header(buf,header);
	return <a href="matrix.c.html#mat_wblk">mat_wblk</a>( file-&gt;fptr, blknum, buf, 2);
}

<LI><H3><a name="unmap_attn_header">int unmap_attn_header(buf,header) </a></H3>
char *buf;
<a href="matrix.h.html#Attn_subheader">Attn_subheader</a> *header;
{
	int i = 0, j = 0;
	<a href="machine_indep.c.html#bufRead_s">bufRead_s</a>(&header-&gt;data_type, buf, &i);
	<a href="machine_indep.c.html#bufRead_s">bufRead_s</a>(&header-&gt;num_dimensions, buf, &i);
	<a href="machine_indep.c.html#bufRead_s">bufRead_s</a>(&header-&gt;attenuation_type, buf, &i);
	<a href="machine_indep.c.html#bufRead_s">bufRead_s</a>(&header-&gt;num_r_elements, buf, &i);
	<a href="machine_indep.c.html#bufRead_s">bufRead_s</a>(&header-&gt;num_angles, buf, &i);
	<a href="machine_indep.c.html#bufRead_s">bufRead_s</a>(&header-&gt;num_z_elements, buf, &i);
	<a href="machine_indep.c.html#bufRead_s">bufRead_s</a>(&header-&gt;ring_difference, buf, &i);
	<a href="machine_indep.c.html#bufRead_f">bufRead_f</a>(&header-&gt;x_resolution, buf, &i);
	<a href="machine_indep.c.html#bufRead_f">bufRead_f</a>(&header-&gt;y_resolution, buf, &i);
	<a href="machine_indep.c.html#bufRead_f">bufRead_f</a>(&header-&gt;z_resolution, buf, &i);
	<a href="machine_indep.c.html#bufRead_f">bufRead_f</a>(&header-&gt;w_resolution, buf, &i);
	<a href="machine_indep.c.html#bufRead_f">bufRead_f</a>(&header-&gt;scale_factor, buf, &i);
	<a href="machine_indep.c.html#bufRead_f">bufRead_f</a>(&header-&gt;x_offset, buf, &i);
	<a href="machine_indep.c.html#bufRead_f">bufRead_f</a>(&header-&gt;y_offset, buf, &i);
	<a href="machine_indep.c.html#bufRead_f">bufRead_f</a>(&header-&gt;x_radius, buf, &i);
	<a href="machine_indep.c.html#bufRead_f">bufRead_f</a>(&header-&gt;y_radius, buf, &i);
	<a href="machine_indep.c.html#bufRead_f">bufRead_f</a>(&header-&gt;tilt_angle, buf, &i);
	<a href="machine_indep.c.html#bufRead_f">bufRead_f</a>(&header-&gt;attenuation_coeff, buf, &i);
	<a href="machine_indep.c.html#bufRead_f">bufRead_f</a>(&header-&gt;attenuation_min, buf, &i);
	<a href="machine_indep.c.html#bufRead_f">bufRead_f</a>(&header-&gt;attenuation_max, buf, &i);
	<a href="machine_indep.c.html#bufRead_f">bufRead_f</a>(&header-&gt;skull_thickness, buf, &i);
	<a href="machine_indep.c.html#bufRead_s">bufRead_s</a>(&header-&gt;num_additional_atten_coeff, buf, &i);
	for(j = 0; j &lt; 8; j++)
		<a href="machine_indep.c.html#bufRead_f">bufRead_f</a>(&header-&gt;additional_atten_coeff[j], buf, &i);
	<a href="machine_indep.c.html#bufRead_f">bufRead_f</a>(&header-&gt;edge_finding_threshold, buf, &i);
	<a href="machine_indep.c.html#bufRead_s">bufRead_s</a>(&header-&gt;storage_order, buf, &i);
	<a href="machine_indep.c.html#bufRead_s">bufRead_s</a>(&header-&gt;span, buf, &i);
	for(j = 0; j &lt; 64; j++)
		<a href="machine_indep.c.html#bufRead_s">bufRead_s</a>(&header-&gt;z_elements[j], buf, &i);

	return 0;
}

<LI><H3><a name="mat_read_attn_subheader">int mat_read_attn_subheader( file, blknum, header)</a></H3>
  MatrixFile* file;
  int blknum; 
  <a href="matrix.h.html#Attn_subheader">Attn_subheader</a> *header;
{
	char buf[MatBLKSIZE];
	if (file-&gt;acs) <a href="rts_cmd.c.html#rtsRblk">rtsRblk</a>(file->fname, blknum, buf);
	else <a href="matrix.c.html#mat_rblk">mat_rblk</a>( file-&gt;fptr, blknum, buf, 1);
	if (file-&gt;mhptr->sw_version &lt; V7)
		return unmap64_attn_header(buf,header, file-&gt;mhptr);
	return <a href="matrix.c.html#unmap_attn_header">unmap_attn_header</a>(buf,header);
}

<LI><H3><a name="unmap_norm_header">int unmap_norm_header(buf,header)</a></H3>
char *buf;
<a href="matrix.h.html#Norm_subheader">Norm_subheader</a> *header;
{
	int i = 0, j = 0;
	<a href="machine_indep.c.html#bufRead_s">bufRead_s</a>(&header-&gt;data_type, buf, &i);
	<a href="machine_indep.c.html#bufRead_s">bufRead_s</a>(&header-&gt;num_dimensions, buf, &i);
	<a href="machine_indep.c.html#bufRead_s">bufRead_s</a>(&header-&gt;num_r_elements, buf, &i);
	<a href="machine_indep.c.html#bufRead_s">bufRead_s</a>(&header-&gt;num_angles, buf, &i);
	<a href="machine_indep.c.html#bufRead_s">bufRead_s</a>(&header-&gt;num_z_elements, buf, &i);
	<a href="machine_indep.c.html#bufRead_s">bufRead_s</a>(&header-&gt;ring_difference, buf, &i);
	<a href="machine_indep.c.html#bufRead_f">bufRead_f</a>(&header-&gt;scale_factor, buf, &i);
	<a href="machine_indep.c.html#bufRead_f">bufRead_f</a>(&header-&gt;norm_min, buf, &i);
	<a href="machine_indep.c.html#bufRead_f">bufRead_f</a>(&header-&gt;norm_max, buf, &i);
	<a href="machine_indep.c.html#bufRead_f">bufRead_f</a>(&header-&gt;fov_source_width, buf, &i);
	<a href="machine_indep.c.html#bufRead_f">bufRead_f</a>(&header-&gt;norm_quality_factor, buf, &i);
	<a href="machine_indep.c.html#bufRead_s">bufRead_s</a>(&header-&gt;norm_quality_factor_code, buf, &i);
	<a href="machine_indep.c.html#bufRead_s">bufRead_s</a>(&header-&gt;storage_order, buf, &i);
	<a href="machine_indep.c.html#bufRead_s">bufRead_s</a>(&header-&gt;span, buf, &i);
	for(j = 0; j &lt; 64; j++)
		<a href="machine_indep.c.html#bufRead_s">bufRead_s</a>(&header-&gt;z_elements[j], buf, &i);
	
	return 0;
}
int unmap_norm3d_header(buf,header)
char *buf;
Norm3D_subheader *header;
{
	int i = 0, j = 0;
	memset(header,0,sizeof(Norm3D_subheader));
	<a href="machine_indep.c.html#bufRead_s">bufRead_s</a>(&header-&gt;data_type, buf, &i);
	<a href="machine_indep.c.html#bufRead_s">bufRead_s</a>(&header-&gt;num_r_elements, buf, &i);
	<a href="machine_indep.c.html#bufRead_s">bufRead_s</a>(&header-&gt;num_transaxial_crystals, buf, &i);
	<a href="machine_indep.c.html#bufRead_s">bufRead_s</a>(&header-&gt;num_crystal_rings, buf, &i);
	<a href="machine_indep.c.html#bufRead_s">bufRead_s</a>(&header-&gt;crystals_per_ring, buf, &i);
	<a href="machine_indep.c.html#bufRead_s">bufRead_s</a>(&header-&gt;num_geo_corr_planes, buf, &i);
	<a href="machine_indep.c.html#bufRead_s">bufRead_s</a>(&header-&gt;uld, buf, &i);
	<a href="machine_indep.c.html#bufRead_s">bufRead_s</a>(&header-&gt;lld, buf, &i);
	<a href="machine_indep.c.html#bufRead_s">bufRead_s</a>(&header-&gt;scatter_energy, buf, &i);
	<a href="machine_indep.c.html#bufRead_s">bufRead_s</a>(&header-&gt;norm_quality_factor_code, buf, &i);
	<a href="machine_indep.c.html#bufRead_f">bufRead_f</a>(&header-&gt;norm_quality_factor, buf, &i);
	for(j = 0; j &lt; 32; j++)
		<a href="machine_indep.c.html#bufRead_f">bufRead_f</a>(&header-&gt;ring_dtcor1[j], buf, &i);
	for(j = 0; j &lt; 32; j++)
		<a href="machine_indep.c.html#bufRead_f">bufRead_f</a>(&header-&gt;ring_dtcor2[j], buf, &i);
	for(j = 0; j &lt; 8; j++)
		<a href="machine_indep.c.html#bufRead_f">bufRead_f</a>(&header-&gt;crystal_dtcor[j], buf, &i);
	<a href="machine_indep.c.html#bufRead_s">bufRead_s</a>(&header-&gt;span, buf, &i);
	<a href="machine_indep.c.html#bufRead_s">bufRead_s</a>(&header-&gt;max_ring_diff, buf, &i);
	return 0;
}

<LI><H3><a name="mat_read_norm_subheader">int mat_read_norm_subheader(file, blknum, header)</a></H3>
  MatrixFile *file;
  int blknum;
  <a href="matrix.h.html#Norm_subheader">Norm_subheader</a> *header;
{
	char buf[MatBLKSIZE];
	if (file-&gt;acs) <a href="rts_cmd.c.html#rtsRblk">rtsRblk</a>(file->fname, blknum, buf);
	else <a href="matrix.c.html#mat_rblk">mat_rblk</a>( file-&gt;fptr, blknum, buf, 1);
	if (file-&gt;mhptr->sw_version &lt; V7)
		return unmap64_norm_header(buf,header, file-&gt;mhptr);
	return <a href="matrix.c.html#unmap_norm_header">unmap_norm_header</a>(buf,header);
}

int mat_read_norm3d_subheader(file, blknum, header)
MatrixFile *file;
int blknum;
Norm3D_subheader *header;
{
	char buf[MatBLKSIZE];
	if (file-&gt;acs) <a href="rts_cmd.c.html#rtsRblk">rtsRblk</a>(file->fname, blknum, buf);
	else <a href="matrix.c.html#mat_rblk">mat_rblk</a>( file-&gt;fptr, blknum, buf, 1);
	if (file-&gt;mhptr->sw_version == V7) return unmap_norm3d_header(buf,header);
	return 0;
}

#ifdef __STDC__
<a href="matrix.c.html#matspec">matspec</a>( const char* str, char* fname, int* matnum)
#else
<LI><H3><a name="matspec">matspec( str, fname, matnum)</a></H3>
  char *str, *fname;
  int *matnum;
#endif
{
	char *cp;
	int mf=0,mp=0,mg=0,ms=0,mb=0;

	strcpy( fname, str);
	cp = (char*) strchr( fname, ',');
	if (cp)
	{
	  *cp++ = '\0';
	  sscanf( cp, "%d,%d,%d,%d,%d", &mf,&mp,&mg,&ms,&mb);
	  *matnum = <a href="matrix.c.html#mat_numcod">mat_numcod</a>( mf,mp,mg,ms,mb);
	  return 1;
	}
	return 0;
}
