head	1.11;
access;
symbols;
locks; strict;
comment	@ * @;


1.11
date	2002.02.27.18.11.36;	author tom;	state Exp;
branches;
next	1.10;

1.10
date	98.07.28.16.25.32;	author tom;	state Exp;
branches;
next	1.9;

1.9
date	98.07.22.16.33.20;	author tom;	state Exp;
branches;
next	1.8;

1.8
date	98.07.21.21.35.17;	author tom;	state Exp;
branches;
next	1.7;

1.7
date	98.07.21.16.18.58;	author tom;	state Exp;
branches;
next	1.6;

1.6
date	95.02.24.17.21.41;	author tom;	state Exp;
branches;
next	1.5;

1.5
date	94.04.13.16.16.35;	author tom;	state Exp;
branches;
next	1.4;

1.4
date	94.03.03.22.09.30;	author tom;	state Exp;
branches;
next	1.3;

1.3
date	94.03.03.22.08.02;	author tom;	state Exp;
branches;
next	1.2;

1.2
date	94.02.23.19.48.27;	author tom;	state Exp;
branches;
next	1.1;

1.1
date	94.02.09.19.50.07;	author tom;	state Exp;
branches;
next	;


desc
@original
@


1.11
log
@lint cleaning
@
text
@/* $Log: bkproj_sun.c,v $
 * Revision 1.10  1998/07/28  16:25:32  tom
 * reduce messages and fix debug
 *
 * Revision 1.9  1998/07/22  16:33:20  tom
 * add DEBUG
 *
 * Revision 1.8  1998/07/21  21:35:17  tom
 * Solaris version
 *
 * Revision 1.7  1998/07/21  16:18:58  tom
 * Solaris version
 *
 * Revision 1.6  1995/02/24  17:21:41  tom
 * skip warning for 961
 *
 * Revision 1.5  1994/04/13  16:16:35  tom
 * copy frame_start_time from input sinogram to output image
 *
 * Revision 1.4  1994/03/03  22:09:30  tom
 * matrix.h and isotope_info.h now included from /usr/local/include/petutil
 *
 * Revision 1.3  1994/03/03  22:08:02  tom
 * changed Id to $Header: /home/npggw/tom/src/bkproj_sun/RCS/bkproj_sun.c,v 1.10 1998/07/28 16:25:32 tom Exp tom $
 *
 * Revision 1.2  1994/02/23  19:48:27  tom
 * added RCS keywords
 * */
/* @@(#)bkproj_sun.c	1.4 3/10/93 */

/* bkproj_sun.c

   Backprojection program running under SUN 4.01, 4.1 kernel.
   Uses CSPI emulation package to do numerical computation

   Environment: RECON_DEBUG 	for turning recon debug on
   Variables	RECON_TIME 	when set to 1 will display recon time
		SCATDIR 	is the path to locate the scatparms.dat file
				being used for scatter correction.

   01-May-1990   P. Luk   Adapted from previous version of Larry Byars.
   22-Feb-1991   P. Luk   handles instrinsic rotation of 933/953 models.
   01-Aug-1991   P. Luk   generic file I/O.
   20-Aug-1991   P. Luk   add arc correction option.
   22-Jul-1992   HPG   	  update arc correction to include 961
   21-Oct-1992   HPG      added data_type for image mhead and feature to
                          report total time of execution.
   28-Dec-1992   HPG      added a flag for specifying intrinsic tilt
                          correction.
   02-Feb-1993   HPG      added scatter correction option.
   04-Mar-1993	 HPG	  branching fraction is now included in the ECF field
			  of image subheader.
   07-Mar-1993	 HPG	  Modified the switch statement being used for arc
			  correction.
   07-Feb-1994   JMO (John Ollinger) Fixed several bugs: order of
		           arc-correction and normalization, parameter in call
			   to makefilter, and scaling of cutoff frequency with
			   sampling distance.
   22-Feb-1994   TOV  changed sincos to separate sin and cos calls for HP-UX
   13-Apr-1994   TOV  copy frame_start_time from input file to image (in msec)
   24-Feb-1995   TOV  skip warning message for 961 sampling size
*/

#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <matrix.h>
#include <isotope_info.h>
#include <string.h>
#include <sys/types.h>
#include <sys/timeb.h>

#ifndef lint
static char     rcsid[] = "$Header: /home/npggw/tom/src/bkproj_sun/RCS/bkproj_sun.c,v 1.10 1998/07/28 16:25:32 tom Exp tom $";
static char     sccsid[] = "@@(#)bkproj_sun.c	1.4 3/10/93  Copyright(c) 1989-1993 CTI PET Systems, Inc.";
#endif

#define SCATTER 16
#define STA_953_SAMPSIZE .3129			 /* JMO 2/5/94 */

main (argc, argv)
	int             argc;
	char           *argv[];
{
	short int      *scan, *imagei;
	int             debug = 0;
	int             numProjs, numViews, i, j, size;
	int             fcode, fft_size, fft_size2, fft_offset;
	int             decayFlag = 0, scatFlag = 0, arcorFlag = 0;
	int             normFlag = 0, atnFlag = 0;
	int             frame, plane=1, gate, bed, data;
	int             bkp_type, bkp_start_view, bkp_numViews;
	int             imageSize;
	int             arg, matnum, atn_matnum = 0, nrm_matnum = 0;
	int             TotalNviews, MultFactor, intrinsicTilt = 0;
	register int    scanSize;

	long            one = 1;

	float           scalef;
	float          *image, *proj, zoom, imageMin, imageMax, zoomSpec;
	float          *scan1;			 /* JMO 2.4.94 */
	float          *fs, *scatParams, *scatterBufr, branchFrac = 1.0;
	float           xoff, yoff, rotoff, irot, x0, y0;
	float           fparms[10], *filterBufr, *fftBufr, *fftBufr2;
	float           offset, ra;
	float          *norm, *attn, *buf1, *buf2;
	float           halfLife, decayFactor = 1.0, dtcor, frameStartTime;
	float           radius, gprofile[512], w, frameDuration;
	float           sf, fone = 1.0;

	double          ln2, lamdaT;
	double          cost, sint, r0, rdx, rdy, rx0, ry0, theta;
	double          t0, t1, t2, t3, t4, t5;
	double          m0, m1, m2, m3, m4, m5;

	char            fname[256], attnFileName[256], normFileName[256];
	char            str[20];

	FILE           *fptr, *mat_create ();

	Main_header     mhead;
	Scan_subheader  shead;
	Image_subheader ihead;
	Norm_subheader  nhead;
	Attn_subheader  ahead;
	MatrixFile     *sfp, *nfp = NULL, *afp;
	MatrixFile     *matrix_open ();
	MatrixData     *scanMatrixData, *normMatrixData, *attnMatrixData;
	MatrixData     *matrix_read ();
	struct timeb   *tp;

	int			makefilter();
	void			mat_write_image();
	void			matspec();
	void			crash();
	static int			readScatter();
	static void			getMatSpec();
	static void			bkprojView();
	static void			bkprojViewTrap();
	static void			arcCorrect();

	if (argc < 5) {
		printf ("Usage: %s scanspec\n\t\t", argv[0]);
		printf ("size[,zoom,xoff,yoff,rot,decay,scatFlag,arcCorr,intTilt]");
		printf ("\n\t\timagespec\n\t\t");
		/* JMO 2/4/94 add filtslope to usage. */
		printf ("filtCode,filtCutoff[,filtOffset,filtslope,scatFrac,scatSlope,pixSize]");
		printf ("\n\t\t-a attenFileSpec\n");
		printf ("\t\t-b bkprojType,startView,numViews\n");
		printf ("\t\t-n normFileSpec\n");
		printf ("\t\t-o offset\n");
		exit (1);
	}
	tp = (struct timeb *) malloc (sizeof (struct timeb));
	ftime (tp);
	t0 = (double) tp->time;
	m0 = (double) tp->millitm;
	t0 = t0 + m0 / 1000.0;

	size = 128;
	zoom = 1.0;
	xoff = 0.0;
	yoff = 0.0;
	rotoff = 0.0;
	fft_size = 512;
	fcode = 0;
	bkp_type = 0;

	buf1 = (float *) malloc (1024 * sizeof (float));
	buf2 = (float *) malloc (1024 * sizeof (float));

	getMatSpec (argv[1], fname, &frame, &plane, &gate, &data, &bed);
	matspec (argv[1], fname, &matnum);
	sfp = matrix_open (fname, "r");
	if (sfp == NULL)
		crash ("%s: error opening scan file %s\n", argv[0], fname);

	fptr = sfp->fptr;			 /* copy file descriptor */
	mhead = *(sfp->mhptr);			 /* copy main header */
	if (mhead.file_type != 1)
		crash ("%s: matrix file '%s' is not a SCAN file\n", argv[0], fname);

	scanMatrixData = matrix_read (sfp, matnum);
	if (scanMatrixData == NULL)
		crash ("%s: error reading %s\n", argv[0], argv[1]);

	shead = *((Scan_subheader *) scanMatrixData->shptr);
	numProjs = shead.dimension_1;
	numViews = shead.dimension_2;
	scanSize = numProjs * numViews;

	scalef = shead.scale_factor;
	if (scalef <= 0.0)
		scalef = 1.0;
	scan = (short int *) scanMatrixData->data_ptr;

	sscanf (argv[2], "%d,%f,%f,%f,%f,%d,%d,%d,%d",
		&size, &zoom, &xoff, &yoff, &rotoff, &decayFlag, &scatFlag,
		&arcorFlag, &intrinsicTilt);


	if (zoom <= 0.5)
		zoom = 1.0;
	if (size < 32)
		size = 32;
	ihead.pixel_size = shead.sample_distance * (float) numProjs / ((float) size * zoom);
	if (ihead.pixel_size <= 0.0)
		ihead.pixel_size = 1.0;

/* Read filter type and other parameters and make the recon filter */

	for (i = 0; i < 10; i++)
		fparms[i] = 0.0;

	sscanf (argv[4], "%d,%f,%f,%f,%f,%f,%f,%f", &fcode, &fparms[0],
		&fparms[1], &fparms[2], &fparms[3],
		&fparms[4], &fparms[5], &fparms[6]);
	if (mhead.system_type == 953)		 /* JMO 2/4/94 */
		fparms[0] = fparms[0] * shead.sample_distance / STA_953_SAMPSIZE;
	else if (mhead.system_type != 961)
		fprintf (stderr, "Unknown scanner type, cutoff frequency might be wrong.\n");

/* Default value of fft_size is  512 */

	while (fft_size < 2 * numProjs)
		fft_size *= 2;
	fft_offset = (fft_size - numProjs) / 2;
	fft_size2 = fft_size / 2;

/* Compute scatter correction vector */

	if (scatFlag) {
		scatParams = (float *) malloc (2 * sizeof (float));
		if ((readScatter (scatParams, plane)) != 0) {
			fprintf (stdout, "WARNING [bkproj_sun]: turning off scatter correction\n");
			scatFlag = 0;
		}
		if (debug) {
			fprintf (stdout, "scatter fraction = %f\n", scatParams[0]);
			fprintf (stdout, "scatter slope = %f\n", scatParams[1]);
			fprintf (stdout, "sample spacing = %f\n", shead.sample_distance);
		}
		fparms[4] = scatParams[0];	 /* scatter fraction */
		fparms[5] = scatParams[1];	 /* scatter slope */
		fparms[6] = shead.sample_distance;	/* pixel size */

		scatterBufr = (float *) malloc (fft_size * sizeof (float));
		makefilter (fft_size, scatterBufr, SCATTER, fparms, buf1, buf2);	/* JMO 2/4/94 */
	}					 /* scatter correction specified */
	if (fcode != 0) {
		filterBufr = (float *) malloc (fft_size * sizeof (float));
		fftBufr = (float *) malloc (fft_size * sizeof (float));
		fftBufr2 = (float *) malloc (fft_size * sizeof (float));

		if (fcode < 0 && debug)
			fprintf (stdout, "Modified ramp is being used ...\n");
		makefilter (fft_size, filterBufr, fcode, fparms, buf1, buf2);
	}					 /* End if code */
	imageSize = size * size;
	proj = (float *) malloc (fft_size * sizeof (float));
	image = (float *) malloc (imageSize * sizeof (float));

	arg = 5;
	offset = 0.0;
	while (arg < argc) {
		if (!strcmp (argv[arg], "-b")) {
			arg++;
			sscanf (argv[arg++], "%d,%d,%d", &bkp_type, &bkp_start_view,
				&bkp_numViews);
			continue;
		} else if (!strcmp (argv[arg], "-o")) {
			arg++;
			sscanf (argv[arg++], "%f", &offset);
			continue;
		} else if (!strcmp (argv[arg], "-n")) {
			arg++;
			matspec (argv[arg++], normFileName, &nrm_matnum);
			if (debug)
				fprintf (stdout, "Opening normalization file %s\n", normFileName);
			nfp = matrix_open (normFileName, "r");
			if (nfp == NULL)
				crash ("%s: error opening norm file %s\n", argv[0], normFileName);

			if (nfp->mhptr->file_type != 4)
				crash ("%s: file '%s' is not a NORM file\n", argv[0], normFileName);

			normMatrixData = matrix_read (nfp, nrm_matnum);
			if (normMatrixData == NULL)
				crash ("%s: error reading %s\n", argv[0], argv[arg]);
			nhead = *((Norm_subheader *) normMatrixData->shptr);
			scalef = scalef * nhead.scale_factor;
			norm = (float *) normMatrixData->data_ptr;
			normFlag = 1;
			continue;
		} else if (!strcmp (argv[arg], "-a")) {
			arg++;
			matspec (argv[arg++], attnFileName, &atn_matnum);
			if (debug)
				fprintf (stdout, "Opening attenuation file %s\n", attnFileName);
			afp = matrix_open (attnFileName, "r");
			if (afp == NULL)
				crash ("%s: error opening atten file %s\n", argv[0], attnFileName);

			if (afp->mhptr->file_type != 3)
				crash ("%s: file '%s' is not an ATTEN file\n", argv[0], attnFileName);

			attnMatrixData = matrix_read (afp, atn_matnum);
			if (attnMatrixData == NULL)
				crash ("%s: error reading %s\n", argv[0], argv[arg]);

			ahead = *((Attn_subheader *) attnMatrixData->shptr);
			scalef = scalef * ahead.scale_factor;
			attn = (float *) attnMatrixData->data_ptr;
			atnFlag = 1;
			continue;
		} else
			crash ("%s: unknown option '%s'\n", argv[0], argv[arg]);
	}					 /* End while arg */

	dtcor = shead.loss_correction_fctr;
	if (dtcor < 1.0)
		dtcor = 1.0;
	frameStartTime = (float) (shead.frame_start_time / 1000);
	frameDuration = (float) (shead.frame_duration / 1000);
	if (frameDuration <= 0.0)
		frameDuration = 1.0;

/* get branching fraction and halfLife if its not transmission scan */

	halfLife = 0.0;
	if (mhead.acquisition_type != 2) {
		j = 0;
		while (j < NumberOfIsotopes &&
		       strcmp (mhead.isotope_code, isotope_info[j].name) != 0)
			j++;
		if (j < NumberOfIsotopes) {
			sscanf (isotope_info[j].branch_ratio, "%f", &branchFrac);
			halfLife = isotope_info[j].hl;
		} else {

/* Warn user if specified isotope in main header not located in isotope_info file */

			fprintf (stdout, "Warning: improper or missing value for isotope(#%2d) in the main header\n", j);
			if (decayFlag) {
				decayFlag = 0;
				fprintf (stdout, "Warning: decay correction has been turned off\n");
			}
		}
	} else
		arcorFlag = 0;

/* Compute decay correction factor */

	if (decayFlag) {

/* If halfLife is not available from isotope_info.h then get it from scan subheader */

		if (halfLife == 0.0)
			halfLife = shead.isotope_halflife;
		if (halfLife > 0) {
			ln2 = log (2.0);
			lamdaT = frameDuration * ln2 / halfLife;
			decayFactor = exp (frameStartTime * ln2 / halfLife) / (1 - lamdaT / 2.0
									   + lamdaT * lamdaT / 6.0
								 - lamdaT * lamdaT * lamdaT / 24.0
						       + lamdaT * lamdaT * lamdaT * lamdaT / 120.0
					    - lamdaT * lamdaT * lamdaT * lamdaT * lamdaT / 720.0);
		}
	}
	ftime (tp);
	t1 = (double) tp->time;
	m1 = (double) tp->millitm;
	t1 = t1 + m1 / 1000.0;

/* Compute various parameters for arc correction */

	MultFactor = ((int) mhead.compression_code) ? (int) mhead.compression_code * 2 : 1;
	TotalNviews = shead.dimension_2 * MultFactor;
	if (debug) {
		fprintf (stdout, "Compression code = %3d", (int) mhead.compression_code);
		fprintf (stdout, "TotalNviews = %3d\n", TotalNviews);
	}
	radius = 0.0;
	if (arcorFlag) {
		switch (mhead.system_type) {
		case 931:
		case 951:
			radius = 102.0 / 2 + 1.0;/* 951/931 model */
			break;
		case 933:
		case 953:
			radius = 76.0 / 2 + 1.0; /* 953/933 model */
			break;
		case 961:
			radius = 82.4 / 2 + 1.0; /* 961 model */
			break;
		case 921:
			radius = 82.0 / 2 + 1.0; /* 921 model */
			break;
		case 831:
			radius = 64.0 / 2 + 1.0; /* 831 model */
			break;
		default:
			arcorFlag = 0;
			radius = 0.0;
			fprintf (stdout, "%s:Warning...Unknown system type. Turning off arc correction\n", argv[0]);
		}				 /* End switch */

		if (arcorFlag && radius > 0.0) {
			for (i = 0; i < numProjs; i++)
				gprofile[i] = numProjs / 2 + radius * sin (M_PI * (i - numProjs / 2) / (2 *
							    TotalNviews)) / shead.sample_distance;
			w = shead.sample_distance * TotalNviews * 2 / M_PI / radius;
			if (debug)
				fprintf (stdout, "arc correction profile made, radius = %f\n", radius);
		}				 /* End if arcorFlag */
	}
/* Correct for intrinsic tilt if specified */

	if (!intrinsicTilt)
		irot = 0.0;
	else {
		if ((numViews % 96) == 0)	 /* 953, 933, and 921 models */
			irot = -15.0;
		else if ((numViews % 98) == 0)	 /* 961 model */
			irot = -12.86;
		else
			irot = 0.0;
	}
	if (debug)
		fprintf (stdout, "Applying intrisic tilt...irot=%f\n", irot);

	sint = sin (M_PI * rotoff / 180.0);
	cost = cos (M_PI * rotoff / 180.0);
	x0 = xoff * cost + yoff * sint;
	y0 = -xoff * sint + yoff * cost;

	fs = (float *) malloc (scanSize * sizeof (float));
	if (fs == NULL) {
		sprintf (str,"%d16",scanSize * sizeof (float));
		crash ("%s: error allocating %d bytes memory\n", argv[0], str);
	}

	ftime (tp);
	t2 = (double) tp->time;
	m2 = (double) tp->millitm;
	t2 = t2 + m2 / 1000.0;

	for (j = 0; j < scanSize; j++)
		fs[j] = 0.0;

/* Must normalize before arc correction. JMO 2/4/94 */

	scan1 = (float *) malloc (scanSize * sizeof (float));
	if (normFlag)
		for (i = 0; i < scanSize; i++)
			scan1[i] = norm[i] * (float) scan[i];
	else
		for (i = 0; i < scanSize; i++)
			scan1[i] = (float) scan[i];

/* Perform arc correction if specified */

	if (arcorFlag)
		arcCorrect (numProjs, numViews, scan1, fs, gprofile, w);
	else
		for (j = 0; j < scanSize; j++)
			fs[j] = scan1[j];
	free (scan1);

	zoomSpec = zoom;
	zoom = (float) numProjs / (float) size / zoom;
	rx0 = (float) (size / 2) - x0 / ihead.pixel_size + offset;
	ry0 = (float) (size / 2) + y0 / ihead.pixel_size + offset;
	xvclr_ (image, &imageSize, &one);

	for (i = 0; i < numViews; i++) {
		theta = M_PI * i / numViews + (rotoff + irot) * M_PI / 180.;
		sint = sin (theta);
		cost = cos (theta);
		rdx = cost * zoom;
		rdy = sint * zoom;
		xvclr_ (proj, &fft_size, &one);

		if (scatFlag) {
			/****if (normFlag)
	                   for (j=0; j<numProjs; j++)
	                       proj[j+fft_offset] = *fs++ * (*norm++);
	                else                          JMO 2/4/94 **************/
			for (j = 0; j < numProjs; j++)
				proj[j + fft_offset] = *fs++;

			sf = (float) ((1.0 - fparms[4]) / (2.0 * fft_size));
			xfrf_ (fftBufr, &ra, proj, &fft_size2);
			xcvmls_ (fftBufr, &fone, fftBufr, scatterBufr, &fft_size2);
			ra = ra * scatterBufr[1];
			xfri_ (proj, &ra, fftBufr, proj, &fft_size2);
			xvsml_ (proj, &sf, &fft_size);

			if (atnFlag)
				for (j = 0; j < numProjs; j++)
					proj[j + fft_offset] *= *attn++;
		} else {
			/* if no scatter correction */
			if (normFlag && atnFlag)
				for (j = 0; j < numProjs; j++)
					proj[j + fft_offset] = *fs++ * /* (*norm++) */ (*attn++);	/* JMO 2.4.94 */
			else if (normFlag)
				for (j = 0; j < numProjs; j++)
					proj[j + fft_offset] = *fs++ /* (*norm++) */ ;	/* JMO 2/4/94 */
			else if (atnFlag)
				for (j = 0; j < numProjs; j++)
					proj[j + fft_offset] = *fs++ * (*attn++);
			else
				for (j = 0; j < numProjs; j++)
					proj[j + fft_offset] = *fs++;
		}

		if (fcode != 0) {
			xfrf_ (fftBufr, &ra, proj, &fft_size2);
			xcvmls_ (fftBufr, &fone, fftBufr, filterBufr, &fft_size2);
			ra = ra * filterBufr[1];
			xfri_ (proj, &ra, fftBufr, fftBufr2, &fft_size2);
		} else if (i == 0)
			fprintf (stdout, "%s:Warning...no filter specified\n", argv[0]);

		r0 = (float) fft_size2 - rx0 * rdx - ry0 * rdy;

		switch (bkp_type) {
		case 1:			 /* trapazoidal backprojection */
			bkprojViewTrap (proj, r0, rdx, rdy, image, size, theta);
			break;
		case 0:			 /* normal */
		default:
			bkprojView (proj, r0, rdx, rdy, image, size);
			break;
		}
	}

	ftime (tp);
	t3 = (double) tp->time;
	m3 = (double) tp->millitm;
	t3 = t3 + m3 / 1000.0;

	imageMax = 0.0;
	imageMin = 0.0;
	for (i = 0; i < imageSize; i++) {
		imageMax = (image[i] > imageMax) ? image[i] : imageMax;
		imageMin = (image[i] < imageMin) ? image[i] : imageMin;
	}
	if (debug)
		fprintf (stdout, "Image min = %f  max = %f\n", imageMin, imageMax);
	imagei = (short int *) malloc (imageSize * sizeof (short int));
	for (i = 0; i < imageSize; i++)
		imagei[i] = 32767. * image[i] / imageMax;

	ftime (tp);
	t4 = (double) tp->time;
	m4 = (double) tp->millitm;
	t4 = t4 + m4 / 1000.0;

	mhead.data_type = 2;
	mhead.file_type = 2;

	ihead.data_type = 2;
	ihead.num_dimensions = 2;
	ihead.dimension_1 = ihead.dimension_2 = size;
	ihead.x_origin = xoff;
	ihead.y_origin = yoff;
	ihead.recon_scale = zoomSpec;

	scalef = scalef * dtcor * decayFactor / frameDuration;
	ihead.quant_scale = scalef * M_PI * imageMax / 32767. / numViews / 2 / fft_size;
	if (debug)
		fprintf (stdout, "Image quant_scale = %e\n", ihead.quant_scale);
	ihead.image_min = 0;
	ihead.image_max = 32767;

	ihead.slice_width = mhead.plane_separation;
	ihead.frame_duration = shead.frame_duration;
	ihead.frame_start_time = shead.frame_start_time;
	ihead.slice_location = 0;
	ihead.recon_start_hour = 0;
	ihead.recon_start_minute = 0;
	ihead.recon_start_sec = 0;
	ihead.recon_duration = 0;
	ihead.filter_code = fcode;
	ihead.scan_matrix_num = matnum;
	ihead.norm_matrix_num = nrm_matnum;
	ihead.atten_cor_matrix_num = atn_matnum;
	ihead.image_rotation = rotoff;
	ihead.plane_eff_corr_fctr = 1.0;
	ihead.decay_corr_fctr = decayFactor;
	ihead.loss_corr_fctr = dtcor;
	ihead.intrinsic_tilt = irot;
	ihead.processing_code = 0;
	ihead.quant_units = 2;
	ihead.recon_start_day = 0;
	ihead.recon_start_month = 0;
	ihead.recon_start_year = 0;
	if (nfp != NULL) {
		mhead.calibration_units = nfp->mhptr->calibration_units;
		ihead.plane_eff_corr_fctr = nhead.scale_factor;
		if (nhead.ecat_calib_factor > 0.0)
			ihead.ecat_calibration_fctr = nhead.ecat_calib_factor / branchFrac;
		else
			ihead.ecat_calibration_fctr = 1.0 / branchFrac;
	} else
			ihead.ecat_calibration_fctr = 1.0;
	for (i = 0; i < 6; i++)
		ihead.filter_params[i] = fparms[i];
	ihead.well_counter_cal_fctr = 1.0;
	strcpy (ihead.annotation, "SUN reconstruction with AP emu library");

	matspec (argv[3], fname, &matnum);
	fptr = mat_open (fname, "r+");
	if (!fptr)
		fptr = mat_create (fname, &mhead);
	mat_write_image (fptr, matnum, &ihead, imagei, imageSize * 2);
	mat_close (fptr);

	ftime (tp);
	t5 = (double) tp->time;
	m5 = (double) tp->millitm;
	t5 = t5 + m5 / 1000.0;
	if (debug) {
		fprintf (stdout, "\n t1-t0   t2-t1   t3-t2   t4-t3   t5-t4   t5-t0\n");
		fprintf (stdout, "%6.3f  %6.3f  %6.3f  %6.3f  %6.3f  %6.3f\n\n\n", t1 - t0,
			 t2 - t1, t3 - t2, t4 - t3, t5 - t4, t5 - t0);
	}
	free (imagei);
	free (buf1);
	free (buf2);
	return (0);
}

static void bkprojView (proj, r0, rdx, rdy, image, size)
	float          *proj, *image;
	double          r0, rdx, rdy;
	int             size;
{
	int             x, y, j;
	double          r, w;

	for (y = 0; y < size; y++) {
		r = r0;
		for (x = 0; x < size; x++) {
			j = (int) r;
			w = r - j;
			(*image++) += (1.0 - w) * proj[j] + w * proj[j + 1];
			r += rdx;
		}
		r0 += rdy;
	}
	return;
}

static void bkprojViewTrap (proj, r0, rdx, rdy, image, size, theta)
	int             size;
	float          *proj, *image;
	double          r0, rdx, rdy, theta;
{
	int             x, y, b1, b2, b3, b4;
	double          r, w, w1, w2, r1, r2, r3, r4, f1, f2, f3, q, q1;

	w1 = M_SQRT2 * fabs (cos (theta + M_PI / 4));
	w2 = M_SQRT2 * fabs (cos (theta - M_PI / 4));
	if (w1 > w2) {
		w = w1;
		w1 = w2;
		w2 = w;
	}
	f1 = 0.5 * (w2 - w1) / (w2 + w1);
	f2 = 2.0 * w1 / (w2 + w1);
	f3 = f1;
	r0 += 0.5;
	for (y = 0; y < size; y++, r0 += rdy) {
		r = r0;
		for (x = 0; x < size; x++, image++, r += rdx) {
			r1 = r - w2 / 2;
			b1 = (int) r1;
			r2 = r - w1 / 2;
			b2 = (int) r2;
			r3 = r + w1 / 2;
			b3 = (int) r3;
			r4 = r + w2 / 2;
			b4 = (int) r4;
			if (b1 == b2)
				(*image) += f1 * proj[b1];
			else {
				q = b2;
				q1 = (q - r1) * (q - r1) / ((r2 - r1) * (r2 - r1));
				(*image) += f1 * q1 * proj[b1] + f1 * (1.0 - q1) * proj[b2];
			}
			if (b2 == b3)
				(*image) += f2 * proj[b2];
			else {
				q = b3;
				q1 = (q - r2) / (r3 - r2);
				(*image) += f2 * q1 * proj[b2] + f2 * (1.0 - q1) * proj[b3];
			}
			if (b3 == b4)
				(*image) += f3 * proj[b3];
			else {
				q = b4;
				q1 = (r4 - q) * (r4 - q) / ((r4 - r3) * (r4 - r3));
				(*image) += f3 * q1 * proj[b4] + f3 * (1.0 - q1) * proj[b3];
			}
		}				 /* next x */
	}					 /* next y */
	return;
}


static void arcCorrect (numProjs, numViews, scan_in, scan_out, profile, w)
	int             numProjs, numViews;
	float          *scan_in;
	float          *scan_out, *profile, w;
{
	int             i, j, o;

	float           f1, f2;

	for (i = 0; i < numProjs; i++) {
		o = (int) profile[i];
		f1 = profile[i] - o;
		f2 = 1.0 - f1;

		if (i == numProjs / 2)
			f2 = w;
		for (j = 0; j < numViews; j++) {
/*           in = scan_in[i+j*numProjs];  JMO 2/4/94   */
			scan_out[o + j * numProjs] += scan_in[i + j * numProjs] * f2;
			scan_out[o + j * numProjs + 1] += scan_in[i + j * numProjs] * f1;
		}
	}
	return;
}


static int             readScatter (scatParam, planeNum)
	float          *scatParam;
	int             planeNum;
{
	int             plane, status = 0;
	char           *s, filename[256];
	FILE           *fptr;

	s = (char *) malloc (256);

	sprintf (filename, "%s", "/usr/local/npg/953/scatparms.dat");

	if ((fptr = fopen (filename, "r")) != NULL) {
		while ((s = fgets (s, 256, fptr)) != NULL) {
			sscanf (s, "%d %f %f", &plane, &scatParam[0], &scatParam[1]);
			if (plane == planeNum)
				break;
		}
		fclose (fptr);
	} else {
		fprintf (stdout, "readScatter:Error...unable to open the file %s\n", filename);
		status = -1;
	}

	free (s);
	return (status);
}

static void getMatSpec (str, fname, f, p, g, d, b)
	int            *f, *p, *g, *d, *b;
	char           *str, *fname;
{
	char           *cp;

	strcpy (fname, str);
	cp = strchr (fname, ',');
	if (cp) {
		*cp++ = '\0';
		sscanf (cp, "%d,%d,%d,%d,%d", &(*f), &(*p), &(*g), &(*d), &(*b));
	}
	return;
}
@


1.10
log
@reduce messages and fix debug
@
text
@d2 3
d24 1
a24 1
 * changed Id to $Header: /home/npggw/tom/src/bkproj_sun/RCS/bkproj_sun.c,v 1.9 1998/07/22 16:33:20 tom Exp tom $
d65 1
a70 1
#include <sys/time.h>
a71 1
#include <sys/file.h>
d73 4
a76 1
static char     rcsid[] = "$Header: /home/npggw/tom/src/bkproj_sun/RCS/bkproj_sun.c,v 1.9 1998/07/22 16:33:20 tom Exp tom $";
a80 4
#ifndef lint
static char     sccsid[] = "@@(#)bkproj_sun.c	1.4 3/10/93  Copyright(c) 1989-1993 CTI PET Systems, Inc.";
#endif

d85 3
a87 2
	short int      *scan, *imagei, *scanp;
	int             numProjs, numViews, i, j, size, debug=0;
d91 1
a91 1
	int             atnum, frame, plane, gate, sino, bed, data;
d93 1
a93 1
	int             imageSize = 0;
d95 1
a95 1
	int             TotalNviews = 0, MultFactor = 1, intrinsicTilt = 0;
d98 1
a98 1
	long            timeval, time (), one = 1;
d100 2
a101 2
	float          *cbufr, *tbufr, scalef = 1.0;
	float          *image, *proj, zoom = 1.0, imageMin, imageMax, zoomSpec;
d104 1
a104 1
	float           xoff = 0.0, yoff = 0.0, rotoff = 0.0, irot = 0.0, x0, y0;
d106 2
a107 2
	float           fdummy0, offset = 0.0, ra;
	float          *norm, *attn, *normp, *attnp, *buf1, *buf2;
d110 1
a110 1
	float           sf = 0.0, fone = 1.0;
d112 1
a112 1
	double          ln2, exp (), log (), lamdaT;
d118 1
a118 1
	char           *getEnviron (), strVal[10];
d122 1
a122 1
	Main_header     mhead, nmain, amain;
d127 2
a128 2
	MatrixFile     *sfp = NULL, *nfp = NULL, *afp = NULL, *ifp = NULL;
	MatrixFile     *matrix_open (), *matrix_create ();
d133 10
a154 4

/*	sprintf (strVal, "%s", (char *) getenv ("DEBUG")); 
	debug = atoi (strVal); */

a167 1
	fdummy0 = 0.5;
a172 2
	if (debug)
		fprintf (stdout, "%s\n", argv[1]);
a191 2
	if (debug)
		fprintf (stdout, "\nnumProjs = %3d  numViews = %3d\n", numProjs, numViews);
a196 1
	scanp = scan;
d213 2
a214 1
	for (i = 0; i < 10; fparms[i++] = 0.0);
a293 1
			normp = norm;
a314 1
			attnp = attn;
a418 1

d424 1
a424 1
		if ((numViews % 96) == 0)	/* 953, 933, and 921 models */
d426 1
a426 1
		else if ((numViews % 98) == 0)	/* 961 model */
d440 4
a443 3
	if (fs == NULL)
		crash ("%s: error allocating %d bytes memory\n", argv[0],
		       scanSize * sizeof (float));
d450 2
a451 1
	for (j = 0; j < scanSize; fs[j++] = 0.0);
a574 1

d579 1
a579 3
	ihead.slice_width = 0.675;
	ihead.intrinsic_tilt = irot;
	ihead.image_rotation = rotoff;
d581 7
a588 3
	ihead.frame_start_time = shead.frame_start_time;
	ihead.frame_duration = shead.frame_duration;
	ihead.quant_units = 2;
d592 1
d594 8
d609 2
a610 3
	}
	ihead.decay_corr_fctr = decayFactor;
	ihead.loss_corr_fctr = dtcor;
d633 2
d638 1
a638 1
bkprojView (proj, r0, rdx, rdy, image, size)
d656 1
d659 1
a659 1
bkprojViewTrap (proj, r0, rdx, rdy, image, size, theta)
a664 1
	static int      flag = 1;
d712 1
d716 1
a716 1
arcCorrect (numProjs, numViews, scan_in, scan_out, profile, w)
d721 1
a721 1
	int             i, j, o, in;
d738 1
d742 1
a742 1
int             readScatter (scatParam, planeNum)
d747 2
a749 4
	char           *s, temp[256], filename[256];

	FILE           *fptr, *fopen ();

a751 4
/*
	sprintf (temp, "%s", (char *) getEnviron ("SCATDIR"));
	sprintf (filename, "%s/scatparms.dat", temp);
*/
d770 1
a770 16
/* get environment variables */

char           *getEnviron (variable)
	char           *variable;
{
	char           *string;

	if ((string = (char *) getenv (variable)) == (char *) NULL) {
		fprintf (stdout, "getEnviron:Error - environment variable %s is not defined\n",
			 variable);
		return (NULL);
	} else
		return (string);
}

getMatSpec (str, fname, f, p, g, d, b)
d782 1
@


1.9
log
@add DEBUG
@
text
@d2 3
d21 1
a21 1
 * changed Id to $Header: /home/npggw/tom/src/bkproj_sun/RCS/bkproj_sun.c,v 1.8 1998/07/21 21:35:17 tom Exp tom $
d71 1
a71 1
static char     rcsid[] = "$Header: /home/npggw/tom/src/bkproj_sun/RCS/bkproj_sun.c,v 1.8 1998/07/21 21:35:17 tom Exp tom $";
a75 1

a77 1

d132 1
a132 1
		printf ("usage: %s scanspec\n\t\t", argv[0]);
d144 2
a145 2
	sprintf (strVal, "%s", (char *) getenv ("DEBUG"));
	debug = atoi (strVal);
d166 2
a167 1
	fprintf (stdout, "%s\n", argv[1]);
d209 2
a210 1
	/* Read filter type and other parameters and make the recon filter */
d221 2
a222 1
	/* Default value of fft_size is  512 */
d228 2
a229 1
	/* Compute scatter correction vector */
d233 1
a233 1
			fprintf (stdout, "bkproj_sun: Warning - turning off scatter correction\n");
d328 2
a329 1
	/* get branching fraction and halfLife if its not transmission scan */
d341 2
a342 4
			/*
			 * Warn the user if the specified isotope in the main header  was not
			 * located in the isotope_info file.
			 */
d352 2
a353 1
	/* Compute decay correction factor */
d356 2
a357 3
		/*
		 * If halfLife is not available from isotope_info.h then get it from scan subheader
		 */
d375 2
a376 1
	/* Compute various parameters for arc correction */
d380 2
a381 2
		fprintf (stdout, "\nCompression code = %3d", (int) mhead.compression_code);
		fprintf (stdout, "\nTotalNviews = %3d\n", TotalNviews);
d418 3
a420 1
	/* Correct for intrinsic tilt if specified */
d424 1
a424 2
		/* 953, 933, and 921 models */
		if ((numViews % 96) == 0)
d426 1
a426 2
		/* 961 model */
		else if ((numViews % 98) == 0)
d451 2
a452 1
	/* Must normalize before arc correction. JMO 2/4/94 */
d461 2
a462 1
	/* Perform arc correction if specified */
@


1.8
log
@Solaris version
@
text
@d2 3
d18 1
a18 1
 * changed Id to $Header: /home/npggw/tom/src/bkproj_sun/RCS/bkproj_sun.c,v 1.7 1998/07/21 16:18:58 tom Exp tom $
d68 1
a68 1
static char     rcsid[] = "$Header: /home/npggw/tom/src/bkproj_sun/RCS/bkproj_sun.c,v 1.7 1998/07/21 16:18:58 tom Exp tom $";
d142 1
a142 1
/*
a144 1
*/
@


1.7
log
@Solaris version
@
text
@d2 3
d15 1
a15 1
 * changed Id to $Header: /home/npggw/tom/src/bkproj_sun/RCS/bkproj_sun.c,v 1.6 1995/02/24 17:21:41 tom Exp tom $
d65 1
a65 1
static char     rcsid[] = "$Header: /home/npggw/tom/src/bkproj_sun/RCS/bkproj_sun.c,v 1.6 1995/02/24 17:21:41 tom Exp tom $";
d81 1
a81 1
	int             numProjs, numViews, i, j, size, debug, recon_time;
d139 2
a140 1
	sprintf (strVal, "%s", (char *) getenv ("RECON_DEBUG"));
d142 1
a142 2
	sprintf (strVal, "%s", (char *) getenv ("RECON_TIME"));
	recon_time = atoi (strVal);
d163 1
d607 1
a607 1
	if (debug || recon_time) {
d613 1
@


1.6
log
@skip warning for 961
@
text
@d2 3
d12 1
a12 1
 * changed Id to $Header: /home/npggw/tom/src/bkproj_sun/RCS/bkproj_sun.c,v 1.5 1994/04/13 16:16:35 tom Exp tom $
d62 1
a62 1
static char     rcsid[] = "$Header: /home/npggw/tom/src/bkproj_sun/RCS/bkproj_sun.c,v 1.5 1994/04/13 16:16:35 tom Exp tom $";
d725 1
d728 2
@


1.5
log
@copy frame_start_time from input sinogram to output image
@
text
@d2 3
d9 1
a9 1
 * changed Id to $Header: /home/petsun2/tom/src/bkproj_sun/RCS/bkproj_sun.c,v 1.4 1994/03/03 22:09:30 tom Exp tom $
d23 1
a23 1
		SCATDIR 	is the path to locate the scatparms.dat file 
d33 1
a33 1
   28-Dec-1992   HPG      added a flag for specifying intrinsic tilt 
d41 2
a42 2
		           arc-correction and normalization, parameter in call 
			   to makefilter, and scaling of cutoff frequency with 
d46 1
d59 1
a59 1
static char rcsid [] = "$Header: /home/petsun2/tom/src/bkproj_sun/RCS/bkproj_sun.c,v 1.4 1994/03/03 22:09:30 tom Exp tom $";
d62 1
a62 1
#define STA_953_SAMPSIZE .3129  /* JMO 2/5/94 */
d66 2
a67 1
static char sccsid[]="@@(#)bkproj_sun.c	1.4 3/10/93  Copyright(c) 1989-1993 CTI PET Systems, Inc.";
d69 4
a72 4
 
main(argc, argv)
  int 		argc;
  char 		*argv[];
d74 11
a84 11
   short int	*scan, *imagei, *scanp;
   int       	numProjs, numViews, i, j, size, debug, recon_time;
   int       	fcode, fft_size, fft_size2, fft_offset;
   int       	decayFlag=0, scatFlag=0, arcorFlag=0;
   int        	normFlag=0, atnFlag=0;
   int       	atnum, frame, plane, gate, sino, bed, data;
   int       	bkp_type, bkp_start_view, bkp_numViews;
   int 		imageSize=0;
   int       	arg, matnum, atn_matnum=0, nrm_matnum=0;
   int      	TotalNviews=0, MultFactor=1, intrinsicTilt=0;
   register int	scanSize;
d86 1
a86 1
   long       	timeval, time(), one=1;
d88 11
a98 11
   float       *cbufr, *tbufr, scalef=1.0;
   float       *image, *proj, zoom=1.0, imageMin, imageMax, zoomSpec;
   float       *scan1; /* JMO 2.4.94 */
   float       *fs, *scatParams, *scatterBufr, branchFrac=1.0;
   float       xoff=0.0, yoff=0.0, rotoff=0.0, irot=0.0, x0, y0;
   float       fparms[10], *filterBufr, *fftBufr, *fftBufr2;
   float       fdummy0, offset=0.0, ra;
   float       *norm, *attn, *normp, *attnp, *buf1, *buf2;
   float       halfLife, decayFactor=1.0, dtcor, frameStartTime;
   float       radius, gprofile[512], w, frameDuration;
   float       sf=0.0, fone=1.0;
d100 4
a103 4
   double      ln2, exp(), log(), lamdaT;
   double      cost, sint, r0, rdx, rdy, rx0, ry0, theta;
   double      t0, t1, t2, t3, t4, t5;
   double      m0, m1, m2, m3, m4, m5;
d105 2
a106 2
   char        fname[256], attnFileName[256], normFileName[256];
   char        *getEnviron(), strVal[10];
d108 1
a108 1
   FILE        *fptr, *mat_create();
d110 10
a119 10
   Main_header     mhead, nmain, amain;
   Scan_subheader  shead;
   Image_subheader ihead;
   Norm_subheader  nhead;
   Attn_subheader  ahead;
   MatrixFile    *sfp=NULL, *nfp=NULL, *afp=NULL, *ifp=NULL;
   MatrixFile    *matrix_open(), *matrix_create();
   MatrixData    *scanMatrixData, *normMatrixData, *attnMatrixData; 
   MatrixData	 *matrix_read();   
   struct timeb  *tp;
d121 16
a136 16
   if (argc < 5) {
      printf("usage: %s scanspec\n\t\t", argv[0]);
      printf("size[,zoom,xoff,yoff,rot,decay,scatFlag,arcCorr,intTilt]");
      printf("\n\t\timagespec\n\t\t");
      /* JMO 2/4/94 add filtslope to usage. */
      printf("filtCode,filtCutoff[,filtOffset,filtslope,scatFrac,scatSlope,pixSize]");
      printf("\n\t\t-a attenFileSpec\n"); 
      printf("\t\t-b bkprojType,startView,numViews\n");
      printf("\t\t-n normFileSpec\n");
      printf("\t\t-o offset\n");
      exit(1);
   }
   sprintf (strVal, "%s", (char*)getenv("RECON_DEBUG"));
   debug = atoi (strVal);
   sprintf (strVal, "%s", (char*)getenv("RECON_TIME"));
   recon_time = atoi (strVal);
d138 5
a142 5
   tp = (struct timeb *) malloc (sizeof (struct timeb));
   ftime(tp);
   t0 = (double)tp->time;
   m0 = (double)tp->millitm;
   t0 = t0 + m0/1000.0;
d144 9
a152 9
   size = 128;
   zoom = 1.0;
   xoff = 0.0;
   yoff = 0.0;
   rotoff = 0.0;
   fft_size = 512;
   fcode = 0;
   fdummy0 = 0.5;
   bkp_type = 0;
d154 2
a155 2
   buf1 = (float *) malloc (1024*sizeof(float));
   buf2 = (float *) malloc (1024*sizeof(float));
d157 5
a161 5
   getMatSpec (argv[1], fname, &frame, &plane, &gate, &data, &bed);
   matspec(argv[1], fname, &matnum);
   sfp = matrix_open(fname, "r");
   if (sfp == NULL)
      crash("%s: error opening scan file %s\n", argv[0], fname);
d163 4
a166 4
   fptr = sfp->fptr;        /* copy file descriptor */
   mhead = *(sfp->mhptr);   /* copy main header */
   if (mhead.file_type != 1)
      crash("%s: matrix file '%s' is not a SCAN file\n", argv[0], fname);
d168 3
a170 3
   scanMatrixData = matrix_read(sfp, matnum);
   if (scanMatrixData == NULL)
      crash("%s: error reading %s\n", argv[0], argv[1]);
d172 6
a177 6
   shead = *((Scan_subheader *) scanMatrixData->shptr);
   numProjs = shead.dimension_1;
   numViews = shead.dimension_2;
   scanSize = numProjs*numViews;
   if (debug)
      fprintf (stdout,"\nnumProjs = %3d  numViews = %3d\n", numProjs, numViews);
d179 5
a183 5
   scalef = shead.scale_factor;
   if (scalef <= 0.0) 
      scalef = 1.0;
   scan = (short int *) scanMatrixData->data_ptr;
   scanp = scan;
d185 3
a187 3
   sscanf(argv[2], "%d,%f,%f,%f,%f,%d,%d,%d,%d",
          &size, &zoom, &xoff, &yoff, &rotoff, &decayFlag, &scatFlag, 
          &arcorFlag, &intrinsicTilt);
a188 8
	
   if (zoom <= 0.5) 
      zoom = 1.0;
   if (size < 32) 
      size = 32;
   ihead.pixel_size = shead.sample_distance*(float)numProjs/((float)size*zoom);
   if (ihead.pixel_size <= 0.0) 
      ihead.pixel_size = 1.0;
d190 7
a196 2
   /* Read filter type and other parameters and make the recon filter */
   for (i=0; i<10; fparms[i++] = 0.0);
d198 2
a199 7
   sscanf(argv[4], "%d,%f,%f,%f,%f,%f,%f,%f", &fcode, &fparms[0],
          &fparms[1], &fparms[2], &fparms[3],
          &fparms[4], &fparms[5], &fparms[6]);
   if(mhead.system_type == 953)  /* JMO 2/4/94 */
	fparms[0] = fparms[0] * shead.sample_distance/STA_953_SAMPSIZE;
   else
	fprintf(stderr,"Unknown scanner type, cutoff frequency might be wrong.\n");
d201 7
a207 5
        /* Default value of fft_size is  512 */
   while (fft_size < 2*numProjs)
         fft_size *= 2;
   fft_offset = (fft_size - numProjs)/2;
   fft_size2 = fft_size/2;
d209 5
a213 15
   /* Compute scatter correction vector */
   if (scatFlag) {
      scatParams = (float *) malloc (2*sizeof(float));
      if ((readScatter (scatParams, plane)) != 0) {
         fprintf (stdout, "bkproj_sun: Warning - turning off scatter correction\n");
         scatFlag = 0;
      }
      if (debug) {
         fprintf (stdout, "scatter fraction = %f\n", scatParams[0]);
         fprintf (stdout, "scatter slope = %f\n", scatParams[1]);
         fprintf (stdout, "sample spacing = %f\n", shead.sample_distance);
      }
      fparms[4] = scatParams[0];   /* scatter fraction */
      fparms[5] = scatParams[1];   /* scatter slope */
      fparms[6] = shead.sample_distance;   /* pixel size */
d215 15
a229 3
      scatterBufr = (float *) malloc(fft_size * sizeof(float));
      makefilter (fft_size, scatterBufr, SCATTER, fparms, buf1, buf2); /* JMO 2/4/94*/
   } /* scatter correction specified */
d231 7
a237 4
   if (fcode != 0) {
      filterBufr = (float*) malloc(fft_size * sizeof(float));
      fftBufr = (float*) malloc(fft_size * sizeof(float));
      fftBufr2 = (float*) malloc(fft_size * sizeof(float));
d239 7
a245 4
      if (fcode < 0 && debug)
         fprintf (stdout, "Modified ramp is being used ...\n");
      makefilter(fft_size, filterBufr, fcode, fparms, buf1, buf2);
   } /* End if code */
d247 20
a266 3
   imageSize = size * size;
   proj = (float*) malloc(fft_size*sizeof(float));
   image = (float*) malloc(imageSize*sizeof(float));
d268 2
a269 22
   arg = 5;
   offset = 0.0;
   while (arg < argc) {
     if (!strcmp(argv[arg], "-b")) { 
        arg++;
        sscanf(argv[arg++], "%d,%d,%d", &bkp_type, &bkp_start_view,
               &bkp_numViews);
        continue;
     }
     else if (!strcmp(argv[arg], "-o")) {
        arg++;
        sscanf(argv[arg++], "%f", &offset);
        continue;
     }
     else if (!strcmp(argv[arg], "-n")) {
        arg++;
        matspec (argv[arg++], normFileName, &nrm_matnum);
        if (debug)
           fprintf (stdout, "Opening normalization file %s\n", normFileName);
        nfp = matrix_open(normFileName, "r");
        if (nfp == NULL)
           crash("%s: error opening norm file %s\n", argv[0], normFileName);
d271 17
a287 2
        if (nfp->mhptr->file_type != 4)
           crash("%s: file '%s' is not a NORM file\n", argv[0], normFileName);
d289 2
a290 18
        normMatrixData = matrix_read(nfp, nrm_matnum);
        if (normMatrixData == NULL)
           crash("%s: error reading %s\n", argv[0], argv[arg]);
        nhead = *((Norm_subheader *) normMatrixData->shptr);
        scalef = scalef * nhead.scale_factor;
        norm = (float *) normMatrixData->data_ptr; 
        normp = norm;
        normFlag = 1;
        continue;
     }
     else if (!strcmp(argv[arg], "-a")) {
        arg++;
        matspec(argv[arg++], attnFileName, &atn_matnum);
        if (debug)
           fprintf (stdout, "Opening attenuation file %s\n", attnFileName);
        afp = matrix_open(attnFileName, "r");
        if (afp == NULL)
           crash("%s: error opening atten file %s\n", argv[0], attnFileName);
d292 3
a294 2
        if (afp->mhptr->file_type != 3)
           crash("%s: file '%s' is not an ATTEN file\n", argv[0], attnFileName);
d296 9
a304 3
        attnMatrixData = matrix_read(afp, atn_matnum);
        if (attnMatrixData == NULL)
           crash("%s: error reading %s\n", argv[0], argv[arg]);
d306 7
a312 10
        ahead = *((Attn_subheader *) attnMatrixData->shptr);
        scalef = scalef * ahead.scale_factor;
        attn = (float *) attnMatrixData->data_ptr;
        attnp = attn;
        atnFlag = 1;
        continue;
     }
     else 
        crash("%s: unknown option '%s'\n", argv[0], argv[arg]);
   } /* End while arg */
d314 11
a324 7
   dtcor = shead.loss_correction_fctr;
   if (dtcor < 1.0) 
      dtcor = 1.0;
   frameStartTime = (float) (shead.frame_start_time/1000);
   frameDuration = (float) (shead.frame_duration/1000);
   if (frameDuration <= 0.0) 
      frameDuration = 1.0;
d326 12
a337 23
   /* get branching fraction and halfLife if its not transmission scan */
   halfLife = 0.0;
   if (mhead.acquisition_type != 2) {
      j = 0 ;
      while (j < NumberOfIsotopes && 
             strcmp (mhead.isotope_code, isotope_info[j].name) != 0) 
            j++;
      if (j < NumberOfIsotopes) {
	 sscanf(isotope_info[j].branch_ratio, "%f", &branchFrac);
	 halfLife = isotope_info[j].hl;
      }
      else {
	 /* Warn the user if the specified isotope in the main header  
          * was not located in the isotope_info file. */
	  fprintf (stdout, "Warning: improper or missing value for isotope(#%2d) in the main header\n", j);
          if (decayFlag) {
             decayFlag = 0;
             fprintf (stdout, "Warning: decay correction has been turned off\n");
          }
      }
   }
   else
      arcorFlag = 0;
d339 2
a340 16
   /* Compute decay correction factor */
   if (decayFlag) {
      /* If halfLife is not available from isotope_info.h then get it from 
       * scan subheader */
      if (halfLife == 0.0)
         halfLife = shead.isotope_halflife;
      if (halfLife > 0) {
         ln2 = log(2.0);
         lamdaT = frameDuration * ln2/halfLife;
         decayFactor = exp(frameStartTime*ln2/halfLife)/(1-lamdaT/2.0
            +lamdaT*lamdaT/6.0
            -lamdaT*lamdaT*lamdaT/24.0
            +lamdaT*lamdaT*lamdaT*lamdaT/120.0 
            -lamdaT*lamdaT*lamdaT*lamdaT*lamdaT/720.0);
      }
   }
d342 19
a360 4
   ftime(tp);
   t1 = (double)tp->time;
   m1 = (double)tp->millitm;
   t1 = t1 + m1/1000.0;
d362 32
a393 7
   /* Compute various parameters for arc correction */
   MultFactor = ((int)mhead.compression_code) ? (int)mhead.compression_code * 2 : 1;
   TotalNviews = shead.dimension_2 * MultFactor;
   if (debug) {
      fprintf (stdout, "\nCompression code = %3d", (int)mhead.compression_code);
      fprintf (stdout, "\nTotalNviews = %3d\n", TotalNviews);
   }
d395 24
a418 25
   radius = 0.0;
   if (arcorFlag) {
      switch (mhead.system_type) {
         case 931:
         case 951:
            radius = 102.0/2 + 1.0;   	/* 951/931 model */
            break;
         case 933:
         case 953:
            radius = 76.0/2 + 1.0;   	/* 953/933 model */
            break;
         case 961:
            radius = 82.4/2 + 1.0;  	/* 961 model */
            break;
         case 921:
            radius = 82.0/2 + 1.0;  	/* 921 model */
            break;
         case 831:
            radius = 64.0/2 + 1.0;  	/* 831 model */
            break;
         default:
            arcorFlag = 0;
            radius = 0.0;
	    fprintf (stdout, "%s:Warning...Unknown system type. Turning off arc correction\n", argv[0]);
      } /* End switch */
d420 4
a423 9
      if (arcorFlag && radius > 0.0) {
         for (i=0; i<numProjs; i++)
             gprofile[i] = numProjs/2 + radius * sin(M_PI*(i-numProjs/2)/(2*
                                           TotalNviews))/shead.sample_distance;
         w = shead.sample_distance * TotalNviews * 2 / M_PI /radius;
         if (debug)
            fprintf(stdout, "arc correction profile made, radius = %f\n", radius);   
      } /* End if arcorFlag */
   }   
d425 4
a428 15
   /* Correct for intrinsic tilt if specified */
   if (!intrinsicTilt) 
      irot = 0.0;
   else {
      /* 953, 933, and 921 models */
      if ((numViews % 96) == 0)
         irot = -15.0;
      /* 961 model */
      else if ((numViews % 98) == 0)
         irot = -12.86;
      else
         irot = 0.0;
      }
   if (debug)
      fprintf (stdout, "Applying intrisic tilt...irot=%f\n", irot);
d430 4
a433 4
   sint = sin(M_PI*rotoff/180.0);
   cost = cos(M_PI*rotoff/180.0);
   x0 = xoff*cost + yoff*sint;
   y0 = -xoff*sint + yoff*cost;
d435 1
a435 4
   fs = (float *) malloc(scanSize*sizeof(float)); 
   if (fs == NULL)
      crash("%s: error allocating %d bytes memory\n", argv[0], 
            scanSize*sizeof(float));
d437 8
a444 4
   ftime(tp);
   t2 = (double)tp->time;
   m2 = (double)tp->millitm;
   t2 = t2 + m2/1000.0;
d446 7
a452 1
   for (j=0; j<scanSize; fs[j++]=0.0);
d454 5
a458 6
   /* Must normalize before arc correction. JMO 2/4/94 */
   scan1 = (float *) malloc(scanSize*sizeof(float)); 
   if (normFlag)
       for(i=0;i<scanSize;i++) scan1[i] = norm[i]*(float)scan[i];
   else
       for(i=0;i<scanSize;i++) scan1[i] = (float)scan[i];
d460 7
a466 7
   /* Perform arc correction if specified */
   if (arcorFlag)
      arcCorrect (numProjs, numViews, scan1, fs, gprofile, w);
   else
      for (j=0; j<scanSize; j++)
          fs[j] = scan1[j];
   free(scan1);
d468 7
a474 5
   zoomSpec = zoom;
   zoom = (float) numProjs / (float) size / zoom;
   rx0 = (float) (size/2) - x0/ihead.pixel_size + offset;
   ry0 = (float) (size/2) + y0/ihead.pixel_size + offset;
   xvclr_ (image, &imageSize, &one);
d476 6
a481 7
   for (i=0; i<numViews; i++) {
       theta = M_PI*i/numViews + (rotoff+irot)*M_PI/180.;
       sint = sin(theta);
       cost = cos(theta);
       rdx = cost * zoom;
       rdy = sint * zoom;
       xvclr_ (proj, &fft_size, &one);
d483 18
a500 7
       if (scatFlag) {
          /****if (normFlag)
             for (j=0; j<numProjs; j++)
                 proj[j+fft_offset] = *fs++ * (*norm++);
          else                          JMO 2/4/94 **************/
             for (j=0; j<numProjs; j++)
                 proj[j+fft_offset] = *fs++;
d502 7
a508 6
          sf = (float) ((1.0-fparms[4])/(2.0*fft_size));
          xfrf_ (fftBufr, &ra, proj, &fft_size2);
          xcvmls_ (fftBufr, &fone, fftBufr, scatterBufr, &fft_size2);
          ra = ra * scatterBufr[1];
          xfri_ (proj, &ra, fftBufr, proj, &fft_size2);
          xvsml_ (proj, &sf, &fft_size);
d510 1
a510 21
          if (atnFlag)
             for (j=0; j<numProjs; j++)
                 proj[j+fft_offset] *= *attn++;
       }
       else {
         /* if no scatter correction */
         if (normFlag && atnFlag)
            for (j=0; j<numProjs; j++)
                proj[j+fft_offset] = *fs++ * /*(*norm++) */ (*attn++); /*JMO 2.4.94 */
         else 
            if (normFlag)
               for (j=0; j<numProjs; j++)
                   proj[j+fft_offset] = *fs++ /* (*norm++)*/;  /* JMO 2/4/94 */
         else 
            if (atnFlag)
               for (j=0; j<numProjs; j++)
                   proj[j+fft_offset] = *fs++ * (*attn++);
         else
            for (j=0; j<numProjs; j++)
                proj[j+fft_offset] = *fs++;
       }
d512 10
a521 9
       if (fcode != 0) {
          xfrf_ (fftBufr, &ra, proj, &fft_size2);
          xcvmls_ (fftBufr, &fone, fftBufr, filterBufr, &fft_size2);
          ra = ra * filterBufr[1];
          xfri_ (proj, &ra, fftBufr, fftBufr2, &fft_size2);
       }
       else
          if (i == 0) 
             fprintf(stdout, "%s:Warning...no filter specified\n", argv[0]);
d523 4
a526 1
       r0 = (float) fft_size2 - rx0*rdx - ry0*rdy;
d528 11
a538 10
       switch (bkp_type) { 
          case 1:   /* trapazoidal backprojection */
             bkprojViewTrap(proj, r0, rdx, rdy, image, size, theta);
             break;
          case 0:   /* normal */
          default:
             bkprojView(proj, r0, rdx, rdy, image, size);
             break;
       }
   }
d540 4
a543 4
   ftime(tp);
   t3 = (double)tp->time;
   m3 = (double)tp->millitm;
   t3 = t3 + m3/1000.0;
d545 2
a546 11
   imageMax = 0.0;
   imageMin = 0.0;
   for (i=0; i<imageSize; i++) {
     imageMax = (image[i] > imageMax) ? image[i] : imageMax;
     imageMin = (image[i] < imageMin) ? image[i] : imageMin;
   }
   if (debug)
      fprintf (stdout, "Image min = %f  max = %f\n", imageMin, imageMax);
   imagei = (short int *) malloc(imageSize*sizeof(short int));
   for (i=0; i<imageSize; i++)
     imagei[i] = 32767.*image[i]/imageMax;
d548 6
a553 4
   ftime(tp);
   t4 = (double)tp->time;
   m4 = (double)tp->millitm;
   t4 = t4 + m4/1000.0;
d555 2
a556 2
   mhead.data_type = 2;
   mhead.file_type = 2;
d558 30
a587 6
   ihead.data_type = 2;
   ihead.num_dimensions = 2;
   ihead.dimension_1 = ihead.dimension_2 = size;
   ihead.x_origin = xoff;
   ihead.y_origin = yoff;
   ihead.recon_scale = zoomSpec;
d589 6
a594 2
   scalef = scalef * dtcor * decayFactor/frameDuration;   
   ihead.quant_scale = scalef * M_PI * imageMax/32767./numViews/2/fft_size;
d596 10
a605 49
   if (debug)
      fprintf (stdout, "Image quant_scale = %e\n", ihead.quant_scale);
   ihead.image_min = 0;
   ihead.image_max = 32767;
   ihead.slice_width = 0.675;
   ihead.intrinsic_tilt = irot;
   ihead.image_rotation = rotoff;
   ihead.slice_width = mhead.plane_separation;
   ihead.filter_code = fcode;
   ihead.frame_start_time = shead.frame_start_time;
   ihead.frame_duration = shead.frame_duration;
   ihead.quant_units = 2;
   ihead.scan_matrix_num = matnum;
   ihead.norm_matrix_num = nrm_matnum;
   ihead.atten_cor_matrix_num = atn_matnum;
   ihead.plane_eff_corr_fctr = 1.0;
   if (nfp != NULL) {
      mhead.calibration_units = nfp->mhptr->calibration_units;
      ihead.plane_eff_corr_fctr = nhead.scale_factor;
      if (nhead.ecat_calib_factor > 0.0)
         ihead.ecat_calibration_fctr = nhead.ecat_calib_factor/branchFrac;
      else
         ihead.ecat_calibration_fctr = 1.0/branchFrac;
   }
   ihead.decay_corr_fctr = decayFactor;
   ihead.loss_corr_fctr = dtcor;
   for (i=0; i<6; i++) 
       ihead.filter_params[i] = fparms[i];
   ihead.well_counter_cal_fctr = 1.0;
   strcpy (ihead.annotation, "SUN reconstruction with AP emu library");
     
   matspec(argv[3], fname, &matnum);
   fptr = mat_open(fname, "r+");
   if (!fptr) 
      fptr = mat_create(fname, &mhead);
   mat_write_image(fptr, matnum, &ihead, imagei, imageSize*2);
   mat_close(fptr);

   ftime(tp);
   t5 = (double)tp->time;
   m5 = (double)tp->millitm;
   t5 = t5 + m5/1000.0;
   if (debug || recon_time) {
      fprintf (stdout, "\n t1-t0   t2-t1   t3-t2   t4-t3   t5-t4   t5-t0\n");
      fprintf (stdout, "%6.3f  %6.3f  %6.3f  %6.3f  %6.3f  %6.3f\n\n\n", t1-t0, 
              t2-t1, t3-t2, t4-t3, t5-t4, t5-t0);
   }

   free (imagei);
d609 3
a611 3
   float 	*proj, *image;
   double 	r0, rdx, rdy;
   int 		size;
d613 2
a614 2
   int 		x, y, j;
   double 	r, w;
d616 10
a625 10
   for (y=0; y<size; y++) {
       r = r0;
       for (x=0; x<size; x++) {
           j = (int) r;
           w = r-j;
           (*image++) += (1.0-w)*proj[j] + w*proj[j+1];
           r += rdx;
       }
       r0 += rdy;
   }
d628 4
a631 4
bkprojViewTrap(proj, r0, rdx, rdy, image, size, theta)
   int 		size;
   float 	*proj, *image;
   double 	r0, rdx, rdy, theta;
d633 3
a635 3
   int 		x, y, b1, b2, b3, b4;
   static int 	flag=1;
   double 	r, w, w1, w2, r1, r2, r3, r4, f1, f2, f3, q, q1;
d637 45
a681 45
   w1=M_SQRT2*fabs(cos(theta+M_PI/4));
   w2=M_SQRT2*fabs(cos(theta-M_PI/4));
   if (w1>w2) {
      w = w1;
      w1 = w2;
      w2 = w;
   }
   f1 = 0.5*(w2-w1)/(w2+w1);
   f2 = 2.0*w1/(w2+w1);
   f3 = f1;
   r0 += 0.5;
   for (y=0; y< size; y++, r0+=rdy) { 
       r = r0;
       for (x=0; x< size; x++, image++, r+=rdx) {
           r1 = r-w2/2;
           b1 = (int) r1;
           r2 = r-w1/2;
           b2 = (int) r2;
           r3 = r+w1/2;
           b3 = (int) r3;
           r4 = r+w2/2;
           b4 = (int) r4;
           if (b1 == b2)
              (*image) += f1*proj[b1];
           else {
             q = b2;
             q1 = (q-r1)*(q-r1)/((r2-r1)*(r2-r1));
             (*image) += f1*q1*proj[b1]+f1*(1.0-q1)*proj[b2];
           }
           if (b2 == b3)
              (*image) += f2*proj[b2];
           else {   
              q = b3;
              q1 = (q-r2)/(r3-r2);
              (*image) += f2*q1*proj[b2]+f2*(1.0-q1)*proj[b3];
           }
           if (b3 == b4)
              (*image) += f3*proj[b3];
           else {
              q = b4;
              q1 = (r4-q)*(r4-q)/((r4-r3)*(r4-r3));
              (*image) += f3*q1*proj[b4]+f3*(1.0-q1)*proj[b3];
           }
       } /* next x */
   } /* next y */
d685 4
a688 4
arcCorrect(numProjs, numViews, scan_in, scan_out, profile, w)
   int       	numProjs, numViews;
   float	*scan_in;
   float    	*scan_out, *profile, w;
d690 1
a690 1
   int       	i, j, o, in;
d692 1
a692 1
   float    	f1, f2;
d694 4
a697 4
   for (i=0; i<numProjs; i++) {
       o = (int) profile[i];
       f1 = profile[i] -  o;
       f2 = 1.0 - f1;
d699 3
a701 3
       if (i == numProjs/2) 
          f2 = w;
       for (j=0; j<numViews; j++) {
d703 4
a706 4
           scan_out[o+j*numProjs] += scan_in[i+j*numProjs] * f2;
           scan_out[o+j*numProjs+1] += scan_in[i+j*numProjs] * f1;
       }
   }
d710 3
a712 3
int readScatter(scatParam, planeNum)
   float    	*scatParam;
   int		planeNum;
d714 1
a714 1
   int       	plane, status = 0;
d716 1
a716 1
   char    	*s, temp[256], filename[256];
d718 1
a718 1
   FILE    	*fptr, *fopen();
d720 1
a720 4
   s = (char *)malloc (256);
  
   sprintf (temp, "%s", (char*)getEnviron("SCATDIR"));
   sprintf (filename, "%s/scatparms.dat", temp);
d722 2
a723 12
   if ((fptr=fopen(filename, "r")) != NULL) {
      while ((s=fgets(s, 256, fptr)) != NULL) {
         sscanf (s, "%d %f %f", &plane, &scatParam[0], &scatParam[1]);
         if (plane == planeNum)
            break;
      }
      fclose (fptr);
   }
   else {
     fprintf (stdout, "readScatter:Error...unable to open the file %s\n", filename);
     status = -1;
   }
d725 14
a738 2
   free (s);
   return(status);
d742 3
a744 3
 
char *getEnviron(variable)
   char 	*variable;
d746 8
a753 9
   char 	*string;
 
   if ((string=(char*)getenv(variable)) == (char*)NULL) {
      fprintf (stdout, "getEnviron:Error - environment variable %s is not defined\n", 
              variable);
      return(NULL);
   }
   else
      return(string);
d757 2
a758 2
   int       	*f, *p, *g, *d, *b;
   char    	*str, *fname;
d760 1
a760 1
   char    	*cp;
d762 6
a767 6
   strcpy(fname, str);
   cp = strchr(fname, ',');
   if (cp) {
      *cp++ = '\0';
      sscanf(cp, "%d,%d,%d,%d,%d", &(*f), &(*p), &(*g), &(*d), &(*b));
   }
@


1.4
log
@matrix.h and isotope_info.h now included from /usr/local/include/petutil
@
text
@d2 3
d6 1
a6 1
 * changed Id to $Header$
d42 1
d55 1
a55 1
static char rcsid [] = "$Header: /home/petsun2/tom/src/bkproj_sun/RCS/bkproj_sun.c,v 1.3 1994/03/03 22:08:02 tom Exp tom $";
d571 1
a571 1
   ihead.frame_start_time = frameStartTime;
@


1.3
log
@changed Id to $Header$
@
text
@d2 3
d43 2
a44 2
#include "matrix.h"
#include "isotope_info.h"
d51 1
a51 1
static char rcsid [] = "$Header$";
@


1.2
log
@added RCS keywords
@
text
@d1 4
a4 1
/* $Log$ */
d48 1
a48 1
static char rcsid [] = "$Id$";
@


1.1
log
@Initial revision
@
text
@d1 1
d32 1
d45 2
d411 2
a412 1
   sincos(M_PI*rotoff/180.0, &sint, &cost);
d451 2
a452 1
       sincos(theta, &sint, &cost);
@
