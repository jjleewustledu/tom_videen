head	3.2;
access;
symbols;
locks; strict;
comment	@ * @;


3.2
date	2006.10.06.17.25.13;	author tom;	state Exp;
branches;
next	3.0;

3.0
date	2004.02.16.17.12.15;	author tom;	state Exp;
branches;
next	2.21;

2.21
date	2004.01.30.22.14.23;	author tom;	state Exp;
branches;
next	2.20;

2.20
date	99.12.21.17.26.27;	author tom;	state Exp;
branches;
next	2.19;

2.19
date	99.12.16.18.09.51;	author tom;	state Exp;
branches;
next	2.18;

2.18
date	99.12.15.19.05.43;	author tom;	state Exp;
branches;
next	2.17;

2.17
date	99.08.27.18.25.59;	author tom;	state Exp;
branches;
next	2.16;

2.16
date	99.08.13.19.36.28;	author tom;	state Exp;
branches;
next	2.15;

2.15
date	98.10.12.21.33.13;	author tom;	state Exp;
branches;
next	2.14;

2.14
date	98.10.12.21.22.26;	author tom;	state Exp;
branches;
next	2.13;

2.13
date	98.01.14.17.44.12;	author tom;	state Exp;
branches;
next	2.12;

2.12
date	97.05.14.19.33.25;	author tom;	state Exp;
branches;
next	2.11;

2.11
date	97.03.10.16.29.05;	author tom;	state Exp;
branches;
next	2.10;

2.10
date	96.10.16.16.40.53;	author tom;	state Exp;
branches;
next	2.6;

2.6
date	96.09.26.17.15.42;	author tom;	state Exp;
branches;
next	2.5;

2.5
date	96.09.03.19.56.47;	author tom;	state Exp;
branches;
next	2.4;

2.4
date	96.08.05.18.07.41;	author tom;	state Exp;
branches;
next	2.3;

2.3
date	96.06.21.15.51.43;	author tom;	state Exp;
branches;
next	2.2;

2.2
date	96.06.03.13.44.06;	author tom;	state Exp;
branches;
next	2.1;

2.1
date	96.05.24.18.04.38;	author tom;	state Exp;
branches;
next	2.0;

2.0
date	96.05.20.21.21.44;	author tom;	state Exp;
branches;
next	1.8;

1.8
date	95.07.21.17.38.14;	author tom;	state Exp;
branches;
next	1.7;

1.7
date	95.07.21.16.43.23;	author tom;	state Exp;
branches;
next	1.6;

1.6
date	94.11.29.22.20.03;	author tom;	state Exp;
branches;
next	1.5;

1.5
date	94.11.28.23.08.27;	author tom;	state Exp;
branches;
next	1.4;

1.4
date	94.11.21.19.02.51;	author tom;	state Exp;
branches;
next	1.3;

1.3
date	94.04.08.20.57.48;	author tom;	state Exp;
branches;
next	1.2;

1.2
date	94.04.08.20.51.41;	author tom;	state Exp;
branches;
next	1.1;

1.1
date	94.04.08.20.31.20;	author tom;	state Exp;
branches;
next	;


desc
@original
@


3.2
log
@add SPM fields to hdr
@
text
@/*$Id: img2analyze.c,v 3.0 2004/02/16 17:12:15 tom Exp tom $*/
/*$Log: img2analyze.c,v $
 * Revision 3.0  2004/02/16  17:12:15  tom
 * Feb 2004
 *
 * Revision 2.21  2004/01/30  22:14:23  tom
 * *** empty log message ***
 *
 * Revision 2.20  1999/12/21  17:26:27  tom
 * new libnrimg
 *
 * Revision 2.19  1999/12/16  18:09:51  tom
 * new libs, sync version
 *
 * Revision 2.18  1999/12/15  19:05:43  tom
 * lint clean
 *
 * Revision 2.17  1999/08/27  18:25:59  tom
 * new keys
 *
 * Revision 2.16  1999/08/13  19:36:28  tom
 * changes to match nucmed interfile format
 *
 * Revision 2.15  1998/10/12  21:33:13  tom
 * clean up messages
 *
 * Revision 2.14  1998/10/12  21:22:26  tom
 * clean up messages
 *
 * Revision 2.13  1998/01/14  17:44:12  tom
 * fix calloc
 *
 * Revision 2.12  1997/05/14  19:33:25  tom
 * change output message
 *
 * Revision 2.11  1997/03/10  16:29:05  tom
 * read frame 1,2 or 3
 *
 * Revision 2.10  1996/10/16  16:40:53  tom
 * sync with Version
 * new libimage
 *
 * Revision 2.6  1996/09/26  17:15:42  tom
 * free_s3tensor
 *
 * Revision 2.5  1996/09/03  19:56:47  tom
 * new libimage
 *
 * Revision 2.4  1996/08/05  18:07:41  tom
 * new libimage and libnrimg
 *
 * Revision 2.3  1996/06/21  15:51:43  tom
 * read frame 1 or 2
 *
 * Revision 2.2  1996/06/03  13:44:06  tom
 * correct pixel size in mm
 *
 * Revision 2.1  1996/05/24  18:04:38  tom
 * new libimage, libnrimg
 *
 * Revision 2.0  1996/05/20  21:21:44  tom
 * new libimage
 *
 * Revision 1.8  1995/07/21  17:38:14  tom
 * initialize version and program_date
 *
 * Revision 1.7  1995/07/21  16:43:23  tom
 * added "atlas origin" and "atlas name" to ifh
 *
 * Revision 1.6  1994/11/29  22:20:03  tom
 * added to ifh header
 *
 * Revision 1.5  1994/11/28  23:08:27  tom
 * added Interfile Format header
 *
 * Revision 1.4  1994/11/21  19:02:51  tom
 * flip x-axis for Analyze labels
 *
 * Revision 1.3  1994/04/08  20:57:48  tom
 * add full filename to descrip field
 *
 * Revision 1.2  1994/04/08  20:51:41  tom
 * mm to cm
 *
 * Revision 1.1  1994/04/08  20:31:20  tom
 * Initial revision
 **/
/*	===============================================================================
 *	Module:			img2analyze.c
 *	Date:			07-Apr-94
 *	Author:			Tom Videen
 *	Description:	Transform PETT VI or ECAT images into Analyze format.
 *		Input images may be any format recognizable by getrealimg.
 *		Output images will be displayed by Analyze with left brain on the left
 *		and with the lower slices first.  This allows the 3D volume rendered
 *		brains to appear upright.
 *	History:
 *		29-Nov-94 (TOV)	Create an Interfile Format header file.
 *		21-Jul-95 (TOV) Add "atlas name" and "atlas origin" to ifh output.
 *		Oct-2006	 set atlas origin
 *	===============================================================================
 */
static char     rcsid[] = "$Header: /home/npggw/tom/src/img2analyze/RCS/img2analyze.c,v 3.0 2004/02/16 17:12:15 tom Exp tom $";

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <image.h>
#include <libimage.h>
#include <libnrimg.h>
#include <imgutil.h>				 /* ROUND */
#include <ANALYZE.h>				 /* dsr */

#define MAXSTR 256
#define TRANSVERSE '\000'
#define CORONAL    '\001'
#define SAGITTAL   '\002'

/*	----------------------------
 *	Function:			img2analyze
 *	----------------------------
 */
main (argc, argv)
	int             argc;
	char           *argv[];
{

	ImageFile      *file;
	Index           indx;
	struct dsr      hdr;			 /* header for ANALYZE */
	FILE           *fd_hdr;			 /* file for ANALYZE hdr */
	FILE           *fd_if;			 /* output Interfile Format header */
	FILE           *fd_img;			 /* output ANALYZE image  */

	char           *PET_img;		 /* input PET image filename */
	char           *ANALYZE_hdr;		 /* output Analyze header filename  */
	char           *ANALYZE_img;		 /* output Analyze image filename */
	char           *IF_hdr;			 /* output Interfile Format header filename */
	char           *xorg, *yorg, *zorg;	 /* atlas origin */
	char           *ptr;
	char            version[5];
	char            program_date[12];
	char            str[5];
	long            dim[3];			 /* dimensions of tensors */
	int             global_max;		 /* global maximum */
	int             global_min;		 /* global minimum */
	int             day, month, year;
	int             z0;
	int             i, j, k;

	float        ***image;			 /* input PET image */
	short        ***img;			 /* output Analyze image */
	short          *row;			 /* single row of output image */

/*
 *  Initializations
 */

	indx.frm = 1;
	indx.pln = 1;
	indx.gate = 1;
	indx.data = 0;
	indx.bed = 0;
	xorg = hdr.hist.originator + 1;
	yorg = hdr.hist.originator + 3;
	zorg = hdr.hist.originator + 5;

	ptr = strstr (rcsid, "v ");
	ptr += 2;
	(void) strcpy (version, "    ");
	if (ptr != NULL) {
		(void) strncpy (version, ptr, 4);
		ptr = strstr (ptr, " ");
		ptr++;
	}
	(void) strcpy (program_date, "           ");
	if (ptr != NULL)
		(void) strncpy (program_date, ptr, 10);
	ptr = strchr (program_date, '/');
	*ptr = ':';
	ptr = strchr (program_date, '/');
	*ptr = ':';

/*
 *	Get command line arguments and initialize filenames:
 */

	if (argc != 5) {
		fprintf (stdout, "Usage: img2analyze PET_img ANALYZE_img ANALYZE_hdr IF_hdr\n");
		return (ERROR);
	}
	PET_img = argv[1];
	ANALYZE_img = argv[2];
	ANALYZE_hdr = argv[3];
	IF_hdr = argv[4];

	if ((fd_hdr = fopen (ANALYZE_hdr, "w")) == 0) {
		fprintf (stderr, "ERROR [img2analyze]: Unable to create ANALYZE header %s\n", ANALYZE_hdr);
		return (ERROR);
	}
	if ((fd_img = fopen (ANALYZE_img, "w")) == 0) {
		fprintf (stderr, "ERROR [img2analyze]: Unable to create ANALYZE image %s\n", ANALYZE_img);
		return (ERROR);
	}
	if ((fd_if = fopen (IF_hdr, "w")) == 0) {
		fprintf (stderr, "ERROR [img2analyze]: Unable to create Interfile Format header %s\n", IF_hdr);
		return (ERROR);
	}
/*
 *	Read the image.
 */

	file = make_imgfile (PET_img);
	if (open_imgfile (file) == ERROR) {
		fprintf (stderr, "ERROR [img2analyze]: Cannot open %s\n", PET_img);
		return (ERROR);
	}
	if (get_mh (file) == ERROR) {
		fprintf (stderr, "ERROR [img2analyze]: Cannot get MainHeader from %s\n", PET_img);
		return (ERROR);
	}
	if (existimgfrm (file, &indx) == ERROR) {
		if (indx.frm == 1) {
			indx.frm = 2;
			if (existimgfrm (file, &indx) == ERROR) {
				indx.frm = 3;
				if (existimgfrm (file, &indx) == ERROR) {
					fprintf (stderr, "ERROR [img2analyze]: cannot find %s frame 1, 2 or 3\n", file->name);
					return (ERROR);
				}
			}
		} else {
			fprintf (stderr, "ERROR [img2analyze]: cannot find %s frame %d\n",
				 file->name, indx.frm);
			return (ERROR);
		}
	}
	if (get_sh (file, &indx) == ERROR) {
		fprintf (stderr, "ERROR [img2analyze]: Cannot read file subheader in %s\n", PET_img);
		return (ERROR);
	}
	dim[0] = (long) file->sh->dim1;
	dim[1] = (long) file->sh->dim2;
	dim[2] = (long) file->sh->dim3;
	z0 = file->mh->zorigin;
	if ((image = readtensor (file, &indx)) == NULL)
		return (ERROR);
	if ((img = s3tensor (1, dim[2], 1, dim[1], 1, dim[0])) == NULL) {
		fprintf (stderr, "ERROR [img2analyze]: Cannot malloc img\n");
		return (ERROR);
	}
	if (NULL == (row = (short *) calloc (dim[0], sizeof (short)))) {
		fprintf (stderr, "ERROR [img2analyze]: Cannot malloc memory for row\n");
		return (ERROR);
	}
/*
 * Convert from float to short, find min and max for hdr
 */

	global_max = 0;
	global_min = 32000;
	for (i = 1; i <= dim[2]; i++) {
		for (j = 1; j <= dim[1]; j++) {
			for (k = 1; k <= dim[0]; k++) {
				img[i][j][k] = ROUND (image[i][j][k]);
				if (img[i][j][k] > global_max)
					global_max = img[i][j][k];
				if (img[i][j][k] < global_min)
					global_min = img[i][j][k];
			}
		}
	}
	free (image);

/*
 * Flip X, Y & Z, and write to output file
			fwrite (fd_img, (char *) row, dim[0] * 2);
 */

	for (i = dim[2]; i > 0; i--) {
		for (j = dim[1]; j > 0; j--) {
			for (k = 1; k <= dim[0]; k++)
				row[k - 1] = img[i][j][dim[0] - (k - 1)];
			(void) fwrite (row, sizeof (short), dim[0], fd_img);
		}
	}
	free_s3tensor (img, 1, dim[2], 1, dim[1], 1, dim[0]);

/*
 * Create Analyze hdr file
 */

	(void) strncpy (hdr.hk.db_name, PET_img, 17);
	(void) strncpy (hdr.hk.data_type, "dsr", 9);
	hdr.hk.sizeof_hdr = sizeof (struct dsr); /* required by developers */
	hdr.hk.extents = 16384;			 /* recommended by developers  */
	hdr.hk.regular = 'r';			 /* required by developers */
	hdr.hk.hkey_un0 = '0';			 /* required by developers */
	hdr.dime.dim[0] = 4;			 /* typically only 4 dimensions  */
	hdr.dime.dim[1] = dim[0];		 /* x dimension of atlas   */
	hdr.dime.dim[2] = dim[1];		 /* y dimension of atlas   */
	hdr.dime.dim[3] = dim[2];		 /* number of slices in volume */
	hdr.dime.dim[4] = 1;			 /* only one volume typically  */
	hdr.dime.unused8 = 0;			 /* despite the label, some of this is used */
	hdr.dime.unused9 = 0;
	hdr.dime.unused10 = 0;
	hdr.dime.unused11 = 0;
	hdr.dime.unused12 = 0;
	hdr.dime.unused13 = 0;
	hdr.dime.unused14 = 0;
	hdr.dime.datatype = 4;			 /* 16 bit signed integer  */
	hdr.dime.bitpix = 16;			 /* number of bits/pixel */
	hdr.dime.pixdim[1] = 10 * file->sh->sample_size_1;	/* in mm */
	hdr.dime.pixdim[2] = 10 * file->sh->sample_size_2;	/* in mm */
	hdr.dime.pixdim[3] = 10 * file->sh->sample_size_3;	/* in mm */
	hdr.dime.funused8 = 0;
	hdr.dime.funused9 = 1.0;		 /* SPM sets this to 1 */
	hdr.dime.funused10 = 0;
	hdr.dime.funused11 = 0;
	hdr.dime.funused12 = 0;
	hdr.dime.funused13 = 0;
	hdr.dime.glmax = global_max;
	hdr.dime.glmin = global_min;
	(void) strncpy (hdr.hist.descrip, PET_img, 79);
	(void) strncpy (hdr.hist.aux_file, "none", 23);
	hdr.hist.orient = TRANSVERSE;
	(void) strcpy (hdr.hist.originator, "img2analy");
	(void) strncpy (hdr.hist.patient_id, version, 4);

	if (dim[0] == 128)
		*xorg = 64;
	if (dim[1] == 128)
		*yorg = 65;
	if (z0 > 0)
		*zorg = dim[2] + 1 - z0;

	if ((fwrite (&hdr, sizeof (struct dsr), 1, fd_hdr)) != 1) {
		fprintf (stderr, "ERROR [img2analyze]: Error writing to: %s\n", ANALYZE_hdr);
		return (ERROR);
	}
/*
 * Create Interfile Format header file
 */

	fprintf (fd_if, "INTERFILE :=\n");
	fprintf (fd_if, "image modality     := PET\n");
	fprintf (fd_if, "originating system := ECAT/%d\n", file->mh->scanner_type);
	fprintf (fd_if, "version of keys    := 3.3\n");
	fprintf (fd_if, "date of keys       := 1992:01:01\n");
	fprintf (fd_if, "conversion program := img2analyze\n");
	fprintf (fd_if, "program version    := %s\n", version);
	fprintf (fd_if, "program date       := %s\n", program_date);
	fprintf (fd_if, ";\n");
	fprintf (fd_if, "GENERAL DATA :=\n");
	fprintf (fd_if, "original institution := Washington University\n");
	fprintf (fd_if, "data starting block  := 0\n");
	fprintf (fd_if, "name of data file    := %s\n", ANALYZE_img);
	fprintf (fd_if, "patient ID := %s\n", file->mh->patnum);
	fprintf (fd_if, "study ID   := PET\n");
	fprintf (fd_if, ";\n");
	fprintf (fd_if, "GENERAL IMAGE DATA :=\n");
	fprintf (fd_if, "type of data := tomographic\n");
	fprintf (fd_if, "total number of images := %d\n", (int) dim[2]);
	(void) strcpy (str, "    ");
	(void) strncpy (str, file->mh->date_time, 2);
	month = atoi (str);
	(void) strncpy (str, file->mh->date_time + 3, 2);
	day = atoi (str);
	(void) strncpy (str, file->mh->date_time + 6, 2);
	year = atoi (str);
	if (year < 90)
		fprintf (fd_if, "study date := 20%02d:%02d:%02d\n", year, month, day);
	else
		fprintf (fd_if, "study date := 19%02d:%02d:%02d\n", year, month, day);
	fprintf (fd_if, "imagedata byte order   := bigendian\n");
	fprintf (fd_if, ";\n");
	fprintf (fd_if, "PET STUDY :=\n");
	fprintf (fd_if, "process status := reconstructed\n");
	fprintf (fd_if, "number of dimensions := 3\n");
	fprintf (fd_if, "number of slices := %d\n", (int) dim[2]);
	fprintf (fd_if, "matrix size [1] := %d\n", (int) dim[0]);
	fprintf (fd_if, "matrix size [2] := %d\n", (int) dim[1]);
	fprintf (fd_if, "matrix size [3] := %d\n", (int) dim[2]);
	fprintf (fd_if, "number format   := signed integer\n");
	fprintf (fd_if, "number of bytes per pixel  := 2\n");
	fprintf (fd_if, "scaling factor (mm/pixel) [1]  := %f\n", 10. * file->sh->sample_size_1);
	fprintf (fd_if, "scaling factor (mm/pixel) [2]  := %f\n", 10. * file->sh->sample_size_2);
	fprintf (fd_if, "scaling factor (mm/pixel) [3]  := %f\n", 10. * file->sh->sample_size_3);
	fprintf (fd_if, "maximum pixel count := %d\n", global_max);
	fprintf (fd_if, "minimum pixel count := %d\n", global_min);
	fprintf (fd_if, "matrix initial element [1] := right\n");
	fprintf (fd_if, "matrix initial element [2] := posterior\n");
	fprintf (fd_if, "matrix initial element [3] := inferior\n");
	if (file->mh->zorigin > 0) {
		fprintf (fd_if, "atlas origin [1] := %.2f\n", 0.5 * ((float) (dim[0] + 1)));
		fprintf (fd_if, "atlas origin [2] := %.2f\n", 0.5 * ((float) (dim[1] + 1)));
		fprintf (fd_if, "atlas origin [3] := %d\n", file->mh->zorigin);
	}
	fprintf (fd_if, "END OF INTERFILE :=\n");

	fprintf (stdout, "Converted: %s to %s\n", PET_img, ANALYZE_img);
	(void) fclose (fd_hdr);
	(void) fclose (fd_img);
	(void) fclose (fd_if);
	free (row);
	return (OK);
}
@


3.0
log
@Feb 2004
@
text
@d1 1
a1 1
/*$Id: img2analyze.c,v 2.21 2004/01/30 22:14:23 tom Exp tom $*/
d3 3
d100 1
d103 1
a103 1
static char     rcsid[] = "$Header: /home/npggw/tom/src/img2analyze/RCS/img2analyze.c,v 2.21 2004/01/30 22:14:23 tom Exp tom $";
d137 2
a138 2
	char           *ANALYZE_hdr;	 /* output Analyze header filename  */
	char           *ANALYZE_img;	 /* output Analyze image filename */
d140 1
d149 1
d165 3
d178 1
a178 1
	if (ptr != NULL) 
d190 1
a190 1
		fprintf (stdout,"Usage: img2analyze PET_img ANALYZE_img ANALYZE_hdr IF_hdr\n");
d246 1
d295 1
d299 1
d318 1
a318 1
	hdr.dime.funused9 = 0;
d326 2
a329 1
	hdr.hist.orient = TRANSVERSE;
d331 7
d364 1
a364 1
	fprintf (fd_if, "total number of images := %d\n",(int) dim[2]);
d366 1
a366 1
	(void) strncpy (str, file->mh->date_time,2);
d368 1
a368 1
	(void) strncpy (str, file->mh->date_time+3,2);
d370 1
a370 1
	(void) strncpy (str, file->mh->date_time+6,2);
d372 1
a372 1
	if (year < 90) 
d402 1
a402 1
	fprintf (stdout,"Converted: %s to %s\n", PET_img, ANALYZE_img);
@


2.21
log
@*** empty log message ***
@
text
@d1 1
a1 1
/*$Id: img2analyze.c,v 2.20 1999/12/21 17:26:27 tom Exp tom $*/
d3 3
d99 1
a99 1
static char     rcsid[] = "$Header: /home/npggw/tom/src/img2analyze/RCS/img2analyze.c,v 2.20 1999/12/21 17:26:27 tom Exp tom $";
d163 5
a167 3
	(void) strncpy (version, ptr, 4);
	ptr = strstr (ptr, " ");
	ptr++;
d169 2
a170 1
	(void) strncpy (program_date, ptr, 10);
@


2.20
log
@new libnrimg
@
text
@d1 1
a1 1
/*$Id: img2analyze.c,v 2.19 1999/12/16 18:09:51 tom Exp tom $*/
d3 3
d96 1
a96 1
static char     rcsid[] = "$Header: /home/npggw/tom/src/img2analyze/RCS/img2analyze.c,v 2.19 1999/12/16 18:09:51 tom Exp tom $";
d159 2
a160 2
	strcpy (version, "    ");
	strncpy (version, ptr, 4);
d163 2
a164 2
	strcpy (program_date, "           ");
	strncpy (program_date, ptr, 10);
d269 1
a269 1
			fwrite (row, sizeof (short), dim[0], fd_img);
d278 1
a278 1
	strncpy (hdr.hk.db_name, PET_img, 17);
d307 3
a309 3
	strncpy (hdr.hist.descrip, PET_img, 79);
	strcpy (hdr.hist.originator, "img2analy");
	strncpy (hdr.hist.patient_id, version, 4);
d339 2
a340 2
	strcpy (str, "    ");
	strncpy (str, file->mh->date_time,2);
d342 1
a342 1
	strncpy (str, file->mh->date_time+3,2);
d344 1
a344 1
	strncpy (str, file->mh->date_time+6,2);
d361 3
a363 3
	fprintf (fd_if, "scaling factor (mm/pixel) [1]  := %f\n", 10 * file->sh->sample_size_1);
	fprintf (fd_if, "scaling factor (mm/pixel) [2]  := %f\n", 10 * file->sh->sample_size_2);
	fprintf (fd_if, "scaling factor (mm/pixel) [3]  := %f\n", 10 * file->sh->sample_size_3);
d377 3
a379 3
	fclose (fd_hdr);
	fclose (fd_img);
	fclose (fd_if);
@


2.19
log
@new libs, sync version
@
text
@d1 1
a1 1
/*$Id: img2analyze.c,v 2.18 1999/12/15 19:05:43 tom Exp tom $*/
d3 3
d93 1
a93 1
static char     rcsid[] = "$Header: /home/npggw/tom/src/img2analyze/RCS/img2analyze.c,v 2.18 1999/12/15 19:05:43 tom Exp tom $";
@


2.18
log
@lint clean
@
text
@d1 1
a1 1
/*$Id: img2analyze.c,v 2.17 1999/08/27 18:25:59 tom Exp tom $*/
d3 3
d90 1
a90 1
static char     rcsid[] = "$Header: /home/npggw/tom/src/img2analyze/RCS/img2analyze.c,v 2.17 1999/08/27 18:25:59 tom Exp tom $";
@


2.17
log
@new keys
@
text
@d1 1
a1 1
/*$Id: img2analyze.c,v 2.16 1999/08/13 19:36:28 tom Exp tom $*/
d3 3
d87 1
a87 1
static char     rcsid[] = "$Header: /home/npggw/tom/src/img2analyze/RCS/img2analyze.c,v 2.16 1999/08/13 19:36:28 tom Exp tom $";
d205 1
a205 1
					fprintf (stderr, "ERROR [img2analyze]: cannot find %s frame 1, 2 or 3\n", file);
d211 1
a211 1
				 file, indx.frm);
d329 1
a329 1
	fprintf (fd_if, "total number of images := %d\n",dim[2]);
d347 3
a349 3
	fprintf (fd_if, "matrix size [1] := %d\n", dim[0]);
	fprintf (fd_if, "matrix size [2] := %d\n", dim[1]);
	fprintf (fd_if, "matrix size [3] := %d\n", dim[2]);
d371 1
@


2.16
log
@changes to match nucmed interfile format
@
text
@d1 1
a1 1
/*$Id: img2analyze.c,v 2.15 1998/10/12 21:33:13 tom Exp tom $*/
d3 3
d84 1
a84 1
static char     rcsid[] = "$Header: /home/npggw/tom/src/img2analyze/RCS/img2analyze.c,v 2.15 1998/10/12 21:33:13 tom Exp tom $";
d87 1
a92 1
#include <matrixlib.h>
d124 1
d128 1
d163 1
a163 1
		printf ("Usage: img2analyze PET_img ANALYZE_img ANALYZE_hdr IF_hdr\n");
d246 1
d260 1
d309 2
d312 1
a312 2
	fprintf (fd_if, "image modality     := nucmed\n");
	fprintf (fd_if, "originating system := %d\n", file->mh->scanner_type);
d316 1
a316 1

d318 3
a320 2
	fprintf (fd_if, "data starting block := 0\n");
	fprintf (fd_if, "name of data file   := %s\n", ANALYZE_img);
d323 1
a323 1

d327 11
a337 1
	fprintf (fd_if, "study date := %s\n", file->mh->date_time);
d339 2
a340 3

	fprintf (fd_if, "SPECT STUDY (General) :=\n");
	fprintf (fd_if, "number of images/energy window := %d\n", dim[2]);
d343 1
d349 3
a361 7

	fprintf (fd_if, "SPECT STUDY (reconstructed data) :=\n");
	fprintf (fd_if, "number of slices := %d\n",dim[2]);
	fprintf (fd_if, "scaling factor (mm/pixel) [1]  := %f\n", 10 * file->sh->sample_size_1);
	fprintf (fd_if, "scaling factor (mm/pixel) [2]  := %f\n", 10 * file->sh->sample_size_2);
	fprintf (fd_if, "scaling factor (mm/pixel) [3]  := %f\n", 10 * file->sh->sample_size_3);
	fprintf (fd_if, "slice thickness (pixels) := 1.0\n");
d364 1
a364 7
/*
 *	Free & Exit
 *	-----------
 */
	printf ("Converted: %s to %s\n", PET_img, ANALYZE_img);
	free (image);
	free_s3tensor (img, 1, dim[2], 1, dim[1], 1, dim[0]);
@


2.15
log
@clean up messages
@
text
@d1 1
a1 1
/*$Id: img2analyze.c,v 2.14 1998/10/12 21:22:26 tom Exp tom $*/
d3 3
d81 1
a81 1
static char     rcsid[] = "$Header: /home/npggw/tom/src/img2analyze/RCS/img2analyze.c,v 2.14 1998/10/12 21:22:26 tom Exp tom $";
d112 1
a112 2
	FILE           *fopen ();		 /* the fopen stuff  */
	int             fd_img;			 /* output ANALYZE image  */
d115 2
a116 2
	char           *ANALYZE_hdr;		 /* output Analyze header filename  */
	char           *ANALYZE_img;		 /* output Analyze image filename */
d170 1
a170 1
	if ((fd_img = open (ANALYZE_img, O_CREAT | O_RDWR, 0666)) == 0) {
d244 1
d251 1
a251 1
			write (fd_img, (char *) row, dim[0] * 2);
d303 1
a303 1
	fprintf (fd_if, "image modality := pet\n");
d307 11
a317 3
	fprintf (fd_if, "program date   := %s\n", program_date);
	fprintf (fd_if, "name of data file  := %s\n", ANALYZE_img);
	fprintf (fd_if, "subject ID	:= %s\n", file->mh->patnum);
d319 1
d321 8
a328 1
	fprintf (fd_if, "number format  := signed integer\n");
d330 2
a331 7
	fprintf (fd_if, "number of dimensions   := 3\n");
	fprintf (fd_if, "matrix size [1]    := %d\n", dim[0]);
	fprintf (fd_if, "matrix size [2]    := %d\n", dim[1]);
	fprintf (fd_if, "matrix size [3]    := %d\n", dim[2]);
	fprintf (fd_if, "scaling factor (mm/pixel) [1]  := %f\n", 10 * file->sh->sample_size_1);
	fprintf (fd_if, "scaling factor (mm/pixel) [2]  := %f\n", 10 * file->sh->sample_size_2);
	fprintf (fd_if, "scaling factor (mm/pixel) [3]  := %f\n", 10 * file->sh->sample_size_3);
a334 1

d340 9
d356 3
a358 3
	close (fd_hdr);
	close (fd_img);
	close (fd_if);
@


2.14
log
@clean up messages
@
text
@d1 1
a1 1
/*$Id: img2analyze.c,v 2.13 1998/01/14 17:44:12 tom Exp tom $*/
d3 3
d78 1
a78 1
static char     rcsid[] = "$Header: /home/npggw/tom/src/img2analyze/RCS/img2analyze.c,v 2.13 1998/01/14 17:44:12 tom Exp tom $";
d331 1
a331 1
	printf ("Successful conversion: %s to %s\n", PET_img, ANALYZE_img);
@


2.13
log
@fix calloc
@
text
@d1 1
a1 1
/*$Id: img2analyze.c,v 2.12 1997/05/14 19:33:25 tom Exp tom $*/
d3 3
d75 1
a75 1
static char     rcsid[] = "$Header: /home/npggw/tom/src/img2analyze/RCS/img2analyze.c,v 2.12 1997/05/14 19:33:25 tom Exp tom $";
d84 2
a85 2
#include <imgutil.h>			 /* ROUND */
#include <ANALYZE.h>			 /* dsr */
d102 1
a102 1
    Index           indx;
d116 1
a116 1
    long            dim[3];          /* dimensions of tensors */
a127 6
 
    indx.frm = 1;
    indx.pln = 1;
    indx.gate = 1;
    indx.data = 0;
    indx.bed = 0;
d129 6
d137 1
a137 1
	strcpy (version,"    ");
d141 1
a141 1
	strcpy (program_date,"           ");
d162 1
a162 1
		printf ("Unable to create ANALYZE header %s\n", ANALYZE_hdr);
d166 1
a166 1
		printf ("Unable to create ANALYZE image %s\n", ANALYZE_img);
d170 1
a170 1
		printf ("Unable to create Interfile Format header %s\n", IF_hdr);
a172 1

d176 14
a189 14
 
    file = make_imgfile (PET_img);
    if (open_imgfile (file) == ERROR) {
        fprintf (stderr, "ERROR [img2analyze]: Cannot open %s\n", PET_img);
        return (ERROR);
    }
    if (get_mh (file) == ERROR) {
        fprintf (stderr, "ERROR [img2analyze]: Cannot get MainHeader from %s\n", PET_img);
        return (ERROR);
    }
    if (existimgfrm (file, &indx) == ERROR) {
        if (indx.frm == 1) {
            indx.frm = 2;
            if (existimgfrm (file, &indx) == ERROR) {
d192 2
a193 2
                	fprintf (stderr, "ERROR [img2analyze]: cannot find %s frame 1, 2 or 3\n", file);
                	return (ERROR);
d195 24
a218 26
            }
        } else {
            fprintf (stderr, "ERROR [img2analyze]: cannot find %s frame %d\n",
                 file, indx.frm);
            return (ERROR);
        }
    }
    if (get_sh (file, &indx) == ERROR) {
        fprintf (stderr, "ERROR [img2analyze]: Cannot read file subheader in %s\n", PET_img);
        return (ERROR);
    }
    dim[0] = (long) file->sh->dim1;
    dim[1] = (long) file->sh->dim2;
    dim[2] = (long) file->sh->dim3;
	printf ("Converting %s\n", PET_img);
    if ((image = readtensor (file, &indx)) == NULL)
        return (ERROR);
    if ((img = s3tensor (1, dim[2], 1, dim[1], 1, dim[0])) == NULL) {
        fprintf (stderr, "ERROR [img2analyze]: Cannot malloc img\n");
        return (ERROR);
    }
    if (NULL == (row = (short *) calloc (dim[0], sizeof (short)))) {
        printf ("ERROR [img2analyze]: Cannot malloc memory for row\n");
        return (ERROR);
    }
	
d244 1
a244 1
				row[k-1] = img[i][j][dim[0] - (k - 1)];
d288 1
a288 1
		printf ("Error writing to: %s\n", ANALYZE_hdr);
d328 1
a328 2

	printf ("Successful conversion to %s\n", ANALYZE_img);
d330 1
a330 1
    free_s3tensor (img, 1, dim[2], 1, dim[1], 1, dim[0]);
@


2.12
log
@change output message
@
text
@d1 1
a1 1
/*$Id: img2analyze.c,v 2.11 1997/03/10 16:29:05 tom Exp tom $*/
d3 3
d72 1
a72 1
static char     rcsid[] = "$Header: /home/npggw/tom/src/img2analyze/RCS/img2analyze.c,v 2.11 1997/03/10 16:29:05 tom Exp tom $";
d214 1
a214 1
    if (NULL == (row = (short *) calloc ((short) (dim[0] * sizeof (short))))) {
@


2.11
log
@read frame 1,2 or 3
@
text
@d1 1
a1 1
/*$Id: img2analyze.c,v 2.10 1996/10/16 16:40:53 tom Exp tom $*/
d3 3
d69 1
a69 1
static char     rcsid[] = "$Header: /home/npggw/tom/src/img2analyze/RCS/img2analyze.c,v 2.10 1996/10/16 16:40:53 tom Exp tom $";
d326 1
a326 1
	printf ("\nSuccessful conversion to %s\n", ANALYZE_img);
@


2.10
log
@sync with Version
new libimage
@
text
@d1 1
a1 1
/*$Id: img2analyze.c,v 2.6 1996/09/26 17:15:42 tom Exp tom $*/
d3 4
d66 1
a66 1
static char     rcsid[] = "$Header: /home/npggw/tom/src/img2analyze/RCS/img2analyze.c,v 2.6 1996/09/26 17:15:42 tom Exp tom $";
d171 1
a171 1
        fprintf (stderr, "ERROR [template]: Cannot open %s\n", PET_img);
d175 1
a175 1
        fprintf (stderr, "ERROR [template]: Cannot get MainHeader from %s\n", PET_img);
d182 5
a186 2
                fprintf (stderr, "ERROR [imghdr]: cannot find %s frame 1 or 2\n", file);
                return (ERROR);
d189 1
a189 1
            fprintf (stderr, "ERROR [imghdr]: cannot find %s frame %d\n",
d195 1
a195 1
        fprintf (stderr, "ERROR [template]: Cannot read file subheader in %s\n", PET_img);
@


2.6
log
@free_s3tensor
@
text
@d1 1
a1 1
/*$Id: img2analyze.c,v 2.5 1996/09/03 19:56:47 tom Exp tom $*/
d3 3
d62 1
a62 1
static char     rcsid[] = "$Header: /home/npggw/tom/src/img2analyze/RCS/img2analyze.c,v 2.5 1996/09/03 19:56:47 tom Exp tom $";
@


2.5
log
@new libimage
@
text
@d1 1
a1 1
/*$Id: img2analyze.c,v 2.4 1996/08/05 18:07:41 tom Exp tom $*/
d3 3
d59 1
a59 1
static char     rcsid[] = "$Header: /home/npggw/tom/src/img2analyze/RCS/img2analyze.c,v 2.4 1996/08/05 18:07:41 tom Exp tom $";
d315 1
a315 6
	for (i = 1; i <= dim[2]; i++) {
		for (j = 1; j <= dim[1]; j++)
			free (img[i][j]);
		free (img[i]);
	}
	free (img);
@


2.4
log
@new libimage and libnrimg
@
text
@d1 1
a1 1
/*$Id: img2analyze.c,v 2.3 1996/06/21 15:51:43 tom Exp tom $*/
d3 3
d56 1
a56 1
static char     rcsid[] = "$Header: /home/npggw/tom/src/img2analyze/RCS/img2analyze.c,v 2.3 1996/06/21 15:51:43 tom Exp tom $";
@


2.3
log
@read frame 1 or 2
@
text
@d1 1
a1 1
/*$Id: img2analyze.c,v 2.2 1996/06/03 13:44:06 tom Exp tom $*/
d3 3
d53 1
a53 1
static char     rcsid[] = "$Header: /home/petsun19/tom/src/img2analyze/RCS/img2analyze.c,v 2.2 1996/06/03 13:44:06 tom Exp tom $";
@


2.2
log
@correct pixel size in mm
@
text
@d1 1
a1 1
/*$Id: img2analyze.c,v 2.1 1996/05/24 18:04:38 tom Exp tom $*/
d3 3
d50 1
a50 1
static char     rcsid[] = "$Header: /home/petsun19/tom/src/img2analyze/RCS/img2analyze.c,v 2.1 1996/05/24 18:04:38 tom Exp tom $";
d161 13
@


2.1
log
@new libimage, libnrimg
@
text
@d1 1
a1 1
/*$Id: img2analyze.c,v 2.0 1996/05/20 21:21:44 tom Exp tom $*/
d3 3
d47 1
a47 1
static char     rcsid[] = "$Header: /home/petsun19/tom/src/img2analyze/RCS/img2analyze.c,v 2.0 1996/05/20 21:21:44 tom Exp tom $";
d230 3
a232 3
	hdr.dime.pixdim[1] = file->sh->sample_size_1;
	hdr.dime.pixdim[2] = file->sh->sample_size_2;
	hdr.dime.pixdim[3] = file->sh->sample_size_3;
d271 3
a273 3
	fprintf (fd_if, "scaling factor (mm/pixel) [1]  := %f\n", file->sh->sample_size_1);
	fprintf (fd_if, "scaling factor (mm/pixel) [2]  := %f\n", file->sh->sample_size_2);
	fprintf (fd_if, "scaling factor (mm/pixel) [3]  := %f\n", file->sh->sample_size_3);
@


2.0
log
@new libimage
@
text
@d1 1
a1 1
/*$Id: img2analyze.c,v 1.8 1995/07/21 17:38:14 tom Exp tom $*/
d3 3
d44 1
a44 1
static char     rcsid[] = "$Header: /home/petsun19/tom/src/img2analyze/RCS/img2analyze.c,v 1.8 1995/07/21 17:38:14 tom Exp tom $";
@


1.8
log
@initialize version and program_date
@
text
@d1 1
a1 1
/*$Id: img2analyze.c,v 1.7 1995/07/21 16:43:23 tom Exp tom $*/
d3 3
d41 1
d46 6
a51 4
#include <petutil/imglist.h>
#include <petutil/matrix.h>
#include <petutil/petutil.h>			 /* ROUND */
#include <petutil/ANALYZE.h>			 /* dsr */
a57 2
static char     rcsid[] = "$Header: /home/npggw/tom/src/img2analyze/RCS/img2analyze.c,v 1.7 1995/07/21 16:43:23 tom Exp tom $";

d67 2
a73 1
	int             fd_in;			 /* input PET image */
a74 6
	struct Matval   matval;
	Image_subheader **subheader;
	Main_header    *main_header;
	MatrixFile     *fptr;
	FILE           *listfp;
	COMMENT_INFO    comment_info_data;	/* comment field from ECAT header */
a79 1
	char            num[12];
d82 1
a82 9
	char            study_date[12];
	char            institution[MAXSTR];
	char            model[MAXSTR];
	char            subject_id[MAXSTR];
	char           atlas_name[MAXSTR];

	int             zorigin;		 /* zorigin read from input file */
	int             scanner;		 /* 6 = PETT VI;  10 = 953B */
	int             dimension;		 /* xdim * ydim * num_slices */
d85 1
a85 1
	int             i, j, k, n;
d87 1
a87 3
	float           pixel_size;
	float           plane_separation;
	float          *image;			 /* input PET image */
a89 2
	short           xdim, ydim;		 /* pixel dimensions */
	short           num_slices;		 /* number of slices */
d91 9
a99 1
	BOOLEAN         encoded_flag;
a100 7
	matval.frame = 1;			 /* default values for matval */
	matval.plane = 1;
	matval.gate = 1;
	matval.data = 0;
	matval.bed = 0;

	strcpy (atlas_name, "Talariach 1988");
a115 1
 *	---------------------------------------------------
d120 1
a120 1
		exit (FAIL);
d129 1
a129 1
		exit (FAIL);
d133 1
a133 1
		exit (FAIL);
d137 1
a137 1
		exit (FAIL);
a138 27
/*
 *	First image, first time -- get scanner and dimensions
 *	------------------------------------------------------------------
 */
	fd_in = open (PET_img, O_RDONLY, 0);
	if (fd_in == -1) {
		fprintf (stderr, "Error opening %s\n", PET_img);
		exit (FAIL);
	}
	scanner = getimage_type (fd_in, PET_img, &encoded_flag, &num_slices);
	close (fd_in);
	if (scanner == ERROR_SCANNER) {
		fprintf (stderr, "Error: file is not a recognized PET image\n");
		exit (FAIL);
	}
	if (scanner == ECAT_SCANNER) {
		fptr = OpenEcat (PET_img, &num_slices, &xdim, &ydim, &pixel_size, &plane_separation, matval);
		if (fptr == (MatrixFile *) NULL) {
			fprintf (stderr, "Error: cannot open %s as an ECAT image file\n", PET_img);
			exit (FAIL);
		}
	} else {
		xdim = 128;
		ydim = 128;
		pixel_size = 0.286;
		plane_separation = 1.44;
	}
d141 1
a141 2
 * Memory Allocation
 * -----------------
d143 17
a159 41

	dimension = xdim * ydim * num_slices;
	image = (float *) calloc (dimension, sizeof (float));
	if (image == NULL) {
		printf ("Memory allocation failure for image\n");
		exit (FAIL);
	}
	main_header = (Main_header *) calloc (1, sizeof (Main_header));
	if (main_header == NULL) {
		printf ("Memory allocation failure for main_header\n");
		exit (FAIL);
	}
	subheader = (Image_subheader **) calloc (num_slices * sizeof (caddr_t));
	if (subheader == NULL) {
		printf ("Memory allocation failure for subheader\n");
		exit (FAIL);
	}
	if (NULL == (img = (short ***) malloc ((short) (num_slices * sizeof (short **))))) {
		printf ("Could not malloc memory for ***img\n");
		exit (FAIL);
	}
	for (i = 0; i < num_slices; i++) {
		if (NULL == (img[i] = (short **) malloc ((short) (ydim * sizeof (short *))))) {
			printf ("Could not malloc memory for **img\n");
			exit (FAIL);
		}
		for (j = 0; j < ydim; j++) {
			if (NULL == (img[i][j] = (short *) malloc ((short) (xdim * sizeof (short))))) {
				printf ("Could not malloc memory for *img\n");
				exit (FAIL);
			}
		}
	}
	if (NULL == (row = (short *) malloc ((short) (xdim * sizeof (short))))) {
		printf ("Could not malloc memory for row\n");
		exit (FAIL);
	}
/*
 * Read input image
 */

d161 11
a171 22
	if (getrealimg (PET_img, scanner, matval, xdim, ydim, num_slices, image,
			main_header, subheader) == FAIL) {
		fprintf (stderr, "Error reading %s\n", PET_img);
		exit (FAIL);
	}
/*	Get system, institution, subject_id, study_date */

	sprintf (model, "%d", main_header->system_type);
	strcpy (institution, main_header->facility_name);
	strcpy (subject_id, main_header->patient_id);
	sprintf (num, "%d", main_header->scan_start_year);
	strcpy (study_date, num);
	strcat (study_date, ":");
	sprintf (num, "%d", main_header->scan_start_month);
	strcat (study_date, num);
	strcat (study_date, ":");
	sprintf (num, "%d", main_header->scan_start_day);
	strcat (study_date, num);

	comment_info (main_header->study_description, &comment_info_data);
	zorigin = comment_info_data.zorigin;

d178 4
a181 5
	n = 0;
	for (i = 0; i < num_slices; i++) {
		for (j = 0; j < ydim; j++) {
			for (k = 0; k < xdim; k++) {
				img[i][j][k] = ROUND (image[n]);
a185 1
				n++;
a187 1
/*		printf ("Slice %d  Max = %d  Min = %d\n", i, global_max, global_min); */
d194 5
a198 5
	for (i = num_slices - 1; i >= 0; i--) {
		for (j = ydim - 1; j >= 0; j--) {
			for (k = 0; k < xdim; k++)
				row[k] = img[i][j][xdim - 1 - k];
			write (fd_img, (char *) row, xdim * 2);
d211 3
a213 3
	hdr.dime.dim[1] = xdim;			 /* x dimension of atlas   */
	hdr.dime.dim[2] = ydim;			 /* y dimension of atlas   */
	hdr.dime.dim[3] = num_slices;		 /* number of slices in volume */
d224 3
a226 3
	hdr.dime.pixdim[1] = 10 * pixel_size;	 /* should be input for scanner  */
	hdr.dime.pixdim[2] = 10 * pixel_size;	 /* should be input for scanner  */
	hdr.dime.pixdim[3] = 10 * plane_separation;	/* z dimension of atlas   */
d242 1
a242 1
		exit (FAIL);
d251 1
a251 1
	fprintf (fd_if, "originating system := %s\n", model);
a254 1
	fprintf (fd_if, "original institution   := %s\n", institution);
d256 2
a257 2
	fprintf (fd_if, "subject ID	:= %s\n", subject_id);
	fprintf (fd_if, "study date := %s\n", study_date);
d262 6
a267 6
	fprintf (fd_if, "matrix size [1]    := %d\n", xdim);
	fprintf (fd_if, "matrix size [2]    := %d\n", ydim);
	fprintf (fd_if, "matrix size [3]    := %d\n", num_slices);
	fprintf (fd_if, "scaling factor (mm/pixel) [1]  := %f\n", 10 * pixel_size);
	fprintf (fd_if, "scaling factor (mm/pixel) [2]  := %f\n", 10 * pixel_size);
	fprintf (fd_if, "scaling factor (mm/pixel) [3]  := %f\n", 10 * plane_separation);
d272 4
a275 5
	if (zorigin > 0) {
		fprintf (fd_if, "atlas name := %s\n", atlas_name);
		fprintf (fd_if, "atlas origin [1] := %.2f\n", 0.5 * ((float) (xdim + 1)));
		fprintf (fd_if, "atlas origin [2] := %.2f\n", 0.5 * ((float) (ydim + 1)));
		fprintf (fd_if, "atlas origin [3] := %d\n", zorigin);
a282 4
	for (i = 0; i < num_slices; i++)
		free (subheader[i]);
	free (subheader);
	free (main_header);
d284 2
a285 2
	for (i = 0; i < num_slices; i++) {
		for (j = 0; j < ydim; j++)
a290 1
	close (fd_in);
d293 1
a293 1
	exit (0);
@


1.7
log
@added "atlas origin" and "atlas name" to ifh
@
text
@d1 1
a1 1
/*$Id: img2analyze.c,v 1.6 1994/11/29 22:20:03 tom Exp tom $*/
d3 3
d52 1
a52 1
static char     rcsid[] = "$Header: /export/home/npggw/tom/src/img2analyze/RCS/img2analyze.c,v 1.6 1994/11/29 22:20:03 tom Exp tom $";
d75 1
a75 1
	COMMENT_INFO    comment_info_data;	 /* comment field from ECAT header */
d88 1
a88 1
	char           *atlas_name = "Talariach 1988";
d113 1
d116 1
d120 1
@


1.6
log
@added to ifh header
@
text
@d1 1
a1 1
/*$Id: img2analyze.c,v 1.5 1994/11/28 23:08:27 tom Exp tom $*/
d3 3
d32 1
d49 1
a49 1
static char     rcsid[] = "$Header: /home/npggw/tom/src/img2analyze/RCS/img2analyze.c,v 1.5 1994/11/28 23:08:27 tom Exp tom $";
d72 1
d74 12
a85 11
	char           *ANALYZE_hdr;	 /* output Analyze header filename  */
	char           *ANALYZE_img;	 /* output Analyze image filename */
	char           *IF_hdr;		 	/* output Interfile Format header filename */
	char			*ptr;
    char            num[12];
    char            version[5];
    char            program_date[12];
    char            study_date[12];
    char            institution[MAXSTR];
    char            model[MAXSTR];
    char            subject_id[MAXSTR];
d87 1
d110 10
a119 10
    ptr = strstr (rcsid, "v ");
    ptr += 2;
    strncpy (version, ptr, 4);
    ptr = strstr (ptr, " ");
    ptr++;
    strncpy (program_date, ptr, 10);
    ptr = strchr (program_date, '/');
    *ptr = ':';
    ptr = strchr (program_date, '/');
    *ptr = ':';
a215 1

a225 1

d228 3
a230 3
    sprintf (model, "%d", main_header->system_type);
    strcpy (institution, main_header->facility_name);
    strcpy (subject_id, main_header->patient_id);
d232 7
a238 7
   	strcpy (study_date, num);
   	strcat (study_date, ":");
   	sprintf (num, "%d", main_header->scan_start_month);
   	strcat (study_date, num);
   	strcat (study_date, ":");
   	sprintf (num, "%d", main_header->scan_start_day);
   	strcat (study_date, num);
d240 3
d271 1
a271 1
				row[k] = img[i][j][xdim-1-k];
d310 3
a312 3
    strcpy (hdr.hist.originator, "img2analy");
    strncpy (hdr.hist.patient_id, version, 4);
    hdr.hist.orient = TRANSVERSE;
a317 1

d321 32
a352 26
 
    fprintf (fd_if, "INTERFILE :=\n");
    fprintf (fd_if, "version of keys    := 3.3\n");
    fprintf (fd_if, "image modality := pet\n");
    fprintf (fd_if, "originating system := %s\n", model);
    fprintf (fd_if, "conversion program := img2analyze\n");
    fprintf (fd_if, "program version    := %s\n", version);
    fprintf (fd_if, "program date   := %s\n", program_date);
    fprintf (fd_if, "original institution   := %s\n", institution);
    fprintf (fd_if, "name of data file  := %s\n", ANALYZE_img);
    fprintf (fd_if, "subject ID	:= %s\n", subject_id);
    fprintf (fd_if, "study date := %s\n", study_date);
 
    fprintf (fd_if, "number format  := signed integer\n");
    fprintf (fd_if, "number of bytes per pixel  := 2\n");
    fprintf (fd_if, "number of dimensions   := 3\n");
    fprintf (fd_if, "matrix size [1]    := %d\n", xdim);
    fprintf (fd_if, "matrix size [2]    := %d\n", ydim);
    fprintf (fd_if, "matrix size [3]    := %d\n", num_slices);
    fprintf (fd_if, "scaling factor (mm/pixel) [1]  := %f\n", 10 * pixel_size);
    fprintf (fd_if, "scaling factor (mm/pixel) [2]  := %f\n", 10 * pixel_size);
    fprintf (fd_if, "scaling factor (mm/pixel) [3]  := %f\n", 10 * plane_separation);
    fprintf (fd_if, "matrix initial element [1] := right\n");
    fprintf (fd_if, "matrix initial element [2] := posterior\n");
    fprintf (fd_if, "matrix initial element [3] := inferior\n");
 
@


1.5
log
@added Interfile Format header
@
text
@d1 1
a1 1
/*$Id: img2analyze.c,v 1.4 1994/11/21 19:02:51 tom Exp tom $*/
d3 3
d28 1
a28 1
 *		28-Nov-94 (TOV)	Create an Interfile Format header file.
d40 1
d45 1
a45 1
static char     rcsid[] = "$Header: /home/npggw/tom/src/img2analyze/RCS/img2analyze.c,v 1.4 1994/11/21 19:02:51 tom Exp tom $";
d77 3
a160 1
		matrix_close (fptr);
d221 14
a309 3
/*
 *	Study date
 */
a310 9
    sprintf (num, "%d", main_header->scan_start_year);
    strcpy (study_date, num);
    strcat (study_date, ":");
    sprintf (num, "%d", main_header->scan_start_month);
    strcat (study_date, num);
    strcat (study_date, ":");
    sprintf (num, "%d", main_header->scan_start_day);
    strcat (study_date, num);

d318 1
a318 1
    fprintf (fd_if, "originating system := %d\n", main_header->system_type);
d322 1
a322 1
    fprintf (fd_if, "original institution   := %s\n", main_header->facility_name);
d324 1
@


1.4
log
@flip x-axis for Analyze labels
@
text
@d1 1
a1 1
/*$Id: img2analyze.c,v 1.3 1994/04/08 20:57:48 tom Exp tom $*/
d3 3
d24 2
d37 3
a39 1
static char     rcsid[] = "$Header: /home/npggw/tom/src/img2analyze/RCS/img2analyze.c,v 1.3 1994/04/08 20:57:48 tom Exp tom $";
d41 2
d54 1
d66 7
a72 1
	char           *ANALYZE_img;		 /* output Analyze image filename */
d96 11
d112 2
a113 2
	if (argc != 4) {
		printf ("Usage: img2analyze PET_img ANALYZE_img ANALYZE_hdr\n");
d119 1
d129 4
d214 1
d282 3
d291 41
d351 1
@


1.3
log
@add full filename to descrip field
@
text
@d1 1
a1 1
/*$Id: img2analyze.c,v 1.2 1994/04/08 20:51:41 tom Exp tom $*/
d3 3
d13 3
a15 3
 *	Module:				img2analyze.c
 *	Date:					07-Apr-94
 *	Author:				Tom Videen
d17 4
a20 4
 *			Input images may be any format recognizable by getrealimg.
 *			Output images will be displayed by Analyze with left brain on the left
 *			and with the lower slices first.  This allows the 3D volume rendered
 *			brains to appear upright.
d29 2
a30 2
#include <petutil/petutil.h>		/* ROUND */
#include <petutil/ANALYZE.h>		/* dsr */
d32 1
a32 1
static char rcsid [] = "$Header: /home/petsun2/tom/src/img2analyze/RCS/img2analyze.c,v 1.2 1994/04/08 20:51:41 tom Exp tom $";
d37 1
a37 1
 */	
d39 2
a40 2
	int	argc;
	char	*argv[];
d43 5
a47 14
  struct dsr hdr; 					/* header for ANALYZE */
  FILE  *fd_hdr;  					/* file for ANALYZE hdr */	
	FILE  *fopen(); 					/* the fopen stuff  */
  int   fd_img;   					/* output ANALYZE image  */
	int		fd_in;							/* input PET image */
 
	struct Matval			matval;
	Image_subheader		**subheader;
	Main_header				*main_header;
	MatrixFile				*fptr;
	FILE							*listfp;
	char		*PET_img;					/* input PET image filename */
  char		*ANALYZE_hdr;  		/* output Analyze header filename  */
  char		*ANALYZE_img;  		/* output Analyze image filename */
d49 8
a56 12
	int			scanner;					/* 6 = PETT VI;  10 = 953B */
	int			dimension;				/*  xdim * ydim * num_slices */
  int			global_max; 			/* global maximum */
  int 		global_min; 			/* global minimum */
  int  		i, j, k, n;
 
	float		pixel_size;
	float		plane_separation;
	float		*image;						/* input PET image */
	short		***img;						/* output Analyze image */
	short		xdim, ydim;				/* pixel dimensions */
	short		num_slices;				/* number of slices */
d58 5
a62 1
	BOOLEAN	encoded_flag;
d64 7
a70 5
	matval.frame	= 1;				/* default values for matval */
	matval.plane	= 1;
	matval.gate		= 1;
	matval.data		= 0;
	matval.bed		= 0;
d72 8
d87 1
a87 1
		exit(FAIL);
d89 3
a91 3
	PET_img	= argv [1];
	ANALYZE_img	= argv [2];
	ANALYZE_hdr	= argv [3];
d93 8
a100 10
  if ((fd_hdr = fopen(ANALYZE_hdr,"w"))==0) {
    printf("Unable to create ANALYZE header %s\n",ANALYZE_hdr);
    exit(FAIL);
  }
 
  if ((fd_img = open(ANALYZE_img,O_CREAT|O_RDWR,0666)) == 0) {
    printf("Unable to create ANALYZE image %s\n",ANALYZE_img);
    exit(FAIL);
  }

d106 1
a106 1
	if (fd_in== -1) {
d118 1
a118 1
		if (fptr  == (MatrixFile *) NULL) {
d139 1
a139 1
		exit(FAIL);
d141 1
a141 1
  main_header = (Main_header *) calloc (1, sizeof (Main_header));
d144 1
a144 1
		exit(FAIL);
d146 1
a146 1
  subheader  = (Image_subheader **) calloc (num_slices * sizeof(caddr_t));
d149 1
a149 1
		exit(FAIL);
d151 20
a171 17
  if (NULL == (img = (short ***) malloc((short)(num_slices*sizeof(short **))))) {
    printf("Could not malloc memory for ***img\n");
    exit(FAIL);
  }
  for(i=0; i<num_slices; i++) {
    if (NULL == (img[i] = (short **) malloc((short)(ydim*sizeof(short *))))) {
      printf("Could not malloc memory for **img\n");
      exit(FAIL);
    }
    for(j=0; j<ydim; j++) {
      if (NULL == (img[i][j] = (short *)malloc((short)(xdim*sizeof(short))))) {
        printf("Could not malloc memory for *img\n");
        exit(FAIL);
      }
    }
  }

d177 2
a178 2
	if (getrealimg (PET_img, scanner, matval, xdim, ydim, num_slices, image, 
				main_header, subheader) == FAIL) {
a181 1

d183 1
a183 1
 * Convert from float to short, find min and max for hdr 
d189 4
a192 4
	for(i=0; i<num_slices; i++) {	
		for (j=0; j<ydim; j++) {
			for (k=0; k<xdim; k++) {
				img[i][j][k] = ROUND(image[n]);
d204 1
a204 1
 * Flip Y & Z, and write to output file
d207 6
a212 3
	for(i=num_slices-1; i >=0; i--) {	
		for (j=ydim-1; j>=0; j--)
			write(fd_img, (char *)img[i][j], xdim*2);
d219 30
a248 30
	strncpy(hdr.hk.db_name,PET_img,17);
  hdr.hk.sizeof_hdr = sizeof(struct dsr);         /* required by developers */
  hdr.hk.extents = 16384;                         /* recommended by developers  */
  hdr.hk.regular = 'r';                           /* required by developers */
  hdr.dime.dim[0] = 4;                            /* typically only 4 dimensions  */
  hdr.dime.dim[1] = xdim;                         /* x dimension of atlas   */
  hdr.dime.dim[2] = ydim;                         /* y dimension of atlas   */
  hdr.dime.dim[3] = num_slices;                   /* number of slices in volume */
  hdr.dime.dim[4] = 1;                            /* only one volume typically  */
  hdr.dime.unused8 = 0;														/* despite the label, some of this is used */
  hdr.dime.unused9 = 0;
  hdr.dime.unused10 = 0;
  hdr.dime.unused11 = 0;
  hdr.dime.unused12 = 0;
  hdr.dime.unused13 = 0;
  hdr.dime.unused14 = 0;
  hdr.dime.datatype = 4;                          /* 16 bit signed integer  */
  hdr.dime.bitpix = 16;                           /* number of bits/pixel */
  hdr.dime.pixdim[1] = 10 * pixel_size;           /* should be input for scanner  */
  hdr.dime.pixdim[2] = 10 * pixel_size;           /* should be input for scanner  */
  hdr.dime.pixdim[3] = 10 * plane_separation;     /* z dimension of atlas   */
  hdr.dime.funused8 = 0;
  hdr.dime.funused9 = 0;
  hdr.dime.funused10 = 0;
  hdr.dime.funused11 = 0;
  hdr.dime.funused12 = 0;
  hdr.dime.funused13 = 0;
  hdr.dime.glmax  = global_max;
  hdr.dime.glmin  = global_min;
  strncpy(hdr.hist.descrip,PET_img,79);
d250 3
a252 3
	if ((fwrite(&hdr, sizeof(struct dsr), 1, fd_hdr)) != 1) {
		printf("Error writing to: %s\n", ANALYZE_hdr);
		exit(FAIL);
a253 1

d259 1
a259 1
	printf("\nSuccessful conversion to %s\n", ANALYZE_img);
d261 1
a261 1
		free (subheader [i]);
d265 5
a269 5
  for(i=0; i<num_slices; i++) {
    for(j=0; j<ydim; j++)
      free (img[i][j]);
    free (img[i]);
  }
d271 4
a274 4
	close(fd_hdr);
	close(fd_in);
	close(fd_img);
	exit(0);
@


1.2
log
@mm to cm
@
text
@d1 1
a1 1
/*$Id: img2analyze.c,v 1.1 1994/04/08 20:31:20 tom Exp tom $*/
d3 3
d29 1
a29 1
static char rcsid [] = "$Header: /home/petsun2/tom/src/img2analyze/RCS/img2analyze.c,v 1.1 1994/04/08 20:31:20 tom Exp tom $";
d241 2
a242 1
 
@


1.1
log
@Initial revision
@
text
@d1 5
a5 2
/*$Id$*/
/*$Log$*/
d26 1
a26 1
static char rcsid [] = "$Header$";
d227 3
a229 3
  hdr.dime.pixdim[1] = pixel_size;                /* should be input for scanner  */
  hdr.dime.pixdim[2] = pixel_size;                /* should be input for scanner  */
  hdr.dime.pixdim[3] = plane_separation;          /* z dimension of atlas   */
@
