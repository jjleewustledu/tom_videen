head	1.2;
access;
symbols;
locks; strict;
comment	@ * @;


1.2
date	95.04.10.18.17.20;	author tom;	state Exp;
branches;
next	1.1;

1.1
date	95.04.10.17.44.06;	author tom;	state Exp;
branches;
next	;


desc
@original v6.5 from CTI
@


1.2
log
@initial 961 version
@
text
@/*
$Id$
$Log$
*/
/*  ===============================================================================
 *  Module:         do_bkproj.c
 *  Author:         CTI PET Systems, Inc
 *  Description:    Sun backprojection
 *  History:
 *      10-Apr-95   Version for 961 TOV with rcsid
 *  ===============================================================================
 */

static char     whatInfo[] = "@@(#) $Workfile:   do_bkproj.c  $ $Revision:   1.2  $ $Date:   03/28/95 10:31:32  $ Copyright (c) 1994 CTI PET Systems, Inc.";

#include <stdio.h>
#include <rpc/rpc.h>
#include <math.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/timeb.h>
#include "reconmgr.h"
#include "matrix.h"
#include "isotope_info.h"

#define	SCATTER 16
#define M_PI 3.14159265358979323846

static char     rcsid[] = "$Header$";

static int      recon_debug = 0;
static int      recon_echo = 1;
static int      ecat_model = -100;
static int      recon_arcor = 1;
static int      system_type = 0;
static int      recon_nprojs = -100;

do_bkproj (jobid, job, cs)
	int             jobid;
	QUE_JOB_DATA   *job;
	struct cstype  *cs;
{

	Main_header     mhead, nmain;
	Scan_subheader  shead;
	Norm_subheader  nsh;
	Attn_subheader  ash;
	Image_subheader ihead;

	short int      *scan = NULL, *scanp;
	int             dspflag, orient, decayflg, scatflg, arccorflg;
	int             err, frame, plane, gate, sino, bed, matnum, scatter_correction;
	int             sino_matnum, norm_matnum, attn_matnum;
	int             nprojs, nviews, i, j, size, TotalNumberOfViews = 0, MultFactor = 1;
	int             fcode, fft_size, fft_size2, fft_offset;
	int             debug = 0, isize, one, cs_size;

	long            maxfcb = 128;
	long            maxfft = 1024, f4096 = 4096;

	float           zoom, zoom_factor, xoff, yoff, rot, fparms[10], theta;
	float           x0, y0, irot, rx0, ry0;
	float          *norm = NULL, *attn = NULL, *corp1, *corp2;
	float           sino_scale, norm_scale, atten_scale, image_scale;
	float           decay_factor, dtcor, pixel_size, sf;
	float           frame_start, scan_duration, frame_duration, half_life, br;
	float           effective_radius;

	double          t0, t1, t2, t3, t4, t5, tickGet ();

	static float    w;
	static float   *x = NULL;

	double          cost, sint;
	double          exp (), log (), lt, ln2;

	char           *p, *index ();
	FILE           *fptr, *mat_create ();

	sino_matnum = norm_matnum = attn_matnum = 0;
	xoff = yoff = rot = 0.0;
	size = 128;
	decayflg = 0;
	scatflg = 0;
	arccorflg = recon_arcor;
	br = 1.0;
	scatter_correction = FALSE;
	norm_scale = atten_scale = decay_factor = scan_duration = 1.0;

	bzero ((char *) &ihead, sizeof (Image_subheader));
	sscanf (job->offs_spec, "%f,%f,%f,%d,%d,%d,%d,%d",
		&xoff, &yoff, &rot, &size, &decayflg, &debug, &scatflg, &arccorflg);
	debug = debug | recon_debug;

	if (debug) {
/*	  cs_size = xlsize_(cs) ; */
		printf ("Number of bytes available to user = %d\n", cs_size);
		printf ("scatter flag = %d\n", scatflg);
	}
	if (debug)
		printf ("scan: %s\n", job->scan_spec);
	if (debug)
		printf ("norm: %s\n", job->norm_spec);
	if (debug)
		printf ("attn: %s\n", job->attn_spec);
	if (debug)
		printf ("imag: %s\n", job->imag_spec);
	if (debug)
		printf ("zoom: %s\n", job->zoom_spec);
	if (debug)
		printf ("offs: %s\n", job->offs_spec);
	if (debug)
		printf ("filt: %s\n", job->filt_spec);
	t0 = tickGet ();

	err = read_matrix (job->scan_spec, &mhead, &shead, &scan, 1, &sino_matnum);
	if (err) {
		printf ("Error reading sinogram file %s\n", job->scan_spec);
		if (scan)
			free (scan);
		return (ERROR);
	}
	nprojs = shead.dimension_1;
	nviews = shead.dimension_2;
	sino_scale = shead.scale_factor;
	if (sino_scale <= 0.0)
		sino_scale = 1.0;
	dtcor = shead.loss_correction_fctr;
	if (dtcor < 1.0)
		dtcor = 1.0;
	frame_start = (float) (shead.frame_start_time / 1000);
	frame_duration = (float) (shead.frame_duration / 1000);
	scan_duration = (float) (shead.gate_duration / 1000);
	if (scan_duration <= 0.0) {
		scan_duration = frame_duration;
		if (scan_duration <= 0.0)
			scan_duration = 1.0;
	}
	/* get branching ratio if its not transmission scan */

	if (mhead.acquisition_type != 2) {
		j = 0;
		while (j < NumberOfIsotopes)
			if (strcmp (mhead.isotope_code, isotope_info[j].name) != 0)
				j++;
			else
				break;
		if (j < NumberOfIsotopes) {
			sscanf (isotope_info[j].branch_ratio, "%f", &br);
			half_life = isotope_info[j].hl;
		} else {

			/*
			 * Warn the user if the specified isotope in the main header  was not
			 * located in the isotope_info file.
			 */
			printf ("Warning: improper or missing value for isotope(#%2d) in the main header\n", j);
			if (decayflg) {
				decayflg = 0;
				printf ("Warning: decay correction has been turned off\n");
			}
		}

		if (debug) {
			printf ("half life = %f\n", half_life);
			printf ("branching ratio = %f\n", br);
			printf ("Decay Flag = %2d  Decay Factor = %f\n", decayflg, decay_factor);
		}
	} else
		arccorflg = 0;

	if (debug) {
		printf ("arccor flg = %d\n", arccorflg);
		printf ("sample_size = %f\n", shead.sample_distance);
		printf ("scan has %d views of %d projections\n", nviews, nprojs);
	}
	if (strcmp (job->norm_spec, "") != 0) {
		err = read_matrix (job->norm_spec, &nmain, &nsh, &norm, 4, &norm_matnum);
		if (err) {
			printf ("Error opening norm file %s\n", job->norm_spec);
			if (scan)
				free (scan);
			if (norm)
				free (norm);
			return (ERROR);
		} else if (norm == NULL) {
			printf ("Error reading data from norm file %s\n", job->norm_spec);
			return (ERROR);
		} else {
			norm_scale = nsh.scale_factor;
			if (norm_scale <= 0.0)
				norm_scale = 1.0;
			if (debug)
				printf ("norm consists of %d views of %d projections\n",
					nsh.dimension_2, nsh.dimension_1);
		}
	}
	if (strcmp (job->attn_spec, "") != 0) {
		err = read_matrix (job->attn_spec, NULL, &ash, &attn, 3, &attn_matnum);
		if (err) {
			printf ("Error opening attn file %s\n", job->attn_spec);
			if (scan)
				free (scan);
			if (norm)
				free (norm);
			if (attn)
				free (attn);
			return (ERROR);
		} else if (attn == NULL) {
			printf ("Error reading attenuation file %s\n", job->attn_spec);
			return (ERROR);
		} else {
			atten_scale = ash.scale_factor;
			if (atten_scale <= 0.0)
				atten_scale = 1.0;
			if (debug)
				printf ("attn consists of %d views of %d projections\n",
					ash.dimension_2, ash.dimension_1);
		}
	}
	if (debug == 3)
		for (i = 0; i < nprojs; i++) {
			if (norm && attn)
				printf ("%3d %7d %6.4f %6.4f\n",
					i, (int) scan[i], norm[i], attn[i]);
			else if (norm)
				printf ("%3d %7d %6.4f\n", i, (int) scan[i], norm[i]);
			else if (attn)
				printf ("%3d %7d %6.4f\n", i, (int) scan[i], attn[i]);
		}

	if (decayflg) {
		if (half_life > 0) {
			ln2 = log (2.0);
			if (shead.gate_duration <= 0.0) {
				lt = scan_duration * ln2 / half_life;
				decay_factor = exp (frame_start * ln2 / half_life) / (1 - lt / 2.0
										   + lt * lt / 6.0
									     - lt * lt * lt / 24.0
								       + lt * lt * lt * lt / 120.0
								- lt * lt * lt * lt * lt / 720.0);
			} else {
				decay_factor = 1.0;

				lt = frame_duration * ln2 / half_life;
				decay_factor /= 1 - lt / 2.0 + lt * lt / 6.0 - lt * lt * lt / 24.0
					+ lt * lt * lt * lt / 120.0 - lt * lt * lt * lt * lt / 720.0;
				lt = (scan_duration / mhead.collimator) * ln2 / half_life;
				decay_factor /= 1 - lt / 2.0 + lt * lt / 6.0 - lt * lt * lt / 24.0
					+ lt * lt * lt * lt / 120.0 - lt * lt * lt * lt * lt / 720.0;
			}
		}
	}
	t1 = tickGet () - t0;
	zoom = 1.0;
	dspflag = 0;
	orient = 1;
	sscanf (job->zoom_spec, "%f,%d,%d", &zoom, &dspflag, &orient);
	if (zoom <= 0.5)
		zoom = 1.0;
	if (size < 32)
		size = 32;
	pixel_size = shead.sample_distance * (float) nprojs / ((float) size * zoom);
	if (debug)
		printf ("pixel_size = %6.4f\n", pixel_size);

	fcode = 0;
	for (i = 0; i < 10; i++)
		fparms[i] = 0.0;
	sscanf (job->filt_spec, "%d,%f,%f,%f,%f,%f,%f,%f", &fcode,
		&fparms[0], &fparms[1], &fparms[2], &fparms[3], &fparms[4],
		&fparms[5], &fparms[6]);
	fparms[1] = 0.1667;			 /* no dc shift */

/*	modified ramp is used by default */

	if (fcode = 1)
		fcode = -fcode;

	if (fcode < 0)
		fparms[1] = 0.0;		 /* no dc shift for modified ramp */
	if (debug)
		printf ("fparms = %f %f %f %f %f %f %f\n", fparms[0], fparms[1],
			fparms[2], fparms[3], fparms[4], fparms[5], fparms[6]);

	if (fparms[4] != 0.0 && fparms[5] != 0.0 && scatflg == 1)
		scatter_correction = TRUE;

	if (arccorflg) {
		switch (mhead.system_type) {
		case 931:
		case 951:
		case 933:
		case 953:
		case 921:
		case 831:
		case 961:
			system_type = mhead.system_type;
			break;
		default:
			break;
		}				 /* End switch mhead.system_type */

		MultFactor = ((int) mhead.compression_code) ?
			(int) mhead.compression_code * 2 : 1;
		TotalNumberOfViews = nviews * MultFactor;

		if (debug == 1) {
			printf ("geometric arc correction invoked !\n");
			printf ("mhead system type = %d\n", mhead.system_type);
			printf ("system type = %d\n", system_type);
			printf ("ecat model = %d\n", ecat_model);
			printf ("compression code = %3d\n", mhead.compression_code);
			printf ("total views = %d\n", TotalNumberOfViews);
		}
		if (ecat_model != system_type || recon_nprojs != nprojs) {
			if (x != NULL)
				free (x);
			x = (float *) malloc (nprojs * sizeof (float));
			switch (system_type) {
			case 961:
				effective_radius = 82.46 / 2 + 1;
				break;
			case 931:
			case 951:
				effective_radius = 102.0 / 2 + 1;
				break;
			case 933:
			case 953:
				effective_radius = 76.0 / 2 + 1;
				break;
			case 921:
				effective_radius = 82.0 / 2 + 1;
				break;
			case 831:
				effective_radius = 64.0 / 2 + 1;
				break;
			default:
				arccorflg = 0;
				printf ("bkproj: unable to do arc correction\n");
				printf ("incompatable ecat model type : %d\n",
					system_type);
				break;
			}			 /* End switch system_type */

			if (arccorflg) {
				w = shead.sample_distance *
					TotalNumberOfViews * 2 / M_PI / effective_radius;
				if (debug == 1) {
					printf ("w = %f\n", w);
					printf ("model = %d, radius = %f\n", system_type, effective_radius);
				}
				for (i = 0; i < nprojs; i++)
					x[i] = nprojs / 2 + effective_radius *
						sin (M_PI * (i - nprojs / 2) / 2 / TotalNumberOfViews) /
						shead.sample_distance;

				cs->nprojs = nprojs;
				for (i = 0; i < nprojs; i++) {
					cs->o[i] = (int) x[i];
					cs->f1[i] = x[i] - cs->o[i];
					cs->f2[i] = 1.0 - cs->f1[i];
				}
				cs->f2[nprojs / 2] = w;
				ecat_model = system_type;	/* save for next job */
				recon_nprojs = nprojs;
			}			 /* End if arccorflg */
		}				 /* End if ecat_model != system_type */
	}					 /* End if arccorflg */
	if (debug == 1)
		printf ("nprojs/2, cs->f2[nprojs/2] : %d %f\n",
			nprojs / 2, cs->f2[nprojs / 2]);


	isize = size * size;
	one = 1;
	xvclr_ (cs->image, &isize, &one);
	fft_size = 512;
	while (fft_size < 2 * nprojs)
		fft_size *= 2;
	fft_offset = (fft_size - nprojs) / 2;
	fft_size2 = fft_size / 2;
	if (scatter_correction) {
		if (fparms[6] == 0.0)
			fparms[6] = shead.sample_distance;
		makefilter (fft_size, cs->scatter_bufr, SCATTER, fparms, cs->tramp,
			    &cs->temp_bufr[0]);
		if (debug) {
			printf ("scatter fraction = %f\n", fparms[4]);
			printf ("scatter slope (1/cm) = %f\n", fparms[5]);
			printf ("spacing in cm = %f\n", fparms[6]);
		}
	}
	if (debug)
		printf ("fcode=%d, fparms[0]=%f\n", fcode, fparms[0]);

	if (fcode != 0) {
		if (debug)
			printf ("making recon filter...\n");
		makefilter (fft_size, cs->filter_bufr, fcode, fparms, cs->tramp, &cs->temp_bufr_1[0]);
	}
	cs->size = size;
	xldone_ (cs);
	fflush (stdout);

	for (i = 0; i < fft_size; i++)
		cs->proj[i] = 0.0;
	cs->fone = 1.0;
	scanp = scan;
	corp1 = norm;
	corp2 = attn;

	/* Correction for intrinsic tilt */
	irot = 0.0;
	if ((nviews % 96) == 0)
		irot = -15.0;
	if ((nviews % 98) == 0)
		irot = -12.86;
/*	sincos( M_PI*rot/180.0, &sint, &cost) ; */
	sint = sin (M_PI * rot / 180.0);
	cost = cos (M_PI * rot / 180.0);
	x0 = xoff * cost + yoff * sint;
	y0 = -xoff * sint + yoff * cost;
	if (debug) {
		printf ("rot angle = %f, cos = %f, sin = %f\n", rot, cost, sint);
		printf ("xoff = %f, yoff = %f\n", x0, y0);
	}
	t2 = tickGet () - t0;

	/* beginning of backprojection loop for all view angles */

	for (i = 0; i < nviews; i++) {
		theta = M_PI * (rot + irot) / 180.;
/*	  sincos( theta + M_PI * i/nviews, &sint, &cost);  */
		sint = sin (theta + M_PI * i / nviews);
		cost = cos (theta + M_PI * i / nviews);

		/*
		 * Synchronize the host and the SuperCard so that the needed values have been
		 * calculated by the SuperCard and are ready to be used by the host program.
		 */

		if (fcode != 0) {
			for (j = 0; j < fft_size; j++)
				cs->temp_bufr[j] = 0.0;
			if (scatter_correction) {
				if (corp1)
					for (j = 0; j < nprojs; j++)
						cs->temp_bufr[j + fft_offset] = (float) *scanp++ * (*corp1++);
				else
					for (j = 0; j < nprojs; j++)
						cs->temp_bufr[j + fft_offset] = (float) *scanp++;
				sf = (float) ((1.0 - fparms[4]) / (2.0 * fft_size));
				xfrf_ (cs->fft_bufr, &cs->ra_temp, cs->temp_bufr, &fft_size2);
				xcvmls_ (cs->fft_bufr, &cs->fone, cs->fft_bufr,
					 cs->scatter_bufr, &fft_size2);
				xldone_ (cs);
				cs->ra_temp = cs->ra_temp * cs->scatter_bufr[1];
				xfri_ (cs->temp_bufr, &cs->ra_temp, cs->fft_bufr,
				       cs->proj, &fft_size2);
				xvsml_ (cs->temp_bufr, &sf, &fft_size);
				xldone_ (cs);
				if (corp2)
					for (j = 0; j < nprojs; j++)
						cs->temp_bufr[j + fft_offset] *= *corp2++;
			} else {		 /* if no scatter correction */
				if (corp1 && corp2)
					for (j = 0; j < nprojs; j++)
						cs->temp_bufr[j + fft_offset] =
							(float) *scanp++ * (*corp1++) * (*corp2++);
				else if (corp1)
					for (j = 0; j < nprojs; j++)
						cs->temp_bufr[j + fft_offset] = (float) *scanp++ * (*corp1++);
				else if (corp2)
					for (j = 0; j < nprojs; j++)
						cs->temp_bufr[j + fft_offset] = (float) *scanp++ * (*corp2++);
				else
					for (j = 0; j < nprojs; j++)
						cs->temp_bufr[j + fft_offset] = (float) *scanp++;
			}

			if (arccorflg) {
				xvclr_ (cs->temp_bufr_1, &f4096, &one);
				arc_correct (cs->nprojs, &cs->temp_bufr[fft_offset],
					     &cs->temp_bufr_1[fft_offset], cs->o, cs->f1, cs->f2);
				xldone_ (cs);
			} else {
				xldone_ (cs);
				xvmov_ (cs->temp_bufr_1, cs->temp_bufr, &f4096, &one, &one);
			}

			xfrf_ (cs->fft_bufr, &cs->ra_temp, cs->temp_bufr_1, &fft_size2);
			xcvmls_ (cs->fft_bufr, &cs->fone,
				 cs->fft_bufr, cs->filter_bufr, &fft_size2);
			cs->ra_temp = cs->ra_temp * cs->filter_bufr[1];
			xfri_ (cs->proj, &cs->ra_temp, cs->fft_bufr,
			       cs->temp_bufr, &fft_size2);
		} else {			 /* if (fcode == 0)  */
			xldone_ (&cs->r0);
			for (j = 0; j < fft_size; j++)
				cs->proj[j] = 0.0;
			for (j = 0; j < nprojs; j++)
				cs->proj[j + fft_offset] = (float) *scanp++;
		}
		xldone_ (cs);
		zoom_factor = (float) nprojs / (float) size / zoom;
		cs->rdx = cost * zoom_factor;
		cs->rdy = sint * zoom_factor;
		rx0 = (float) size / 2 - x0 / pixel_size;
		ry0 = (float) size / 2 + y0 / pixel_size;
		cs->r0 = (float) fft_size2 - rx0 * cs->rdx - ry0 * cs->rdy;
		if (debug == 2)
			printf ("%3d %6.2f %6.2f %6.2f\n", i, cs->r0, cs->rdx, cs->rdy);
		bkproj_view (cs->proj, cs->r0, cs->rdx, cs->rdy, cs->image, cs->size);
	}

/*    Synchronize the host and the Supercard after falling through the loop.  */

	xldone_ (&cs->r0);
	if (strcmp (job->imag_spec, "") != 0) {
		t3 = tickGet () - t0;
		cs->c32767 = 32767.;
		cs->zero = 0.0;
		cs->image[0] = 0.0;
		xrmn_ (&cs->image_min, cs->image, &isize);
		xrmx_ (&cs->image_max, cs->image, &isize);
		xsdiv_ (&cs->scalef, &cs->c32767, &cs->image_max);
		xvfx4_ (cs->imagei, &cs->scalef, cs->image, &cs->zero, &isize);
		xldone_ (cs);
		if (debug)
			printf ("cs->image_min = %f\n", cs->image_min);
		if (debug)
			printf ("cs->image_max = %f\n", cs->image_max);
		if (debug)
			printf ("cs->scalef    = %f\n", cs->scalef);

		for (i = 0; i < size * size; i++)
			cs->imagei2[i] = cs->imagei[i];
		t4 = tickGet () - t0;
		sino_scale = sino_scale * dtcor * decay_factor / scan_duration;
		image_scale = cs->image_max * 3.14159 / 32767. / nviews / 2 / fft_size;
		image_scale = image_scale * sino_scale * norm_scale * atten_scale;
		mhead.file_type = 2;
		mhead.data_type = 2;
		mhead.calibration_units = nmain.calibration_units;
		ihead.data_type = 2;
		ihead.num_dimensions = 2;
		ihead.dimension_1 = ihead.dimension_2 = size;
		ihead.x_origin = xoff;
		ihead.y_origin = yoff;
		ihead.quant_scale = image_scale;
		ihead.image_min = 0;
		ihead.image_max = 32767;
		ihead.slice_width = mhead.plane_separation;
		ihead.filter_code = fcode;
		ihead.frame_start_time = shead.frame_start_time;
		ihead.frame_duration = shead.frame_duration;
		ihead.gate_duration = shead.gate_duration;
		ihead.quant_units = 2;
		ihead.scan_matrix_num = sino_matnum;
		ihead.norm_matrix_num = norm_matnum;
		ihead.atten_cor_matrix_num = attn_matnum;
		ihead.plane_eff_corr_fctr = norm_scale;
		ihead.decay_corr_fctr = decay_factor;
		ihead.loss_corr_fctr = dtcor;
		ihead.image_rotation = rot;
		ihead.intrinsic_tilt = irot;
		ihead.processing_code = 0;
		if (norm && nsh.ecat_calib_factor > 0.0)
			ihead.ecat_calibration_fctr = nsh.ecat_calib_factor / br;
		else
			ihead.ecat_calibration_fctr = 1.0;
		for (i = 0; i < 6; i++)
			ihead.filter_params[i] = fparms[i];
		ihead.pixel_size = pixel_size;
		if (ihead.pixel_size <= 0.0)
			ihead.pixel_size = 1.0;
		ihead.recon_scale = zoom;
		ihead.well_counter_cal_fctr = 1.0;
		strcpy (ihead.annotation, "ACS reconstruction with new AP");
		p = index (job->imag_spec, ',');
		*p++ = '\0';
		if (debug)
			printf ("Saving data into image file...\n");
		fptr = mat_open (job->imag_spec, "r+");
		if (!fptr)
			fptr = mat_create (job->imag_spec, &mhead);
		frame = plane = gate = sino = bed = 0;
		sscanf (p, "%d,%d,%d,%d,%d", &frame, &plane,
			&gate, &sino, &bed);
		*(--p) = ',';
		matnum = mat_numcod (frame, plane, gate, sino, bed);
		mat_write_image (fptr, matnum, &ihead, cs->imagei2, size * size * 2);
		mat_close (fptr);
		free (scan);
		if (norm)
			free (norm);
		if (attn)
			free (attn);
		t5 = tickGet () - t0;
		if (debug)
			printf ("bkproj: job %10d, %3d, %3d %6.3f,%6.3f,%6.3f,%6.3f,%6.3f = %6.3f sec.\n\n", jobid, size, nviews,
				t1 / 60., (t2 - t1) / 60., (t3 - t2) / 60., (t4 - t3) / 60., (t5 - t4) / 60., t5 / 60.);
		else if (recon_echo)
			printf (" (%d %4.1f)", jobid, t5 / 60.);
	}
	fflush (stdout);
	return OK;
}

#define ERROR_NOFILE -1
#define ERROR_NOMATNUM -2
#define ERROR_NOMATRIX -3
#define ERROR_WRONG_FTYPE -4

read_matrix (matspec, mhptr, shptr, dptr, ftype, ret_matnum)
	char           *matspec;
	Main_header    *mhptr;
	caddr_t         shptr, *dptr;
	int             ftype, *ret_matnum;
{
	char            tempstr[256], *p, *index ();
	FILE           *fptr;
	Main_header     mhead;
	int             mf, mp, mg, md, mb, matnum, nblks;
	struct MatDir   entry;

	strncpy (tempstr, matspec, 255);
	p = index (tempstr, ',');
	if (!p)
		return (ERROR_NOMATNUM);
	*p++ = '\0';
	fptr = mat_open (tempstr, "r");
	if (!fptr)
		return (ERROR_NOFILE);
	if (!mhptr)
		mhptr = &mhead;
	mat_read_main_header (fptr, mhptr);
	if (mhptr->file_type != ftype) {
		mat_close (fptr);
		printf ("read_matrix: ERROR wrong file type for %s, type was %d, requested type %d\n",
			tempstr, mhptr->file_type, ftype);
		return (ERROR_WRONG_FTYPE);
	}
	mf = mp = mg = md = mb = 0;
	sscanf (p, "%d,%d,%d,%d,%d", &mf, &mp, &mg, &md, &mb);
	matnum = mat_numcod (mf, mp, mg, md, mb);
	*ret_matnum = matnum;
	if (recon_debug)
		printf ("do_bkproj:read_matrix: ret_matnum = %x\n", *ret_matnum);
	if (!mat_lookup (fptr, matnum, &entry)) {
		mat_close (fptr);
		return (ERROR_NOMATRIX);
	}
	nblks = entry.endblk - entry.strtblk;
	if (dptr)
		*dptr = (caddr_t) malloc (512 * nblks);
	if (shptr)
		switch (mhptr->file_type) {
		case 1:
			mat_read_scan_subheader (fptr, entry.strtblk, shptr);
			if (dptr && &dptr)
				read_matrix_data (fptr, entry.strtblk + 1, nblks, *dptr,
						  ((Scan_subheader *) shptr)->data_type);
			break;
		case 2:
			mat_read_image_subheader (fptr, entry.strtblk, shptr);
			if (dptr && &dptr)
				read_matrix_data (fptr, entry.strtblk + 1, nblks, *dptr,
						  ((Image_subheader *) shptr)->data_type);
			break;
		case 3:
			mat_read_attn_subheader (fptr, entry.strtblk, shptr);
			if (dptr && &dptr)
				read_matrix_data (fptr, entry.strtblk + 1, nblks, *dptr,
						  ((Attn_subheader *) shptr)->data_type);
			break;
		case 4:
			mat_read_norm_subheader (fptr, entry.strtblk, shptr);
			if (dptr && &dptr)
				read_matrix_data (fptr, entry.strtblk + 1, nblks, *dptr,
						  ((Norm_subheader *) shptr)->data_type);
			break;
		}
	mat_close (fptr);
	return (OK);
}


bkproj_view (proj, r0, rdx, rdy, image, size)
	float          *proj, *image;
	float           r0, rdx, rdy;
	int             size;
{
	int             x, y, j;
	double          r, w;

	for (y = 0; y < size; y++) {
		r = r0;
		for (x = 0; x < size; x++) {
			j = (int) r;
			w = r - j;
			(*image++) += (1.0 - w) * proj[j] + w * proj[j + 1];
			r += rdx;
		}
		r0 += rdy;
	}
}

arc_correct (nprojs, scan_in, scan_out, o, f1, f2)
	int             nprojs, *o;
	float          *scan_in, *scan_out, *f1, *f2;
{
	int             i, *otemp;
	float          *f1temp, *f2temp, *in;

	otemp = o;
	f1temp = f1;
	f2temp = f2;
	in = scan_in;
	for (i = 0; i < nprojs; i++) {
		scan_out[*otemp] += *in * (*f2temp++);
		scan_out[*otemp + 1] += *in * (*f1temp++);
		otemp++;
		in++;
	}
}


double          tickGet ()
{
	double          t0 = 0.0, m0 = 0.0;
	struct timeb    tp;

	ftime (&tp);
	t0 = (double) tp.time;
	m0 = (double) tp.millitm;

	t0 = t0 + m0 / 1000.0;
	return (t0 * 60.0);
}


xldone_ (ptr)
	float          *ptr;
{
	return;
}
@


1.1
log
@Initial revision
@
text
@d1 12
a12 4
/* $Revision:   1.2  $ $Date:   03/28/95 10:31:32  $                                            */
/* Copyright (c) 1993 CTI PET Systems, Inc.                     */
 
static char whatInfo[] = "@@(#) $Workfile:   do_bkproj.c  $ $Revision:   1.2  $ $Date:   03/28/95 10:31:32  $ Copyright (c) 1994 CTI PET Systems, Inc.";
d14 2
a18 3
#include <reconmgr.h>
#include <matrix.h>
#include "isotope_info.h"
d22 4
a25 1
 
d29 1
a29 6
static int recon_debug = 0 ;
static int recon_echo = 1 ;
static int ecat_model = -100 ;
static int recon_arcor = 1 ;
static int system_type = 0 ;
static int recon_nprojs = -100 ;
d31 11
a41 4
do_bkproj( jobid, job, cs)
  int jobid;
  QUE_JOB_DATA *job;
  struct cstype *cs;
d44 4
a47 4
	Main_header mhead, nmain;
	Scan_subheader shead;
	Norm_subheader nsh;
	Attn_subheader ash;
d50 7
a56 7
	short int *scan=NULL, *scanp;
	int 	dspflag, orient, decayflg, scatflg, arccorflg;
	int 	err, frame, plane, gate, sino, bed, matnum, scatter_correction;
	int 	sino_matnum, norm_matnum, attn_matnum ;
	int 	nprojs, nviews, i, j, size, TotalNumberOfViews=0, MultFactor=1;
	int 	fcode, fft_size, fft_size2, fft_offset;
	int 	debug=0, isize, one, cs_size ;
d58 2
a59 2
        long 	maxfcb = 128;
        long 	maxfft = 1024, f4096 = 4096 ;
d61 7
a67 7
	float 	zoom, zoom_factor, xoff, yoff, rot, fparms[10], theta;
	float 	x0, y0, irot, rx0, ry0 ;
	float 	*norm=NULL, *attn=NULL, *corp1, *corp2;
	float	sino_scale, norm_scale, atten_scale, image_scale ;
	float	decay_factor, dtcor, pixel_size, sf ;
	float	frame_start, scan_duration, frame_duration, half_life, br ;
	float	effective_radius ;
d69 1
a69 1
	double 	t0, t1, t2, t3, t4, t5, tickGet();
d71 2
a72 2
	static float w ;
	static float *x=NULL ;
d74 2
a75 2
	double 	cost, sint;
	double	exp(), log(), lt, ln2 ;
d77 2
a78 2
	char *p, *index();
	FILE *fptr, *mat_create();
d80 1
a80 1
	sino_matnum = norm_matnum = attn_matnum = 0 ;
d85 1
a85 1
	arccorflg = recon_arcor ;
d88 1
a88 1
	norm_scale=atten_scale=decay_factor=scan_duration=1.0 ;
d90 4
a93 4
	bzero((char *) &ihead, sizeof(Image_subheader)) ;
	sscanf( job->offs_spec, "%f,%f,%f,%d,%d,%d,%d,%d",
		&xoff, &yoff, &rot, &size, &decayflg, &debug, &scatflg, &arccorflg) ;
	debug = debug | recon_debug ;
d95 1
a95 2
	if (debug)
	{
d97 2
a98 2
	  printf("Number of bytes available to user = %d\n", cs_size) ;
	  printf("scatter flag = %d\n", scatflg) ;
d100 15
a114 8
	if (debug) printf("scan: %s\n", job->scan_spec);
	if (debug) printf("norm: %s\n", job->norm_spec);
	if (debug) printf("attn: %s\n", job->attn_spec);
	if (debug) printf("imag: %s\n", job->imag_spec);
	if (debug) printf("zoom: %s\n", job->zoom_spec);
	if (debug) printf("offs: %s\n", job->offs_spec);
	if (debug) printf("filt: %s\n", job->filt_spec);
	t0 = tickGet();
d116 6
a121 6
	err = read_matrix( job->scan_spec, &mhead, &shead, &scan, 1, &sino_matnum);
	if (err)
	{
	    printf("Error reading sinogram file %s\n", job->scan_spec) ;
	    if (scan) free(scan) ;
	    return (ERROR);
d125 14
a138 13
	sino_scale = shead.scale_factor ;
	if (sino_scale <= 0.0) sino_scale = 1.0 ;
	dtcor = shead.loss_correction_fctr ;
	if (dtcor < 1.0) dtcor = 1.0 ;
	frame_start =  (float) (shead.frame_start_time/1000) ;
        frame_duration = (float) (shead.frame_duration/1000);
        scan_duration = (float) (shead.gate_duration/1000);
        if (scan_duration <= 0.0) {
	   scan_duration = frame_duration;
	   if (scan_duration <= 0.0) 
              scan_duration = 1.0 ;
        }

d141 11
a151 22
	if (mhead.acquisition_type != 2)
	{
	  j = 0 ;
	  while (j < NumberOfIsotopes) 
             if (strcmp(mhead.isotope_code, isotope_info[j].name) != 0)
                j++ ;
             else
                break;
	  if ( j < NumberOfIsotopes)
	  {
	    sscanf(isotope_info[j].branch_ratio, "%f", &br) ;
	    half_life = isotope_info[j].hl ;
	  }
	  else {
	     /* Warn the user if the specified isotope in the main header  
              * was not located in the isotope_info file. */
	     printf ("Warning: improper or missing value for isotope(#%2d) in the main header\n", j);
             if (decayflg) {
                decayflg = 0;
                printf ("Warning: decay correction has been turned off\n");
             }
          }
d153 10
a162 8
	  if (debug) {
	     printf("half life = %f\n", half_life) ;
	     printf("branching ratio = %f\n", br) ;
	     printf("Decay Flag = %2d  Decay Factor = %f\n", decayflg, decay_factor);
          }
	}
	else
	   arccorflg = 0 ;
d164 7
a170 6
	if (debug)
	{
	    printf("arccor flg = %d\n", arccorflg) ;
	    printf("sample_size = %f\n", shead.sample_distance);
	    printf("scan has %d views of %d projections\n", nviews, nprojs);
	}
d172 4
a175 22
	if (strcmp(job->norm_spec, "") != 0)
	{
	  err = read_matrix(job->norm_spec, &nmain, &nsh, &norm, 4, &norm_matnum);
	  if (err)
	  {
	    printf("Error opening norm file %s\n", job->norm_spec) ;
	    if (scan) free(scan) ;
	    if (norm) free(norm) ;
	    return(ERROR) ;
	  }
	  else if (norm == NULL)
	  {
	    printf("Error reading data from norm file %s\n", job->norm_spec);
	    return(ERROR) ;
	  }
	  else
	  {
	    norm_scale = nsh.scale_factor ;
	    if (norm_scale <= 0.0) norm_scale = 1.0 ;
	    if (debug) printf("norm consists of %d views of %d projections\n",
				nsh.dimension_2, nsh.dimension_1) ;
	  }
d177 20
a196 24

	if (strcmp(job->attn_spec, "") != 0)
	{
	  err = read_matrix( job->attn_spec, NULL, &ash, &attn, 3, &attn_matnum);
	  if (err)
	  {
	    printf("Error opening attn file %s\n", job->attn_spec) ;
	    if (scan) free(scan) ;
	    if (norm) free(norm) ;
	    if (attn) free(attn) ;
	    return(ERROR) ;
	  }
	  else if (attn == NULL)
	  {
	    printf("Error reading attenuation file %s\n", job->attn_spec);
	    return(ERROR) ;
	  }
	  else
	  {
	    atten_scale = ash.scale_factor ;
	    if (atten_scale <= 0.0) atten_scale = 1.0 ;
	    if (debug) printf("attn consists of %d views of %d projections\n",
				ash.dimension_2, ash.dimension_1);
	  }
d198 22
a219 7

	if (debug==3) for (i=0; i<nprojs; i++)
	{
	  if (norm && attn) printf("%3d %7d %6.4f %6.4f\n",
				i, (int) scan[i], norm[i], attn[i]);
	  else if (norm) printf("%3d %7d %6.4f\n", i, (int) scan[i], norm[i]);
	  else if (attn) printf("%3d %7d %6.4f\n", i, (int) scan[i], attn[i]);
d221 10
d232 12
a243 15
	if (decayflg)
	{
	  if (half_life > 0)
	  {
	    ln2 = log(2.0) ;
            if (shead.gate_duration <= 0.0) {
	       lt = scan_duration * ln2/half_life ;
	       decay_factor = exp(frame_start*ln2/half_life)/(1-lt/2.0
				+lt*lt/6.0
				-lt*lt*lt/24.0
				+lt*lt*lt*lt/120.0 
				-lt*lt*lt*lt*lt/720.0) ;
            }
            else {
               decay_factor = 1.0;
d245 10
a254 11
	       lt = frame_duration * ln2/half_life ;
               decay_factor /= 1 - lt/2.0 + lt*lt/6.0 - lt*lt*lt/24.0
				 + lt*lt*lt*lt/120.0 - lt*lt*lt*lt*lt/720.0 ;
               lt = (scan_duration/mhead.collimator) * ln2/half_life;
               decay_factor /= 1 - lt/2.0 + lt*lt/6.0 - lt*lt*lt/24.0
				 + lt*lt*lt*lt/120.0 - lt*lt*lt*lt*lt/720.0 ;
            }
	  }
	}	    

	t1 = tickGet()-t0;
d258 8
a265 5
	sscanf( job->zoom_spec, "%f,%d,%d", &zoom, &dspflag, &orient);
	if (zoom <= 0.5) zoom = 1.0;
	if (size < 32) size = 32;
	pixel_size = shead.sample_distance*(float)nprojs/((float)size*zoom) ;
	if (debug) printf("pixel_size = %6.4f\n", pixel_size);
d268 6
a273 5
	for (i=0; i<10; i++) fparms[i] = 0.0;
	sscanf( job->filt_spec, "%d,%f,%f,%f,%f,%f,%f,%f", &fcode,
	  &fparms[0], &fparms[1], &fparms[2], &fparms[3], &fparms[4],
	  &fparms[5], &fparms[6]);
	fparms[1] = 0.1667 ;   		/* no dc shift */
a275 1
	fcode = -fcode ; 
d277 5
a281 1
	if (fcode < 0) fparms[1] = 0.0 ;   /* no dc shift for modified ramp */
d283 2
a284 2
	   printf("fparms = %f %f %f %f %f %f %f\n", fparms[0], fparms[1],
	   fparms[2], fparms[3], fparms[4], fparms[5], fparms[6]) ;
d287 1
a287 1
		scatter_correction = TRUE ;
d289 2
a290 4
	if (arccorflg)
	{
	    switch (mhead.system_type)
	    {
d298 2
a299 2
			system_type = mhead.system_type ;
			break ;
d301 2
a302 2
			break ;
	    } /* End switch mhead.system_type */
d304 3
a306 3
            MultFactor = ((int) mhead.compression_code) ? 
                                  (int) mhead.compression_code * 2 : 1;
            TotalNumberOfViews = nviews * MultFactor;
d308 34
a341 37
	    if (debug == 1)
	    {
		printf("geometric arc correction invoked !\n") ;
		printf("mhead system type = %d\n", mhead.system_type) ;
		printf("system type = %d\n", system_type) ;
		printf("ecat model = %d\n", ecat_model) ;
                printf("compression code = %3d\n", mhead.compression_code);
                printf("total views = %d\n", TotalNumberOfViews);
	    }

	    if (ecat_model != system_type || recon_nprojs != nprojs)
	    {
		if (x != NULL) free(x) ;
		x = (float *) malloc(nprojs*sizeof(float)) ;
		switch (system_type)
		{
		   case 961 :
			effective_radius = 82.46/2 + 1;
			break;
		   case 931 :
		   case 951 :
			effective_radius = 102.0/2 + 1 ;
			break ;
		   case 933 :
		   case 953 :
			effective_radius = 76.0/2 + 1 ;
			break ;
		   case 921 :
			effective_radius = 82.0/2 + 1 ;
			break ;
		   case 831 :
			effective_radius = 64.0/2 + 1 ;
			break ;
		   default :
			arccorflg = 0 ;
			printf("bkproj: unable to do arc correction\n") ;
			printf("incompatable ecat model type : %d\n",
d343 2
a344 2
			break ;
		} /* End switch system_type */
d346 11
a356 9
		if (arccorflg)
		{
		  w = shead.sample_distance * 
                      TotalNumberOfViews*2/M_PI/effective_radius ;
		  if (debug == 1)
		  {
		    printf("w = %f\n", w) ;
		    printf("model = %d, radius = %f\n", system_type, effective_radius) ;
		  }
d358 12
a369 21
		  for (i=0 ; i<nprojs ; i++)
		     x[i] = nprojs/2 + effective_radius * 
                            sin(M_PI*(i-nprojs/2)/2/TotalNumberOfViews)/ 
                                                  shead.sample_distance ;

		  cs->nprojs = nprojs ;
		  for (i=0 ; i<nprojs ; i++)
		  {
		      cs->o[i] = (int) x[i] ;
		      cs->f1[i] = x[i] - cs->o[i] ;
		      cs->f2[i] = 1.0 - cs->f1[i] ;
		  }
		  cs->f2[nprojs/2] = w ;
		  ecat_model = system_type ;	/* save for next job */
                  recon_nprojs = nprojs ;
		} /* End if arccorflg */

	    } /* End if ecat_model != system_type */
	} /* End if arccorflg */

	    
d371 2
a372 2
	   printf("nprojs/2, cs->f2[nprojs/2] : %d %f\n", 
                                nprojs/2, cs->f2[nprojs/2]) ; 
d375 1
a375 1
	isize = size*size;
d377 1
a377 1
	xvclr_( cs->image, &isize, &one);
d379 2
a380 2
	while (fft_size < 2*nprojs)
	  fft_size *= 2;
d382 11
a392 12
	fft_size2 = fft_size/2;
	if (scatter_correction)
	{
	  if (fparms[6] == 0.0) fparms[6] = shead.sample_distance ;
	  makefilter( fft_size, cs->scatter_bufr, SCATTER, fparms, cs->tramp, 
                      &cs->temp_bufr[0]) ;
	  if (debug)
	  {
		printf("scatter fraction = %f\n", fparms[4]) ;
		printf("scatter slope (1/cm) = %f\n", fparms[5]) ;
		printf("spacing in cm = %f\n", fparms[6]) ;
	  }
d394 2
a395 1
	if (debug) printf("fcode=%d, fparms[0]=%f\n", fcode, fparms[0]) ;
d397 4
a400 4
	if (fcode!=0)
	{
	  if (debug) printf("making recon filter...\n") ;
	  makefilter( fft_size, cs->filter_bufr, fcode, fparms, cs->tramp, &cs->temp_bufr_1[0]);
d403 2
a404 2
	xldone_(cs);
	fflush(stdout);
d406 2
a407 2
	for (i=0; i<fft_size; i++)
	  cs->proj[i] = 0.0;
d413 6
a418 4
        /* Correction for intrinsic tilt */
	irot = 0.0 ;
	if ( (nviews % 96) == 0 ) irot = -15.0 ;
        if ( (nviews % 98) == 0 ) irot = -12.86;
d420 7
a426 8
	sint = sin( M_PI*rot/180.0) ;
	cost = cos( M_PI*rot/180.0) ;
	x0 = xoff*cost + yoff*sint ;
	y0 = -xoff*sint + yoff*cost ;
	if (debug)
	{
	   printf("rot angle = %f, cos = %f, sin = %f\n", rot, cost, sint) ;
	   printf("xoff = %f, yoff = %f\n", x0, y0) ;
d428 1
a429 2
	t2 = tickGet()-t0;

d432 2
a433 3
	for (i=0; i<nviews; i++)
	{
	  theta = M_PI*(rot+irot)/180.;
d435 2
a436 2
	  sint = sin( theta + M_PI * i/nviews); 
	  cost = cos( theta + M_PI * i/nviews); 
d438 4
a441 3
        /* Synchronize the host and the SuperCard so that the needed values
	   have been calculated by the SuperCard and are ready to be used
	   by the host program.	*/
d443 38
a480 42
	  if (fcode != 0)
	  {
	    for (j=0; j<fft_size; j++)
	      cs->temp_bufr[j] = 0.0;
	    if (scatter_correction)
	    {
		if (corp1)
		  for (j=0; j<nprojs; j++)
	            cs->temp_bufr[j+fft_offset] = (float) *scanp++ * (*corp1++);
		else
	          for (j=0; j<nprojs; j++)
	            cs->temp_bufr[j+fft_offset] = (float) *scanp++;
		sf = (float) ( (1.0-fparms[4])/(2.0*fft_size) ) ;
		xfrf_(cs->fft_bufr, &cs->ra_temp, cs->temp_bufr, &fft_size2) ;
		xcvmls_(cs->fft_bufr, &cs->fone, cs->fft_bufr,
					cs->scatter_bufr, &fft_size2);
		xldone_(cs) ;
		cs->ra_temp = cs->ra_temp*cs->scatter_bufr[1] ;
		xfri_(cs->temp_bufr, &cs->ra_temp, cs->fft_bufr,
					cs->proj, &fft_size2) ;
		xvsml_(cs->temp_bufr, &sf, &fft_size) ;
		xldone_(cs) ;
		if (corp2)
		  for (j=0; j<nprojs; j++)
	            cs->temp_bufr[j+fft_offset] *= *corp2++ ;
	    }
	    else  /* if no scatter correction */
	    {
	      if (corp1 && corp2)
	        for (j=0; j<nprojs; j++)
	          cs->temp_bufr[j+fft_offset] =
				(float) *scanp++ * (*corp1++) * (*corp2++);
	      else if (corp1)
	        for (j=0; j<nprojs; j++)
	          cs->temp_bufr[j+fft_offset] = (float) *scanp++ * (*corp1++);
	      else if (corp2)
	        for (j=0; j<nprojs; j++)
	          cs->temp_bufr[j+fft_offset] = (float) *scanp++ * (*corp2++);
	      else
	        for (j=0; j<nprojs; j++)
	          cs->temp_bufr[j+fft_offset] = (float) *scanp++;
	    }
d482 9
a490 15
	    if (arccorflg)
	    {
	      xvclr_(cs->temp_bufr_1, &f4096, &one) ;
              arc_correct (cs->nprojs, &cs->temp_bufr[fft_offset], 
                           &cs->temp_bufr_1[fft_offset], cs->o, cs->f1, cs->f2);
/***
	      xccall_(x_f(sc_arc_correct), cs, x_p(&cs->nprojs), x_p(&cs->temp_bufr[fft_offset]), x_p(&cs->temp_bufr_1[fft_offset]), x_p(cs->o), x_p(cs->f1), x_p(cs->f2)) ;
***/
	      xldone_(cs) ;
	    }
	    else
	    {
	        xldone_ (cs) ;
	        xvmov_(cs->temp_bufr_1, cs->temp_bufr, &f4096, &one, &one) ;
	    }
d492 23
a514 28
	    xfrf_( cs->fft_bufr, &cs->ra_temp, cs->temp_bufr_1, &fft_size2);
	    xcvmls_( cs->fft_bufr, &cs->fone, 
		cs->fft_bufr, cs->filter_bufr, &fft_size2);
	    cs->ra_temp=cs->ra_temp*cs->filter_bufr[1];
	    xfri_( cs->proj, &cs->ra_temp, cs->fft_bufr,
		cs->temp_bufr, &fft_size2);
	  }
	  else	/*  if (fcode == 0)  */
	  {
	    xldone_ (&cs->r0);	
	    for (j=0; j<fft_size; j++)
	      cs->proj[j] = 0.0;
	    for (j=0; j<nprojs; j++)
	      cs->proj[j+fft_offset] = (float) *scanp++;
	  }
	  xldone_ (cs) ;
	  zoom_factor = (float) nprojs / (float) size / zoom ;
	  cs->rdx = cost * zoom_factor ;
	  cs->rdy = sint * zoom_factor ;
	  rx0 = (float) size/2 - x0/pixel_size;
	  ry0 = (float) size/2 + y0/pixel_size;
	  cs->r0 = (float) fft_size2 - rx0*cs->rdx - ry0*cs->rdy;
	  if (debug==2)
		printf("%3d %6.2f %6.2f %6.2f\n", i, cs->r0, cs->rdx, cs->rdy);
          bkproj_view (cs->proj, cs->r0, cs->rdx, cs->rdy, cs->image, cs->size);
/***
          xbp_(cs->image, &cs->r0, cs->proj, &fft_size, &cs->size);
***/
d520 16
a535 14
	if (strcmp(job->imag_spec, "") != 0)
	{
	t3 = tickGet()-t0;
	cs->c32767 = 32767.;
	cs->zero = 0.0;
	cs->image[0] = 0.0;
	xrmn_( &cs->image_min, cs->image, &isize);
	xrmx_( &cs->image_max, cs->image, &isize);
	xsdiv_( &cs->scalef, &cs->c32767, &cs->image_max);
	xvfx4_( cs->imagei, &cs->scalef, cs->image, &cs->zero, &isize);
	xldone_(cs);
	if (debug) printf("cs->image_min = %f\n", cs->image_min);
	if (debug) printf("cs->image_max = %f\n", cs->image_max);
	if (debug) printf("cs->scalef    = %f\n", cs->scalef);
d537 69
a605 49
	for (i=0; i<size*size; i++)
	  cs->imagei2[i] = cs->imagei[i];
	t4 = tickGet()-t0;
	sino_scale = sino_scale * dtcor * decay_factor / scan_duration ;
	image_scale = cs->image_max*3.14159/32767./nviews/2/fft_size ;
	image_scale = image_scale*sino_scale*norm_scale*atten_scale ;
	mhead.file_type = 2;
	mhead.data_type = 2;
	mhead.calibration_units = nmain.calibration_units;
	ihead.data_type = 2;
	ihead.num_dimensions = 2;
	ihead.dimension_1 = ihead.dimension_2 = size;
	ihead.x_origin = xoff;
	ihead.y_origin = yoff;
	ihead.quant_scale = image_scale ;
	ihead.image_min = 0;
	ihead.image_max = 32767;
	ihead.slice_width = mhead.plane_separation ;
	ihead.filter_code = fcode ;
	ihead.frame_start_time = shead.frame_start_time ;
	ihead.frame_duration = shead.frame_duration ;
	ihead.gate_duration = shead.gate_duration ;
	ihead.quant_units = 2 ;
	ihead.scan_matrix_num = sino_matnum ;
	ihead.norm_matrix_num = norm_matnum ;
	ihead.atten_cor_matrix_num = attn_matnum ;
	ihead.plane_eff_corr_fctr = norm_scale ;
	ihead.decay_corr_fctr = decay_factor ;
	ihead.loss_corr_fctr = dtcor ;
	ihead.image_rotation = rot ;
	ihead.intrinsic_tilt = irot ;
	ihead.processing_code = 0 ;
	if (norm && nsh.ecat_calib_factor > 0.0)
	  ihead.ecat_calibration_fctr = nsh.ecat_calib_factor/br ;
	else
	  ihead.ecat_calibration_fctr = 1.0 ;
	for (i=0 ; i<6 ; i++) ihead.filter_params[i] = fparms[i] ;
	ihead.pixel_size=pixel_size;
	if (ihead.pixel_size <= 0.0) ihead.pixel_size = 1.0;
	ihead.recon_scale = zoom ;
	ihead.well_counter_cal_fctr = 1.0 ;
	strcpy(ihead.annotation, "ACS reconstruction with new AP") ;
	p = index( job->imag_spec, ',');
	*p++ = '\0';
	if (debug) printf("Saving data into image file...\n") ;
	fptr = mat_open( job->imag_spec, "r+");
	if (!fptr)
	{
	   fptr = mat_create( job->imag_spec, &mhead);
d607 1
a607 26
/*
	else
	{
	   err = mat_write_main_header(fptr, &mhead) ;
	   if (err) printf("bkproj - error updating image main header\n") ;
	   return (ERROR) ;
	}
*/
	frame=plane=gate=sino=bed=0;
	sscanf( p, "%d,%d,%d,%d,%d", &frame, &plane,
		&gate, &sino, &bed);
	*(--p) = ',';
	matnum = mat_numcod( frame, plane, gate, sino, bed);
	mat_write_image( fptr, matnum, &ihead, cs->imagei2, size*size*2);
	mat_close( fptr);
	free(scan);
	if (norm) free(norm);
	if (attn) free(attn);
	t5 = tickGet()-t0;
	if (debug)
	   printf("bkproj: job %10d, %3d, %3d %6.3f,%6.3f,%6.3f,%6.3f,%6.3f = %6.3f sec.\n\n", jobid, size, nviews,
	   t1/60., (t2-t1)/60., (t3-t2)/60., (t4-t3)/60., (t5-t4)/60., t5/60.);
	else
	   if (recon_echo) printf(" (%d %4.1f)", jobid, t5/60.) ;
	}
	fflush(stdout);
d616 5
a620 5
read_matrix( matspec, mhptr, shptr, dptr, ftype, ret_matnum)
  char *matspec;
  Main_header *mhptr;
  caddr_t shptr, *dptr;
  int ftype, *ret_matnum;
d622 5
a626 5
	char tempstr[256], *p, *index();
	FILE *fptr;
	Main_header mhead;
	int mf, mp, mg, md, mb, matnum, nblks;
	struct MatDir entry;
d628 4
a631 3
	strncpy( tempstr, matspec, 255);
	p = index( tempstr, ',');
	if (!p) return (ERROR_NOMATNUM);
d633 1
a633 1
	fptr = mat_open( tempstr, "r");
d635 9
a643 8
	  return (ERROR_NOFILE);
	if (!mhptr) mhptr = &mhead;
	mat_read_main_header( fptr, mhptr);
	if (mhptr->file_type != ftype)
	{ mat_close( fptr);
	  printf("read_matrix: ERROR wrong file type for %s, type was %d, requested type %d\n",
		tempstr, mhptr->file_type, ftype);
	  return (ERROR_WRONG_FTYPE);
d645 4
a648 4
	mf=mp=mg=md=mb=0;
	sscanf(p, "%d,%d,%d,%d,%d", &mf,&mp,&mg,&md,&mb);
	matnum = mat_numcod( mf, mp, mg, md, mb);
	*ret_matnum = matnum ;
d650 4
a653 4
	  printf("do_bkproj:read_matrix: ret_matnum = %x\n", *ret_matnum) ;
	if (!mat_lookup( fptr, matnum, &entry))
	{ mat_close( fptr);
	  return (ERROR_NOMATRIX);
d655 31
a685 29
	nblks = entry.endblk-entry.strtblk;
	if (dptr) *dptr = (caddr_t) malloc( 512*nblks);
	if (shptr) switch( mhptr->file_type)
	{ case 1:
		mat_read_scan_subheader( fptr, entry.strtblk, shptr);
		if (dptr && &dptr)
		  read_matrix_data( fptr, entry.strtblk+1, nblks, *dptr,
		   ((Scan_subheader *)shptr)->data_type);
		break;
	  case 2:
		mat_read_image_subheader( fptr, entry.strtblk, shptr);
		if (dptr && &dptr)
		  read_matrix_data( fptr, entry.strtblk+1, nblks, *dptr,
		    ((Image_subheader *) shptr)->data_type);
		break;
	  case 3:
		mat_read_attn_subheader( fptr, entry.strtblk, shptr);
		if (dptr && &dptr)
		  read_matrix_data( fptr, entry.strtblk+1, nblks, *dptr,
		    ((Attn_subheader *) shptr)->data_type);
		break;
	  case 4:
		mat_read_norm_subheader( fptr, entry.strtblk, shptr);
		if (dptr && &dptr)
		  read_matrix_data( fptr, entry.strtblk+1, nblks, *dptr,
		    ((Norm_subheader *) shptr)->data_type);
		break;
	}
	mat_close( fptr);
d690 4
a693 3
/***********
fix_matrix( matstr)
  char *matstr;
d695 2
a696 4
	int err;
	Main_header mhead;
	Attn_subheader ash;
	float *attn=NULL;
d698 9
a706 4
	err = read_matrix( matstr, &mhead, &ash, &attn, 3);
	if (err)
	{ printf("fix_matrix: error reading %s\n", matstr);
	  return err;
a707 7
	ash.data_type = 5;
	err = write_matrix( matstr, NULL, &ash, &attn, 3);
	if (err)
	{ printf("fix_matrix: error writing %s\n", matstr);
	  return err;
	}
	return OK;
d710 3
a712 5
write_matrix( matspec, mhptr, shptr, dptr, ftype)
  char *matspec;
  Main_header *mhptr;
  caddr_t shptr, *dptr;
  int ftype;
d714 2
a715 5
	char tempstr[256], *p, *index();
	FILE *fptr;
	Main_header mhead;
	int mf, mp, mg, md, mb, matnum, nblks;
	struct MatDir entry;
d717 9
a725 14
	strncpy( tempstr, matspec, 255);
	p = index( tempstr, ',');
	if (!p) return (ERROR_NOMATNUM);
	*p++ = '\0';
	fptr = mat_open( tempstr, "r");
	if (!fptr)
	  return (ERROR_NOFILE);
	if (!mhptr) mhptr = &mhead;
	mat_read_main_header( fptr, mhptr);
	if (mhptr->file_type != ftype)
	{ mat_close( fptr);
	  printf("write_matrix: ERROR wrong file type for %s, type was %d, requested type %d\n",
		tempstr, mhptr->file_type, ftype);
	  return (ERROR_WRONG_FTYPE);
a726 36
	mf=mp=mg=md=mb=0;
	sscanf(p, "%d,%d,%d,%d,%d", &mf,&mp,&mg,&md,&mb);
	matnum = mat_numcod( mf, mp, mg, md, mb);
	if (!mat_lookup( fptr, matnum, &entry))
	{ mat_close( fptr);
	  return (ERROR_NOMATRIX);
	}
	nblks = entry.endblk-entry.strtblk;
	if (shptr) switch( mhptr->file_type)
	{ case 1:
		mat_write_scan_subheader( fptr, entry.strtblk, shptr);
		if (dptr && &dptr)
		  write_matrix_data( fptr, entry.strtblk+1, nblks, *dptr,
		   ((Scan_subheader *)shptr)->data_type);
		break;
	  case 2:
		mat_write_image_subheader( fptr, entry.strtblk, shptr);
		if (dptr && &dptr)
		  write_matrix_data( fptr, entry.strtblk+1, nblks, *dptr,
		    ((Image_subheader *) shptr)->data_type);
		break;
	  case 3:
		mat_write_attn_subheader( fptr, entry.strtblk, shptr);
		if (dptr && &dptr)
		  write_matrix_data( fptr, entry.strtblk+1, nblks, *dptr,
		    ((Attn_subheader *) shptr)->data_type);
		break;
	  case 4:
		mat_write_norm_subheader( fptr, entry.strtblk, shptr);
		if (dptr && &dptr)
		  write_matrix_data( fptr, entry.strtblk+1, nblks, *dptr,
		    ((Norm_subheader *) shptr)->data_type);
		break;
	}
	mat_close( fptr);
	return (OK);
a727 1
**********/
a728 7
bkproj_view( proj, r0, rdx, rdy, image, size)
  float *proj, *image;
  float r0, rdx, rdy;
  int size;
{
	int x, y, j;
	double r, w;
d730 1
a730 18
	for (y=0; y<size; y++)
	{
	  r = r0;
	  for (x=0; x<size; x++)
	  {
		j = (int) r;
		w = r-j;
		(*image++) += (1.0-w)*proj[j] + w*proj[j+1];
		r += rdx;
	  }
	  r0 += rdy;
	}
}

arc_correct(nprojs, scan_in, scan_out, o, f1, f2)

  int nprojs, *o ;
  float	*scan_in, *scan_out, *f1, *f2;
d732 2
a733 2
  int	i, *otemp ;
  float	*f1temp, *f2temp, *in ;
d735 3
a737 12
	otemp = o ;
	f1temp = f1 ;
	f2temp = f2 ;
	in = scan_in ;
	for (i=0 ; i<nprojs ; i++)
	{
	   scan_out[*otemp] += *in*(*f2temp++) ;
	   scan_out[*otemp+1] += *in*(*f1temp++) ;
	   otemp++ ;
	   in++ ;
	}
}
d739 2
a740 12

double tickGet ()
{
   double      	t0=0.0, m0=0.0;
   struct timeb  tp;

   ftime(&tp);
   t0 = (double)tp.time;
   m0 = (double)tp.millitm;

   t0 = t0 + m0/1000.0;
   return (t0*60.0);
d745 1
a745 1
   float 	*ptr;
d747 1
a747 1
   return;
a748 1

@
