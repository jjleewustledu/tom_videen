head	3.1;
access;
symbols;
locks; strict;
comment	@ * @;


3.1
date	2004.05.26.21.23.40;	author tom;	state Exp;
branches;
next	3.0;

3.0
date	2004.02.16.17.07.18;	author tom;	state Exp;
branches;
next	2.33;

2.33
date	2002.01.18.22.12.58;	author tom;	state Exp;
branches;
next	2.32;

2.32
date	2001.12.21.15.35.18;	author tom;	state Exp;
branches;
next	2.31;

2.31
date	2001.12.20.19.16.57;	author tom;	state Exp;
branches;
next	2.30;

2.30
date	99.12.16.18.08.47;	author tom;	state Exp;
branches;
next	2.29;

2.29
date	99.12.15.18.58.48;	author tom;	state Exp;
branches;
next	2.28;

2.28
date	99.11.26.18.59.23;	author tom;	state Exp;
branches;
next	2.27;

2.27
date	99.10.12.13.25.01;	author tom;	state Exp;
branches;
next	2.26;

2.26
date	99.07.12.16.22.54;	author tom;	state Exp;
branches;
next	2.25;

2.25
date	99.07.07.18.06.28;	author tom;	state Exp;
branches;
next	2.24;

2.24
date	99.06.30.17.28.24;	author tom;	state Exp;
branches;
next	2.23;

2.23
date	99.06.30.15.43.43;	author tom;	state Exp;
branches;
next	2.22;

2.22
date	98.12.04.20.44.09;	author tom;	state Exp;
branches;
next	2.21;

2.21
date	98.06.10.20.01.57;	author tom;	state Exp;
branches;
next	2.20;

2.20
date	97.01.08.22.47.32;	author tom;	state Exp;
branches;
next	2.19;

2.19
date	96.12.26.19.03.58;	author tom;	state Exp;
branches;
next	2.18;

2.18
date	96.11.12.16.25.41;	author tom;	state Exp;
branches;
next	2.17;

2.17
date	96.11.06.17.20.59;	author tom;	state Exp;
branches;
next	2.16;

2.16
date	96.10.16.16.38.48;	author tom;	state Exp;
branches;
next	2.12;

2.12
date	96.09.17.18.30.30;	author tom;	state Exp;
branches;
next	2.11;

2.11
date	96.09.17.17.31.30;	author tom;	state Exp;
branches;
next	2.10;

2.10
date	96.08.30.17.12.04;	author tom;	state Exp;
branches;
next	2.9;

2.9
date	96.08.30.16.02.41;	author tom;	state Exp;
branches;
next	2.8;

2.8
date	96.08.26.18.19.58;	author tom;	state Exp;
branches;
next	2.7;

2.7
date	96.08.22.17.33.04;	author tom;	state Exp;
branches;
next	2.6;

2.6
date	96.08.05.18.05.03;	author tom;	state Exp;
branches;
next	2.5;

2.5
date	96.06.21.15.40.23;	author tom;	state Exp;
branches;
next	2.4;

2.4
date	96.06.13.22.01.43;	author tom;	state Exp;
branches;
next	2.2;

2.2
date	96.05.24.18.16.52;	author tom;	state Exp;
branches;
next	2.1;

2.1
date	96.04.29.13.59.50;	author tom;	state Exp;
branches;
next	2.0;

2.0
date	96.04.24.23.05.51;	author tom;	state Exp;
branches;
next	1.1;

1.1
date	94.10.12.20.22.49;	author tom;	state Exp;
branches;
next	;


desc
@initial version
@


3.1
log
@fix major bug
@
text
@/* $Log: imean.c,v $
 * Revision 3.0  2004/02/16  17:07:18  tom
 * Feb 2004
 *
 * Revision 2.33  2002/01/18  22:12:58  tom
 * fix free bug
 *
 * Revision 2.32  2001/12/21  15:35:18  tom
 * *** empty log message ***
 *
 * Revision 2.31  2001/12/20  19:16:57  tom
 * *** empty log message ***
 *
 * Revision 2.30  1999/12/16  18:08:47  tom
 * new libs
 *
 * Revision 2.29  1999/12/15  18:58:48  tom
 * lint cleaning
 *
 * Revision 2.28  1999/11/26  18:59:23  tom
 * no hdr file created for paired (subtraction) images
 *
 * Revision 2.27  1999/10/12  13:25:01  tom
 * new libimgutil with updated arc path
 *
 * Revision 2.26  1999/07/12  16:22:54  tom
 * use pixel dimensions of input image unless PETT VI
 *
 * Revision 2.25  1999/07/07  18:06:28  tom
 * check for firstimgfrm of each image
 *
 * Revision 2.24  1999/06/30  17:28:24  tom
 * add PROC_ODIV
 *
 * Revision 2.23  1999/06/30  15:43:43  tom
 * process oef
 *
 * Revision 2.22  1998/12/04  20:44:09  tom
 * move copyright to header
 *
 * Revision 2.21  1998/06/10  20:01:57  tom
 * update calls to processPET
 *
 * Revision 2.20  1997/01/08  22:47:32  tom
 * create sd and n images
 * use parameters: smg_divisor, smg_included, smg_sdimage, smg_nimage
 * use weights from imagelist
 *
 * Revision 2.19  1996/12/26  19:03:58  tom
 * correct bug in computing paired difference images (mean and order)
 *
 * Revision 2.18  1996/11/12  16:25:41  tom
 * set flip flag in output image!
 *
 * Revision 2.17  1996/11/06  17:20:59  tom
 * add scaling for processed images
 *
 * Revision 2.16  1996/10/16  16:38:48  tom
 * sync with Version
 * new libimage
 *
 * Revision 2.12  1996/09/17  18:30:30  tom
 * add hdr to processOxygen
 *
 * Revision 2.11  1996/09/17  17:31:30  tom
 * pass hdr to processOxygen
 *
 * Revision 2.10  1996/08/30  17:12:04  tom
 * option -z
 *
 * Revision 2.9  1996/08/30  16:02:41  tom
 * remove image_mask option
 *
 * Revision 2.8  1996/08/26  18:19:58  tom
 * new libimage with wrimg7 & wrimg6 fixed for scaling
 *
 * Revision 2.7  1996/08/22  17:33:04  tom
 * new libimage
 *
 * Revision 2.6  1996/08/05  18:05:03  tom
 * new libimage and libnrimg
 *
 * Revision 2.5  1996/06/21  15:40:23  tom
 * change libimgutil to permit non-physiological OEF values
 *
 * Revision 2.4  1996/06/13  22:01:43  tom
 * fixed bug in processOxygen in libimgutil.a
 *
 * Revision 2.2  1996/05/24  18:16:52  tom
 * new libimage, libnrimg
 *
 * Revision 2.1  1996/04/29  13:59:50  tom
 * fix bug in paired image calculation
 *
 * Revision 2.0  1996/04/24  23:05:51  tom
 * new library release
 *
 * Revision 1.1  1994/10/12  20:22:49  tom
 * Initial revision
 *
 */
/*	===============================================================================
 *	Module:			imean.c
 *	Date:			Apr 1996
 *	Author:			Tom Videen
 *	Description:
 *		Compute mean PET images (PETT VI or ECAT) without atlas transformation.
 *		Optionally create summed images (difference, mean, or single).
 *		Optionally process images as cvf, cbv, oef, cmro2.
 *
 *	Command line parameters:
 *		parameter file
 *		image list
 *		output filename
 *
 *	Input Files:
 *		parameter file  (prm (5))
 *		image list      (imglist5))
 *		PET image files (PETT VI, ECAT image format; any readable by getrealimg)
 *		hdr files       (hdr (5))
 *
 *	Output Files:
 *		composite image (ECAT image format)
 *		rec file        (rec (5))
 *		hdr file        (hdr (5))
 *		sd image        (ECAT image format)
 *		n image         (ECAT image format)
 *
 *	History:
 *		Aug 1995 TOV add option for sd and n images.
 *		Apr 1996 TOV revise for new libraries (libimage, libimgutil, etc).
 *		Jan 1996 TOV revise to add sd and n images
 *
 *	Copyright 1991-1998. Washington University.
 *	All rights reserved. Unauthorized reproduction prohibited.
 *	===============================================================================
 */
static char     rcsid[] = "$Header: /home/npggw/tom/src/imean/RCS/imean.c,v 3.0 2004/02/16 17:07:18 tom Exp tom $";

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <myvalues.h>
#include <image.h>
#include <libimage.h>
#include <nrutil.h>
#include <libnrimg.h>
#include <imgutil.h>
#define  EARLY_EXIT	3			 /* return status to delete the rec file */

main (argc, argv)
	int             argc;
	char           *argv[];
{
	void            image_mask ();
	void            image_scale ();
	void            image_sum ();
	int             getprms_imean ();
	int             complete_imglist ();

	ImageFile      *file1;
	Index           indx;
	FILE           *recfp;
	PARAMETER_DATA  prm;			 /* processing parameters */
	IMAGE_LIST_DATA *imglist;		 /* list of files to process */
	HEADER_DATA     hdr;			 /* hdr structure */

	char           *lstfile;
	char           *prmfile;
	char           *outfile;
	char           *recfile;
	char            sdfile[MAXPATH];
	char            wtfile[MAXPATH];
	char           *ext;
	char            runstamp[40];		 /* version, date and userid info */
	char           *zeroslc;
	char           *today;
	char           *userid;
	char         ***scan;			 /* scan filenames */
	char           *scan1;			 /* filename for activation scan */
	char           *scan2;			 /* filename for control scan */
	char           *flow_scan1;		 /* cbf filename for activation */
	char           *vol_scan1;		 /* cbv filename for activation */
	char           *flow_scan2;		 /* cbf filename for control */
	char           *vol_scan2;		 /* cbv filename for control */
	int             pdim[3];		 /* image dimensions in pixels */
	int             lstsize = 0;
	int             filtmode = IMGFILTER_MODE;
	int             i, j, k;		 /* array indices */
	int             n;
	float           scaler;			 /* scale individual PET images */
	float           weight;
	float           maxwt = 0;
	float        ***sumimg;			 /* composite image */
	float        ***sdimage;		 /* SD image */
	float        ***totwt;			 /* total of weighted images contributing to each
						  * element of atlas_image */
	float        ***img1;			 /* first (activation) PET image */
	float        ***img2;			 /* second (control) PET image */
	float        ***flowimg;		 /* flow PET image for oxygen processing */
	float        ***volimg;			 /* volume PET image for oxygen processing */

	int             oxygen_mode = 0;
	int             paired_images = 0;
	int             compute_sd = 0;

/*
 *	additional parameters read from prm file
 */

	float           smg_norm;
	char            smg_mode[10];
	char            smg_divisor[10];
	char            smg_included[10];
	char            smg_sdimage[10];
	char            smg_nimage[10];

/*
 *	Read command line arguments and initialize filenames.
 */

	if (argc != 14) {
		printf ("Usage: imean prmlist imglist outfile recfile date\n");
		return (ERROR);
	}
	prmfile = argv[1];
	lstfile = argv[2];
	outfile = argv[3];
	recfile = argv[4];
	zeroslc = argv[5];
	n = 6;
	(void) sprintf (runstamp, "%s %s %s %s %s %s", argv[n], argv[n + 1], argv[n + 2], argv[n + 4], argv[n + 5], argv[n + 7]);
	today = argv[11];
	userid = argv[12];

	(void) strcpy (sdfile, outfile);
	ext = strrchr (sdfile, '.');
	if (ext != NULL)
		(void) strcpy (ext, ".sd");
	else
		(void) strcat (sdfile, ".sd");

	(void) strcpy (wtfile, outfile);
	ext = strrchr (wtfile, '.');
	if (ext != NULL)
		(void) strcpy (ext, ".n");
	else
		(void) strcat (wtfile, ".n");

	recfp = fopen (recfile, "a");
	if (recfp == (FILE *) NULL) {
		fprintf (stderr, "ERROR [imean]: cannot open %s\n", recfile);
		return (ERROR);
	}
	indx.frm = 1;
	indx.pln = 1;
	indx.gate = 1;
	indx.data = 0;
	indx.bed = 0;

/*
 * Initialize parameters (prm)
 */

	if (readprm (prmfile, &prm) == ERROR) {
		fprintf (stderr, "ERROR [imean]: reading %s\n", prmfile);
		return (ERROR);
	}
	if (getprms_imean (prmfile, &smg_norm, smg_divisor, smg_included, smg_mode,
			   smg_sdimage, smg_nimage) == ERROR) {
		fprintf (stderr, "ERROR [imean]: reading parameter file %s\n", prmfile);
		return (ERROR);
	}
	if (prm.processing == PROC_OEF || prm.processing == PROC_CMRO2 ||
	    prm.processing == PROC_ODIV) {
		oxygen_mode = 1;
		prm.imglist_mode = MULTITRACER_IMAGE_MODE;
	} else if (strcmp (smg_mode, "diff") == 0)
		prm.imglist_mode = DIFIMAGE_MODE;
	else
		prm.imglist_mode = STDIMAGE_MODE;
	if (strcmp (smg_mode, "paired") == 0)
		paired_images = 1;

/*
 *  Get and complete imagelist
 */

	imglist = (IMAGE_LIST_DATA *) malloc (MAX_IMAGE_LIST_SIZE * sizeof (IMAGE_LIST_DATA));
	if (imglist == NULL)
		return (ERROR);
	if (readimglist (lstfile, imglist, &lstsize) == ERROR) {
		fprintf (stderr, "ERROR [imean]: Cannot read %s\n", lstfile);
		return (ERROR);
	}
	if (lstsize > MAX_IMAGE_LIST_SIZE) {
		fprintf (stderr, "ERROR [imean]: imglist size %d > %d\n", lstsize, MAX_IMAGE_LIST_SIZE);
		return (ERROR);
	}
	scan = (char ***) malloc (lstsize * sizeof (char **));
	if (scan == NULL)
		return (ERROR);
	for (i = 0; i < lstsize; i++) {
		scan[i] = (char **) malloc (6 * sizeof (char *));
		for (j = 0; j < 6; j++)
			scan[i][j] = (char *) malloc (sizeof (MAXPATH));
	}

	if (complete_imglist (&prm, imglist, lstsize, filtmode, scan) == ERROR) {
		fprintf (stderr, "ERROR [imean]: complete_imglist\n");
		return (ERROR);
	}
	scan1 = scan[0][0];
	file1 = make_imgfile (scan1);
	if (open_imgfile (file1) == ERROR) {
		fprintf (stderr, "ERROR [imean]: Cannot open %s\n", scan1);
		return (ERROR);
	}
	if (get_mh (file1) == ERROR) {
		fprintf (stderr, "ERROR [imean]: Cannot get MainHeader from %s\n", scan1);
		return (ERROR);
	}
	indx.frm = firstimgfrm (file1);
	if (indx.frm < 1) {
		fprintf (stderr, "ERROR [imean]: cannot find %s frame(s) 1 to %d\n", scan1, -indx.frm);
		return (ERROR);
	}
	if (get_sh (file1, &indx) == ERROR) {
		fprintf (stderr, "ERROR [imean]: Cannot read file subheader in %s\n", scan1);
		return (ERROR);
	}
	pdim[0] = file1->sh->dim1;
	pdim[1] = file1->sh->dim2;
	pdim[2] = file1->sh->dim3;
	if (file1->mh->scanner_type == 6) {
		pdim[0] = 128;
		pdim[1] = 128;
	}
	(void) save_rcs (file1, rcsid, runstamp);

	if ((sumimg = f3tensor (1, pdim[2], 1, pdim[1], 1, pdim[0])) == NULL) {
		fprintf (stderr, "ERROR [imean]: Cannot malloc composite image\n");
		return (ERROR);
	}
	if ((totwt = f3tensor (1, pdim[2], 1, pdim[1], 1, pdim[0])) == NULL) {
		fprintf (stderr, "ERROR [imean]: Cannot malloc image for totwt\n");
		return (ERROR);
	}
	if (strcmp (smg_sdimage, "yes") == 0) {
		compute_sd = 1;
		if ((sdimage = f3tensor (1, pdim[2], 1, pdim[1], 1, pdim[0])) == NULL) {
			fprintf (stderr, "ERROR [imean]: Cannot malloc image for sdimage\n");
			return (ERROR);
		}
	} else
		sdimage = (float ***) NULL;

	for (i = 1; i <= pdim[2]; i++) {
		for (j = 1; j <= pdim[1]; j++) {
			for (k = 1; k <= pdim[0]; k++) {
				sumimg[i][j][k] = 0.;
				totwt[i][j][k] = 0.;
				if (compute_sd != 0)
					sdimage[i][j][k] = 0.;
			}
		}
	}

/*
 *	LOOP for each image or image-pair in the list:
 *	---------------------------------------------
 */

	for (i = 0; i < lstsize; ++i) {
		scan1 = scan[i][0];
		weight = imglist[i].weight;
		maxwt += weight;
		if (oxygen_mode != 0) {
			flow_scan1 = scan[i][1];
			vol_scan1 = scan[i][2];
			if (paired_images != 0) {
				scan2 = scan[i][3];
				flow_scan2 = scan[i][4];
				vol_scan2 = scan[i][5];
			}
		} else if (paired_images != 0) {
			scan2 = scan[i][1];
		}
/*
 *	Read and process First (activation) image
 *	-----------------------------------------
 */
		if ((img1 = rdtensor1 (scan1, pdim)) == NULL) {
			fprintf (stderr, "ERROR [imean]: Cannot read %s\n", scan1);
			return (ERROR);
		}
		recout (recfp, scan1);
		printf ("Activation  = %s\n", scan1);

		if (oxygen_mode != 0) {
			flow_scan1 = scan[i][1];
			if ((flowimg = rdtensor1 (flow_scan1, pdim)) == NULL) {
				fprintf (stderr, "ERROR [imean]: Cannot read %s\n", flow_scan1);
				return (ERROR);
			}
			recout (recfp, flow_scan1);
			printf ("   CBF  = %s\n", flow_scan1);

			vol_scan1 = scan[i][2];
			if ((volimg = rdtensor1 (vol_scan1, pdim)) == NULL) {
				fprintf (stderr, "ERROR [imean]: Cannot open %s\n", vol_scan1);
				return (ERROR);
			}
			recout (recfp, vol_scan1);
			printf ("   CBV  = %s\n", vol_scan1);
		}
		if (prm.imglist_mode == DIFIMAGE_MODE)
			scaler = 1.0;
		else if (smg_norm == 0) {
			fprintf (stderr, "ERROR [imean]: Parameter smg_norm in parameter list is 0\n");
			return (ERROR);
		} else if (imglist[i].mean1 == 0) {
			fprintf (stderr, "ERROR [imean]: Normalization factor in image list is 0\n");
			return (ERROR);
		} else
			scaler = smg_norm / imglist[i].mean1;
		fprintf (recfp, "Scale %s by %f\n", scan1, scaler);

/*  Oxygen processing or Not */

		if (oxygen_mode != 0) {
			if (processOxygen (img1, flowimg, volimg, pdim, scaler,
				 prm.processing, scan1, flow_scan1, vol_scan1, recfp, &hdr) > 0) {
				fprintf (stderr, "ERROR [imean] processing %s %s %s\n", scan1,
					 flow_scan1, vol_scan1);
				return (ERROR);
			}
			free_f3tensor (flowimg, 1, pdim[2], 1, pdim[1], 1, pdim[0]);
			free_f3tensor (volimg, 1, pdim[2], 1, pdim[1], 1, pdim[0]);

		} else if (processPET (img1, pdim, scaler, prm.processing, scan1, recfp, &hdr) > 0) {
			fprintf (stderr, "ERROR [imean] processing %s\n", scan1);
			return (ERROR);
		}
/*
 *	Read and process the second (control) image (for paired lists)
 *	then sum images
 *	----------------------------------------------------------
 */

		if (paired_images != 0) {
			if (oxygen_mode != 0) {
				scan2 = scan[i][3];
				if ((img2 = rdtensor1 (scan2, pdim)) == NULL) {
					fprintf (stderr, "ERROR [imean] Cannot read %s\n", scan2);
					return (ERROR);
				}
				recout (recfp, scan2);
				printf ("Control  = %s\n", scan2);

				flow_scan2 = scan[i][4];
				if ((flowimg = rdtensor1 (flow_scan2, pdim)) == NULL) {
					fprintf (stderr, "ERROR [imean] Cannot read %s\n", flow_scan2);
					return (ERROR);
				}
				recout (recfp, flow_scan2);
				printf ("   CBF  = %s\n", flow_scan2);

				vol_scan2 = scan[i][5];
				if ((volimg = rdtensor1 (vol_scan2, pdim)) == NULL) {
					fprintf (stderr, "ERROR [imean]: Cannot open %s\n", vol_scan2);
					return (ERROR);
				}
				recout (recfp, vol_scan2);
				printf ("   CBV  = %s\n", vol_scan2);
			} else {
				scan2 = scan[i][1];
				if ((img2 = rdtensor1 (scan2, pdim)) == NULL) {
					fprintf (stderr, "ERROR [imean] Cannot read %s\n", scan2);
					return (ERROR);
				}
				recout (recfp, scan2);
				printf ("Control  = %s\n", scan2);
			}
			if (prm.imglist_mode == DIFIMAGE_MODE)
				scaler = 1.0;
			else if (smg_norm == 0) {
				fprintf (stderr, "ERROR [imean]: Parameter smg_norm in parameter list is 0\n");
				return (ERROR);
			} else if (imglist[i].mean2 == 0) {
				fprintf (stderr, "ERROR [imean]: Normalization factor in image list is 0\n");
				return (ERROR);
			} else
				scaler = smg_norm / imglist[i].mean2;
			fprintf (recfp, "Scale %s by %f\n", scan2, scaler);

/*  Oxygen processing or Not */

			if (oxygen_mode != 0) {
				if (processOxygen (img2, flowimg, volimg, pdim, scaler,
				 prm.processing, scan2, flow_scan2, vol_scan2, recfp, &hdr) > 0) {
					fprintf (stderr, "ERROR [imean] processing %s %s %s\n", scan2,
						 flow_scan2, vol_scan2);
					return (ERROR);
				}
				free_f3tensor (flowimg, 1, pdim[2], 1, pdim[1], 1, pdim[0]);
				free_f3tensor (volimg, 1, pdim[2], 1, pdim[1], 1, pdim[0]);

			} else if (processPET (img2, pdim, scaler, prm.processing, scan2, recfp, &hdr) > 0) {
				fprintf (stderr, "ERROR [imean] processing %s\n", scan2);
				return (ERROR);
			}
		}
		image_sum (img1, img2, sumimg, totwt, sdimage, weight, pdim, paired_images, compute_sd);
		free_f3tensor (img1, 1, pdim[2], 1, pdim[1], 1, pdim[0]);
		if (paired_images != 0)
			free_f3tensor (img2, 1, pdim[2], 1, pdim[1], 1, pdim[0]);
	}
/*	End LOOP
 *	--------
 *	Scale composite image and write to outfile
 */

	if (paired_images != 0)
		scaler = 1;
	else if (prm.processing == PROC_CBF)
		scaler = SCALE_CBF;
	else if (prm.processing == PROC_CBV)
		scaler = SCALE_CBV;
	else if (prm.processing == PROC_OEF)
		scaler = SCALE_OEF;
	else if (prm.processing == PROC_CMRO2)
		scaler = SCALE_CMRO2;
	else
		scaler = 1;
	image_scale (sumimg, totwt, sdimage, pdim, maxwt, scaler, smg_divisor, smg_included, compute_sd);

	if (strncmp (zeroslc, "y", 1) == 0) {
		if (prm.first_slice > 0 && prm.last_slice > 0 &&
		    (prm.first_slice > 1 || prm.last_slice < pdim[2]))
			image_mask (sumimg, pdim, prm.first_slice, prm.last_slice);
	}
	close_imgfile (file1);
	file1->name = outfile;
	(void) strcpy (file1->mode, "w");
	indx.frm = 1;
	printf ("Writing %s\n", outfile);
	if (open_imgfile (file1) == ERROR) {
		fprintf (stderr, "ERROR [sumimg]: Cannot open %s\n", outfile);
		return (ERROR);
	}
	file1->mh->nframe = indx.frm;
	file1->mh->orientation = 0;
	if (put_mh (file1) == ERROR) {
		fprintf (stderr, "ERROR [imean] writing %s\n", outfile);
		return (ERROR);
	}
	if (wrtensor (file1, indx, sumimg) == ERROR) {
		fprintf (stderr, "ERROR [imean] writing %s\n", outfile);
		return (ERROR);
	}
	close_imgfile (file1);

/*
 *	Write HDR file
 *	--------------
 */
	if (prm.processing != PROC_NONE && paired_images != 0) {
		if (writehdr (&hdr, outfile, userid, today, prm.processing, (short) pdim[2]) == ERROR) {
			fprintf (stderr, "ERROR [imean]: writing hdr file\n");
		}
	}
/*
 *  Write SD Image to sdfile
 *  ------------------------
 */
	if (compute_sd != 0) {
		file1->name = sdfile;
		(void) strcpy (file1->mode, "w");
		printf ("Writing %s\n", sdfile);
		if (open_imgfile (file1) == ERROR) {
			fprintf (stderr, "ERROR [imean]: Cannot open %s\n", sdfile);
			return (ERROR);
		}
		indx.frm = 1;
		file1->mh->nframe = indx.frm;
		file1->mh->orientation = 0;
		if (put_mh (file1) == ERROR) {
			fprintf (stderr, "ERROR [imean] writing %s\n", sdfile);
			return (ERROR);
		}
		if (wrtensor (file1, indx, sdimage) == ERROR) {
			fprintf (stderr, "ERROR [imean] writing %s\n", sdfile);
			return (ERROR);
		}
		close_imgfile (file1);
	}
/*
 *  Write Total Weight Image to wtfile
 *  ----------------------------------
 */
	if (strcmp (smg_nimage, "yes") == 0) {
		file1->name = wtfile;
		(void) strcpy (file1->mode, "w");
		printf ("Writing %s\n", wtfile);
		if (open_imgfile (file1) == ERROR) {
			fprintf (stderr, "ERROR [imean]: Cannot open %s\n", wtfile);
			return (ERROR);
		}
		indx.frm = 1;
		file1->mh->nframe = indx.frm;
		file1->mh->orientation = 0;
		if (put_mh (file1) == ERROR) {
			fprintf (stderr, "ERROR [imean] writing %s\n", wtfile);
			return (ERROR);
		}
		if (wrtensor (file1, indx, totwt) == ERROR) {
			fprintf (stderr, "ERROR [imean] writing %s\n", wtfile);
			return (ERROR);
		}
		close_imgfile (file1);
		free_imgfile (file1);
	}
/*
 *	Free memory
 *	-----------
 */

	if (compute_sd != 0 && sdimage != NULL)
		free_f3tensor (sdimage, 1, pdim[2], 1, pdim[1], 1, pdim[0]);
	free_f3tensor (totwt, 1, pdim[2], 1, pdim[1], 1, pdim[0]);
	free_f3tensor (sumimg, 1, pdim[2], 1, pdim[1], 1, pdim[0]);
	for (i = 0; i < lstsize; i++) {
		free (scan[i]);
	}
	free (scan);
	free (imglist);
	(void) fclose (recfp);
	return (0);
}
@


3.0
log
@Feb 2004
@
text
@d2 3
d138 1
a138 1
static char     rcsid[] = "$Header: /home/npggw/tom/src/imean/RCS/imean.c,v 2.33 2002/01/18 22:12:58 tom Exp tom $";
d203 3
a205 3
	int				oxygen_mode = 0;
	int				paired_images = 0;
	int				compute_sd = 0;
d274 2
a275 2
	if (prm.processing == PROC_OEF || prm.processing == PROC_CMRO2 || 
		prm.processing == PROC_ODIV) {
a312 1

d323 5
a327 5
    indx.frm =  firstimgfrm (file1);
    if (indx.frm < 1) {
       fprintf (stderr, "ERROR [imean]: cannot find %s frame(s) 1 to %d\n", scan1, -indx.frm);
       return (ERROR);
    }
d393 1
a393 4
		
		file1->name = scan1;
        indx.frm =  firstimgfrm (file1);
		if ((img1 = rdtensor (file1, indx, pdim)) == NULL) {
d515 2
a516 1
		if (paired_images != 0) {
a517 2
			free_f3tensor (img1, 1, pdim[2], 1, pdim[1], 1, pdim[0]);
		}
@


2.33
log
@fix free bug
@
text
@d2 3
d101 1
a101 1
 *	Date:			Apr-96
d127 3
a129 3
 *		09-Aug-95 TOV add option for sd and n images.
 *		Apr-96	TOV	revise for new libraries (libimage, libimgutil, etc).
 *		Jan-96	TOV revise to add sd and n images
d135 1
a135 1
static char     rcsid[] = "$Header: /home/npggw/tom/src/imean/RCS/imean.c,v 2.32 2001/12/21 15:35:18 tom Exp tom $";
d156 1
a156 1
	void            complete_imglist ();
d158 3
a160 4
	ImageFile      *file1;			 /* input image file structure */
	ImageFile      *file2;
	Index           indx;			 /* frame, plane, gate, data, bed */
	FILE           *recfp;			 /* rec file */
d200 3
a202 3
	BOOLEAN         oxygen_mode = 0;
	BOOLEAN         paired_images = 0;
	BOOLEAN         compute_sd = 0;
d229 1
a229 1
	sprintf (runstamp, "%s %s %s %s %s %s", argv[n], argv[n + 1], argv[n + 2], argv[n + 4], argv[n + 5], argv[n + 7]);
d233 1
a233 1
	strcpy (sdfile, outfile);
d236 1
a236 1
		strcpy (ext, ".sd");
d238 1
a238 1
		strcat (sdfile, ".sd");
d240 1
a240 1
	strcpy (wtfile, outfile);
d243 1
a243 1
		strcpy (ext, ".n");
d245 1
a245 1
		strcat (wtfile, ".n");
d287 2
d298 2
d306 4
a309 1
	complete_imglist (&prm, imglist, lstsize, filtmode, scan);
d337 1
a337 1
	save_rcs (file1, rcsid, runstamp);
d345 1
a345 1
		exit (ERROR);
d351 1
a351 1
			exit (ERROR);
d361 1
a361 1
				if (compute_sd)
d376 1
a376 1
		if (oxygen_mode) {
d379 1
a379 1
			if (paired_images) {
d384 1
a384 1
		} else if (paired_images) {
d394 1
a394 1
		if ((img1 = rdtensor (scan1, indx, pdim)) == NULL) {
d401 1
a401 1
		if (oxygen_mode) {
d403 1
a403 7
			file2 = make_imgfile (flow_scan1);
			if (open_imgfile (file2) == ERROR) {
				fprintf (stderr, "ERROR [imean]: Cannot open %s\n", flow_scan1);
				return (ERROR);
			}
        	indx.frm =  firstimgfrm (file2);
			if ((flowimg = rdtensor (flow_scan1, indx, pdim)) == NULL) {
a408 1
			close_imgfile (file2);
d411 1
a411 2
			file2 = make_imgfile (vol_scan1);
			if (open_imgfile (file2) == ERROR) {
a414 5
        	indx.frm =  firstimgfrm (file2);
			if ((volimg = rdtensor (vol_scan1, indx, pdim)) == NULL) {
				fprintf (stderr, "ERROR [imean]: Cannot open %s\n", vol_scan1);
				return (ERROR);
			}
a416 1
			close_imgfile (file2);
d432 1
a432 1
		if (oxygen_mode) {
d452 2
a453 2
		if (paired_images) {
			if (oxygen_mode) {
d455 1
a455 7
				file2 = make_imgfile (scan2);
				if (open_imgfile (file2) == ERROR) {
					fprintf (stderr, "ERROR [imean]: Cannot open %s\n", scan2);
					return (ERROR);
				}
        		indx.frm =  firstimgfrm (file2);
				if ((img2 = rdtensor (scan2, indx, pdim)) == NULL) {
a460 1
				close_imgfile (file2);
d463 1
a463 7
				file2 = make_imgfile (flow_scan2);
				if (open_imgfile (file2) == ERROR) {
					fprintf (stderr, "ERROR [imean]: Cannot open %s\n", flow_scan2);
					return (ERROR);
				}
        		indx.frm =  firstimgfrm (file2);
				if ((flowimg = rdtensor (flow_scan2, indx, pdim)) == NULL) {
a468 1
				close_imgfile (file2);
d471 1
a471 2
				file2 = make_imgfile (vol_scan2);
				if (open_imgfile (file2) == ERROR) {
a474 5
        		indx.frm =  firstimgfrm (file2);
				if ((volimg = rdtensor (vol_scan2, indx, pdim)) == NULL) {
					fprintf (stderr, "ERROR [imean]: Cannot open %s\n", vol_scan2);
					return (ERROR);
				}
a476 1
				close_imgfile (file2);
d479 1
a479 7
				file2 = make_imgfile (scan2);
				if (open_imgfile (file2) == ERROR) {
					fprintf (stderr, "ERROR [imean]: Cannot open %s\n", scan2);
					return (ERROR);
				}
        		indx.frm =  firstimgfrm (file2);
				if ((img2 = rdtensor (scan2, indx, pdim)) == NULL) {
a484 1
				close_imgfile (file2);
d500 1
a500 1
			if (oxygen_mode) {
d516 1
a516 1
		if (paired_images) {
d526 1
a526 1
	if (paired_images)
d547 1
a547 1
	strcpy (file1->mode, "w");
d552 1
a552 1
		exit (ERROR);
d558 1
a558 1
		exit (ERROR);
d562 1
a562 1
		exit (ERROR);
d570 1
a570 1
	if (prm.processing != PROC_NONE && !paired_images) {
d579 1
a579 1
	if (compute_sd) {
d581 1
a581 1
		strcpy (file1->mode, "w");
d585 1
a585 1
			exit (ERROR);
d592 1
a592 1
			exit (ERROR);
d596 1
a596 1
			exit (ERROR);
d606 1
a606 1
		strcpy (file1->mode, "w");
d610 1
a610 1
			exit (ERROR);
d617 1
a617 1
			exit (ERROR);
d621 1
a621 1
			exit (ERROR);
d624 1
d631 1
a631 1
	if (compute_sd)
@


2.32
log
@*** empty log message ***
@
text
@d2 3
d132 1
a132 1
static char     rcsid[] = "$Header: /home/npggw/tom/src/imean/RCS/imean.c,v 2.31 2001/12/20 19:16:57 tom Exp tom $";
d182 1
a182 1
	int             lstsize;
a666 1
	free_imgfile (file1);
d672 1
a672 1
	fclose (recfp);
@


2.31
log
@*** empty log message ***
@
text
@d2 3
d129 1
a129 1
static char     rcsid[] = "$Header: /home/npggw/tom/src/imean/RCS/imean.c,v 2.30 1999/12/16 18:08:47 tom Exp tom $";
d382 1
a382 1
		if ((img1 = rdtensor (scan1, &indx, pdim)) == NULL) {
d397 1
a397 1
			if ((flowimg = rdtensor (flow_scan1, &indx, pdim)) == NULL) {
d412 1
a412 1
			if ((volimg = rdtensor (vol_scan1, &indx, pdim)) == NULL) {
d463 1
a463 1
				if ((img2 = rdtensor (scan2, &indx, pdim)) == NULL) {
d478 1
a478 1
				if ((flowimg = rdtensor (flow_scan2, &indx, pdim)) == NULL) {
d493 1
a493 1
				if ((volimg = rdtensor (vol_scan2, &indx, pdim)) == NULL) {
d508 1
a508 1
				if ((img2 = rdtensor (scan2, &indx, pdim)) == NULL) {
d590 1
a590 1
	if (writetensor (file1, &indx, sumimg) == ERROR) {
d624 1
a624 1
		if (writetensor (file1, &indx, sdimage) == ERROR) {
d649 1
a649 1
		if (writetensor (file1, &indx, totwt) == ERROR) {
@


2.30
log
@new libs
@
text
@d2 3
d126 1
a126 1
static char     rcsid[] = "$Header: /home/npggw/tom/src/imean/RCS/imean.c,v 2.29 1999/12/15 18:58:48 tom Exp tom $";
d614 1
d639 1
a662 2
		for (j = 0; j < 6; j++)
			free (scan[i][j]);
@


2.29
log
@lint cleaning
@
text
@d2 3
d123 1
a123 1
static char     rcsid[] = "$Header: /home/npggw/tom/src/imean/RCS/imean.c,v 2.28 1999/11/26 18:59:23 tom Exp tom $";
@


2.28
log
@no hdr file created for paired (subtraction) images
@
text
@d2 3
d120 1
a120 1
static char     rcsid[] = "$Header: /home/npggw/tom/src/imean/RCS/imean.c,v 2.27 1999/10/12 13:25:01 tom Exp tom $";
d125 1
@


2.27
log
@new libimgutil with updated arc path
@
text
@d2 3
d117 1
a117 1
static char     rcsid[] = "$Header: /home/npggw/tom/src/imean/RCS/imean.c,v 2.26 1999/07/12 16:22:54 tom Exp tom $";
a121 1
#include <math.h>
a123 1
#include <nr.h>
d543 3
a545 1
	if (prm.processing == PROC_CBF)
d587 1
a587 1
	if (prm.processing != PROC_NONE) {
@


2.26
log
@use pixel dimensions of input image unless PETT VI
@
text
@d2 3
d114 1
a114 1
static char     rcsid[] = "$Header: /home/npggw/tom/src/imean/RCS/imean.c,v 2.25 1999/07/07 18:06:28 tom Exp tom $";
@


2.25
log
@check for firstimgfrm of each image
@
text
@d2 3
d111 1
a111 1
static char     rcsid[] = "$Header: /home/npggw/tom/src/imean/RCS/imean.c,v 2.24 1999/06/30 17:28:24 tom Exp tom $";
d301 2
a302 2
	pdim[0] = 128;
	pdim[1] = 128;
d304 4
@


2.24
log
@add PROC_ODIV
@
text
@d2 3
d108 1
a108 1
static char     rcsid[] = "$Header: /home/npggw/tom/src/imean/RCS/imean.c,v 2.23 1999/06/30 15:43:43 tom Exp tom $";
d133 1
d289 5
a293 7
	if (existimgfrm (file1, &indx) == ERROR) {
		indx.frm = 2;
		if (existimgfrm (file1, &indx) == ERROR) {
			fprintf (stderr, "ERROR [imean]: Cannot read scan %s frame %d\n", scan1, indx.frm);
			return (ERROR);
		}
	}
d355 3
d367 6
a372 1
			vol_scan1 = scan[i][2];
d379 9
d394 1
d433 6
a438 2
				flow_scan2 = scan[i][4];
				vol_scan2 = scan[i][5];
d445 9
d460 9
d475 1
d478 6
d490 1
a573 1

@


2.23
log
@process oef
@
text
@d2 3
d105 1
a105 1
static char     rcsid[] = "$Header: /home/npggw/tom/src/imean/RCS/imean.c,v 2.22 1998/12/04 20:44:09 tom Exp tom $";
d242 2
a243 1
	if (prm.processing == PROC_OEF || prm.processing == PROC_CMRO2) {
@


2.22
log
@move copyright to header
@
text
@d2 3
d102 1
a102 1
static char     rcsid[] = "$Header: /home/npggw/tom/src/imean/RCS/imean.c,v 2.21 1998/06/10 20:01:57 tom Exp tom $";
a107 1
#include <libnrimg.h>
d110 3
a113 1
#include <nrutil.h>
d124 1
a125 1
	FILE           *recfp;
d128 2
a130 1
	PARAMETER_DATA  prm;			 /* processing parameters */
a131 3
	BOOLEAN         oxygen;			 /* oxygen processing */
	BOOLEAN         paired_images;
	BOOLEAN         compute_sd = 0;
a132 5
	char            program[MAXFNAME];
	char            version[MAXFNAME];
	char            runstamp[40];	 /* version, date and userid info */

	char         ***imgname;		 /* image file names */
d136 1
d140 1
a140 1
	char           *recfile;
d144 7
a150 3
	char           *scan1, *scan2;		 /* filenames (activation, control primary files) */
	char           *cbfscan1, *cbvscan1; /* filenames (CBF, CBV for activation) */
	char           *cbfscan2, *cbvscan2; /* filenames (CBF, CBV for control) */
a152 1
	int             image_mode;
d162 1
a162 1
									  * element of atlas_image */
d168 4
a219 3
	sscanf (rcsid, "%s %s", program, version);
	strcat (program, " ");
	strcat (program, version);
d227 1
a227 1
 * Read parameters into prm
d239 10
d250 1
a250 1
 *  Read imagelist into imglist
d262 1
a262 5
/*
 *  Complete filenames
 */

	imgname = (char ***) malloc (lstsize * sizeof (char **));
d264 1
a264 1
		imgname[i] = (char **) malloc (6 * sizeof (char *));
d266 1
a266 1
			imgname[i][j] = (char *) malloc (MAXPATH);
a267 5
	if ((fillimglist (&prm, imglist, lstsize, filtmode, imgname)) == ERROR) {
		fprintf (stderr, "ERROR [imean]: Reading input list files\n");
		return (ERROR);
	}
/* Initializations based on selected parameters */
d269 1
a269 5
	if (prm.processing == PROC_OEF || prm.processing == PROC_CMRO2) {
		oxygen = TRUE;
		image_mode = MULTITRACER_IMAGE_MODE;
	} else
		oxygen = FALSE;
d271 1
a271 11
	if (strcmp (smg_mode, "paired") == 0)
		paired_images = TRUE;
	else
		paired_images = FALSE;

	if (strcmp (smg_mode, "diff") == 0)
		image_mode = DIFIMAGE_MODE;
	else
		image_mode = STDIMAGE_MODE;

	scan1 = imgname[0][0];
d331 1
a331 1
		scan1 = imgname[i][0];
d334 3
a336 3
		if (oxygen) {
			cbfscan1 = imgname[i][1];
			cbvscan1 = imgname[i][2];
d338 3
a340 3
				scan2 = imgname[i][3];
				cbfscan2 = imgname[i][4];
				cbvscan2 = imgname[i][5];
d343 1
a343 1
			scan2 = imgname[i][1];
d356 5
a360 5
		if (oxygen) {
			cbfscan1 = imgname[i][1];
			cbvscan1 = imgname[i][2];
			if ((flowimg = rdtensor (cbfscan1, &indx, pdim)) == NULL) {
				fprintf (stderr, "ERROR [imean]: Cannot read %s\n", cbfscan1);
d363 4
a366 4
			recout (recfp, cbfscan1);
			printf ("   CBF  = %s\n", cbfscan1);
			if ((volimg = rdtensor (cbvscan1, &indx, pdim)) == NULL) {
				fprintf (stderr, "ERROR [imean]: Cannot open %s\n", cbvscan1);
d369 2
a370 2
			recout (recfp, cbvscan1);
			printf ("   CBV  = %s\n", cbvscan1);
d372 1
a372 1
		if (image_mode == DIFIMAGE_MODE)
d386 1
a386 1
		if (oxygen) {
d388 1
a388 1
				    prm.processing, scan1, cbfscan1, cbvscan1, recfp, &hdr) > 0) {
d390 1
a390 1
					 cbfscan1, cbvscan1);
a399 1

d407 4
a410 4
			if (oxygen) {
				scan2 = imgname[i][3];
				cbfscan2 = imgname[i][4];
				cbvscan2 = imgname[i][5];
d417 2
a418 2
				if ((flowimg = rdtensor (cbfscan2, &indx, pdim)) == NULL) {
					fprintf (stderr, "ERROR [imean] Cannot read %s\n", cbfscan2);
d421 4
a424 4
				recout (recfp, cbfscan2);
				printf ("   CBF  = %s\n", cbfscan2);
				if ((volimg = rdtensor (cbvscan2, &indx, pdim)) == NULL) {
					fprintf (stderr, "ERROR [imean]: Cannot open %s\n", cbvscan2);
d427 2
a428 2
				recout (recfp, cbvscan2);
				printf ("   CBV  = %s\n", cbvscan2);
d430 1
a430 1
				scan2 = imgname[i][1];
d438 1
a438 1
			if (image_mode == DIFIMAGE_MODE)
d452 1
a452 1
			if (oxygen) {
d454 1
a454 1
				    prm.processing, scan2, cbfscan2, cbvscan2, recfp, &hdr) > 0) {
d456 1
a456 1
						 cbfscan2, cbvscan2);
d586 2
a587 2
			free (imgname[i][j]);
		free (imgname[i]);
d589 1
a589 1
	free (imgname);
@


2.21
log
@update calls to processPET
@
text
@d2 3
d94 3
d99 1
a99 1
static char     rcsid[] = "$Header: /home/npggw/tom/src/imean/RCS/imean.c,v 2.20 1997/01/08 22:47:32 tom Exp tom $";
a181 2
	printf ("Copyright 1991-1997, Washington University\n");
	printf ("All rights reserved. Unauthorized reproduction prohibited.\n");
@


2.20
log
@create sd and n images
use parameters: smg_divisor, smg_included, smg_sdimage, smg_nimage
use weights from imagelist
@
text
@d2 5
d93 1
a93 1
static char     rcsid[] = "$Header: /home/npggw/tom/src/imean/RCS/imean.c,v 2.19 1996/12/26 19:03:58 tom Exp tom $";
d403 3
a405 11
		} else {
			if (prm.processing != PROC_NONE) {
				if (readhdr (scan1, &hdr, recfp) == ERROR) {
					fprintf (stderr, "ERROR [imean] processing %s\n", scan1);
					return (ERROR);
				}
			}
			if (processPET (img1, pdim, scaler, prm.processing, &hdr) > 0) {
				fprintf (stderr, "ERROR [imean] processing %s\n", scan1);
				return (ERROR);
			}
d456 1
a456 1
			fprintf (recfp, "Scale %s by %f\n", scan1, scaler);
d462 2
a463 2
				    prm.processing, scan1, cbfscan1, cbvscan1, recfp, &hdr) > 0) {
					fprintf (stderr, "ERROR [imean] processing %s %s %s\n", scan1,
d470 3
a472 11
			} else {
				if (prm.processing != PROC_NONE) {
					if (readhdr (scan1, &hdr, recfp) == ERROR) {
						fprintf (stderr, "ERROR [imean] processing %s\n", scan1);
						return (ERROR);
					}
				}
				if (processPET (img2, pdim, scaler, prm.processing, &hdr) > 0) {
					fprintf (stderr, "ERROR [imean] processing %s\n", scan1);
					return (ERROR);
				}
@


2.19
log
@correct bug in computing paired difference images (mean and order)
@
text
@d2 3
d76 1
a76 1
 *		composite image     (ECAT image format)
d85 1
d88 1
a88 1
static char     rcsid[] = "$Header: /home/npggw/tom/src/imean/RCS/imean.c,v 2.18 1996/11/12 16:25:41 tom Exp tom $";
a106 1
	void            image_sub ();
d108 1
d111 1
a111 1
	ImageFile      *file1;	 		 /* input image file structure */
d118 1
d128 3
d138 1
a138 1
	int             pdim[3];			 /* image dimensions in pixels */
d145 2
d148 3
d157 1
a157 1
 *	parameters read from prm file
d162 4
d171 1
a171 1
	printf ("Copyright 1991-1996, Washington University\n");
d183 1
a183 1
	sprintf (runstamp, "%s %s %s %s %s %s", argv[n], argv[n+1], argv[n+2], argv[n+4], argv[n+5], argv[n+7]);
d187 14
d223 2
a224 1
	if (getprms_imean (prmfile, &smg_norm, smg_mode) == ERROR) {
d286 1
a286 1
			fprintf (stderr, "ERROR [imean]: Cannot read frame %d\n", scan1, indx.frm);
d300 1
a300 1
		fprintf (stderr, "ERROR [imean]: Cannot malloc composite image%s\n");
d303 12
a314 4
	for (k = 1; k <= pdim[2]; k++)
		for (j = 1; j <= pdim[1]; j++)
			for (i = 1; i <= pdim[0]; i++)
				sumimg[k][j][i] = 0.;
d316 11
d334 2
d390 1
a390 1
					   prm.processing, scan1, cbfscan1, cbvscan1, recfp, &hdr) > 0) {
a411 1
 *	Sum non-paired images, otherwise
d413 1
d417 1
a417 5
		if (!paired_images) {
			image_sum (sumimg, img1, pdim);
			free_f3tensor (img1, 1, pdim[2], 1, pdim[1], 1, pdim[0]);

		} else {
d465 1
a465 1
					  prm.processing, scan1, cbfscan1, cbvscan1, recfp, &hdr) > 0) {
d474 2
a475 2
				if (readhdr (scan1, &hdr, recfp) == ERROR) {
					if (prm.processing != PROC_NONE) {
d485 4
a488 2
			image_sub (img1, img2, pdim);
			image_sum (sumimg, img1, pdim);
a489 1
			free_f3tensor (img2, 1, pdim[2], 1, pdim[1], 1, pdim[0]);
a491 1

a496 1
	scaler = 1. / (float) lstsize;
d498 1
a498 1
		scaler *= SCALE_CBF;
d500 1
a500 1
		scaler *= SCALE_CBV;
d502 1
a502 1
		scaler *= SCALE_OEF;
d504 4
a507 2
		scaler *= SCALE_CMRO2;
	image_scale (sumimg, pdim, scaler);
d511 1
a511 1
	    	(prm.first_slice > 1 || prm.last_slice < pdim[2]))
a513 1

d518 1
a518 1
	printf ("Writing composite image %s, frame %d\n", outfile, indx.frm);
d525 2
a526 1
	if (put_mh (file1) == ERROR)
d528 3
a530 1
	if (writetensor (file1, &indx, sumimg) == ERROR)
d532 2
d546 48
d598 3
@


2.18
log
@set flip flag in output image!
@
text
@d2 3
d84 1
a84 1
static char     rcsid[] = "$Header: /home/npggw/tom/src/imean/RCS/imean.c,v 2.17 1996/11/06 17:20:59 tom Exp tom $";
d405 1
a405 1
			} else if (imglist[i].mean1 == 0) {
d409 1
a409 1
				scaler = smg_norm / imglist[i].mean1;
d436 2
a437 2
			image_sub (img2, img1, pdim);
			image_sum (sumimg, img2, pdim);
@


2.17
log
@add scaling for processed images
@
text
@d2 3
d81 1
a81 1
static char     rcsid[] = "$Header: /home/npggw/tom/src/imean/RCS/imean.c,v 2.16 1996/10/16 16:38:48 tom Exp tom $";
d472 1
@


2.16
log
@sync with Version
new libimage
@
text
@d2 4
d78 1
a78 1
static char     rcsid[] = "$Header: /home/npggw/tom/src/imean/RCS/imean.c,v 2.12 1996/09/17 18:30:30 tom Exp tom $";
d443 8
@


2.12
log
@add hdr to processOxygen
@
text
@d2 3
d74 1
a74 1
static char     rcsid[] = "$Header: /home/npggw/tom/src/imean/RCS/imean.c,v 2.11 1996/09/17 17:31:30 tom Exp tom $";
@


2.11
log
@pass hdr to processOxygen
@
text
@d2 3
d71 1
a71 1
static char     rcsid[] = "$Header: /home/npggw/tom/src/imean/RCS/imean.c,v 2.10 1996/08/30 17:12:04 tom Exp tom $";
d403 1
a403 1
					  prm.processing, scan1, cbfscan1, cbvscan1, recfp) > 0) {
d465 1
a465 1
		if (writehdr (hdr, outfile, userid, today, prm.processing, (short) pdim[2]) == ERROR) {
@


2.10
log
@option -z
@
text
@d2 3
d68 1
a68 1
static char     rcsid[] = "$Header: /home/npggw/tom/src/imean/RCS/imean.c,v 2.9 1996/08/30 16:02:41 tom Exp tom $";
d321 1
a321 1
					   prm.processing, scan1, cbfscan1, cbvscan1, recfp) > 0) {
@


2.9
log
@remove image_mask option
@
text
@d2 3
d65 1
a65 1
static char     rcsid[] = "$Header: /home/npggw/tom/src/imean/RCS/imean.c,v 2.8 1996/08/26 18:19:58 tom Exp tom $";
d105 1
d116 1
d137 1
a137 1
	if (argc != 13) {
d145 3
a147 1
	sprintf (runstamp, "%s %s %s %s %s %s", argv[5], argv[6], argv[7], argv[9], argv[10], argv[12]);
d432 5
a436 5
/*	REMOVE OPTION TO ZERO SLICES
	if (prm.first_slice > 0 && prm.last_slice > 0 &&
	    (prm.first_slice > 1 || prm.last_slice < pdim[2]))
		image_mask (sumimg, pdim, prm.first_slice, prm.last_slice);
 */
@


2.8
log
@new libimage with wrimg7 & wrimg6 fixed for scaling
@
text
@d2 3
d62 1
a62 1
static char     rcsid[] = "$Header: /home/npggw/tom/src/imean/RCS/imean.c,v 2.7 1996/08/22 17:33:04 tom Exp tom $";
d425 1
d429 1
@


2.7
log
@new libimage
@
text
@d2 3
d59 1
a59 1
static char     rcsid[] = "$Header: /home/npggw/tom/src/imean/RCS/imean.c,v 2.6 1996/08/05 18:05:03 tom Exp tom $";
@


2.6
log
@new libimage and libnrimg
@
text
@d2 3
d56 1
a56 1
static char     rcsid[] = "$Header: /home/npggw/tom/src/imean/RCS/imean.c,v 2.5 1996/06/21 15:40:23 tom Exp tom $";
@


2.5
log
@change libimgutil to permit non-physiological OEF values
@
text
@d2 3
d53 1
a53 1
static char     rcsid[] = "$Header: /home/petsun19/tom/src/imean/RCS/imean.c,v 2.4 1996/06/13 22:01:43 tom Exp tom $";
@


2.4
log
@fixed bug in processOxygen in libimgutil.a
@
text
@d2 3
d50 1
a50 1
static char     rcsid[] = "$Header: /home/petsun19/tom/src/imean/RCS/imean.c,v 2.2 1996/05/24 18:16:52 tom Exp tom $";
@


2.2
log
@new libimage, libnrimg
@
text
@d2 3
d47 1
a47 1
static char     rcsid[] = "$Header: /home/petsun19/tom/src/imean/RCS/imean.c,v 2.1 1996/04/29 13:59:50 tom Exp tom $";
@


2.1
log
@fix bug in paired image calculation
@
text
@d2 3
d44 1
a44 1
static char     rcsid[] = "$Header: /home/petsun19/tom/src/imean/RCS/imean.c,v 2.0 1996/04/24 23:05:51 tom Exp tom $";
@


2.0
log
@new library release
@
text
@d2 3
d41 1
a41 1
static char     rcsid[] = "$Header: /home/npggw/tom/src/imean/RCS/imean.c,v 1.1 1994/10/12 20:22:49 tom Exp tom $";
d312 2
a313 1
 *	Read and process second (control) image (for paired lists)
d317 5
a321 1
		if (paired_images) {
d390 2
a393 2
		image_sum (sumimg, img1, pdim);
		free_f3tensor (img1, 1, pdim[2], 1, pdim[1], 1, pdim[0]);
@


1.1
log
@Initial revision
@
text
@d1 4
a4 1
/* $Log$
d8 1
a8 1
 *	Date:			12-Oct-94
d22 1
a22 1
 *		image list      (imagelist (5))
d34 2
d38 1
d43 7
a49 7
#include <fcntl.h>
#include <petutil/matrix.h>
#include <petutil/package.h>	/* BOOLEAN */
#include <petutil/petutil.h>	/* SXR_OUTPUT */
#include <petutil/imglist.h>	/* IMAGE_LIST_DATA, MAXPATH */
#include "imean.h"
#define  EARLY_EXIT	3	/* exit status to delete the rec file */
a50 9
static char     rcsid[] = "$Header$";
char            list[] = "*;*;*;*";	/* any frame plane gate bed */

REAL_SLICE     *composite_image;/* composite image */

/*	----------------------------
 *	Function:	imean
 *	----------------------------
 */
d55 1
a55 1
	void            get_input_lists ();
d57 1
a59 4
	Image_subheader **subheader;
	Main_header    *main_header;
	MatrixFile     *fptr;
	FILE           *listfp;
d61 7
a67 3
	PARAMETER_DATA  parameter_data;
	IMAGE_LIST_DATA *image_list;
	HEADER_DATA    *hdr;	/* hdr structure */
d69 5
a73 4
	BOOLEAN         encoded_flag;
	BOOLEAN         paired_images = 0;
	BOOLEAN         oxygen_mode = 0;
	COMMENT_INFO    comment_info_data;
a77 2
	char           *ext;
	char            date[40];
d80 4
a83 6
	char           *activation_scan;
	char           *control_scan;
	char           *flow_scan1;
	char           *vol_scan1;
	char           *flow_scan2;
	char           *vol_scan2;
d86 8
a93 18
	int             filter_mode;
	int             fd;
	int             i, j, k, m;	/* array indices */
	float           scaler;	/* scale individual PET images */
	float           pixel_size;
	float           plane_separation;
	float           default_pixel_size;
	float           default_plane_separation;
	int             scanner;/* 6 = PETT VI;  10 = 953B */
	short           nx;
	short           ny;
	short           num_slices;
	struct Matval   matval;
	REAL_SLICE     *image1;	/* first (activation) PET image */
	REAL_SLICE     *image2;	/* second (control) PET image */
	REAL_SLICE     *image3;	/* flow PET image for oxygen processing */
	REAL_SLICE     *image4;	/* volume PET image for oxygen processing */
	SCANLIST_ARRAY *scan;
a100 1
	char            processing[10];
a101 8
	matval.frame = 1;	/* default values for matval */
	matval.plane = 1;
	matval.gate = 1;
	matval.data = 0;
	matval.bed = 0;

	filter_mode = IMGFILTER_MODE;

a103 1
 *	---------------------------------------------------
d106 1
a106 1
	printf ("Copyright 1991-1994, Washington University\n");
d110 1
a110 1
		exit (FAIL);
d116 1
a116 1
	sprintf (date, "%s %s %s %s %s %s", argv[5], argv[6], argv[7], argv[8], argv[9], argv[10]);
d122 2
a123 2
		fprintf (stderr, "Error: cannot open %s\n", recfile);
		exit (FAIL);
d125 9
d135 1
a135 2
 *	Read imagelist into structure image_list
 *	----------------------------------------
d138 11
a148 1
	image_list = (IMAGE_LIST_DATA *) malloc (sizeof (IMAGE_LIST_DATA) * MAX_IMAGE_LIST_SIZE);
d150 4
a153 3
	if (readimglist (lstfile, image_list, &lstsize) == FAIL) {
		fprintf (stderr, "Error: reading %s\n", lstfile);
		exit (FAIL);
d155 4
d160 1
a160 2
 *	Read parameters into structure parameter_data
 *	---------------------------------------------
d163 11
a173 1
	scan = (SCANLIST_ARRAY *) malloc (lstsize * sizeof (SCANLIST_ARRAY));
d175 6
a180 4
	if (getprms_imean (prmfile, &smg_norm, processing, smg_mode) == FAIL) {
		fprintf (stderr, "Error: reading parameter file %s\n", prmfile);
		exit (FAIL);
	}
d182 3
a184 1
		paired_images = 1;
d186 1
a186 4
	if ((strcmp (processing, "oef") == 0) || (strcmp (processing, "cmro2") == 0)) {
		oxygen_mode = 1;
		image_mode = MULTITRACER_IMAGE_MODE;
	} else if (strcmp (smg_mode, "diff") == 0)
d191 25
a215 5
/*
 *	Construct full path names in scan
 */
	get_input_lists (prmfile, lstfile, lstsize, image_mode, filter_mode, scan,
			 &parameter_data, image_list);
d217 8
a224 2
	main_header = (Main_header *) calloc (1, sizeof (Main_header));
	hdr = (HEADER_DATA *) malloc (sizeof (HEADER_DATA));
d232 4
a235 4
		activation_scan = scan[i][0];
		if (oxygen_mode) {
			flow_scan1 = scan[i][1];
			vol_scan1 = scan[i][2];
d237 3
a239 3
				control_scan = scan[i][3];
				flow_scan2 = scan[i][4];
				vol_scan2 = scan[i][5];
d242 1
a242 1
			control_scan = scan[i][1];
a244 41
 *	First image, first time -- get scanner and dimensions; zero arrays (composite_image)
 *	------------------------------------------------------------------
 */
		if (i == 0) {
			fd = open (activation_scan, O_RDONLY, 0);
			if (fd == -1) {
				fprintf (stderr, "Error opening %s\n", activation_scan);
				exit (FAIL);
			}
			scanner = getimage_type (fd, activation_scan, &encoded_flag, &num_slices);
			close (fd);
			if (scanner == ERROR_SCANNER) {
				fprintf (stderr, "Error: file is not a recognized PET image\n");
				exit (FAIL);
			}
			if (scanner == ECAT_SCANNER) {
				fptr = OpenEcat (activation_scan, &num_slices, &nx, &ny, &pixel_size,
						 &plane_separation, matval);
				if (fptr == (MatrixFile *) NULL) {
					fprintf (stderr, "Error: cannot open %s as an ECAT image file\n", activation_scan);
					exit (FAIL);
				}
				matrix_close (fptr);
			} else {
				nx = DIM;
				ny = DIM;
				pixel_size = 0.286;
				plane_separation = 1.44;
			}

			image1 = (REAL_SLICE *) calloc (num_slices, sizeof (REAL_SLICE));
			if (paired_images)
				image2 = (REAL_SLICE *) calloc (num_slices, sizeof (REAL_SLICE));
			if (oxygen_mode) {
				image3 = (REAL_SLICE *) calloc (num_slices, sizeof (REAL_SLICE));
				image4 = (REAL_SLICE *) calloc (num_slices, sizeof (REAL_SLICE));
			}
			subheader = (Image_subheader **) malloc (num_slices * sizeof (caddr_t));
			composite_image = (REAL_SLICE *) calloc (num_slices, sizeof (REAL_SLICE));
		}
/*
d248 6
a253 8
		if (oxygen_mode) {
			if (getrealimg (flow_scan1, scanner, matval, nx, ny, num_slices, image3,
					main_header, subheader) == FAIL) {
				fprintf (stderr, "Error reading %s\n", flow_scan1);
				exit (FAIL);
			}
			recout (recfp, flow_scan1);
			printf ("Flow = %s\n", flow_scan1);
d255 6
a260 4
			if (getrealimg (vol_scan1, scanner, matval, nx, ny, num_slices, image4,
					main_header, subheader) == FAIL) {
				fprintf (stderr, "Error reading %s\n", vol_scan1);
				exit (FAIL);
d262 8
a269 2
			recout (recfp, vol_scan1);
			printf ("Vol  = %s\n", vol_scan1);
a270 8
		if (getrealimg (activation_scan, scanner, matval, nx, ny, num_slices, image1,
				main_header, subheader) == FAIL) {
			fprintf (stderr, "Error reading %s\n", activation_scan);
			exit (FAIL);
		}
		recout (recfp, activation_scan);
		printf ("Activation  = %s\n", activation_scan);

d274 5
a278 5
			fprintf (stderr, "Error: Parameter smg_norm in parameter list is 0\n");
			exit (FAIL);
		} else if (image_list[i].mean1 == 0) {
			fprintf (stderr, "Error: Normalization factor in image list is 0\n");
			exit (FAIL);
d280 2
a281 2
			scaler = smg_norm / image_list[i].mean1;
		fprintf (recfp, "Scale %s by %f\n", activation_scan, scaler);
d283 8
a290 6
		if (oxygen_mode) {
			if (process_oxygen (image1, image3, image4, nx, ny, num_slices, scaler,
			    processing, activation_scan, flow_scan1, vol_scan1, recfp, hdr) > 0) {
				fprintf (stderr, "Error processing %s %s %s\n", activation_scan,
					 flow_scan1, vol_scan1);
				exit (FAIL);
d292 14
a305 4
		} else if (process_pet (image1, nx, ny, num_slices, scaler, processing,
					activation_scan, recfp, hdr) > 0) {
			fprintf (stderr, "Error processing %s\n", activation_scan);
			exit (FAIL);
d307 1
d314 7
a320 5
			if (oxygen_mode) {
				if (getrealimg (flow_scan2, scanner, matval, nx, ny, num_slices, image3,
						main_header, subheader) == FAIL) {
					fprintf (stderr, "Error reading %s\n", flow_scan2);
					exit (FAIL);
d322 5
a326 7
				recout (recfp, flow_scan2);
				printf ("Flow = %s\n", flow_scan2);

				if (getrealimg (vol_scan2, scanner, matval, nx, ny, num_slices, image4,
						main_header, subheader) == FAIL) {
					fprintf (stderr, "Error reading %s\n", vol_scan2);
					exit (FAIL);
d328 16
a343 2
				recout (recfp, vol_scan2);
				printf ("Vol  = %s\n", vol_scan2);
a344 8
			if (getrealimg (control_scan, scanner, matval, nx, ny, num_slices, image2,
					main_header, subheader) == FAIL) {
				fprintf (stderr, "Error reading %s\n", control_scan);
				exit (FAIL);
			}
			recout (recfp, control_scan);
			printf ("Control  = %s\n", control_scan);

d347 6
a352 3
			else if (image_list[i].mean2 == 0) {
				fprintf (stderr, "Error: Normalization factor in image list is 0\n");
				exit (FAIL);
d354 2
a355 2
				scaler = smg_norm / image_list[i].mean2;
			fprintf (recfp, "Scale %s by %f\n", control_scan, scaler);
d357 8
a364 6
			if (oxygen_mode) {
				if (process_oxygen (image2, image3, image4, nx, ny, num_slices, scaler,
				processing, control_scan, flow_scan2, vol_scan2, recfp, hdr) > 0) {
					fprintf (stderr, "Error processing %s %s %s\n", control_scan,
						 flow_scan2, vol_scan2);
					exit (FAIL);
d366 14
a379 4
			} else if (process_pet (image2, nx, ny, num_slices, scaler, processing,
						control_scan, recfp, hdr) > 0) {
				fprintf (stderr, "Error processing %s\n", control_scan);
				exit (FAIL);
d381 2
a382 1
			image_diff (image1, image2, num_slices);
d384 2
a385 1
		image_sum (composite_image, image1, num_slices);
d387 1
a389 1
 *
a390 1
 *	--------------------------------------------
d393 2
a394 5
	image_scale (composite_image, num_slices, lstsize);
	strncpy (main_header->physician_name, &rcsid[9], sizeof (main_header->physician_name) - 1);
	strncpy (main_header->operator_name, date, sizeof (main_header->operator_name) - 1);
	comment_info (main_header->study_description, &comment_info_data);
	info2comment (comment_info_data, main_header->study_description);
d396 12
a407 3
	if (writerealimg (outfile, matval, DIM, DIM, num_slices, composite_image, main_header, subheader)
	    == FAIL) {
		fprintf (stderr, "Error writing %s\n", outfile);
d409 6
d420 3
a422 3
	if (strcmp (processing, "none") != 0) {
		if (writehdr (hdr, outfile, userid, today, processing, (short) num_slices) == FAIL) {
			fprintf (stderr, "Error writing hdr file\n");
d430 6
a435 10
	for (i = 0; i < num_slices; i++)
		free (subheader[i]);
	free (subheader);
	free (main_header);
	free (image1);
	if (paired_images)
		free (image2);
	if (oxygen_mode) {
		free (image3);
		free (image4);
d437 2
a438 3
	free (image_list);
	free (scan);
	free (hdr);
d440 1
a440 1
	exit (0);
@
