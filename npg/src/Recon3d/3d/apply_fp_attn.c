/*$Id: apply_fp_attn.c,v 1.2 1995/01/30 16:01:00 ty7777 Exp $*/
/*$Log: apply_fp_attn.c,v $
 * Revision 1.2  1995/01/30  16:01:00  ty7777
 * Added program version.
 **/

/* @(#)apply_fp_attn.c	1.3 6/14/91 */

#include <math.h>
#include "matrix.h"

/*
	This procedure reads sinograms normally processed by 'import_3dscan'
	and sinograms computed from forward projecting through the transmission
	volume and corrects the sinograms.  Attenuation sinograms are "zoomed"
	as necessary. Input arguments are:
		em3d.scn	- the imported 3d sinograms to be corrected
		attn.scn	- the forward projected attenuation scans
	A list of measured sinograms is expected from stdin. This list can be
	generated by the pipe :
		list_sinograms 5 | grep measured |
*/

#define max(a,b) ((a)>(b)?(a):(b))

static char rcsid [] = "$Header: /export/home/npggw/tom/src/recon3d/RCS/apply_fp_attn.c,v 1.2 1995/01/30 16:01:00 ty7777 Exp $";

static char *prgnam;

main( argc, argv)
  int argc;
  char **argv;
{
	MatrixFile *mptr1, *mptr2;
	MatrixData *scan=NULL, *attn=NULL;
	Scan_subheader *sh1, *sh2;
	short int *idata, *adata;
	float *fdata=NULL;
	int rd, matnum, nv, znum, nsinos;
	char flag[256];
	float zoff, phi;
	int nprojs, nviews, zoom;
	int np_attn, nv_attn;
	int i, j, k, l, view, v, w, a, b;

	prgnam = argv[0];
	if (argc<3)
	  crash( "usage: %s em3d.scn attn.scn\n", prgnam);
	mptr1 = matrix_open( argv[1], MAT_READ_WRITE, SCAN_DATA);
	if (!mptr1) matrix_perror( prgnam);
	mptr2 = matrix_open( argv[2], MAT_READ_ONLY, SCAN_DATA);
	if (!mptr2) matrix_perror( prgnam);
	nsinos = 0;
	while ((nv=scanf( "%d,%d,%f,%f,%d,%s %d,%d", &rd, &znum, &phi, &zoff, &matnum, flag, &a, &b))==8)
	{
		if (scan)
		{
		  free(scan->shptr);
		  free(scan->data_ptr);
		  free(scan);
		  free(attn->shptr);
		  free(attn->data_ptr);
		  free(attn);
		}
		scan = matrix_read( mptr1, matnum, MAT_WORD);
		if (!scan)
		  crash( "%s: %s,%d matrix missing\n", prgnam, argv[1], matnum);
		idata = (short int*) scan->data_ptr;
		sh1 = (Scan_subheader*) scan->shptr;
		nprojs = sh1->dimension_1;
		nviews = sh1->dimension_2;
		attn = matrix_read( mptr2, matnum, MAT_WORD);
		if (!attn)
		  crash( "%s: %s,%d matrix missing\n", prgnam, argv[2], matnum);
		sh2 = (Scan_subheader*) attn->shptr;
		np_attn = sh2->dimension_1;
		nv_attn = sh2->dimension_2;
		adata = (short int*) attn->data_ptr;
		if (!fdata)
		  fdata = (float*) malloc( nprojs*nviews*sizeof(float));
		for (view=0; view<nviews; view++)
		{
			v = view*nv_attn/nviews;
			for (j=0; j<nprojs; j++)
			{
			  k = j+view*nprojs;
			  w = j%(nprojs/np_attn);
			  l = j*np_attn/nprojs+v*np_attn;
			  fdata[k] = idata[k] * sh1->scale_factor * 
			    exp( sh2->sample_distance * sh2->scale_factor * 0.5* (adata[l]+adata[l+w]) );
			}
		}
		convert_float_scan( scan, fdata);
		matrix_write( mptr1, matnum, scan);
	}
	matrix_close( mptr1);
	matrix_close( mptr2);
}
