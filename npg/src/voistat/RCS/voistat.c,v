head	2.0;
access;
symbols;
locks; strict;
comment	@ * @;


2.0
date	2004.02.20.16.23.04;	author tom;	state Exp;
branches;
next	1.44;

1.44
date	2003.08.21.15.30.57;	author tom;	state Exp;
branches;
next	1.43;

1.43
date	2003.08.15.17.26.18;	author tom;	state Exp;
branches;
next	1.42;

1.42
date	2003.04.24.14.01.25;	author tom;	state Exp;
branches;
next	1.41;

1.41
date	2003.04.03.21.46.38;	author tom;	state Exp;
branches;
next	1.40;

1.40
date	2003.04.03.19.47.02;	author tom;	state Exp;
branches;
next	1.39;

1.39
date	2003.01.03.20.24.41;	author tom;	state Exp;
branches;
next	1.38;

1.38
date	2002.11.27.18.21.57;	author tom;	state Exp;
branches;
next	1.37;

1.37
date	2002.02.08.14.51.03;	author tom;	state Exp;
branches;
next	1.36;

1.36
date	2001.09.07.20.12.09;	author tom;	state Exp;
branches;
next	1.35;

1.35
date	2001.09.06.14.11.38;	author tom;	state Exp;
branches;
next	1.34;

1.34
date	2001.08.17.13.39.38;	author tom;	state Exp;
branches;
next	1.33;

1.33
date	2001.05.31.19.34.52;	author tom;	state Exp;
branches;
next	1.32;

1.32
date	2000.08.28.15.15.22;	author tom;	state Exp;
branches;
next	1.31;

1.31
date	2000.07.18.16.00.42;	author tom;	state Exp;
branches;
next	1.30;

1.30
date	99.12.17.16.19.58;	author tom;	state Exp;
branches;
next	1.29;

1.29
date	99.12.17.14.53.08;	author tom;	state Exp;
branches;
next	1.28;

1.28
date	99.10.12.13.53.09;	author tom;	state Exp;
branches;
next	1.27;

1.27
date	99.07.15.15.45.25;	author tom;	state Exp;
branches;
next	1.26;

1.26
date	98.06.02.16.33.21;	author tom;	state Exp;
branches;
next	1.25;

1.25
date	98.05.27.19.09.04;	author tom;	state Exp;
branches;
next	1.24;

1.24
date	98.05.27.15.45.22;	author tom;	state Exp;
branches;
next	1.23;

1.23
date	98.02.02.15.22.07;	author tom;	state Exp;
branches;
next	1.22;

1.22
date	97.06.02.20.58.12;	author tom;	state Exp;
branches;
next	1.21;

1.21
date	97.03.28.15.49.22;	author tom;	state Exp;
branches;
next	1.20;

1.20
date	97.03.19.22.34.31;	author tom;	state Exp;
branches;
next	1.19;

1.19
date	97.03.10.16.31.57;	author tom;	state Exp;
branches;
next	1.18;

1.18
date	96.11.22.16.04.41;	author tom;	state Exp;
branches;
next	1.17;

1.17
date	96.11.06.17.52.45;	author tom;	state Exp;
branches;
next	1.16;

1.16
date	96.10.30.22.16.29;	author tom;	state Exp;
branches;
next	1.15;

1.15
date	96.10.22.22.10.24;	author tom;	state Exp;
branches;
next	1.14;

1.14
date	96.10.16.17.25.14;	author tom;	state Exp;
branches;
next	1.10;

1.10
date	96.10.03.20.44.01;	author tom;	state Exp;
branches;
next	1.9;

1.9
date	96.09.05.16.23.29;	author tom;	state Exp;
branches;
next	1.8;

1.8
date	96.08.05.14.30.52;	author tom;	state Exp;
branches;
next	1.7;

1.7
date	96.07.19.15.40.25;	author tom;	state Exp;
branches;
next	1.6;

1.6
date	96.05.24.17.39.16;	author tom;	state Exp;
branches;
next	1.5;

1.5
date	96.05.17.20.32.04;	author tom;	state Exp;
branches;
next	1.4;

1.4
date	96.04.26.21.09.46;	author tom;	state Exp;
branches;
next	1.3;

1.3
date	96.04.26.15.52.53;	author tom;	state Exp;
branches;
next	1.2;

1.2
date	96.04.25.20.48.58;	author tom;	state Exp;
branches;
next	1.1;

1.1
date	96.04.25.16.16.01;	author tom;	state Exp;
branches;
next	;


desc
@initial release
@


2.0
log
@Feb 2004
@
text
@/*	$Log: voistat.c,v $
 * Revision 1.44  2003/08/21  15:30:57  tom
 * 21Aug2003
 *
 * Revision 1.43  2003/08/15  17:26:18  tom
 * don't quit if a frame is unreadable
 *
 * Revision 1.42  2003/04/24  14:01:25  tom
 * add option to use frame 2 as default start time without prompting
 *
 * Revision 1.41  2003/04/03  21:46:38  tom
 * *** empty log message ***
 *
 * Revision 1.40  2003/04/03  19:47:02  tom
 * change start time prompt
 *
 * Revision 1.39  2003/01/03  20:24:41  tom
 * write zerotime to stdout instead of passing in return
 *
 * Revision 1.38  2002/11/27  18:21:57  tom
 * *** empty log message ***
 *
 * Revision 1.37  2002/02/08  14:51:03  tom
 * modify Reading message
 *
 * Revision 1.36  2001/09/07  20:12:09  tom
 * fprintf
 *
 * Revision 1.35  2001/09/06  14:11:38  tom
 * eliminate "Reading" message for each frame
 *
 * Revision 1.34  2001/08/17  13:39:38  tom
 * return zerotime
 *
 * Revision 1.33  2001/05/31  19:34:52  tom
 * read version number correctly
 *
 * Revision 1.32  2000/08/28  15:15:22  tom
 * check file->name == NULL
 *
 * Revision 1.31  2000/07/18  16:00:42  tom
 * *** empty log message ***
 *
 * Revision 1.30  1999/12/17  16:19:58  tom
 * lint cleaning
 *
 * Revision 1.29  1999/12/17  14:53:08  tom
 * lint cleaning
 *
 * Revision 1.28  1999/10/12  13:53:09  tom
 * new libimgutil with updated arc path
 * cleanup some code with lin
 *
 * Revision 1.27  1999/07/15  15:45:25  tom
 * old and new sphere options
 *
 * Revision 1.26  1998/06/02  16:33:21  tom
 * correct order of free_imgfile in loop
 *
 * Revision 1.25  1998/05/27  19:09:04  tom
 * voi_order = 1 will compute regional means before metabolic values
 * voi_order = 0 (default) will compute metabolic images before regional means
 *
 * Revision 1.23  1998/02/02  15:22:07  tom
 * new buildnames in libimgutil.a
 *
 * Revision 1.22  1997/06/02  20:58:12  tom
 * add voi_zero_chk to average.c
 *
 * Revision 1.21  1997/03/28  15:49:22  tom
 * changed some error messages
 *
 * Revision 1.20  1997/03/19  22:34:31  tom
 * add -atlas and map file option
 *
 * Revision 1.19  1997/03/10  16:31:57  tom
 * read frame 1,2 or 3
 *
 * Revision 1.18  1996/11/22  16:04:41  tom
 * add oxygen processing of single images when ntype > 10
 *
 * Revision 1.17  1996/11/06  17:52:45  tom
 * new libimgutil with correct scaling of cmro2 and oef images
 *
 * Revision 1.16  1996/10/30  22:16:29  tom
 * fix processing of tissue activity
 * new libimgutil with corrected processPET.c
 *
 * Revision 1.15  1996/10/22  22:10:24  tom
 * change call to processPET
 * alloc of rgtlist
 *
 * Revision 1.14  1996/10/16  17:25:14  tom
 * sync with Version
 * new libimage
 *
 * Revision 1.10  1996/10/03  20:44:01  tom
 * change average.c
 *
 * Revision 1.9  1996/09/05  16:23:29  tom
 * new libimage
 * .,
 *
 * Revision 1.8  1996/08/05  14:30:52  tom
 * new libimage & libnrimg
 *
 * Revision 1.7  1996/07/19  15:40:25  tom
 * only look for hdr if processing != none
 *
 * Revision 1.6  1996/05/24  17:39:16  tom
 * new libimage and libnrimg
 *
 * Revision 1.5  1996/05/17  20:32:04  tom
 * revised libimgutil.a
 *
 * Revision 1.4  1996/04/26  21:09:46  tom
 * revised readvoi.c and writergt.c
 *
 * Revision 1.3  1996/04/26  15:52:53  tom
 * changed structure of rgtlist
 *
 * Revision 1.2  1996/04/25  20:48:58  tom
 * eliminate prompt for zerotime except for decay-corrected on non-corrected processing
 *
 * Revision 1.1  1996/04/25  16:16:01  tom
 * Initial revision
 * */
/* ===============================================================================
 *	Module:			voistat.c
 *	Date:			Apr 1996
 *	Author:			Tom Videen
 *	Description:	Compute mean values for a list of VOIs.
 *	History:
 *		Revised version of voimean (Tom Yang 02/21/94)
 *	Notes:
 *		No explicit memory freed during early return (ERROR).
 * ===============================================================================
 */
static char     rcsid[] = "$Header: /home/npggw/tom/src/voistat/RCS/voistat.c,v 1.44 2003/08/21 15:30:57 tom Exp tom $";

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <imgutil.h>
#include <voistat.h>
#include <nrutil.h>
#include <image.h>
#include <libimage.h>
#include <libnrimg.h>

#define MAXLIST 2000

main (argc, argv)
	int             argc;
	char          **argv;
{
	ImageFile      *file1;
	Index           indx;			 /* frame, plane, gate, data, bed */
	int             named_voi;		 /* VOI file named on command line input */
	int             oxygen;			 /* oxygen processing */
	int             nohdr;			 /* no hdr file exists */
	int             atlas;			 /* compute atlas coordinates */
	int             start;			 /* prompt for zerotime */
	IMAGE_LIST_DATA *imglist;		 /* list of files to process */
	PARAMETER_DATA  prm;			 /* processing parameters */
	RGTDATA        *rgtlist;		 /* list of region processing output */
	VOIDATA        *voilist;		 /* list of VOI definitions */
	HEADER_DATA     hdr;			 /* hdr structure */
	HEADER_DATA     hohdr;			 /* hdr structure */
	HEADER_DATA     ochdr;			 /* hdr structure */
	int             getorigin ();
	char            maxfile[MAXPATH];
	char            date[MAXLINE];
	char            program[MAXFNAME];
	char            version[MAXFNAME];
	char           *fname0, *fname1, *fname2;/* filenames (primary, CBF, CBV) */
	char           *regfile;		 /* region file */
	char           *lstfile;		 /* input imglist file */
	char           *prmfile;		 /* input parameter file */
	char           *rgtfile;		 /* output RGT file (means) */
	char           *sdfile;			 /* output SD file (standard devs) */
	FILE           *recfp;			 /* rec file (/dev/null) */
	char           *uid;
	char           *ptr;			 /* string to extract filename */
	char            ext[MAXFNAME];	 /* extension for map files */
	char         ***imgname;		 /* image file names */
	char          **mapfile;		 /* map filenames */
	float        ***img;			 /* primary image */
	float        ***flowimg;		 /* CBF image (for oxygen processing) */
	float        ***volimg;			 /* CBV image (for oxygen processing) */
	float         **map;			 /* conversion matrix Atlas -> PET   */
	float           scaler;			 /* normalization scaling factor */
	float           adim[3];		 /* voxel dimensions in mm */
	float           framelen;		 /* frame duration (sec) */
	float           framestart;		 /* frame start time (sec) */
	float           frametime;		 /* frame start time (sec) */
	float           zerotime;		 /* start time relative to time of frame 1 */
	float           pettconv;		 /* PET conversion factor */
	float           cnts;			 /* mean regional PET counts */
	float           flowcnts;		 /* mean regional PET counts */
	float           volcnts;		 /* mean regional PET counts */
	float           sd;			 	 /* SD */
	float           flowsd;			 /* SD */
	float           volsd;			 /* SD */
	int             nfrm;			 /* z-origin used to create map file */
	int             z0;				 /* z-origin used to create map file */
	int             pdim[3];		 /* image dimensions in pixels (128x128) */
	int             nvoi_max;		 /* maximum number of VOIs */
	int             lstsize = 0;	 /* number of entries in image list */
	int             nvoi = 0;		 /* number of VOIs */
	int             npixels;		 /* number of pixels in VOI */
	int             pixused = 0;	 /* actual number of pixels used in computation */
	int             firstfrm;		 /* first valid frame */
	int             filtmode = IMGFILTER_MODE;
	int             i, j, k, n;
	int             flag;			 /* read hdrs once */
	int             sampled = 1;	 /* 1 => frame exists */
	long            ztime = 0;		 /* zerotime in msec */

/*
 * Get command line arguments.
 */
	if (argc != 15) {
		fprintf (stderr, "Usage: voistat prm lst rgt sd voi atlas start date uid\n");
		return (ERROR);
	}
	prmfile = argv[1];
	lstfile = argv[2];
	rgtfile = argv[3];
	sdfile = argv[4];
	if ((strncmp (argv[5], "NULL", 4)) == 0) {
		named_voi = 0;
		regfile = (char *) malloc (MAXPATH * sizeof(char));
		if (regfile == NULL) return (ERROR);
	} else {
		named_voi = 1;
		regfile = argv[5];
	}
	map = matrix (1, 4, 1, 4);
	if (atoi (argv[6]) == 0)
		atlas = FALSE;
	else {
		atlas = TRUE;
		(void) strcpy (ext, MAP_EXT);
	}
	if (atoi (argv[7]) == 0)
		start = FALSE;
	else
		start = TRUE;
	n = 8;
	(void) sprintf (date, "%s %s %s %s %s %s",
			argv[n], argv[n + 1], argv[n + 2], argv[n + 3], argv[n + 4], argv[n + 5]);
	uid = argv[n + 6];

	recfp = fopen ("/dev/null", "w");
	if (recfp == NULL) {
		fprintf (stderr, "ERROR [voistat]: Cannot open /dev/null\n");
		return (ERROR);
	}
	(void) sscanf (rcsid, "$Header: %s %s", program, version);
	(void) strcat (program, " ");
	(void) strcat (program, version);
	indx.frm = 1;
	indx.pln = 1;
	indx.gate = 1;
	indx.data = 0;
	indx.bed = 0;
	nvoi_max = 0;
	npixels = 0;
	z0 = 0;
	nohdr = FALSE;
	rgtlist = (RGTDATA *) malloc (MAXLIST * sizeof (RGTDATA));
	if (rgtlist == NULL) return (ERROR);

/*
 *  Read imagelist into structure imglist
 */

	imglist = (IMAGE_LIST_DATA *) malloc (MAXLIST * sizeof (IMAGE_LIST_DATA));
	if (imglist == NULL) return (ERROR);
	if (readmaplist (lstfile, imglist, &lstsize) == ERROR) {
		fprintf (stderr, "ERROR [voistat]: Cannot read %s\n", lstfile);
		return (ERROR);
	}
	if (lstsize > MAXLIST) {
		fprintf (stderr, "ERROR [voistat]: imglist size %d > %d\n", lstsize, MAXLIST);
		return (ERROR);
	}
/*
 *  Read parameters into structure prm and get image filenames
 */

	imgname = (char ***) malloc (lstsize * sizeof (char **));
	if (imgname == NULL) return (ERROR);
	for (i = 0; i < lstsize; i++) {
		imgname[i] = (char **) malloc (6 * sizeof (char *));
		if (imgname[i] == NULL) return (ERROR);
		for (j = 0; j < 6; j++)
			imgname[i][j] = (char *) malloc (MAXPATH * sizeof(char));
	}
	if ((get_imglist (prmfile, filtmode, &prm, imglist, lstsize, imgname)) == ERROR) {
		fprintf (stderr, "ERROR [voistat]: Reading input list files\n");
		return (ERROR);
	}
	if (atlas) {
		if (prm.voi_shape != VOI_OLD_SPHERE && prm.voi_shape != VOI_NEW_SPHERE) {
			fprintf (stderr, "ERROR [voistat]: Atlas transformation requires spherical VOIs\n");
			return (ERROR);
		}
		mapfile = (char **) malloc (lstsize * sizeof (char *));
		if (mapfile == NULL) return (ERROR);
		if (mapfile == NULL)
			return (ERROR);
		for (i = 0; i < lstsize; i++)
			mapfile[i] = (char *) malloc (MAXPATH * sizeof(char));
		if ((get_maplist (&prm, imglist, lstsize, ext, mapfile)) == ERROR) {
			fprintf (stderr, "ERROR [voistat]: Reading map files\n");
			return (ERROR);
		}
	}
	if (prm.processing == PROC_OEF || prm.processing == PROC_CMRO2)
		oxygen = TRUE;
	else
		oxygen = FALSE;

/*
 *	Process the image list
 */

	for (i = 0; i < lstsize; i++) {

/*
 *	Get the region file name for this image
 */
		if (named_voi == 0) {
			(void) strcpy (regfile, prm.species);
			(void) strcat (regfile, imglist[i].subject_id);
			if (strlen (imglist[i].sxrid) > 0) {
				ptr = strrchr (imglist[i].sxrid, '.');
				if (ptr != NULL)
					(void) strncat (regfile, imglist[i].sxrid,
							strlen (imglist[i].sxrid) - strlen (ptr));
				else
					(void) strcat (regfile, imglist[i].sxrid);
			}
			(void) strcat (regfile, REG_EXT);
		}
/*
 * Read the region file.
 */
		voilist = (VOIDATA *) malloc (MAXLIST * sizeof (VOIDATA));
		if (voilist == NULL) return (ERROR);
		if (readvoi (regfile, &nvoi, voilist) == ERROR) {
			fprintf (stderr, "ERROR [voistat]: Reading VOI\n");
			return (ERROR);
		}
		if (nvoi > nvoi_max) {
			nvoi_max = nvoi;
			(void) strcpy (maxfile, regfile);
		}
/*
 * Get the number of frames.
 */
		rgtlist[i].fname = imgname[i][0];
		fname0 = rgtlist[i].fname;
		file1 = make_imgfile (fname0);
    	if (file1 == NULL) {
        	fprintf (stderr, "ERROR [voistat]: making file1\n");
        	return (ERROR);
    	}

    	if (get_imgh (file1, &indx) == ERROR) {
        	fprintf (stderr, "ERROR [voistat]: Cannot open %s\n", fname0);
        	return (ERROR);
    	}
		firstfrm = indx.frm;

		rgtlist[i].nframe = file1->mh->nframe;
		nfrm = rgtlist[i].nframe;
		adim[0] = 10.0 * file1->sh->sample_size_1;
		adim[1] = 10.0 * file1->sh->sample_size_2;
		adim[2] = 10.0 * file1->sh->sample_size_3;
		if (file1->sh->dim1 <= 128 && file1->sh->dim2 <= 128) {
			pdim[0] = 128;
			pdim[1] = 128;
		} else {
			pdim[0] = file1->sh->dim1;
			pdim[1] = file1->sh->dim2;
		}
		pdim[2] = file1->sh->dim3;
		zerotime = 0.001 * file1->sh->start_time;
		fprintf (stderr, "Image %s:  %d frames %d planes\n", fname0, nfrm, pdim[2]);
		fprintf (stderr, "First frame = %d started at (sec) %8.3f\n", firstfrm, zerotime);
		if (prm.processing == PROC_DECAYCOR || prm.processing == PROC_UNCORRECTED || nfrm > 4) {
			if (start == 0) {
				fprintf (stderr, "Enter Zero Time (sec):  ");
				if (scanf ("%f", &zerotime) != 1) {
					fprintf (stderr, "ERROR [voistat]\n");
					return (ERROR);
				} else
					fprintf (stderr, "Zero Time =  frame %d  started at %8.3f sec\n", firstfrm, zerotime);
			}
		} else {
			zerotime = 0.;
		}
		ztime = (long) (1000 * zerotime);

		if (atlas) {
			if (getmap (mapfile[i], map) == ERROR) {
				fprintf (stderr, "ERROR [voistat] reading mapfile %s\n", mapfile[i]);
				return (ERROR);
			}
			if (getorigin (prmfile, &z0) == ERROR) {
				fprintf (stderr, "ERROR [voistat] cannot determine z-origin\n");
				return (ERROR);
			}
		}
/*
 * Read image and compute means
 */
		rgtlist[i].nvoi = nvoi;
		rgtlist[i].time = (float *) malloc ((nfrm + 1) * sizeof (float));
		rgtlist[i].duration = (float *) malloc ((nfrm + 1) * sizeof (float));
		rgtlist[i].mean = (float **) malloc ((nfrm + 1) * sizeof (float *));
		rgtlist[i].sd = (float **) malloc ((nfrm + 1) * sizeof (float *));

		fprintf (stderr, "Reading = %s  frames %d - %d\n", fname0, firstfrm, nfrm);
		for (j = firstfrm; j <= nfrm; j++) {
			rgtlist[i].mean[j] = (float *) malloc (rgtlist[i].nvoi * sizeof (float));
			rgtlist[i].sd[j] = (float *) malloc (rgtlist[i].nvoi * sizeof (float));
			indx.frm = j;
			fname0 = imgname[i][0];
			rgtlist[i].time[j] = (0.001 * file1->sh->start_time) - zerotime;
			rgtlist[i].duration[j] = 0.001 * file1->sh->duration;
			if (oxygen) {		 /* is this a t88 image which uses a single image file? */
				if ((readhdr (fname0, &hdr, recfp) != ERROR) && (hdr.ntype >= 11))
					oxygen = FALSE;
				else {
					fname1 = imgname[i][1];
					fname2 = imgname[i][2];
					if ((flowimg = rdtensor1 (fname1, pdim)) == NULL) {
						fprintf (stderr, "ERROR [voistat] Cannot read %s\n", fname1);
						return (ERROR);
					}
					fprintf (stderr, "   CBF  = %s\n", fname1);
					if ((volimg = rdtensor1 (fname2, pdim)) == NULL) {
						fprintf (stderr, "ERROR [voistat]: Cannot open %s\n", fname2);
						return (ERROR);
					}
					fprintf (stderr, "   CBV  = %s\n", fname2);
				}
			}

			file1->name = fname0;
			if ((img = rdtensor (file1, &indx, pdim)) == NULL) {
				fprintf (stderr, "ERROR [voistat] Cannot read %s\n", fname0);
				return (ERROR);
			}
			if (prm.voi_norm > 0.0 && imglist[i].mean1 > 0.0)
				scaler = prm.voi_norm / imglist[i].mean1;
			else
				scaler = 1.0;

			if (prm.voi_order == 0) {	/* Metabolic conversion BEFORE VOIs */
				if (oxygen) {	 		/* Oxygen processing */
					if (processOxygen (img, flowimg, volimg, pdim, scaler,
						 prm.processing, fname0, fname1, fname2, recfp, &hdr) > 0) {
						fprintf (stderr, "ERROR [voistat]: processing %s %s %s\n", fname0, fname1, fname2);
						return (ERROR);
					}
					free_f3tensor (flowimg, 1, pdim[2], 1, pdim[1], 1, pdim[0]);
					free_f3tensor (volimg, 1, pdim[2], 1, pdim[1], 1, pdim[0]);

				} else {	 /* Non-oxygen processing */
					if (readhdr (fname0, &hdr, recfp) == ERROR) {
						if (prm.processing != PROC_NONE) {
							fprintf (stderr, "ERROR [voistat]: hdr file not found for %s\n", fname0);
							return (ERROR);
						}
						nohdr = TRUE;
					}
					if (get_sh (file1, &indx) == ERROR)
						sampled = 0;
					else {
						sampled = 1;
						framelen = file1->sh->duration * 0.001;	/* compute decay-correction */
						framestart = 0.001 * file1->sh->start_time - zerotime;
						rgtlist[i].time[j] = framestart;
						rgtlist[i].duration[j] = framelen;
						if (nohdr)
							frametime = framestart;
						else {
							frametime = framestart - (log (0.5 * (1.0 + exp (-hdr.tau * framelen)))) / (hdr.tau);
							pettconv = hdr.efactor * hdr.pieslope * 60;
							hdr.pettcnv1 = pettconv;
							hdr.decay_factor1 = pettconv * exp (frametime * hdr.tau);
							hdr.framelen = framelen;
						}
						if (processPET (img, pdim, scaler, prm.processing, fname0, recfp, &hdr) > 0) {
							fprintf (stderr, "ERROR [voistat]: processing %s\n", fname0);
							return (ERROR);
						}
					}
				}
				if (sampled == 1) {
					for (k = 0; k < nvoi; k++) {
						rgtmean (img, pdim, adim, k, voilist, prm, atlas, map, z0,
						    &rgtlist[i].mean[j][k], &rgtlist[i].sd[j][k], &pixused);
					}
					if (pixused > npixels)
						npixels = pixused;
				} else {
					for (k = 0; k < nvoi; k++) {
						rgtlist[i].mean[j][k] = 0;
						rgtlist[i].sd[j][k] = 0;
					}
				}
				free_f3tensor (img, 1, pdim[2], 1, pdim[1], 1, pdim[0]);

			} else {		 /* Metabolic conversion AFTER VOIs */
				flag = 1;
				for (k = 0; k < nvoi; k++) {
					if (oxygen) {	/* Oxygen processing */
						rgtmean (img, pdim, adim, k, voilist, prm, atlas, map, z0, &cnts, &sd, &pixused);
						rgtmean (flowimg, pdim, adim, k, voilist, prm, atlas, map, z0, &flowcnts, &flowsd, &pixused);
						rgtmean (volimg, pdim, adim, k, voilist, prm, atlas, map, z0, &volcnts, &volsd, &pixused);
						rgtlist[i].mean[j][k] = procOxygen2 (cnts, flowcnts, volcnts, prm.processing,
						 fname0, fname1, fname2, &hdr, &hohdr, &ochdr, recfp, flag);
						rgtlist[i].sd[j][k] = procOxygen2 (sd, flowsd, volsd, prm.processing,
						 fname0, fname1, fname2, &hdr, &hohdr, &ochdr, recfp, flag);

					} else {	 /* Non-oxygen processing for which a hdr file exists */
						if (flag > 0) {
							if (readhdr (fname0, &hdr, recfp) == ERROR) {
								if (prm.processing != PROC_NONE) {
									fprintf (stderr, "ERROR [voistat]: hdr file not found for %s\n", fname0);
									return (ERROR);
								}
								nohdr = TRUE;
							}
						}
						if (get_sh (file1, &indx) == ERROR) {
							fprintf (stderr, "ERROR [voistat]: Cannot read file subheader in %s\n", fname0);
							return (ERROR);
						}
						framelen = file1->sh->duration * 0.001;	/* compute decay
											 * correction */
						framestart = 0.001 * file1->sh->start_time - zerotime;
						rgtlist[i].time[j] = framestart;
						rgtlist[i].duration[j] = framelen;
						if (nohdr)
							frametime = framestart;
						else {
							frametime = framestart - (log (0.5 * (1.0 + exp (-hdr.tau * framelen)))) / (hdr.tau);
							pettconv = hdr.efactor * hdr.pieslope * 60;
							hdr.pettcnv1 = pettconv;
							hdr.decay_factor1 = pettconv * exp (frametime * hdr.tau);
							hdr.framelen = framelen;
						}
						rgtmean (img, pdim, adim, k, voilist, prm, atlas, map, z0, &cnts, &sd, &pixused);
						rgtlist[i].mean[j][k] = procPET2 (cnts, prm.processing, fname0, &hdr, recfp, flag);
						rgtlist[i].sd[j][k] = procPET2 (sd, prm.processing, fname0, &hdr, recfp, flag);
					}
					if (pixused > npixels)
						npixels = pixused;
					flag = 0;
				}
				free_f3tensor (img, 1, pdim[2], 1, pdim[1], 1, pdim[0]);
				if (oxygen) {
					free_f3tensor (volimg, 1, pdim[2], 1, pdim[1], 1, pdim[0]);
					free_f3tensor (flowimg, 1, pdim[2], 1, pdim[1], 1, pdim[0]);
				}
			}
		}
		close_imgfile (file1);
		free_imgfile (file1);
		free (voilist);
	}

	voilist = (VOIDATA *) malloc (nvoi_max * sizeof (VOIDATA));
	if (voilist == NULL) return (ERROR);
	if (readvoi (maxfile, &nvoi, voilist) == ERROR) {
		fprintf (stderr, "ERROR [voistat]: from readvoi\n");
		return (ERROR);
	}

/* Write rgtfile */

	if (writergt (rgtfile, prm, program, nvoi, voilist, firstfrm, lstsize, rgtlist, date, uid,
		      regfile, prmfile, npixels, adim, FALSE) == ERROR)
		fprintf (stderr, "ERROR [voistat] in writing rgt data to file %s\n", rgtfile);
	if (prm.voi_sd)
		if (writergt (sdfile, prm, program, nvoi, voilist, firstfrm, lstsize, rgtlist, date, uid,
			      regfile, prmfile, npixels, adim, TRUE) == ERROR)
			fprintf (stderr, "ERROR [voistat] in writing sd data to file %s\n", sdfile);
	(void) fclose (recfp);
	fprintf (stdout, "Zero Time (msec) = %ld\n", ztime);

	free (voilist);
	free (imglist);
	for (i = 0; i < lstsize; i++) {
		free (rgtlist[i].time);
		free (rgtlist[i].duration);
		free (rgtlist[i].mean);
		free (rgtlist[i].sd);
	}
	free (rgtlist);
	for (i = 0; i < lstsize; i++)
		free (imgname[i]);
	free (imgname);
	free_matrix (map, 1, 4, 1, 4);
	return (OK);
}
@


1.44
log
@21Aug2003
@
text
@d2 3
d130 1
a130 1
 *	Date:			Apr-96
d139 1
a139 1
static char     rcsid[] = "$Header: /home/npggw/tom/src/voistat/RCS/voistat.c,v 1.43 2003/08/15 17:26:18 tom Exp $";
d158 1
a158 1
	ImageFile      *file = NULL;	 /* input image file structure */
d214 1
a214 1
	int             firstfrm = 1;	 /* first valid frame */
d233 3
a235 2
		named_voi = FALSE;
		regfile = (char *) malloc (MAXPATH);
d237 1
a237 1
		named_voi = TRUE;
d257 4
d274 1
d281 1
d295 1
d298 1
d300 1
a300 1
			imgname[i][j] = (char *) malloc (MAXPATH);
d312 3
d316 1
a316 1
			mapfile[i] = (char *) malloc (sizeof (MAXPATH));
d336 1
a336 1
		if (!named_voi) {
d341 1
a341 1
				if (*ptr)
d352 2
a353 1
		voilist = (VOIDATA *) malloc (sizeof (VOIDATA) * MAXLIST);
d367 13
a379 28
		if (file == NULL)
			file = make_imgfile (fname0);
		if (file->name == NULL)
			file = make_imgfile (fname0);
		if (open_imgfile (file) == ERROR) {
			fprintf (stderr, "ERROR [voistat]: Cannot open %s\n", fname0);
			return (ERROR);
		}
		if (get_mh (file) == ERROR) {
			fprintf (stderr, "ERROR [voistat]: Cannot get MainHeader from %s\n", fname0);
			return (ERROR);
		}
		firstfrm = firstimgfrm (file);
		if (firstfrm > 0) {
			indx.frm = firstfrm;
			if (existimgfrm (file, &indx) == ERROR) {
				fprintf (stderr, "ERROR [voistat]: Cannot read %s frame %d\n", fname0, indx.frm);
				return (ERROR);
			}
		} else {
			fprintf (stderr, "ERROR [voistat]: Cannot read %s frame %d\n", fname0, indx.frm);
			return (ERROR);
		}
		if (get_sh (file, &indx) == ERROR) {
			fprintf (stderr, "ERROR [voistat]: Cannot read file subheader in %s\n", fname0);
			return (ERROR);
		}
		rgtlist[i].nframe = file->mh->nframe;
d381 4
a384 4
		adim[0] = 10.0 * file->sh->sample_size_1;
		adim[1] = 10.0 * file->sh->sample_size_2;
		adim[2] = 10.0 * file->sh->sample_size_3;
		if (file->sh->dim1 <= 128 && file->sh->dim2 <= 128) {
d388 2
a389 2
			pdim[0] = file->sh->dim1;
			pdim[1] = file->sh->dim2;
d391 2
a392 2
		pdim[2] = file->sh->dim3;
		zerotime = 0.001 * file->sh->start_time;
d434 2
a435 2
			rgtlist[i].time[j] = (0.001 * file->sh->start_time) - zerotime;
			rgtlist[i].duration[j] = 0.001 * file->sh->duration;
d442 1
a442 1
					if ((flowimg = rdtensor (fname1, &indx, pdim)) == NULL) {
d447 1
a447 1
					if ((volimg = rdtensor (fname2, &indx, pdim)) == NULL) {
d455 2
a456 1
			if ((img = rdtensor (fname0, &indx, pdim)) == NULL) {
d483 1
a483 1
					if (get_sh (file, &indx) == ERROR)
d487 2
a488 2
						framelen = file->sh->duration * 0.001;	/* compute decay-correction */
						framestart = 0.001 * file->sh->start_time - zerotime;
d543 1
a543 1
						if (get_sh (file, &indx) == ERROR) {
d547 1
a547 1
						framelen = file->sh->duration * 0.001;	/* compute decay
d549 1
a549 1
						framestart = 0.001 * file->sh->start_time - zerotime;
d576 2
a577 1
		free_imgfile (file);
d581 2
a582 1
	voilist = (VOIDATA *) malloc (sizeof (VOIDATA) * nvoi_max);
a604 4
		for (j = firstfrm; j <= rgtlist[i].nframe; j++) {
			free (rgtlist[i].mean[j]);
			free (rgtlist[i].sd[j]);
		}
d609 1
a609 3
	for (i = 0; i < lstsize; i++) {
		for (j = 0; j < 6; j++)
			free (imgname[i][j]);
a610 1
	}
@


1.43
log
@don't quit if a frame is unreadable
@
text
@d2 3
d136 1
a136 1
static char     rcsid[] = "$Header: /home/npggw/tom/src/voistat/RCS/voistat.c,v 1.42 2003/04/24 14:01:25 tom Exp tom $";
d236 1
a240 1
		map = matrix (1, 4, 1, 4);
d453 1
d593 3
d605 2
d612 1
d615 1
a615 2
	(void) fclose (recfp);
	fprintf (stdout, "Zero Time (msec) = %ld\n", ztime);
@


1.42
log
@add option to use frame 2 as default start time without prompting
@
text
@d2 3
d133 1
a133 1
static char     rcsid[] = "$Header: /home/npggw/tom/src/voistat/RCS/voistat.c,v 1.41 2003/04/03 21:46:38 tom Exp tom $";
d152 1
a152 1
	ImageFile      *file = NULL;		 /* input image file structure */
d180 1
a180 1
	char            ext[MAXFNAME];		 /* extension for map files */
d197 1
a197 1
	float           sd;			 /* SD */
d201 1
a201 1
	int             z0;			 /* z-origin used to create map file */
d204 1
a204 1
	int             lstsize = 0;		 /* number of entries in image list */
d207 2
a208 2
	int             pixused = 0;		 /* actual number of pixels used in computation */
	int             firstfrm = 1;		 /* first valid frame */
d212 1
d432 1
a432 2
			if (oxygen) {		 /* is this a t88 image which uses a single image
						  * file? */
d459 2
a460 2
			if (prm.voi_order == 0) {/* Metabolic conversion BEFORE VOIs */
				if (oxygen) {	 /* Oxygen processing */
d462 2
a463 3
					prm.processing, fname0, fname1, fname2, recfp, &hdr) > 0) {
						fprintf (stderr, "ERROR [voistat]: processing %s %s %s\n", fname0,
							 fname1, fname2);
d469 1
a469 2
				} else {	 /* Non-oxygen processing for which a hdr file
						  * exists */
d477 2
a478 11
					if (get_sh (file, &indx) == ERROR) {
						fprintf (stderr, "ERROR [voistat]: Cannot read file subheader in %s\n", fname0);
						return (ERROR);
					}
					framelen = file->sh->duration * 0.001;	/* compute decay
										 * correction */
					framestart = 0.001 * file->sh->start_time - zerotime;
					rgtlist[i].time[j] = framestart;
					rgtlist[i].duration[j] = framelen;
					if (nohdr)
						frametime = framestart;
d480 18
a497 5
						frametime = framestart - (log (0.5 * (1.0 + exp (-hdr.tau * framelen)))) / (hdr.tau);
						pettconv = hdr.efactor * hdr.pieslope * 60;
						hdr.pettcnv1 = pettconv;
						hdr.decay_factor1 = pettconv * exp (frametime * hdr.tau);
						hdr.framelen = framelen;
d499 5
a503 3
					if (processPET (img, pdim, scaler, prm.processing, fname0, recfp, &hdr) > 0) {
						fprintf (stderr, "ERROR [voistat]: processing %s\n", fname0);
						return (ERROR);
d505 7
a512 6
				for (k = 0; k < nvoi; k++) {
					rgtmean (img, pdim, adim, k, voilist, prm, atlas, map, z0,
					  &rgtlist[i].mean[j][k], &rgtlist[i].sd[j][k], &pixused);
				}
				if (pixused > npixels)
					npixels = pixused;
d523 1
a523 1
										     fname0, fname1, fname2, &hdr, &hohdr, &ochdr, recfp, flag);
d525 1
a525 1
										   fname0, fname1, fname2, &hdr, &hohdr, &ochdr, recfp, flag);
d527 1
a527 2
					} else { /* Non-oxygen processing for which a hdr file
						  * exists */
d579 1
@


1.41
log
@*** empty log message ***
@
text
@d2 3
d130 1
a130 1
static char     rcsid[] = "$Header: /home/npggw/tom/src/voistat/RCS/voistat.c,v 1.40 2003/04/03 19:47:02 tom Exp tom $";
d149 1
a149 1
	ImageFile      *file = NULL;	 /* input image file structure */
d151 5
a155 4
	int		        named_voi;		 /* VOI file named on command line input */
	int		        oxygen;			 /* oxygen processing */
	int		        nohdr;			 /* no hdr file exists */
	int		        atlas;			 /* compute atlas coordinates */
d163 1
a163 1
	int             getorigin();
d177 1
a177 1
	char            ext[MAXFNAME];	 /* extension for map files */
d189 1
a189 1
	float           zerotime=0;		 /* start time relative to time of frame 1 */
d194 1
a194 1
	float           sd;				 /* SD */
d198 1
a198 1
	int             z0;				 /* z-origin used to create map file */
d201 2
a202 2
	int             lstsize=0;		 /* number of entries in image list */
	int             nvoi=0;			 /* number of VOIs */
d204 2
a205 2
	int             pixused=0;		 /* actual number of pixels used in computation */
	int             firstfrm=1;		 /* first valid frame */
d214 2
a215 2
	if (argc != 14) {
		fprintf (stderr, "Usage: voistat prm lst rgt sd voi atlas date uid\n");
d236 5
a240 1
	n = 7;
d242 1
a242 1
		 argv[n], argv[n + 1], argv[n + 2], argv[n + 3], argv[n + 4], argv[n + 5]);
d244 1
d321 1
a321 1
						 strlen (imglist[i].sxrid) - strlen (ptr));
d384 1
d386 1
a386 1
		fprintf (stderr, "First frame = %d started at (sec) %8.3f\n", firstfrm, 0.001 * file->sh->start_time);
d388 7
a394 4
			fprintf (stderr, "Enter Zero Time (sec):  ");
			if (scanf ("%f", &zerotime) != 1) {
				fprintf (stderr, "ERROR [voistat]\n");
				return (ERROR);
d399 1
a399 1
		ztime = (long) (1000*zerotime);
d428 2
a429 1
			if (oxygen) {	/* is this a t88 image which uses a single image file? */
d444 1
a444 1
					fprintf (stderr,"   CBV  = %s\n", fname2);
d456 2
a457 2
			if (prm.voi_order == 0) {		/*  Metabolic conversion BEFORE VOIs */
				if (oxygen) {		/* Oxygen processing */
d467 2
a468 1
				} else {		/* Non-oxygen processing for which a hdr file exists */
d480 2
a481 1
					framelen = file->sh->duration * 0.001;	/* compute decay correction */
d507 1
a507 1
			} else {		/*  Metabolic conversion AFTER VOIs */
d510 1
a510 1
					if (oxygen) {		/* Oxygen processing */
d515 1
a515 1
							     fname0, fname1, fname2, &hdr, &hohdr, &ochdr, recfp, flag);
d517 1
a517 1
							     fname0, fname1, fname2, &hdr, &hohdr, &ochdr, recfp, flag);
d519 2
a520 1
					} else {	/* Non-oxygen processing for which a hdr file exists */
d534 2
a535 1
						framelen = file->sh->duration * 0.001;	/* compute decay correction */
a571 1

d598 1
a598 1
	fprintf (stdout, "Zero Time (msec) = %ld\n",ztime);
@


1.40
log
@change start time prompt
@
text
@d2 3
d127 1
a127 1
static char     rcsid[] = "$Header: /home/npggw/tom/src/voistat/RCS/voistat.c,v 1.39 2003/01/03 20:24:41 tom Exp tom $";
a192 1
	long            ztime;			 /* zerotime in msec */
d205 1
d230 1
a230 1
		strcpy (ext, MAP_EXT);
d238 2
a239 2
	strcat (program, " ");
	strcat (program, version);
d306 2
a307 2
			strcpy (regfile, prm.species);
			strcat (regfile, imglist[i].subject_id);
d311 1
a311 1
					strncat (regfile, imglist[i].sxrid,
d314 1
a314 1
					strcat (regfile, imglist[i].sxrid);
d316 1
a316 1
			strcat (regfile, REG_EXT);
d328 1
a328 1
			strcpy (maxfile, regfile);
a361 1
		nfrm = file->mh->nframe;
a572 2
		free (rgtlist[i].mean);
		free (rgtlist[i].sd);
a577 1
		free (imgname[i]);
d581 1
a581 1
	fprintf (stdout, "Zero Time (msec) = %d\n",ztime);
@


1.39
log
@write zerotime to stdout instead of passing in return
@
text
@d2 3
d124 1
a124 1
static char     rcsid[] = "$Header: /home/npggw/tom/src/voistat/RCS/voistat.c,v 1.38 2002/11/27 18:21:57 tom Exp tom $";
d374 1
a374 1
		fprintf (stderr, "First frame = %d started at %f sec\n", firstfrm, 0.001 * file->sh->start_time);
@


1.38
log
@*** empty log message ***
@
text
@d2 3
d121 1
a121 1
static char     rcsid[] = "$Header: /home/npggw/tom/src/voistat/RCS/voistat.c,v 1.37 2002/02/08 14:51:03 tom Exp tom $";
d187 1
a187 1
	int             ztime;			 /* rounded zerotime */
d370 2
a371 2
		fprintf (stdout, "Image %s:  %d frames %d planes\n", fname0, nfrm, pdim[2]);
		fprintf (stdout, "First frame = %d started at %f sec\n", firstfrm, 0.001 * file->sh->start_time);
d373 1
a373 1
			fprintf (stdout, "Enter Zero Time (sec):  ");
d381 1
a381 1
		ztime = (int) (zerotime + 0.99);
d402 1
a402 1
		fprintf (stdout, "\nReading = %s  frames %d - %d\n", fname0, firstfrm, nfrm);
d420 1
a420 1
					fprintf (stdout, "   CBF  = %s\n", fname1);
d425 1
a425 1
					fprintf (stdout,"   CBV  = %s\n", fname2);
d579 2
a580 1
	return (ztime);
@


1.37
log
@modify Reading message
@
text
@d2 3
d118 1
a118 1
static char     rcsid[] = "$Header: /home/npggw/tom/src/voistat/RCS/voistat.c,v 1.36 2001/09/07 20:12:09 tom Exp tom $";
d224 1
a224 1
	sprintf (date, "%s %s %s %s %s %s",
d228 1
a228 1
	sscanf (rcsid, "$Header: %s %s", program, version);
d575 1
a575 1
	fclose (recfp);
@


1.36
log
@fprintf
@
text
@d2 3
d115 1
a115 1
static char     rcsid[] = "$Header: /home/npggw/tom/src/voistat/RCS/voistat.c,v 1.35 2001/09/06 14:11:38 tom Exp tom $";
d396 1
a396 1
		fprintf (stdout, "Reading = %s  frames %d - %d\n", fname0, firstfrm, nfrm);
@


1.35
log
@eliminate "Reading" message for each frame
@
text
@d2 3
d112 1
a112 1
static char     rcsid[] = "$Header: /home/npggw/tom/src/voistat/RCS/voistat.c,v 1.34 2001/08/17 13:39:38 tom Exp tom $";
d361 2
a362 2
		printf ("Image %s:  %d frames %d planes\n", fname0, nfrm, pdim[2]);
		printf ("First frame = %d started at %f sec\n", firstfrm, 0.001 * file->sh->start_time);
d364 1
a364 1
			printf ("Enter Zero Time (sec):  ");
d393 1
a393 1
		printf ("Reading = %s  frames %d - %d\n", fname0, firstfrm, nfrm);
d411 1
a411 1
					printf ("   CBF  = %s\n", fname1);
d416 1
a416 1
					printf ("   CBV  = %s\n", fname2);
@


1.34
log
@return zerotime
@
text
@d2 3
d109 1
a109 1
static char     rcsid[] = "$Header: /home/npggw/tom/src/voistat/RCS/voistat.c,v 1.33 2001/05/31 19:34:52 tom Exp tom $";
d390 1
a395 1
			printf ("Reading = %s  frame %d\n", fname0, indx.frm);
@


1.33
log
@read version number correctly
@
text
@d2 3
d106 1
a106 1
static char     rcsid[] = "$Header: /home/npggw/tom/src/voistat/RCS/voistat.c,v 1.32 2000/08/28 15:15:22 tom Exp tom $";
d172 1
d366 1
d564 1
a564 1
	return (OK);
@


1.32
log
@check file->name == NULL
@
text
@d2 3
d103 1
a103 1
static char     rcsid[] = "$Header: /home/npggw/tom/src/voistat/RCS/voistat.c,v 1.31 2000/07/18 16:00:42 tom Exp tom $";
d212 1
a212 1
	sscanf (rcsid, "%s %s", program, version);
@


1.31
log
@*** empty log message ***
@
text
@d2 3
d100 1
a100 1
static char     rcsid[] = "$Header: /home/npggw/tom/src/voistat/RCS/voistat.c,v 1.30 1999/12/17 16:19:58 tom Exp $";
d309 2
@


1.30
log
@lint cleaning
@
text
@d2 3
d97 1
a97 1
static char     rcsid[] = "$Header: /home/npggw/tom/src/voistat/RCS/voistat.c,v 1.29 1999/12/17 14:53:08 tom Exp tom $";
d116 1
a116 1
	ImageFile      *file;			 /* input image file structure */
d163 1
d304 2
a305 1
		file = make_imgfile (fname0);
d329 1
d331 1
d335 7
a341 2
		pdim[0] = 128;
		pdim[1] = 128;
d343 1
a343 1
		printf ("Image %s:  %d frames %d planes\n", fname0, file->mh->nframe, pdim[2]);
d345 1
a345 2
		if (prm.processing == PROC_DECAYCOR || prm.processing == PROC_UNCORRECTED
		    || rgtlist[i].nframe > 4) {
d369 4
a372 4
		rgtlist[i].time = (float *) malloc ((rgtlist[i].nframe + 1) * sizeof (float));
		rgtlist[i].duration = (float *) malloc ((rgtlist[i].nframe + 1) * sizeof (float));
		rgtlist[i].mean = (float **) malloc ((rgtlist[i].nframe + 1) * sizeof (float *));
		rgtlist[i].sd = (float **) malloc ((rgtlist[i].nframe + 1) * sizeof (float *));
d374 1
a374 1
		for (j = firstfrm; j <= rgtlist[i].nframe; j++) {
d423 1
a423 1
							fprintf (stderr, "ERROR [voistat]: a hdr file is necessary for %s\n", fname0);
d474 1
a474 1
									fprintf (stderr, "ERROR [voistat]: a hdr file is necessary for %s\n", fname0);
d540 2
d547 1
@


1.29
log
@lint cleaning
@
text
@d2 3
d94 1
a94 1
static char     rcsid[] = "$Header: /home/npggw/tom/src/voistat/RCS/voistat.c,v 1.28 1999/10/12 13:53:09 tom Exp tom $";
d152 1
a152 1
	float           zerotime;		 /* start time relative to time of frame 1 */
d163 2
a164 2
	int             lstsize;		 /* number of entries in image list */
	int             nvoi;			 /* number of VOIs */
d166 2
a167 2
	int             pixused;		 /* actual number of pixels used in computation */
	int             firstfrm;		 /* first valid frame */
@


1.28
log
@new libimgutil with updated arc path
cleanup some code with lin
@
text
@d2 4
d91 1
a91 1
static char     rcsid[] = "$Header: /home/npggw/tom/src/voistat/RCS/voistat.c,v 1.27 1999/07/15 15:45:25 tom Exp tom $";
d112 4
a115 4
	BOOLEAN         named_voi;		 /* VOI file named on command line input */
	BOOLEAN         oxygen;			 /* oxygen processing */
	BOOLEAN         nohdr;			 /* no hdr file exists */
	BOOLEAN         atlas;			 /* compute atlas coordinates */
@


1.27
log
@old and new sphere options
@
text
@d2 3
d87 1
a87 1
static char     rcsid[] = "$Header: /home/npggw/tom/src/voistat/RCS/voistat.c,v 1.26 1998/06/02 16:33:21 tom Exp tom $";
a521 2
		free (rgtlist[i].mean);
		free (rgtlist[i].sd);
a526 1
		free (imgname[i]);
@


1.26
log
@correct order of free_imgfile in loop
@
text
@d2 3
d84 1
a84 1
static char     rcsid[] = "$Header: /home/npggw/tom/src/voistat/RCS/voistat.c,v 1.25 1998/05/27 19:09:04 tom Exp tom $";
a91 1
#include <nr.h>
d114 3
d130 1
a130 1
	char            ext[MAXFNAME];		 /* extension for map files */
d147 1
a147 1
	float           sd;			 /* SD */
d150 1
a150 1
	int             z0;			 /* z-origin used to create map file */
d157 1
a157 1
	int             firstfrm = 1;		 /* first valid frame */
d160 1
d195 1
a195 1
	indx.frm = firstfrm;
a205 3
	fprintf (stdout, "Copyright 1996-7, Washington University.\n");
	fprintf (stdout, "All rights reserved. Unauthorized reproduction prohibited.\n\n");

d234 1
a234 1
		if (prm.voi_shape != VOI_SPHERE) {
d340 1
a340 1
				fprintf (stderr, "ERROR [voistat] cannot determine z-origin%s\n");
d361 2
a362 5
			if (oxygen) {

/*	Check if this is a t88 image which uses a single image file */

				if ((readhdr (fname0, &hdr, recfp) != ERROR) && (hdr.ntype >= 11)) {
d364 1
a364 1
				} else {
d388 2
a389 7
/*	Metabolic conversion before VOIs */

			if (prm.voi_order == 0) {

				/* Oxygen processing */

				if (oxygen) {
d399 1
a399 3
					/* Non-oxygen processing for which a hdr file exists */

				} else {
a406 2
					/* Compute decay-corrected conversion factor */

d411 1
a411 1
					framelen = file->sh->duration * 0.001;
d415 1
a415 1
					if (nohdr) {
d417 1
a417 1
					} else {
a423 1

a428 1

a432 1

d437 2
a438 4
			} else {

/*	Metabolic conversion after VOIs */

d440 1
a440 4

					/* Oxygen processing */

					if (oxygen) {
d444 4
a447 4
						rgtlist[i].mean[j][k] = procOxygen (cnts, flowcnts, volcnts, prm.processing,
							     fname0, fname1, fname2, &hdr, recfp);
						rgtlist[i].sd[j][k] = procOxygen (sd, flowsd, volsd, prm.processing,
							     fname0, fname1, fname2, &hdr, recfp);
d449 8
a456 10
						/*
						 * Non-oxygen processing for which a hdr file
						 * exists
						 */

					} else {
						if (readhdr (fname0, &hdr, recfp) == ERROR) {
							if (prm.processing != PROC_NONE) {
								fprintf (stderr, "ERROR [voistat]: a hdr file is necessary for %s\n", fname0);
								return (ERROR);
a457 1
							nohdr = TRUE;
a458 2
						/* Compute decay-corrected conversion factor */

d463 1
a463 1
						framelen = file->sh->duration * 0.001;
d467 1
a467 1
						if (nohdr) {
d469 1
a469 1
						} else {
a475 1

d477 2
a478 2
						rgtlist[i].mean[j][k] = procPET (cnts, prm.processing, fname0, &hdr, recfp);
						rgtlist[i].sd[j][k] = procPET (sd, prm.processing, fname0, &hdr, recfp);
d480 3
a483 3

				if (pixused > npixels)
					npixels = pixused;
d500 3
a502 3
/*
 * Write the rgt data to rgtfile.
 */
d504 1
a504 1
		      regfile, prmfile, npixels, adim, FALSE) == ERROR) {
d506 1
a506 2
	}
	if (prm.voi_sd) {
d508 1
a508 1
			      regfile, prmfile, npixels, adim, TRUE) == ERROR) {
a509 2
		}
	}
d529 1
a529 1
	close (recfp);
@


1.25
log
@voi_order = 1 will compute regional means before metabolic values
voi_order = 0 (default) will compute metabolic images before regional means
@
text
@d2 4
d81 1
a81 1
static char     rcsid[] = "$Header: /home/npggw/tom/src/voistat/RCS/voistat.c,v 1.23 1998/02/02 15:22:07 tom Exp $";
d444 1
a512 2
			free_imgfile (file);
			free (voilist);
d514 2
@


1.24
log
@metabolic processing performed after computing mean regional counts
@
text
@d77 1
a77 1
static char     rcsid[] = "$Header: /home/npggw/tom/src/voistat/RCS/voistat.c,v 1.23 1998/02/02 15:22:07 tom Exp tom $";
d138 1
a138 1
	float           sd;				 /* SD */
d141 1
a141 1
	int             z0;				 /* z-origin used to create map file */
d196 1
a196 1
	fprintf (stdout, "Copyright 1996-8, Washington University.\n");
d384 1
a384 1
/*	Oxygen processing */
d386 4
a389 1
			for (k = 0; k < nvoi; k++) {
d391 8
a398 7
					rgtmean (img, pdim, adim, k, voilist, prm, atlas, map, z0, &cnts, &sd, &pixused);
					rgtmean (flowimg, pdim, adim, k, voilist, prm, atlas, map, z0, &flowcnts, &flowsd, &pixused);
					rgtmean (volimg, pdim, adim, k, voilist, prm, atlas, map, z0, &volcnts, &volsd, &pixused);
					rgtlist[i].mean[j][k] = procOxygen (cnts, flowcnts, volcnts, prm.processing,
							     fname0, fname1, fname2, &hdr, recfp);
					rgtlist[i].sd[j][k] = procOxygen (sd, flowsd, volsd, prm.processing,
							     fname0, fname1, fname2, &hdr, recfp);
d400 1
a400 1
/*	Non-oxygen processing for which a hdr file exists */
d430 4
a433 3
					rgtmean (img, pdim, adim, k, voilist, prm, atlas, map, z0, &cnts, &sd, &pixused);
					rgtlist[i].mean[j][k] = procPET (cnts, prm.processing, fname0, &hdr, recfp);
					rgtlist[i].sd[j][k] = procPET (sd, prm.processing, fname0, &hdr, recfp);
a434 1
			}
d436 71
a506 6
			if (pixused > npixels)
				npixels = pixused;
			free_f3tensor (img, 1, pdim[2], 1, pdim[1], 1, pdim[0]);
			if (oxygen) {
				free_f3tensor (volimg, 1, pdim[2], 1, pdim[1], 1, pdim[0]);
				free_f3tensor (flowimg, 1, pdim[2], 1, pdim[1], 1, pdim[0]);
d508 2
a510 2
		free_imgfile (file);
		free (voilist);
@


1.23
log
@new buildnames in libimgutil.a
@
text
@d2 3
d77 1
a77 1
static char     rcsid[] = "$Header: /home/npggw/tom/src/voistat/RCS/voistat.c,v 1.22 1997/06/02 20:58:12 tom Exp tom $";
d135 7
a141 1
	int				z0;				 /* z-origin used to create map file */
d170 1
a170 1
	if (atoi(argv[6]) == 0)
d196 1
a196 1
	fprintf (stdout, "Copyright 1996-7, Washington University.\n");
d386 9
a394 9
			if (oxygen) {
				if (processOxygen (img, flowimg, volimg, pdim, scaler,
				       prm.processing, fname0, fname1, fname2, recfp, &hdr) > 0) {
					fprintf (stderr, "ERROR [voistat]: processing %s %s %s\n", fname0,
						 fname1, fname2);
					return (ERROR);
				}
				free_f3tensor (flowimg, 1, pdim[2], 1, pdim[1], 1, pdim[0]);
				free_f3tensor (volimg, 1, pdim[2], 1, pdim[1], 1, pdim[0]);
d398 12
a409 4
			} else {
				if (readhdr (fname0, &hdr, recfp) == ERROR) {
					if (prm.processing != PROC_NONE) {
						fprintf (stderr, "ERROR [voistat]: a hdr file is necessary for %s\n", fname0);
d412 13
a424 3
					nohdr = TRUE;
				}
				/* Compute decay-corrected conversion factor */
d426 3
a428 3
				if (get_sh (file, &indx) == ERROR) {
					fprintf (stderr, "ERROR [voistat]: Cannot read file subheader in %s\n", fname0);
					return (ERROR);
a429 18
				framelen = file->sh->duration * 0.001;
				framestart = 0.001 * file->sh->start_time - zerotime;
				rgtlist[i].time[j] = framestart;
				rgtlist[i].duration[j] = framelen;
				if (nohdr) {
					frametime = framestart;
				} else {
					frametime = framestart - (log (0.5 * (1.0 + exp (-hdr.tau * framelen)))) / (hdr.tau);
					pettconv = hdr.efactor * hdr.pieslope * 60;
					hdr.pettcnv1 = pettconv;
					hdr.decay_factor1 = pettconv * exp (frametime * hdr.tau);
					hdr.framelen = framelen;
				}

				if (processPET (img, pdim, scaler, prm.processing, fname0, recfp, &hdr) > 0) {
					fprintf (stderr, "ERROR [voistat]: processing %s\n", fname0);
					return (ERROR);
				}
a431 8
			for (k = 0; k < nvoi; k++) {
				rgtmean (img, pdim, adim, k, voilist, prm, atlas, map, z0,
					&rgtlist[i].mean[j][k], &rgtlist[i].sd[j][k], &pixused);
			}
/*
			rgtmean (img, pdim, adim, nvoi, voilist, prm, rgtlist[i].mean + ((j - 1) * rgtlist[i].nvoi),
				 rgtlist[i].sd + ((j - 1) * rgtlist[i].nvoi), &pixused);
*/
d435 4
@


1.22
log
@add voi_zero_chk to average.c
@
text
@d2 3
d74 1
a74 1
static char     rcsid[] = "$Header: /home/npggw/tom/src/voistat/RCS/voistat.c,v 1.21 1997/03/28 15:49:22 tom Exp tom $";
@


1.21
log
@changed some error messages
@
text
@d2 3
d71 1
a71 1
static char     rcsid[] = "$Header: /home/npggw/tom/src/voistat/RCS/voistat.c,v 1.20 1997/03/19 22:34:31 tom Exp tom $";
@


1.20
log
@add -atlas and map file option
@
text
@d2 3
d68 1
a68 1
static char     rcsid[] = "$Header: /home/npggw/tom/src/voistat/RCS/voistat.c,v 1.19 1997/03/10 16:31:57 tom Exp tom $";
d374 1
a374 1
					fprintf (stderr, "ERROR [voistat] processing %s %s %s\n", fname0,
d386 1
a386 1
						fprintf (stderr, "ERROR [voistat] processing %s\n", fname0);
d412 1
a412 1
					fprintf (stderr, "ERROR [voistat] processing %s\n", fname0);
@


1.19
log
@read frame 1,2 or 3
@
text
@d2 3
d65 1
a65 1
static char     rcsid[] = "$Header: /home/npggw/tom/src/voistat/RCS/voistat.c,v 1.18 1996/11/22 16:04:41 tom Exp tom $";
d73 2
d90 1
d109 1
d111 1
d115 1
d123 1
d132 1
a132 1
	int             i, j, k;
d137 2
a138 2
	if (argc != 13) {
		fprintf (stderr, "Usage: voistat prm lst rgt sd voi date uid\n");
d152 8
d161 2
a162 2
		 argv[6], argv[7], argv[8], argv[9], argv[10], argv[11]);
	uid = argv[12];
d174 1
d178 1
a178 1
	fprintf (stdout, "\nCopyright 1996, Washington University.\n");
d186 1
a186 1
	if (readimglist (lstfile, imglist, &lstsize) == ERROR) {
d204 1
a204 2

	if ((get_input_lists (prmfile, lstsize, filtmode, imgname, &prm, imglist)) == ERROR) {
d208 13
d274 4
a277 12
		if (existimgfrm (file, &indx) == ERROR) {
			if (firstfrm == 1) {
				firstfrm = 2;
				indx.frm = firstfrm;
				if (existimgfrm (file, &indx) == ERROR) {
					indx.frm = 3;
					if (existimgfrm (file, &indx) == ERROR) {
						fprintf (stderr, "ERROR [voistat]: Cannot read %s frame %d\n", fname0, indx.frm);
						return (ERROR);
					}
				}
			} else {
d281 3
d309 10
d415 2
a416 2
				rgtmean (img, pdim, adim, k, voilist, prm, &rgtlist[i].mean[j][k], &rgtlist[i].sd[j][k],
					 &pixused);
@


1.18
log
@add oxygen processing of single images when ntype > 10
@
text
@d2 3
d62 1
a62 1
static char     rcsid[] = "$Header: /home/npggw/tom/src/voistat/RCS/voistat.c,v 1.17 1996/11/06 17:52:45 tom Exp tom $";
d248 5
a252 2
					fprintf (stderr, "ERROR [voistat]: Cannot read %s frame %d\n", fname0, indx.frm);
					return (ERROR);
@


1.17
log
@new libimgutil with correct scaling of cmro2 and oef images
@
text
@d2 3
d59 1
a59 1
static char     rcsid[] = "$Header: /home/npggw/tom/src/voistat/RCS/voistat.c,v 1.16 1996/10/30 22:16:29 tom Exp tom $";
d86 1
a86 1
	HEADER_DATA     hdr;		 	 /* hdr structure */
d117 1
a117 1
	int             firstfrm = 1;	 /* first valid frame */
d267 1
a267 1
				|| rgtlist[i].nframe > 4) {
d281 4
a284 4
		rgtlist[i].time = (float *) malloc ((rgtlist[i].nframe+1) * sizeof (float));
		rgtlist[i].duration = (float *) malloc ((rgtlist[i].nframe+1) * sizeof (float));
		rgtlist[i].mean = (float **) malloc ((rgtlist[i].nframe+1) * sizeof (float *));
		rgtlist[i].sd = (float **) malloc ((rgtlist[i].nframe+1) * sizeof (float *));
d295 18
a312 5
				fname1 = imgname[i][1];
				fname2 = imgname[i][2];
				if ((flowimg = rdtensor (fname1, &indx, pdim)) == NULL) {
					fprintf (stderr, "ERROR [voistat] Cannot read %s\n", fname1);
					return (ERROR);
a313 6
				printf ("   CBF  = %s\n", fname1);
				if ((volimg = rdtensor (fname2, &indx, pdim)) == NULL) {
					fprintf (stderr, "ERROR [voistat]: Cannot open %s\n", fname2);
					return (ERROR);
				}
				printf ("   CBV  = %s\n", fname2);
d328 1
a328 1
					     prm.processing, fname0, fname1, fname2, recfp, &hdr) > 0) {
d339 2
a340 2
					if (readhdr (fname0, &hdr, recfp) == ERROR) {
				if (prm.processing != PROC_NONE) {
d346 1
a347 2
				/*	Compute decay-corrected conversion factor */

d374 1
a374 1
					&pixused);
@


1.16
log
@fix processing of tissue activity
new libimgutil with corrected processPET.c
@
text
@d2 4
d56 1
a56 1
static char     rcsid[] = "$Header: /home/npggw/tom/src/voistat/RCS/voistat.c,v 1.15 1996/10/22 22:10:24 tom Exp tom $";
@


1.15
log
@change call to processPET
alloc of rgtlist
@
text
@d2 4
d52 1
a52 1
static char     rcsid[] = "$Header: /home/npggw/tom/src/voistat/RCS/voistat.c,v 1.14 1996/10/16 17:25:14 tom Exp tom $";
@


1.14
log
@sync with Version
new libimage
@
text
@d2 4
d48 1
a48 1
static char     rcsid[] = "$Header: /home/npggw/tom/src/voistat/RCS/voistat.c,v 1.10 1996/10/03 20:44:01 tom Exp tom $";
d234 1
a234 1
					fprintf (stderr, "ERROR [voistat]: Cannot read frame %d\n", fname0, indx.frm);
d238 1
a238 1
				fprintf (stderr, "ERROR [voistat]: Cannot read frame %d\n", fname0, indx.frm);
d270 4
a273 4
		rgtlist[i].time = (float *) malloc (rgtlist[i].nframe * sizeof (float));
		rgtlist[i].duration = (float *) malloc (rgtlist[i].nframe * sizeof (float));
		rgtlist[i].mean = (float **) malloc (rgtlist[i].nframe * sizeof (float *));
		rgtlist[i].sd = (float **) malloc (rgtlist[i].nframe * sizeof (float *));
d310 1
a310 1
					     prm.processing, fname0, fname1, fname2, recfp) > 0) {
d349 1
a349 1
				if (processPET (img, pdim, scaler, prm.processing, &hdr) > 0) {
@


1.10
log
@change average.c
@
text
@d2 3
d44 1
a44 1
static char     rcsid[] = "$Header: /home/npggw/tom/src/voistat/RCS/voistat.c,v 1.9 1996/09/05 16:23:29 tom Exp tom $";
@


1.9
log
@new libimage
.,
@
text
@d2 4
d41 1
a41 1
static char     rcsid[] = "$Header: /home/npggw/tom/src/voistat/RCS/voistat.c,v 1.8 1996/08/05 14:30:52 tom Exp tom $";
@


1.8
log
@new libimage & libnrimg
@
text
@d2 3
d37 1
a37 1
static char     rcsid[] = "$Header: /home/npggw/tom/src/voistat/RCS/voistat.c,v 1.7 1996/07/19 15:40:25 tom Exp tom $";
@


1.7
log
@only look for hdr if processing != none
@
text
@d2 3
d34 1
a34 1
static char     rcsid[] = "$Header: /home/npggw/tom/src/voistat/RCS/voistat.c,v 1.6 1996/05/24 17:39:16 tom Exp tom $";
d307 1
a308 1
					if (readhdr (fname0, &hdr, recfp) == ERROR) {
@


1.6
log
@new libimage and libnrimg
@
text
@d2 3
d31 1
a31 1
static char     rcsid[] = "$Header: /home/petsun19/tom/src/voistat/RCS/voistat.c,v 1.5 1996/05/17 20:32:04 tom Exp tom $";
d304 2
a305 2
				if (readhdr (fname0, &hdr, recfp) == ERROR) {
					if (prm.processing != PROC_NONE) {
@


1.5
log
@revised libimgutil.a
@
text
@d2 3
d28 1
a28 1
static char     rcsid[] = "$Header: /home/petsun19/tom/src/voistat/RCS/voistat.c,v 1.4 1996/04/26 21:09:46 tom Exp tom $";
@


1.4
log
@revised readvoi.c and writergt.c
@
text
@d2 3
d25 1
a25 1
static char     rcsid[] = "$Header: /home/petsun19/tom/src/voistat/RCS/voistat.c,v 1.3 1996/04/26 15:52:53 tom Exp tom $";
@


1.3
log
@changed structure of rgtlist
@
text
@d2 3
d22 1
a22 1
static char     rcsid[] = "$Header: /home/petsun19/tom/src/voistat/RCS/voistat.c,v 1.2 1996/04/25 20:48:58 tom Exp tom $";
@


1.2
log
@eliminate prompt for zerotime except for decay-corrected on non-corrected processing
@
text
@d2 3
d19 1
a19 1
static char     rcsid[] = "$Header: /home/petsun19/tom/src/voistat/RCS/voistat.c,v 1.1 1996/04/25 16:16:01 tom Exp $";
d79 1
a79 1
	int             i, j;
d225 3
a227 2
		printf ("Time of frame %d = %f sec\n", firstfrm, 0.001 * file->sh->start_time);
		if (prm.processing == PROC_DECAYCOR || prm.processing == PROC_UNCORRECTED) {
d241 4
a244 4
		rgtlist[i].mean = (float *) malloc (sizeof (float) * rgtlist[i].nframe * rgtlist[i].nvoi);
		rgtlist[i].sd = (float *) malloc (sizeof (float) * rgtlist[i].nframe * rgtlist[i].nvoi);
		rgtlist[i].time = (float *) malloc (sizeof (float) * rgtlist[i].nframe * rgtlist[i].nvoi);
		rgtlist[i].duration = (float *) malloc (sizeof (float) * rgtlist[i].nframe * rgtlist[i].nvoi);
d247 2
d252 2
a253 2
			rgtlist[i].time[j-1] = (0.001 * file->sh->start_time) - zerotime;
			rgtlist[i].duration[j-1] = 0.001 * file->sh->duration;
d308 2
a318 2
				rgtlist[i].time[j-1] = frametime;
				rgtlist[i].duration[j-1] = framelen;
d326 5
d333 1
d363 6
a370 2
		free (rgtlist[i].time);
		free (rgtlist[i].duration);
@


1.1
log
@Initial revision
@
text
@d1 4
a4 1
/*	$Log$ */
d16 1
a16 1
static char     rcsid[] = "$Header: /home/petsun19/tom/src/gauss/RCS/gauss.c,v 2.4 1996/02/22 15:34:38 tom Exp tom $";
d223 8
a230 4
		printf ("Enter Zero Time (sec):  ");
		if (scanf ("%f", &zerotime) != 1) {
			fprintf (stderr, "ERROR [voistat]\n");
			return (ERROR);
@
