head	3.1;
access;
symbols;
locks; strict;
comment	@ * @;


3.1
date	2010.05.11.16.01.20;	author tom;	state Exp;
branches;
next	3.0;

3.0
date	2004.02.16.17.36.43;	author tom;	state Exp;
branches;
next	2.7;

2.7
date	2002.11.26.22.27.16;	author tom;	state Exp;
branches;
next	2.6;

2.6
date	98.12.29.18.49.33;	author tom;	state Exp;
branches;
next	2.5;

2.5
date	97.07.24.21.30.16;	author tom;	state Exp;
branches;
next	2.4;

2.4
date	97.01.24.18.19.12;	author tom;	state Exp;
branches;
next	2.3;

2.3
date	96.10.21.22.28.39;	author tom;	state Exp;
branches;
next	2.2;

2.2
date	96.10.11.16.27.46;	author tom;	state Exp;
branches;
next	2.1;

2.1
date	96.08.21.22.36.51;	author tom;	state Exp;
branches;
next	2.0;

2.0
date	96.05.16.19.52.40;	author tom;	state Exp;
branches;
next	1.18;

1.18
date	94.10.03.16.07.58;	author tom;	state Exp;
branches;
next	1.17;

1.17
date	94.09.14.15.09.32;	author ty7777;	state Exp;
branches;
next	1.16;

1.16
date	94.05.19.17.18.00;	author ty7777;	state Exp;
branches;
next	1.15;

1.15
date	94.04.22.16.14.07;	author ty7777;	state Exp;
branches;
next	1.14;

1.14
date	94.04.11.20.59.12;	author ty7777;	state Exp;
branches;
next	1.13;

1.13
date	94.03.10.16.38.12;	author ty7777;	state Exp;
branches;
next	1.12;

1.12
date	93.10.29.20.11.51;	author ty7777;	state Exp;
branches;
next	1.11;

1.11
date	93.10.27.21.26.07;	author ty7777;	state Exp;
branches;
next	1.10;

1.10
date	93.09.03.21.23.27;	author ty7777;	state Exp;
branches;
next	1.9;

1.9
date	93.08.12.17.07.56;	author ty7777;	state Exp;
branches;
next	1.8;

1.8
date	93.08.12.15.46.43;	author ty7777;	state Exp;
branches;
next	1.7;

1.7
date	93.08.09.21.10.13;	author ty7777;	state Exp;
branches;
next	1.6;

1.6
date	93.08.03.19.32.56;	author ty7777;	state Exp;
branches;
next	1.5;

1.5
date	93.08.03.19.30.13;	author ty7777;	state Exp;
branches;
next	1.4;

1.4
date	93.08.02.14.49.17;	author ty7777;	state Exp;
branches;
next	1.3;

1.3
date	93.07.30.16.57.51;	author ty7777;	state Exp;
branches;
next	1.2;

1.2
date	93.07.30.16.53.02;	author ty7777;	state Exp;
branches;
next	1.1;

1.1
date	93.07.30.14.38.04;	author ty7777;	state Exp;
branches;
next	;


desc
@Working version. First release.
@


3.1
log
@revision to buildnames in libimgutil
@
text
@/*	$Id: template.c,v 3.0 2004/02/16 17:36:43 tom Exp tom $
	$Log: template.c,v $
 * Revision 3.0  2004/02/16  17:36:43  tom
 * Feb 2004
 *
 * Revision 2.7  2002/11/26  22:27:16  tom
 * *** empty log message ***
 *
 * Revision 2.6  1998/12/29  18:49:33  tom
 * add voi_order parameter
 *
 * Revision 2.5  1997/07/24  21:30:16  tom
 * fix bug in second CBF/CBV image
 *
 * Revision 2.4  1997/01/24  18:19:12  tom
 * add firstimgfrm to check for frames 1-3
 *
 * Revision 2.3  1996/10/21  22:28:39  tom
 * free_imgfiles added
 *
 * Revision 2.2  1996/10/11  16:27:46  tom
 * update prms to processPET and processOxygen
 *
 * Revision 2.1  1996/08/21  22:36:51  tom
 * correct some free memory omissions
 *
 * Revision 2.0  1996/05/16  19:52:40  tom
 * new libraries
 * */
/* ===============================================================================
 *	Module:			template.c
 *	Author:			Tom Yang
 *	Date:			Jul 1993
 *	Description:	This function creates a thresholded mask image and then
 *					computes the  mean pixel value within this mask for
 *					activation and control images.
 *	History:
 *		Created by Tom Yang on 07/27/1993
 *		30-Sep-94	Modified TOV to call makemask, which allows a peak plane to be specified
 *		21-Feb-96	Modified TOV to call readtensor.
 *		May-96	TOV	Eliminate expansion of image names and filtering from this routine.
 *
 *	Algorithm:
 *		a) Threshold the filtered mask image to mskpct% of the whole brain maximum
 *			or of a specified plane's maximum pixel if peakpln > 0.
 *		b) Mask the filtered activation image by the thresholded mask image and
 *		   compute activation_mean.
 *		c) Mask the filtered control image by the thresholded mask image and
 *		   compute control_mean if image list is paired.
 * ===============================================================================
 */
/*@@unused@@*/
#ifndef lint
static char     rcsid[] = "$Header: /home/npggw/tom/src/imgmean/RCS/template.c,v 3.0 2004/02/16 17:36:43 tom Exp tom $";
#endif

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <image.h>
#include <libimage.h>
#include <nrutil.h>
#include <libnrimg.h>
#include <imgutil.h>

int             template (imgname, oxygen, mskname, prm, list, peakpln)
	char           *(imgname[6]);		 /* complete filenames */
	int             oxygen;			 /* true -> oxygen processing */
	char           *mskname;		 /* complete filename of mask */
	PARAMETER_DATA  prm;			 /* image parameters */
	IMAGE_LIST_DATA *list;			 /* returns activation & control means */
	int             peakpln;		 /* plane of peak to use for thresholding */
{
	ImageFile      *file, *file2;
	Index           indx;
	HEADER_DATA     hdr;			 /* hdr structure */
	FILE           *recfp = NULL;		 /* rec file pointer (unused) */
	float        ***mskimg = NULL;		 /* mask image tensor */
	float        ***image = NULL;		 /* primary image tensor */
	float        ***cbfimg = NULL;		 /* CBF or flow image tensor */
	float        ***cbvimg = NULL;		 /* CBV or volume  image tensor */
	char           *fname;			 /* temp for filenames */
	int             firstpln;		 /* first plane to use in computing mean */
	int             lastpln;		 /* last plane to use in computing mean */
	long            npixels;
	float           sum, fsum, vsum;
	float           cnts, flowcnts, volcnts;
	float           scaler = 1.0;
	long            dim[3];			 /* dimensions of tensors */
	int             i, j, pln;

/*
 *	Initializations
 */

	indx.frm = 1;
	indx.pln = 1;
	indx.gate = 1;
	indx.data = 0;
	indx.bed = 0;

/*
 *	Read the mask image.
 *	Determine the planes in which the peak may exist, and then generate the mask
 */

	file = make_imgfile (mskname);
	if (open_imgfile (file) == ERROR) {
		fprintf (stderr, "ERROR [template]: Cannot open %s\n", mskname);
		return (ERROR);
	}
	if (get_mh (file) == ERROR) {
		fprintf (stderr, "ERROR [template]: Cannot get MainHeader from %s\n", mskname);
		return (ERROR);
	}
	indx.frm = firstimgfrm (file);
	if (indx.frm <= 0) {
		fprintf (stderr, "ERROR [template]: cannot find %s frame 1, 2 or 3\n", mskname);
		return (ERROR);
	}
	if (get_sh (file, &indx) == ERROR) {
		fprintf (stderr, "ERROR [template]: Cannot read file subheader in %s\n", mskname);
		return (ERROR);
	}
	dim[0] = (long) file->sh->dim1;
	dim[1] = (long) file->sh->dim2;
	dim[2] = (long) file->sh->dim3;
	if ((mskimg = readtensor (file, &indx)) == NULL)
		return (ERROR);
	if (prm.first_slice > 0) {
		firstpln = prm.first_slice;
		lastpln = prm.last_slice;
	} else {
		firstpln = 1;
		lastpln = dim[2];
	}
	masktensor (file, mskimg, prm.mskpct, firstpln, lastpln, peakpln, &npixels);
	free_imgfile (file);
	if (npixels == 0) {
		list->mean1 = 0;
		list->mean2 = 0;
		return (OK);
	}
/*
 *	Read the primary image: imgname[0]
 */

	indx.frm = 1;
	indx.pln = 1;
	indx.gate = 1;
	indx.data = 0;
	indx.bed = 0;
	fname = imgname[0];
	file = make_imgfile (fname);
	if (open_imgfile (file) == ERROR) {
		fprintf (stderr, "ERROR [template]: Cannot open %s\n", fname);
		return (ERROR);
	}
	if (get_mh (file) == ERROR) {
		fprintf (stderr, "ERROR [template]: Cannot get MainHeader from %s\n", fname);
		return (ERROR);
	}
	indx.frm = firstimgfrm (file);
	if (indx.frm <= 0) {
		fprintf (stderr, "ERROR [template]: cannot find %s frame 1, 2 or 3\n", fname);
		return (ERROR);
	}
	if (get_sh (file, &indx) == ERROR) {
		fprintf (stderr, "ERROR [template]: Cannot read file subheader in %s\n", fname);
		return (ERROR);
	}
	if ((image = readtensor (file, &indx)) == NULL)
		return (ERROR);
/*
 *	Process the image (if specified):
 */
	if (oxygen == TRUE && prm.imglist_mode == MULTITRACER_IMAGE_MODE) {
		fname = imgname[1];
		file2 = make_imgfile (fname);
		if (open_imgfile (file2) == ERROR) {
			fprintf (stderr, "ERROR [template]: Cannot open %s\n", fname);
			return (ERROR);
		}
		if (get_mh (file2) == ERROR) {
			fprintf (stderr, "ERROR [template]: Cannot get MainHeader from %s\n", fname);
			return (ERROR);
		}
		indx.frm = firstimgfrm (file);
		if (indx.frm <= 0) {
			fprintf (stderr, "ERROR [template]: cannot find %s frame 1, 2 or 3\n", fname);
			return (ERROR);
		}
		if (get_sh (file2, &indx) == ERROR) {
			fprintf (stderr, "ERROR [template]: Cannot read file subheader in %s\n", fname);
			return (ERROR);
		}
		if ((cbfimg = readtensor (file2, &indx)) == NULL)
			return (ERROR);
		free_imgfile (file2);

		fname = imgname[2];
		file2 = make_imgfile (fname);
		if (open_imgfile (file2) == ERROR) {
			fprintf (stderr, "ERROR [template]: Cannot open %s\n", fname);
			return (ERROR);
		}
		if (get_mh (file2) == ERROR) {
			fprintf (stderr, "ERROR [template]: Cannot get MainHeader from %s\n", fname);
			return (ERROR);
		}
		indx.frm = firstimgfrm (file);
		if (indx.frm <= 0) {
			fprintf (stderr, "ERROR [template]: cannot find %s frame 1, 2 or 3\n", fname);
			return (ERROR);
		}
		if (get_sh (file2, &indx) == ERROR) {
			fprintf (stderr, "ERROR [template]: Cannot read file subheader in %s\n", fname);
			return (ERROR);
		}
		if ((cbvimg = readtensor (file2, &indx)) == NULL)
			return (ERROR);
		free_imgfile (file2);
	}
/*  Metabolic conversion before VOIs */

	if (prm.voi_order == 0) {

		if (oxygen == TRUE) {
			if ((processOxygen (image, cbfimg, cbvimg, dim, scaler, prm.processing,
				     imgname[0], imgname[1], imgname[2], recfp, &hdr)) == ERROR) {
				return (ERROR);
			}
		} else {
			fname = imgname[0];
			if (prm.processing != PROC_NONE) {
				if (readhdr (fname, &hdr, recfp) == ERROR) {
					fprintf (stderr, "ERROR [template] processing %s\n", fname);
					return (ERROR);
				}
			}
			if ((processPET (image, dim, scaler, prm.processing, fname, recfp, &hdr)) == ERROR) {
				return (ERROR);
			}
		}

		sum = 0.0;
		for (pln = firstpln; pln <= lastpln; pln++) {
			for (j = 1; j <= dim[1]; j++) {
				for (i = 1; i <= dim[0]; i++) {
					if (mskimg[pln][j][i] > 0.)
						sum += image[pln][j][i];
				}
			}
		}
		list->mean1 = sum / npixels;

	} else {

/*  Metabolic conversion after VOIs */

		if (oxygen == TRUE) {
			sum = 0.0;
			fsum = 0.0;
			vsum = 0.0;
			for (pln = firstpln; pln <= lastpln; pln++) {
				for (j = 1; j <= dim[1]; j++) {
					for (i = 1; i <= dim[0]; i++) {
						if (mskimg[pln][j][i] > 0.) {
							sum += image[pln][j][i];
							fsum += cbfimg[pln][j][i];
							vsum += cbvimg[pln][j][i];
						}
					}
				}
			}
			cnts = sum / npixels;
			flowcnts = fsum / npixels;
			volcnts = vsum / npixels;
			list->mean1 = procOxygen (cnts, flowcnts, volcnts, prm.processing,
						  imgname[0], imgname[1], imgname[2], &hdr, recfp);

		} else {
			fname = imgname[0];
			if (prm.processing != PROC_NONE) {
				if (readhdr (fname, &hdr, recfp) == ERROR) {
					fprintf (stderr, "ERROR [template] processing %s\n", fname);
					return (ERROR);
				}
			}
			sum = 0.0;
			for (pln = firstpln; pln <= lastpln; pln++) {
				for (j = 1; j <= dim[1]; j++) {
					for (i = 1; i <= dim[0]; i++) {
						if (mskimg[pln][j][i] > 0.)
							sum += image[pln][j][i];
					}
				}
			}
			cnts = sum / npixels;
			list->mean1 = procPET (cnts, prm.processing, imgname[0], &hdr, recfp);
		}

	}
	if (image != NULL)
		free_f3tensor (image, 1, dim[2], 1, dim[1], 1, dim[0]);
	if (cbfimg != NULL)
		free_f3tensor (cbfimg, 1, dim[2], 1, dim[1], 1, dim[0]);
	if (cbvimg != NULL)
		free_f3tensor (cbvimg, 1, dim[2], 1, dim[1], 1, dim[0]);
	free_imgfile (file);

/*
 * If there is a second image (activation pair), process it:
 * Oxygen processing uses oo = imgname[3], cbf = imgname[4], cbv = imgname[5]
 * Activation processing uses control = imgname[1]
 */
	if (strlen (list->scanset2_id) > 0) {
		if (oxygen == TRUE && prm.imglist_mode == MULTITRACER_IMAGE_MODE)
			fname = imgname[3];
		else
			fname = imgname[1];
		file = make_imgfile (fname);
		if (open_imgfile (file) == ERROR) {
			fprintf (stderr, "ERROR [template]: Cannot open %s\n", fname);
			return (ERROR);
		}
		if (get_mh (file) == ERROR) {
			fprintf (stderr, "ERROR [template]: Cannot get MainHeader from %s\n", fname);
			return (ERROR);
		}
		indx.frm = firstimgfrm (file);
		if (indx.frm <= 0) {
			fprintf (stderr, "ERROR [template]: cannot find %s frame 1, 2 or 3\n", fname);
			return (ERROR);
		}
		if (get_sh (file, &indx) == ERROR) {
			fprintf (stderr, "ERROR [template]: Cannot read file subheader in %s\n", fname);
			return (ERROR);
		}
		if ((image = readtensor (file, &indx)) == NULL) {
			return (ERROR);
		}
		if (oxygen == TRUE && prm.imglist_mode == MULTITRACER_IMAGE_MODE) {
			fname = imgname[4];
			file2 = make_imgfile (fname);
			if (open_imgfile (file2) == ERROR) {
				fprintf (stderr, "ERROR [template]: Cannot open %s\n", fname);
				return (ERROR);
			}
			if (get_mh (file2) == ERROR) {
				fprintf (stderr, "ERROR [template]: Cannot get MainHeader from %s\n", fname);
				return (ERROR);
			}
			indx.frm = firstimgfrm (file);
			if (indx.frm <= 0) {
				fprintf (stderr, "ERROR [template]: cannot find %s frame 1, 2 or 3\n", fname);
				return (ERROR);
			}
			if (get_sh (file2, &indx) == ERROR) {
				fprintf (stderr, "ERROR [template]: Cannot read file subheader in %s\n", fname);
				return (ERROR);
			}
			if ((cbfimg = readtensor (file2, &indx)) == NULL) {
				return (ERROR);
			}
			free_imgfile (file2);

			fname = imgname[5];
			file2 = make_imgfile (fname);
			if (open_imgfile (file2) == ERROR) {
				fprintf (stderr, "ERROR [template]: Cannot open %s\n", fname);
				return (ERROR);
			}
			if (get_mh (file2) == ERROR) {
				fprintf (stderr, "ERROR [template]: Cannot get MainHeader from %s\n", fname);
				return (ERROR);
			}
			indx.frm = firstimgfrm (file);
			if (indx.frm <= 0) {
				fprintf (stderr, "ERROR [template]: cannot find %s frame 1, 2 or 3\n", fname);
				return (ERROR);
			}
			if (get_sh (file2, &indx) == ERROR) {
				fprintf (stderr, "ERROR [template]: Cannot read file subheader in %s\n", fname);
				return (ERROR);
			}
			if ((cbvimg = readtensor (file2, &indx)) == NULL) {
				return (ERROR);
			}
			free_imgfile (file2);
		}
/*  Metabolic conversion before VOIs */

		if (prm.voi_order == 0) {

			if (oxygen == TRUE) {
				if ((processOxygen (image, cbfimg, cbvimg, dim, scaler, prm.processing,
				     imgname[3], imgname[4], imgname[5], recfp, &hdr)) == ERROR) {
					return (ERROR);
				}
			} else {
				if (prm.processing != PROC_NONE) {
					if (readhdr (fname, &hdr, recfp) == ERROR) {
						fprintf (stderr, "ERROR [template] processing %s\n", fname);
						return (ERROR);
					}
				}
				if ((processPET (image, dim, scaler, prm.processing, imgname[1], recfp, &hdr)) == ERROR) {
					return (ERROR);
				}
			}

			sum = 0.0;
			for (pln = firstpln; pln <= lastpln; pln++) {
				for (j = 1; j <= dim[1]; j++) {
					for (i = 1; i <= dim[0]; i++) {
						if (mskimg[pln][j][i] > 0.)
							sum += image[pln][j][i];
					}
				}

			}
			list->mean2 = sum / npixels;

		} else {

/*  Metabolic conversion after VOIs */

			if (oxygen == TRUE) {
				sum = 0.0;
				fsum = 0.0;
				vsum = 0.0;
				for (pln = firstpln; pln <= lastpln; pln++) {
					for (j = 1; j <= dim[1]; j++) {
						for (i = 1; i <= dim[0]; i++) {
							if (mskimg[pln][j][i] > 0.) {
								sum += image[pln][j][i];
								fsum += cbfimg[pln][j][i];
								vsum += cbvimg[pln][j][i];
							}
						}
					}
				}
				cnts = sum / npixels;
				flowcnts = fsum / npixels;
				volcnts = vsum / npixels;
				list->mean1 = procOxygen (cnts, flowcnts, volcnts, prm.processing,
						 imgname[3], imgname[4], imgname[5], &hdr, recfp);

			} else {
				fname = imgname[1];
				if (prm.processing != PROC_NONE) {
					if (readhdr (fname, &hdr, recfp) == ERROR) {
						fprintf (stderr, "ERROR [template] processing %s\n", fname);
						return (ERROR);
					}
				}
				sum = 0.0;
				for (pln = firstpln; pln <= lastpln; pln++) {
					for (j = 1; j <= dim[1]; j++) {
						for (i = 1; i <= dim[0]; i++) {
							if (mskimg[pln][j][i] > 0.)
								sum += image[pln][j][i];
						}
					}
				}
				cnts = sum / npixels;
				list->mean1 = procPET (cnts, prm.processing, imgname[1], &hdr, recfp);
			}

		}


		if (image != NULL)
			free_f3tensor (image, 1, dim[2], 1, dim[1], 1, dim[0]);
		if (cbfimg != NULL)
			free_f3tensor (cbfimg, 1, dim[2], 1, dim[1], 1, dim[0]);
		if (cbvimg != NULL)
			free_f3tensor (cbvimg, 1, dim[2], 1, dim[1], 1, dim[0]);
		free_imgfile (file);
	}
	free_f3tensor (mskimg, 1, dim[2], 1, dim[1], 1, dim[0]);
/*
 * Normalize the mean if it is required.
 */
	if (prm.voi_norm > 0.0) {
		if (list->mean1 > 0.0)
			list->mean1 = prm.voi_norm / list->mean1;
		if (list->mean2 > 0.0)
			list->mean2 = prm.voi_norm / list->mean2;
	}
	return (OK);
}
@


3.0
log
@Feb 2004
@
text
@d1 1
a1 1
/*	$Id: template.c,v 2.7 2002/11/26 22:27:16 tom Exp tom $
d3 3
d54 1
a54 1
static char     rcsid[] = "$Header: /home/npggw/tom/src/imgmean/RCS/template.c,v 2.7 2002/11/26 22:27:16 tom Exp tom $";
@


2.7
log
@*** empty log message ***
@
text
@d1 1
a1 1
/*	$Id: template.c,v 2.6 1998/12/29 18:49:33 tom Exp tom $
d3 3
d30 1
a30 1
 *	Date:			July, 1993
d49 1
d51 1
a51 1
static char     rcsid[] = "$Header: /home/npggw/tom/src/imgmean/RCS/template.c,v 2.6 1998/12/29 18:49:33 tom Exp tom $";
d174 1
a174 1
	if (oxygen && prm.imglist_mode == MULTITRACER_IMAGE_MODE) {
d225 1
a225 1
		if (oxygen) {
d258 1
a258 1
		if (oxygen) {
d315 1
a315 1
		if (oxygen && prm.imglist_mode == MULTITRACER_IMAGE_MODE)
d340 1
a340 1
		if (oxygen && prm.imglist_mode == MULTITRACER_IMAGE_MODE) {
d393 1
a393 1
			if (oxygen) {
d426 1
a426 1
			if (oxygen) {
@


2.6
log
@add voi_order parameter
@
text
@d1 1
a1 1
/*	$Id: template.c,v 2.5 1997/07/24 21:30:16 tom Exp tom $
d3 3
d47 1
a47 1
static char     rcsid[] = "$Header: /home/npggw/tom/src/imgmean/RCS/template.c,v 2.5 1997/07/24 21:30:16 tom Exp tom $";
a54 1
#include <nr.h>
@


2.5
log
@fix bug in second CBF/CBV image
@
text
@d1 1
a1 1
/*	$Id: template.c,v 2.4 1997/01/24 18:19:12 tom Exp tom $
d3 3
d44 1
a44 1
static char     rcsid[] = "$Header: /home/npggw/tom/src/imgmean/RCS/template.c,v 2.4 1997/01/24 18:19:12 tom Exp tom $";
d77 2
a78 1
	float           sum;
d130 5
a134 1

d215 7
a221 10
	if (oxygen) {
		if ((processOxygen (image, cbfimg, cbvimg, dim, scaler, prm.processing,
				    imgname[0], imgname[1], imgname[2], recfp, &hdr)) == ERROR) {
			return (ERROR);
		}
	} else {
		fname = imgname[0];
		if (prm.processing != PROC_NONE) {
			if (readhdr (fname, &hdr, recfp) == ERROR) {
				fprintf (stderr, "ERROR [template] processing %s\n", fname);
d224 11
d236 9
a244 2
		if ((processPET (image, dim, scaler, prm.processing, fname, recfp, &hdr)) == ERROR) {
			return (ERROR);
d246 1
a246 1
	}
d248 18
a265 6
	sum = 0.0;
	for (pln = firstpln; pln <= lastpln; pln++) {
		for (j = 1; j <= dim[1]; j++) {
			for (i = 1; i <= dim[0]; i++) {
				if (mskimg[pln][j][i] > 0.)
					sum += image[pln][j][i];
d267 25
d293 1
a294 6

	if (npixels > 0)
		list->mean1 = sum / npixels;
	else
		list->mean1 = 0.0;

d383 6
a388 2
		if (oxygen) {
			if ((processOxygen (image, cbfimg, cbvimg, dim, scaler, prm.processing,
a389 6
				return (ERROR);
			}
		} else {
			if (prm.processing != PROC_NONE) {
				if (readhdr (fname, &hdr, recfp) == ERROR) {
					fprintf (stderr, "ERROR [template] processing %s\n", fname);
d392 10
d403 10
a412 2
			if ((processPET (image, dim, scaler, prm.processing, imgname[1], recfp, &hdr)) == ERROR) {
				return (ERROR);
d414 1
a414 1
		}
d416 18
a433 6
		sum = 0.0;
		for (pln = firstpln; pln <= lastpln; pln++) {
			for (j = 1; j <= dim[1]; j++) {
				for (i = 1; i <= dim[0]; i++) {
					if (mskimg[pln][j][i] > 0.)
						sum += image[pln][j][i];
d435 25
a462 4
		if (npixels > 0)
			list->mean2 = sum / npixels;
		else
			list->mean2 = 0.0;
d464 1
@


2.4
log
@add firstimgfrm to check for frames 1-3
@
text
@d1 1
a1 1
/*	$Id: template.c,v 2.3 1996/10/21 22:28:39 tom Exp tom $
d3 3
d41 1
a41 1
static char     rcsid[] = "$Header: /home/npggw/tom/src/imgmean/RCS/template.c,v 2.3 1996/10/21 22:28:39 tom Exp tom $";
d136 2
a137 1
	file = make_imgfile (imgname[0]);
d139 1
a139 1
		fprintf (stderr, "ERROR [template]: Cannot open %s\n", imgname[0]);
d143 1
a143 1
		fprintf (stderr, "ERROR [template]: Cannot get MainHeader from %s\n", imgname[0]);
d148 1
a148 1
		fprintf (stderr, "ERROR [template]: cannot find %s frame 1, 2 or 3\n", imgname[0]);
d152 1
a152 1
		fprintf (stderr, "ERROR [template]: Cannot read file subheader in %s\n", imgname[0]);
d161 2
a162 1
		file2 = make_imgfile (imgname[1]);
d164 1
a164 1
			fprintf (stderr, "ERROR [template]: Cannot open %s\n", imgname[1]);
d168 1
a168 1
			fprintf (stderr, "ERROR [template]: Cannot get MainHeader from %s\n", imgname[1]);
d173 1
a173 1
			fprintf (stderr, "ERROR [template]: cannot find %s frame 1, 2 or 3\n", imgname[1]);
d177 1
a177 1
			fprintf (stderr, "ERROR [template]: Cannot read file subheader in %s\n", imgname[1]);
d184 2
a185 1
		file2 = make_imgfile (imgname[2]);
d187 1
a187 1
			fprintf (stderr, "ERROR [template]: Cannot open %s\n", imgname[2]);
d191 1
a191 1
			fprintf (stderr, "ERROR [template]: Cannot get MainHeader from %s\n", imgname[2]);
d196 1
a196 1
			fprintf (stderr, "ERROR [template]: cannot find %s frame 1, 2 or 3\n", imgname[2]);
d200 1
a200 1
			fprintf (stderr, "ERROR [template]: Cannot read file subheader in %s\n", imgname[2]);
d213 1
d215 2
a216 2
			if (readhdr (imgname[0], &hdr, recfp) == ERROR) {
				fprintf (stderr, "ERROR [template] processing %s\n", imgname[0]);
d220 1
a220 1
		if ((processPET (image, dim, scaler, prm.processing, imgname[0], recfp, &hdr)) == ERROR) {
d280 2
a281 1
			file2 = make_imgfile (imgname[4]);
d283 1
a283 1
				fprintf (stderr, "ERROR [template]: Cannot open %s\n", imgname[4]);
d287 1
a287 1
				fprintf (stderr, "ERROR [template]: Cannot get MainHeader from %s\n", imgname[4]);
d292 1
a292 1
				fprintf (stderr, "ERROR [template]: cannot find %s frame 1, 2 or 3\n", imgname[4]);
d296 1
a296 1
				fprintf (stderr, "ERROR [template]: Cannot read file subheader in %s\n", imgname[4]);
d304 2
a305 1
			file2 = make_imgfile (imgname[5]);
d307 1
a307 1
				fprintf (stderr, "ERROR [template]: Cannot open %s\n", imgname[5]);
d311 1
a311 1
				fprintf (stderr, "ERROR [template]: Cannot get MainHeader from %s\n", imgname[5]);
d316 1
a316 1
				fprintf (stderr, "ERROR [template]: cannot find %s frame 1, 2 or 3\n", imgname[5]);
d320 1
a320 1
				fprintf (stderr, "ERROR [template]: Cannot read file subheader in %s\n", imgname[5]);
d340 1
a340 1
			if ((processPET (image, dim, scaler, prm.processing, imgname[0], recfp, &hdr)) == ERROR) {
@


2.3
log
@free_imgfiles added
@
text
@d1 1
a1 1
/*	$Id: template.c,v 2.2 1996/10/11 16:27:46 tom Exp $
d3 3
d38 1
a38 1
static char     rcsid[] = "$Header: /home/npggw/tom/src/imgmean/RCS/template.c,v 2.2 1996/10/11 16:27:46 tom Exp $";
d52 1
a52 1
	char           *(imgname[6]);	 /* complete filenames */
d62 5
a66 5
	FILE           *recfp = NULL;	 /* rec file pointer (unused) */
	float        ***mskimg = NULL;	 /* mask image tensor */
	float        ***image = NULL;	 /* primary image tensor */
	float        ***cbfimg = NULL;	 /* CBF or flow image tensor */
	float        ***cbvimg = NULL;	 /* CBV or volume  image tensor */
d100 5
d128 5
d142 5
d166 5
d188 5
d260 5
d282 5
d305 5
d321 1
a321 1
					    imgname[3], imgname[4], imgname[5], recfp, &hdr)) == ERROR) {
@


2.2
log
@update prms to processPET and processOxygen
@
text
@d1 1
a1 1
/*	$Id: template.c,v 2.1 1996/08/21 22:36:51 tom Exp tom $
d3 3
d35 1
a35 1
static char     rcsid[] = "$Header: /home/npggw/tom/src/imgmean/RCS/template.c,v 2.1 1996/08/21 22:36:51 tom Exp tom $";
d211 1
d314 1
@


2.1
log
@correct some free memory omissions
@
text
@d1 1
a1 1
/*	$Id: template.c,v 2.0 1996/05/16 19:52:40 tom Exp tom $
d3 3
d32 1
a32 1
static char     rcsid[] = "$Header: /home/npggw/tom/src/imgmean/RCS/template.c,v 2.0 1996/05/16 19:52:40 tom Exp tom $";
d172 1
a172 1
				    imgname[0], imgname[1], imgname[2], recfp)) == ERROR) {
d182 1
a182 1
		if ((processPET (image, dim, scaler, prm.processing, &hdr)) == ERROR) {
d274 1
a274 1
					    imgname[3], imgname[4], imgname[5], recfp)) == ERROR) {
d284 1
a284 1
			if ((processPET (image, dim, scaler, prm.processing, &hdr)) == ERROR) {
@


2.0
log
@new libraries
@
text
@d1 5
a5 2
/*	$Id$
	$Log$ */
a27 1

d29 1
a29 2
static char     rcsid[] = "$Header$";

d98 1
a98 1
	if ((mskimg = readtensor (file, &indx)) == NULL) {
a99 1
	}
d127 1
a127 1
	if ((image = readtensor (file, &indx)) == NULL) {
a128 1
	}
d146 1
a146 1
		if ((cbfimg = readtensor (file2, &indx)) == NULL) {
a147 1
		}
d163 1
a163 1
		if ((cbvimg = readtensor (file2, &indx)) == NULL) {
a164 1
		}
d199 7
a211 6
		if (image != NULL)
			free_f3tensor (image, 1, dim[2], 1, dim[1], 1, dim[0]);
		if (cbfimg != NULL)
			free_f3tensor (cbfimg, 1, dim[2], 1, dim[1], 1, dim[0]);
		if (cbvimg != NULL)
			free_f3tensor (cbvimg, 1, dim[2], 1, dim[1], 1, dim[0]);
d285 1
d294 1
d300 7
d308 1
@


1.18
log
@standardize format with indent
add msk_scan and norm_slices as input parameters;
replace checkimg with checklst;
read peakslice from sxr file;
@
text
@d1 5
a5 58
/*$Id: template.c,v 1.17 1994/09/14 15:09:32 ty7777 Exp tom $*/
/*$Log: template.c,v $
 * Revision 1.17  1994/09/14  15:09:32  ty7777
 * Update the doeumentation.
 *
 * Revision 1.16  1994/05/19  17:18:00  ty7777
 * Separate mask num_slices with image num_slices.
 *
 * Revision 1.15  1994/04/22  16:14:07  ty7777
 * Fixed bug for annmary.
 *
 * Revision 1.14  1994/04/11  20:59:12  ty7777
 * Modified for cbf, cbv, oef, cmro2, and tissue activity processing.
 *
 * Revision 1.13  1994/03/10  16:38:12  ty7777
 * Changed the comments.
 *
 * Revision 1.12  1993/10/29  20:11:51  ty7777
 * Moved build_filter_filename () and filter_image to libhp.a.
 *
 * Revision 1.11  1993/10/27  21:26:07  ty7777
 * Added initialization for matval.
 *
 * Revision 1.10  1993/09/03  21:23:27  ty7777
 * Updated for new list format.
 *
 * Revision 1.9  1993/08/12  17:07:56  ty7777
 * Calling modified setpath ().
 *
 * Revision 1.8  1993/08/12  15:46:43  ty7777
 * Added values.h.
 *
 * Revision 1.7  1993/08/09  21:10:13  ty7777
 * Change FAIL to -MAXINT for non exist control number.
 *
 * Revision 1.6  1993/08/03  19:32:56  ty7777
 * Searching in datapath also.
 *
 * Revision 1.5  1993/08/03  19:30:13  ty7777
 *  Searching filtered images in local and tmp.
 *
 * Revision 1.4  1993/08/02  14:49:17  ty7777
 * Wroking version of template.c
 *
 * Revision 1.3  1993/07/30  16:57:51  ty7777
 *  Added rcsid.
 *
 * Revision 1.2  1993/07/30  16:53:02  ty7777
 * Compute the mean for any selected range of slices.
 *
 * Revision 1.1  1993/07/30  14:38:04  ty7777
 * Initial revision
 **/

static char     rcsid[] = "$Header: /export/home/npggw/tom/src/imgmean/RCS/template.c,v 1.17 1994/09/14 15:09:32 ty7777 Exp tom $";

/*	================================================================================
 *	File Name:		template.c
d7 3
a9 4
 *	Author:			Tom Yang
 *	Description:	This function creates an thresholded mask image (calling makemask),
 *					applies the mask to the activation and control images, and
 *					computes the mean pixel value within the mask for these images.
d12 3
a14 1
 *		30-Sep-94	Modified TOV to call makemask, which allows a peak slice number to be specified
a15 20
 *	Function:
 *		PUBLIC int template (char complete_image_files [][MAXPATH],
 *		int num_image_files, BOOLEAN oxygen_processing,
 *		char *complete_control_filename, char *mskimg_filename,
 *		PARAMETER_DATA parameter_data, IMAGE_LIST_DATA *image_list)
 *
 *	Arguments:
 *		complete_image_files	- complete image names containing both activation and control files
 *		num_image_files			- number of image files in the list.
 *		oxygen_processing		- TRUE: oxygen progrssing; FALSE: other processing
 *		mskimg_filename			- mask image name with path.
 *		parameter_data			- structure containing image parameters.
 *		image_list				- IMAGE_LIST_DATA structure containing activation_mean & control_mean
 *								  modified upon return.
 *		peakslice				- slice to get the peak from from thresholding the mask
 *
 *	Return:
 *		SUCCEED = 0
 *		FAIL = -1
 *
d17 7
a23 78
 *			a) Filter the mask image with mskfilter.
 *			b) Filter each image with imgfilter.
 *			c) Get image dimension.
 *			d) Threshold the filtered mask image to mskpct% of the whole brain maximum
 *				or of a specified slice's maximum pixel if peakslice > 0.
 *			e) Mask the filtered activation image by the thresholded mask image and
 *			   compute activation_mean.
 *			f) Mask the filtered control image by the thresholded mask image and
 *			   compute control_mean if image list is paired.
 *
 *	Called by:	imgmean
 *
 *	Calling:	functions in libhp.a
 *		build_filter_filename (), filter_image (), getimagedim (), getrealimg ().
 *
 *	============================================================================= */

#include <values.h>
#include <petutil/imglist.h>
#include <petutil/matrix.h>
PUBLIC	int	makemask ();

PUBLIC int
template (complete_image_files, num_image_files, oxygen_processing, mskimg_filename, parameter_data,
	  image_list, peakslice)
	char            complete_image_files[][MAXPATH];
	int             num_image_files;
	BOOLEAN         oxygen_processing;
	char           *mskimg_filename;
	PARAMETER_DATA  parameter_data;
	IMAGE_LIST_DATA *image_list;
	int				peakslice;
{
	BOOLEAN         filter_found[6];
	BOOLEAN         bool_value;
	BOOLEAN         mskfilter_found;
	Image_subheader **subheader_list;
	Main_header    *main_header;
	char            cbuffer[MAXNAME];
	char            command[MAXPATH];
	char            complete_control_image[MAXPATH];
	char            complete_filtered_images[6][MAXPATH];
	char            filtered_mskimg[MAXPATH];
	char            short_filtered_images[6][MAXLINE];
	char            short_filtered_mskimg[MAXLINE];
	char            subject_id[MAXNAME];
	float          *flow3d;
	float          *image3d;
	float          *volume3d;
	float           mask_pixel_height;
	float           mask_pixel_width;
	float           mask_plane_separation;
	float           pixel_height;
	float           pixel_width;
	float           plane_separation;
	float           sum;
	int             first_slice;
	int             i;
	int             last_slice;
	int             mask_scanner;
	int             scanner;
	long            end_index;
	long            image_dimension;
	long            start_index;
	long            slice_dimension;
	long            pixels_in_mask;
	short           height;
	short          *mask3d;
	short           mask_height;
	short           mask_width;
	short           mask_num_slices;
	short           num_slices;
	short           width;
	struct INFO_TYPE finfo;
	struct Matval   matval;

/*
 * Initialization for matval.
a24 5
	matval.frame = 1;
	matval.plane = 1;
	matval.gate = 1;
	matval.data = 0;
	matval.bed = 0;
d26 2
a27 5
/*
 * Construct the subject id.
 */
	strcpy (subject_id, parameter_data.species);
	strcat (subject_id, image_list->subject_id);
d29 1
a29 4
/*
 * Fill the finfo structure for searching in archive.
 */
	get_finfo (parameter_data, &finfo);
d31 9
a39 7
/*
 * Filter the mask image if necessary.
 * (Do NOT filter if mskimg is "specified" in prm file, but DO if specified in command line)
 */
	if (parameter_data.mskfilter_type != FILTER_NONE &&
		parameter_data.mskimg_type != MASK_SPECIFIED &&
	    strncmp (parameter_data.scanner, "953", 3) == 0) {
d41 24
a64 7
/*
 * Construct filtered mask image name.
 */
		strncpy (short_filtered_mskimg, "\0", MAXLINE);
		build_filter_filename (mskimg_filename, parameter_data.mskfilter_type,
			parameter_data.mskfilter_cutoff, parameter_data.mskfilter_order,
			    short_filtered_mskimg);
d67 1
a67 1
 * Filter the raw mask image if necessary.
a68 3
		if (mskfilter_found = setpath (parameter_data.datapath, short_filtered_mskimg,
					  subject_id, &finfo, filtered_mskimg, TRUE) != SUCCEED) {
			strcpy (filtered_mskimg, short_filtered_mskimg);
d70 5
a74 10
			if (filter_image (mskimg_filename, parameter_data.mskfilter_type,
				  parameter_data.mskfilter_cutoff, parameter_data.mskfilter_order,
					  filtered_mskimg) == FAIL) {
				fprintf (stderr, "Error in filtering image %s\n", mskimg_filename);
				return FAIL;
			}
		}
	} else
		strcpy (filtered_mskimg, mskimg_filename);
	fprintf (stdout, "%s\n", filtered_mskimg);
d77 2
a78 1
 * Filter the activation image and control image if necessary.
a79 2
	if (parameter_data.imgfilter_type != FILTER_NONE &&
	    strncmp (parameter_data.scanner, "953", 3) == 0) {
d81 4
a84 32
/*
 * Construct filtered short image name.
 */
		for (i = 0; i < num_image_files; i++) {
			strncpy (short_filtered_images[i], "\0", MAXLINE);
			build_filter_filename (complete_image_files[i],
					       parameter_data.imgfilter_type,
					       parameter_data.imgfilter_cutoff,
					       parameter_data.imgfilter_order,
					       short_filtered_images[i]);

/*
 * Filter the raw activation image if necessary.
 */
			if (filter_found[i] = setpath (parameter_data.datapath,
			short_filtered_images[i], subject_id, &finfo, complete_filtered_images[i],
						       TRUE) != SUCCEED) {
				strcpy (complete_filtered_images[i], short_filtered_images[i]);

				if (filter_image (complete_image_files[i],
				   parameter_data.imgfilter_type, parameter_data.imgfilter_cutoff,
						  parameter_data.imgfilter_order, complete_filtered_images[i]) == FAIL) {
					fprintf (stderr, "Error in filtering activation image %s\n",
						 complete_image_files[i]);
					return FAIL;
				}
			}
		}
	} else {
		for (i = 0; i < num_image_files; i++) {
			strcpy (complete_filtered_images[i], complete_image_files[i]);
		}
d86 3
a88 8

/*
 * Get image dimension and allocate memory for 3D mask image.
 */
	if (getimagedim (filtered_mskimg, matval, &mask_scanner, &mask_width, &mask_height,
			&mask_num_slices, &mask_pixel_width, &mask_pixel_height, &mask_plane_separation) == FAIL) {
		fprintf (stderr, "getimagedim () error in template.\n");
		return FAIL;
d90 3
a92 12
	slice_dimension = mask_width * mask_height;
	image_dimension = slice_dimension * mask_num_slices;
	mask3d = (short *) pkg_malloc (image_dimension * sizeof (short), "template", "mask3d");

/*
 *	Threshold the filtered mask image.
 */
	first_slice = parameter_data.first_slice;
	last_slice = parameter_data.last_slice;
	if (first_slice == 0 && last_slice == 0) {
		first_slice = 1;
		last_slice = mask_num_slices;
d94 5
a98 9
	if (last_slice > mask_num_slices)
		last_slice = mask_num_slices;

	if (makemask (filtered_mskimg, mask_scanner, parameter_data.mskpct, mask_width, mask_height,
		mask_num_slices, first_slice, last_slice, mask3d, &pixels_in_mask, peakslice) == FAIL) {
        fprintf (stderr, "makemask () error in template for image %s.\n",
             complete_filtered_images[0]);
        free (mask3d);
        return FAIL;
d100 9
d111 1
a111 1
 *	Read in the activation image, the control image, and compute the mean.
d113 5
a117 6
	if (getimagedim (complete_filtered_images[0], matval, &scanner, &width, &height,
		&num_slices, &pixel_width, &pixel_height, &plane_separation) == FAIL) {
		fprintf (stderr, "getimagedim () error in template for image %s.\n",
			 complete_filtered_images[0]);
		free (mask3d);
		return FAIL;
d119 3
a121 17
	if (mask_width != width || mask_height != height
	    || mask_pixel_width != pixel_width || mask_pixel_height != pixel_height
	    || mask_plane_separation != plane_separation) {
		fprintf (stderr, "Error: maskimage %s aand control image %s either has\n",
			 filtered_mskimg, complete_filtered_images[0]);
		fprintf (stderr,
			 "       different slice width or height, or different voxel size\n");
		fprintf (stderr, "Maskimage %s dimension %d x %d x %d\n", filtered_mskimg,
			 mask_width, mask_height, mask_num_slices);
		fprintf (stderr, "Maskimage %s voxel_size %f x %f x %f\n", filtered_mskimg,
			 mask_pixel_width, mask_pixel_height, mask_plane_separation);
		fprintf (stderr, "Image %s dimension %d x %d x %d\n", complete_filtered_images[0],
			 width, height, num_slices);
		fprintf (stderr, "Image %s voxel_size %f x %f x %f\n", complete_filtered_images[0],
			 pixel_width, pixel_height, plane_separation);
		free (mask3d);
		return FAIL;
d123 3
a125 3
	if (mask_num_slices != num_slices) {
		fprintf (stderr, "Warning: maskimage %s has %d slices\n", filtered_mskimg, mask_num_slices);
		fprintf (stderr, "Warning: image %s has %d slices\n", complete_filtered_images[0], num_slices);
d127 2
a128 5
	main_header = (Main_header *) calloc (1, sizeof (Main_header));
	if (main_header == (Main_header *) NULL) {
		fprintf (stderr, "Memory allocation error for main_header in threshold.c.\n");
		free (mask3d);
		return FAIL;
a129 22
	subheader_list = (Image_subheader **) pkg_malloc (num_slices * sizeof (caddr_t),
							  "threshold", "subheader_list");
	if (subheader_list == (Image_subheader **) NULL) {
		fprintf (stderr, "Memory allocation error for subheader_list in threshold.c.\n");
		free (mask3d);
		return FAIL;
	}
	slice_dimension = width * height;
	image_dimension = slice_dimension * num_slices;
	image3d = (float *) pkg_malloc (image_dimension * sizeof (float), "template", "image3d");
	if (image3d == (float *) NULL) {
		fprintf (stderr, "Memory allocation error for image3d in threshold.c.\n");
		free (mask3d);
		return FAIL;
	}
	if (getrealimg (complete_filtered_images[0], scanner, matval, width, height,
			num_slices, image3d, main_header, subheader_list) == FAIL) {
		fprintf (stderr, "Error in getrealimg ().\n");
		free (mask3d);
		free (image3d);
		return FAIL;
	}
d131 1
a131 1
 *	Process the image.
d133 5
a137 7
	if (oxygen_processing && parameter_data.imglist_mode == MULTITRACER_IMAGE_MODE) {
		flow3d = (float *) pkg_malloc (image_dimension * sizeof (float),"template", "flow3d");
		if (flow3d == (float *) NULL) {
			fprintf (stderr, "Memory allocation error for flow3d in threshold.c.\n");
			free (mask3d);
			free (image3d);
			return FAIL;
d139 3
a141 7
		if (getrealimg (complete_filtered_images[1], scanner, matval, width, height,
				num_slices, flow3d, main_header, subheader_list) == FAIL) {
			fprintf (stderr, "Error in getrealimg ().\n");
			free (mask3d);
			free (image3d);
			free (flow3d);
			return FAIL;
d143 3
a145 7
		volume3d = (float *) pkg_malloc (image_dimension * sizeof (float), "template", "volume3d");
		if (volume3d == (float *) NULL) {
			fprintf (stderr, "Memory allocation error for volume3d in threshold.c.\n");
			free (mask3d);
			free (image3d);
			free (flow3d);
			return FAIL;
d147 2
a148 8
		if (getrealimg (complete_filtered_images[2], scanner, matval, width, height,
				num_slices, volume3d, main_header, subheader_list) == FAIL) {
			fprintf (stderr, "Error in getrealimg ().\n");
			free (mask3d);
			free (image3d);
			free (flow3d);
			free (volume3d);
			return FAIL;
d150 19
d170 5
a174 4
	if (oxygen_processing) {
		bool_value = ProcessOxygen (image3d, flow3d, volume3d, image_dimension,
			parameter_data.processing, complete_filtered_images[0],
			complete_filtered_images[1], complete_filtered_images[2]);
d176 9
a184 2
		bool_value = ProcessImage (image3d, image_dimension, parameter_data.processing,
			parameter_data.halflife, complete_filtered_images[0], matval);
a186 9
	if (bool_value == FAIL) {
		fprintf (stderr, "Error processing %s\n", complete_filtered_images[0]);
		free (mask3d);
		free (image3d);
		return FAIL;
	}
	start_index = (first_slice - 1) * slice_dimension;
	end_index = last_slice * slice_dimension;

d188 6
a193 3
	for (i = start_index; i < end_index; i++) {
		if (mask3d[i]) {
			sum += image3d[i];
d197 2
a198 2
	if (pixels_in_mask > 0)
		image_list->mean1 = sum / pixels_in_mask;
d200 1
a200 1
		image_list->mean1 = 0.0;
d202 14
a215 4
	if (strlen (image_list->scanset2_id) > 0) {
		if (oxygen_processing &&
		    parameter_data.imglist_mode == MULTITRACER_IMAGE_MODE)
			strcpy (complete_control_image, complete_filtered_images[3]);
d217 22
a238 13
			strcpy (complete_control_image, complete_filtered_images[1]);

		if (oxygen_processing &&
		    parameter_data.imglist_mode == MULTITRACER_IMAGE_MODE) {
			if (getrealimg (complete_filtered_images[4], scanner, matval,
			width, height, num_slices, flow3d, main_header, subheader_list) == FAIL) {
				fprintf (stderr, "Error in getrealimg ().\n");
				free (mask3d);
				free (image3d);
				free (flow3d);
				free (volume3d);

				return FAIL;
d240 12
a251 3
			if (getrealimg (complete_filtered_images[5], scanner, matval,
					width, height, num_slices, volume3d, main_header, subheader_list) == FAIL) {
				fprintf (stderr, "Error in getrealimg ().\n");
d253 4
a256 6
				free (mask3d);
				free (image3d);
				free (flow3d);
				free (volume3d);

				return FAIL;
d258 12
d271 5
a275 17
		if (getrealimg (complete_control_image, scanner, matval, width, height,
				num_slices, image3d, main_header, subheader_list) == FAIL) {
			fprintf (stderr, "Error in getrealimg ().\n");

			free (mask3d);
			free (image3d);
			free (flow3d);
			free (volume3d);

			return FAIL;
		}
		if (oxygen_processing) {
			bool_value = ProcessOxygen (image3d, flow3d,
					     volume3d, image_dimension, parameter_data.processing,
						    complete_filtered_images[3],
						    complete_filtered_images[4],
						    complete_filtered_images[5]);
d277 9
a285 4
			bool_value = ProcessImage (image3d, image_dimension,
						   parameter_data.processing,
						   parameter_data.halflife,
						   complete_control_image, matval);
a286 11

		if (bool_value == FAIL) {
			fprintf (stderr, "Error processing %s\n", complete_control_image);

			free (mask3d);
			free (image3d);
			free (flow3d);
			free (volume3d);

			return FAIL;
		}
d288 7
a294 3
		for (i = start_index; i < end_index; i++) {
			if (mask3d[i])
				sum += image3d[i];
d296 2
a297 3

		if (pixels_in_mask > 0)
			image_list->mean2 = sum / pixels_in_mask;
d299 1
a299 1
			image_list->mean2 = 0.0;
d304 5
a308 7
	if (parameter_data.voi_norm > 0.0) {
		if (image_list->mean1 > 0.0)
			image_list->mean1 = parameter_data.voi_norm
				/ image_list->mean1;
		if (image_list->mean2 > 0.0)
			image_list->mean2 = parameter_data.voi_norm
				/ image_list->mean2;
d310 1
a310 49
/*
 * Free memories.
 */
	for (i = 0; i < num_slices; i++)
		free (subheader_list[i]);
	free (subheader_list);
	free (main_header);
	free (mask3d);
	free (image3d);
	if (oxygen_processing && parameter_data.imglist_mode == MULTITRACER_IMAGE_MODE) {
		free (flow3d);
		free (volume3d);
	}
/*
 *	Move the filtered image files in the local directory to /tmp.
 *	Do NOT move if "mskimg: specified" in prm file!
 */
	strcpy (cbuffer, "/bin/mv ");
	if (parameter_data.mskfilter_type != FILTER_NONE && 
		parameter_data.mskimg_type != MASK_SPECIFIED &&
		strncmp (parameter_data.scanner, "953", 3) == 0) {
		if (mskfilter_found != SUCCEED) {
			strcpy (command, cbuffer);
			strcat (command, filtered_mskimg);
			strcat (command, " /tmp");
			if (system (command) != 0) {
				fprintf (stderr, "Error in removing temporary filtered mask file %s\n",
					 filtered_mskimg);
				return FAIL;
			}
		}
	}
	if (parameter_data.imgfilter_type != FILTER_NONE &&
	    strncmp (parameter_data.scanner, "953", 3) == 0) {
		for (i = 0; i < num_image_files; i++) {
			if (filter_found[i] != SUCCEED) {
				strcpy (command, cbuffer);
				strcat (command, complete_filtered_images[i]);
				strcat (command, " /tmp");
				if (system (command) != 0) {
					fprintf (stderr,
						 "Error in removing temporary filtered file %s\n",
						 complete_filtered_images[i]);
					return FAIL;
				}
			}
		}
	}
	return SUCCEED;
@


1.17
log
@Update the doeumentation.
@
text
@d1 1
a1 1
/*$Id: template.c,v 1.16 1994/05/19 17:18:00 ty7777 Exp ty7777 $*/
d3 3
d55 1
a55 1
static char rcsid [] = "$Header: /home/petsun4/ty7777/src/imgmean/RCS/template.c,v 1.16 1994/05/19 17:18:00 ty7777 Exp ty7777 $";
d57 48
a104 2
/*______________________________________________________________________________
File Name:	template.c
a105 51
Function:	PUBLIC int template (char complete_image_files [][MAXPATH], 
		int num_image_files, BOOLEAN oxygen_processing,
		char *complete_control_filename, char *mskimg_filename, 
		PARAMETER_DATA parameter_data, IMAGE_LIST_DATA *image_list)

Arguments:	complete_image_files:		complete image names containing both
						the activation and control files.
		num_image_files,		number of image files in the list.
		oxygen_processing,		TRUE: oxygen progrssing; FALSE: other
						processing.
		mskimg_filename:		mask image name with path.
		parameter_data:			structure containing image parameters.
		image_list:			IMAGE_LIST_DATA structure containing
						activation_mean and control_mean,
						modified upon return.

Return:		SUCCEED = 0, successful.
		FAIL = -1, failed.

Description:	This function creats an thresholded mask image and apply the mask image
		to the activation image and control image to compute mean. 

Algorithm: 

		a) Filter the mask image with mskfilter.

		b) Filter each image with imgfilter.

		c) Get image dimension.

		d) Threshold the filtered mask image to mskpct% of the whole brain maximum

		e) Mask the filtered activation image by the thresholded mask image and
		   compute activation_mean.

		f) Mask the filtered control image by the thresholded mask image and
		   compute control_mean if image list is paired.

Called by:	The main program in imgmean.c.	

Calling:	functions in libhp.a
		build_filter_filename (), filter_image (), getimagedim (), getrealimg ().

		threshold () in threshold.c

Author:		Tom Yang, July, 1993.

History:	Created by Tom Yang on 07/27/1993

______________________________________________________________________________*/

d109 1
d111 10
a120 8
PUBLIC int template (complete_image_files, num_image_files, oxygen_processing, 
	mskimg_filename, parameter_data, image_list)
	char 			complete_image_files [][MAXPATH];
	int 			num_image_files;
	BOOLEAN			oxygen_processing;
	char			*mskimg_filename;
	PARAMETER_DATA		parameter_data;
	IMAGE_LIST_DATA		*image_list;
d122 42
a163 42
	BOOLEAN			filter_found [6];
	BOOLEAN			bool_value;
	BOOLEAN			mskfilter_found;
	Image_subheader		**subheader_list;
	Main_header		*main_header;
	char			cbuffer [MAXNAME];
	char			command [MAXPATH];	
	char			complete_control_image [MAXPATH];
	char			complete_filtered_images [6][MAXPATH];
	char			filtered_mskimg [MAXPATH];
	char			short_filtered_images [6][MAXLINE];
	char			short_filtered_mskimg [MAXLINE];
	char			subject_id [MAXNAME];
	float			*flow3d;
	float			*image3d;
	float			*volume3d;
	float			mask_pixel_height;
	float			mask_pixel_width;
	float			mask_plane_separation;
	float			pixel_height;
	float			pixel_width;
	float			plane_separation;
	float			total_sum;
	int			first_slice;
	int			i;
	int			last_slice;
	int			mask_scanner;
	int			scanner;
	long			end_index;
	long			image_dimension;
	long			start_index;
	long			slice_dimension;
	long			total_pixel;
	short			height;
	short			*mask3d;
	short			mask_height;
	short			mask_width;
	short			mask_num_slices;
	short			num_slices;
	short			width;
	struct INFO_TYPE	finfo;
	struct Matval		matval;
d165 8
a172 8
	/*______________________________________________________
	 * Initialization for matval.
	 *______________________________________________________*/
	matval.frame	= 1;
	matval.plane	= 1;
	matval.gate	= 1;
	matval.data	= 0;
	matval.bed	= 0;
d174 3
a176 3
	/* 
	 * Construct the subject id.
	 */
d180 3
a182 3
	/* 
	 * Fill the finfo structure for searching in archive.
	 */
d185 4
a188 3
	/*
	 * Filter the mask image if necessary.
	 */
d190 6
a195 5
	strncmp (parameter_data.scanner, "953", 3) == 0)
	{
		/*
		 * Construct filtered mask image name.
		 */
d197 3
a199 3
		build_filter_filename (mskimg_filename, parameter_data.mskfilter_type, 
			parameter_data.mskfilter_cutoff, parameter_data.mskfilter_order, 
			short_filtered_mskimg);
d201 5
a205 6
		/*
		 * Filter the raw mask image if necessary.
		 */
		if (mskfilter_found = setpath (parameter_data.datapath, short_filtered_mskimg, 
		subject_id, &finfo, filtered_mskimg, TRUE) != SUCCEED)
		{
d208 3
a210 4
			if (filter_image (mskimg_filename, parameter_data.mskfilter_type, 
			parameter_data.mskfilter_cutoff, parameter_data.mskfilter_order, 
			filtered_mskimg) == FAIL)
			{
d215 1
a215 2
	}
	else
d217 1
d219 3
a221 3
	/*
	 * Filter the activation image and control image if necessary.
	 */
d223 1
a223 21
	strncmp (parameter_data.scanner, "953", 3) == 0)
	{
		/*
		 * Construct filtered short image name.
		 */
		for (i = 0; i < num_image_files; i++)
		{
			strncpy (short_filtered_images [i], "\0", MAXLINE);
			build_filter_filename (complete_image_files [i], 
						parameter_data.imgfilter_type, 
						parameter_data.imgfilter_cutoff, 
						parameter_data.imgfilter_order, 
						short_filtered_images [i]);
			/*
		 	 * Filter the raw activation image if necessary.
		 	 */
			if (filter_found [i] = setpath (parameter_data.datapath, 
			short_filtered_images [i], subject_id, &finfo, complete_filtered_images [i], 
			TRUE) != SUCCEED)
			{
				strcpy (complete_filtered_images [i], short_filtered_images [i]);
d225 24
a248 6
				if (filter_image (complete_image_files [i], 
				parameter_data.imgfilter_type, parameter_data.imgfilter_cutoff, 
				parameter_data.imgfilter_order, complete_filtered_images [i]) == FAIL)
				{
					fprintf (stderr, "Error in filtering activation image %s\n", 
						complete_image_files [i]);
d253 3
a255 6
	}
	else
	{
		for (i = 0; i < num_image_files; i++)
		{
			strcpy (complete_filtered_images [i], complete_image_files [i]);
d259 5
a263 6
	/*
	 * Get image dimension and allocate memory for 3D mask image.
	 */
	if (getimagedim (filtered_mskimg, matval, &mask_scanner, &mask_width, &mask_height, 
	&mask_num_slices, &mask_pixel_width, &mask_pixel_height, &mask_plane_separation) == FAIL) 
	{
d267 3
d271 8
a278 13
	slice_dimension	= mask_width * mask_height;
	image_dimension	= slice_dimension * mask_num_slices;
	mask3d		= (short *) pkg_malloc (image_dimension * sizeof (short), "template", "mask3d");

	/*
	 * Thresholding the filtered mask image.
	 */
	first_slice	= parameter_data.first_slice;
	last_slice	= parameter_data.last_slice;
	if (first_slice == 0 && last_slice == 0)
	{
		first_slice	= 1;
		last_slice	= mask_num_slices;
a279 1

d281 1
a281 1
		last_slice	= mask_num_slices;
d283 7
a289 2
	threshold (filtered_mskimg, mask_scanner, parameter_data.mskpct, mask_width, 
	mask_height, mask_num_slices, first_slice, last_slice, mask3d, &total_pixel);	
d291 5
a295 6
	/*
	 * Read in the activation image, the control image, and compute the mean.
	 */
	if (getimagedim (complete_filtered_images [0], matval, &scanner, &width, &height, 
	&num_slices, &pixel_width, &pixel_height, &plane_separation) == FAIL) 
	{
d297 1
a297 1
		complete_filtered_images [0]);
d301 3
a303 5

	if (mask_width != width || mask_height != height 
	|| mask_pixel_width != pixel_width || mask_pixel_height != pixel_height
	|| mask_plane_separation != plane_separation)
	{
d305 3
a307 3
			filtered_mskimg, complete_filtered_images [0]);
		fprintf (stderr, 
			"       different slice width or height, or different voxel size\n");
d309 1
a309 1
			mask_width, mask_height, mask_num_slices);
d311 5
a315 5
			mask_pixel_width, mask_pixel_height, mask_plane_separation);
		fprintf (stderr, "Image %s dimension %d x %d x %d\n", complete_filtered_images [0],
			width, height, num_slices);
		fprintf (stderr, "Image %s voxel_size %f x %f x %f\n", complete_filtered_images [0],
			pixel_width, pixel_height, plane_separation);
d319 3
a321 7

	if (mask_num_slices != num_slices)
	{
		fprintf (stderr, "Warning: maskimage %s has %d slices\n", 
			filtered_mskimg, mask_num_slices);
		fprintf (stderr, "Warning: image %s has %d slices\n", 
			complete_filtered_images [0], num_slices);
d323 3
a325 5

	main_header	= (Main_header *) calloc (1, sizeof (Main_header));
	if (main_header == (Main_header *) NULL)
	{
		fprintf (stderr, "Memory allocation error for main_header in threshold.c.\n"); 
d329 4
a332 6

	subheader_list	= (Image_subheader **) pkg_malloc (num_slices * sizeof (caddr_t), 
				"threshold", "subheader_list");
	if (subheader_list == (Image_subheader **) NULL)
	{
		fprintf (stderr, "Memory allocation error for subheader_list in threshold.c.\n"); 
d336 5
a340 7

	slice_dimension	= width * height;
	image_dimension	= slice_dimension * num_slices;
	image3d		= (float *) pkg_malloc (image_dimension * sizeof (float), "template", "image3d");
	if (image3d == (float *) NULL)
	{
		fprintf (stderr, "Memory allocation error for image3d in threshold.c.\n"); 
d344 2
a345 4

	if (getrealimg (complete_filtered_images [0], scanner, matval, width, height, 
	num_slices, image3d, main_header, subheader_list) == FAIL)
	{
d351 7
a357 12

	/*
	 * Processing image.
	 */
	if (oxygen_processing && 
	parameter_data.imglist_mode == MULTITRACER_IMAGE_MODE)
	{
		flow3d		= (float *) pkg_malloc (image_dimension * sizeof (float), 
				"template", "flow3d");
		if (flow3d == (float *) NULL)
		{
			fprintf (stderr, "Memory allocation error for flow3d in threshold.c.\n"); 
a359 1

d362 2
a363 4

		if (getrealimg (complete_filtered_images [1], scanner, matval, width, height, 
		num_slices, flow3d, main_header, subheader_list) == FAIL)
		{
a367 1

d370 3
a372 6

		volume3d	= (float *) pkg_malloc (image_dimension * sizeof (float), 
				"template", "volume3d");
		if (volume3d == (float *) NULL)
		{
			fprintf (stderr, "Memory allocation error for volume3d in threshold.c.\n"); 
a375 1

d378 2
a379 4

		if (getrealimg (complete_filtered_images [2], scanner, matval, width, height, 
		num_slices, volume3d, main_header, subheader_list) == FAIL)
		{
a384 1

d388 7
a394 8

	if (oxygen_processing)
	{
		bool_value	= ProcessOxygen (image3d, flow3d, 
				volume3d, image_dimension, parameter_data.processing, 
				complete_filtered_images [0], 
				complete_filtered_images [1], 
				complete_filtered_images [2]);
a395 7
	else 
	{
		bool_value	= ProcessImage (image3d, image_dimension, 
				parameter_data.processing, 
				parameter_data.halflife, 
				complete_filtered_images [0], matval);
	}
d397 2
a398 3
	if (bool_value == FAIL)
	{
		fprintf (stderr, "Error processing %s\n", complete_filtered_images [0]);
d403 2
d406 4
a409 9
	start_index	= (first_slice - 1) * slice_dimension;
	end_index	= last_slice * slice_dimension;

	total_sum	= 0.0;
	for (i = start_index; i < end_index; i++)
	{
		if (mask3d [i])
		{
			total_sum	+= image3d [i];
d413 2
a414 2
	if (total_pixel > 0)
		image_list->mean1	= total_sum / total_pixel;
d416 1
a416 1
		image_list->mean1	= 0.0;
d418 4
a421 5
	if (strlen (image_list->scanset2_id) > 0)
	{
		if (oxygen_processing && 
		parameter_data.imglist_mode == MULTITRACER_IMAGE_MODE)
			strcpy (complete_control_image, complete_filtered_images [3]);
d423 1
a423 1
			strcpy (complete_control_image, complete_filtered_images [1]);
d425 4
a428 6
		if (oxygen_processing && 
		parameter_data.imglist_mode == MULTITRACER_IMAGE_MODE)
		{
			if (getrealimg (complete_filtered_images [4], scanner, matval, 
			width, height, num_slices, flow3d, main_header, subheader_list) == FAIL)
			{
d437 2
a438 4

			if (getrealimg (complete_filtered_images [5], scanner, matval, 
			width, height, num_slices, volume3d, main_header, subheader_list) == FAIL)
			{
d449 2
a450 4

		if (getrealimg (complete_control_image, scanner, matval, width, height, 
		num_slices, image3d, main_header, subheader_list) == FAIL)
		{
d460 11
a470 8

		if (oxygen_processing)
		{
			bool_value	= ProcessOxygen (image3d, flow3d, 
				volume3d, image_dimension, parameter_data.processing, 
				complete_filtered_images [3], 
				complete_filtered_images [4], 
				complete_filtered_images [5]);
a471 7
		else 
		{
			bool_value	= ProcessImage (image3d, image_dimension, 
					parameter_data.processing, 
					parameter_data.halflife, 
					complete_control_image, matval);
		}
d473 1
a473 2
		if (bool_value == FAIL)
		{
d483 4
a486 6

		total_sum	= 0.0;
		for (i = start_index; i < end_index; i++)
		{
			if (mask3d [i])
				total_sum	+= image3d [i];
d489 2
a490 2
		if (total_pixel > 0)
			image_list->mean2	= total_sum / total_pixel;
d492 1
a492 1
			image_list->mean2	= 0.0;
d494 4
a497 6

	/*
	 * Normalize the mean if it is required.
	 */
	if (parameter_data.voi_norm > 0.0)
	{ 
d499 2
a500 2
			image_list->mean1	= parameter_data.voi_norm 
						/ image_list->mean1;
d502 2
a503 2
			image_list->mean2	= parameter_data.voi_norm 
						/ image_list->mean2;
d505 3
a507 4

	/*
	 * Free memories.
	 */
d509 1
a509 3
	{
		free (subheader_list [i]);
	}
a511 1

d514 1
a514 3
	if (oxygen_processing && 
	parameter_data.imglist_mode == MULTITRACER_IMAGE_MODE)
	{
d518 4
a521 4

	/*
	 * Move the filtered image file in the local directory to /tmp.
	 */
d523 4
a526 5
	if (parameter_data.mskfilter_type != FILTER_NONE &&
	strncmp (parameter_data.scanner, "953", 3) == 0)
	{
		if (mskfilter_found != SUCCEED)
		{
d530 3
a532 4
			if (system (command) != 0)
			{
				fprintf (stderr, "Error in removing temporary filtered mask file %s\n", 
					filtered_mskimg);
a536 1

d538 3
a540 6
	strncmp (parameter_data.scanner, "953", 3) == 0)
	{
		for (i = 0; i < num_image_files; i++)
		{
			if (filter_found [i] != SUCCEED)
			{
d542 1
a542 1
				strcat (command, complete_filtered_images [i]);
d544 4
a547 5
				if (system (command) != 0)
				{
					fprintf (stderr, 
					"Error in removing temporary filtered file %s\n", 
					complete_filtered_images [i]);
a552 1

@


1.16
log
@Separate mask num_slices with image num_slices.
@
text
@d1 1
a1 1
/*$Id: template.c,v 1.15 1994/04/22 16:14:07 ty7777 Exp ty7777 $*/
d3 3
d52 1
a52 1
static char rcsid [] = "$Header: /home/petsun4/ty7777/src/imgmean/RCS/template.c,v 1.15 1994/04/22 16:14:07 ty7777 Exp ty7777 $";
d102 1
a102 1
Creator:	Tom Yang
@


1.15
log
@Fixed bug for annmary.
@
text
@d1 1
a1 1
/*$Id: template.c,v 1.14 1994/04/11 20:59:12 ty7777 Exp ty7777 $*/
d3 3
d49 1
a49 1
static char rcsid [] = "$Header: /home/petsun4/ty7777/src/imgmean/RCS/template.c,v 1.14 1994/04/11 20:59:12 ty7777 Exp ty7777 $";
d134 3
a136 1
	short			*mask3d;
d142 1
d144 1
a144 1
	int			i;
d152 4
d263 2
a264 2
	if (getimagedim (filtered_mskimg, matval, &scanner, &width, &height, 
	&num_slices, &pixel_width, &pixel_height, &plane_separation) == FAIL) 
d270 2
a271 2
	slice_dimension	= width * height;
	image_dimension	= slice_dimension * num_slices;
d282 1
a282 1
		last_slice	= num_slices;
d285 2
a286 2
	threshold (filtered_mskimg, scanner, parameter_data.mskpct, width, height, num_slices, 
		first_slice, last_slice, mask3d, &total_pixel);	
d288 3
d294 37
d348 2
@


1.14
log
@Modified for cbf, cbv, oef, cmro2, and tissue activity processing.
@
text
@d1 1
a1 1
/*$Id: template.c,v 1.13 1994/03/10 16:38:12 ty7777 Exp ty7777 $*/
d3 3
d46 1
a46 1
static char rcsid [] = "$Header: /home/petsun4/ty7777/src/imgmean/RCS/template.c,v 1.13 1994/03/10 16:38:12 ty7777 Exp ty7777 $";
d411 6
a416 1
		strcpy (complete_control_image, complete_filtered_images [3]);
@


1.13
log
@Changed the comments.
@
text
@d1 1
a1 1
/*$Id: template.c,v 1.12 1993/10/29 20:11:51 ty7777 Exp ty7777 $*/
d3 3
d43 1
a43 1
static char rcsid [] = "$Header: /home/petsun4/ty7777/src/imgmean/RCS/template.c,v 1.12 1993/10/29 20:11:51 ty7777 Exp ty7777 $";
d48 2
a49 1
Function:	PUBLIC int template (char *complete_activation_filename, 
d53 5
a57 2
Arguments:	complete_activation_filename:	activation image name with path.
		complete_control_filename:	control image name with path.
d103 1
a103 1
PUBLIC int template (complete_activation_filename, complete_control_filename, 
d105 3
a107 2
	char 			*complete_activation_filename;
	char 			*complete_control_filename;
d112 2
a113 2
	BOOLEAN			activation_filter_found;
	BOOLEAN			control_filter_found;
d119 2
a120 2
	char			filtered_activation [MAXPATH];
	char			filtered_control [MAXPATH];
d122 1
a122 2
	char			short_filtered_activation [MAXLINE];
	char			short_filtered_control [MAXPATH];
d125 1
d127 1
a136 1
	int			stat;
d211 1
a211 9
		strncpy (short_filtered_activation, "\0", MAXLINE);
		build_filter_filename (complete_activation_filename, parameter_data.imgfilter_type, 
			parameter_data.imgfilter_cutoff, parameter_data.imgfilter_order, 
			short_filtered_activation);
		/*
		 * Filter the raw activation image if necessary.
		 */
		if (activation_filter_found = setpath (parameter_data.datapath, short_filtered_activation, 
		subject_id, &finfo, filtered_activation, TRUE) != SUCCEED)
d213 6
a218 14
			strcpy (filtered_activation, short_filtered_activation);

			if (filter_image (complete_activation_filename, parameter_data.imgfilter_type, 
			parameter_data.imgfilter_cutoff, parameter_data.imgfilter_order, 
			filtered_activation) == FAIL)
			{
				fprintf (stderr, "Error in filtering activation image %s\n", 
					complete_activation_filename);
				return FAIL;
			}
		}

		if (strlen (image_list->scanset2_id) > 0)
		{
d220 1
a220 1
		 	 * Construct filtered mask image name.
d222 3
a224 10
			strncpy (short_filtered_control, "\0", MAXLINE);
			build_filter_filename (complete_control_filename, parameter_data.imgfilter_type, 
			parameter_data.imgfilter_cutoff, parameter_data.imgfilter_order, 
			short_filtered_control);

			/*
			 * Filter the raw control image if necessary.
			 */
			if (control_filter_found = setpath (parameter_data.datapath, short_filtered_control, 
			subject_id, &finfo, filtered_control, TRUE) != SUCCEED)
d226 1
a226 1
				strcpy (filtered_control, short_filtered_control);
d228 3
a230 3
				if (filter_image (complete_control_filename, parameter_data.imgfilter_type, 
				parameter_data.imgfilter_cutoff, parameter_data.imgfilter_order, 
				filtered_control) == FAIL)
d232 2
a233 2
					fprintf (stderr, "Error in filtering control image %s\n", 
						complete_control_filename);
d241 4
a244 2
		strcpy (filtered_activation, complete_activation_filename);
		strcpy (filtered_control, complete_control_filename);
d250 1
a250 1
	if (getimagedim (complete_activation_filename, matval, &scanner, &width, &height, 
d303 2
a304 2
	if (getrealimg (filtered_activation, scanner, matval, width, height, num_slices, image3d, 
		main_header, subheader_list) == FAIL)
d312 77
d408 31
a438 1
		if (getrealimg (filtered_control, scanner, matval, width, height, 
d442 1
d445 3
d451 28
d493 13
d515 1
d517 6
a522 1
	free (mask3d);
d548 1
a548 1
		if (activation_filter_found != SUCCEED)
d550 1
a550 4
			strcpy (command, cbuffer);
			strcat (command, filtered_activation);
			strcat (command, " /tmp");
			if (system (command) != 0)
d552 10
a561 18
				fprintf (stderr, 
					"Error in removing temporary filtered activation file %s\n", 
					filtered_activation);
				return FAIL;
			}
		}

		if (strlen (image_list->scanset2_id) > 0 && control_filter_found != SUCCEED)
		{
			strcpy (command, cbuffer);
			strcat (command, filtered_control);
			strcat (command, " /tmp");
			if (system (command) != 0)
			{
				fprintf (stderr, 
					"Error in removing temporary filtered control file %s\n", 
					filtered_control);
				return FAIL;
@


1.12
log
@Moved build_filter_filename () and filter_image to libhp.a.
@
text
@d1 1
a1 1
/*$Id: template.c,v 1.11 1993/10/27 21:26:07 ty7777 Exp ty7777 $*/
d3 3
d40 1
a40 1
static char rcsid [] = "$Header$";
d201 1
a201 1
		 * Construct filtered mask image name.
@


1.11
log
@Added initialization for matval.
@
text
@d1 1
a1 1
/*$Id: template.c,v 1.10 1993/09/03 21:23:27 ty7777 Exp ty7777 $*/
d3 3
d37 1
a37 1
static char rcsid [] = "$Id: template.c,v 1.10 1993/09/03 21:23:27 ty7777 Exp ty7777 $";
d79 1
a79 1
		getimagedim (), getrealimg ().
a92 5
#define CUTOFF_MAGNIFIER	10	/* cutoff 0.2 will generate _g2 or _?b2 */

PRIVATE void	build_filter_filename ();
PRIVATE int	filter_image ();

a426 83
	}

	return SUCCEED;
}

PRIVATE void build_filter_filename (rawimage_name, filter_type, cutoff, order, 
	filtered_image_name)
	char	*rawimage_name;
	int	filter_type;
	float	cutoff;
	int	order;
	char	*filtered_image_name;
{
	char	cbuffer [MAXNAME];
	char	*extension;
	char	short_filename [MAXLINE];
	char	*pstring;
	int	magnified_cutoff;

	/*
	 * Get the short_filename.
	 */
	strncpy (short_filename, "\0", MAXLINE);
	if ((pstring = strrchr (rawimage_name, '/')) != NULL) 
	{
		strcpy (short_filename, pstring + 1);
	}
	else
		strcpy (short_filename, rawimage_name);

	/*
	 * Get the root of the short file name.
	 */
	if ((extension = strrchr (short_filename, '.')) != NULL &&
	strlen (extension) < strlen (short_filename))
	{
		strncpy (filtered_image_name, short_filename,
			strlen (short_filename) - strlen (extension));
	}
	else
		strcpy (filtered_image_name, short_filename);

	filter_suffix (filter_type, cutoff, order, cbuffer);
	strcat (filtered_image_name, cbuffer);
	strcat (filtered_image_name, IMAGE_EXT);
}

PRIVATE int filter_image (rawimage_name, filter_type, cutoff, order, filtered_image_name)
	char	*rawimage_name;
	int	filter_type;
	float	cutoff;
	int	order;
	char	*filtered_image_name;
{
	char	cbuffer [MAXNAME];
	char	command [MAXPATH];	

	if (filter_type == FILTER_GAUSS)
	{
		strcpy (command, "gauss ");
	}
	else if (filter_type == FILTER_BUTTERWORTH)
	{
		strcpy (command, "butterworth ");
	}
	strcat (command, rawimage_name);
	strcat (command, " ");
	strcat (command, filtered_image_name);
	strcat (command, " ");

	sprintf (cbuffer, " %f", cutoff);
	strcat (command, cbuffer);

	if (filter_type == FILTER_BUTTERWORTH)
	{
		sprintf (cbuffer, " %d", order);
		strcat (command, cbuffer);
	}

	if (system (command) != 0)
	{
		fprintf (stderr, "Error in filtering ECAT image %s\n", rawimage_name);
		return FAIL;
@


1.10
log
@Updated for new list format.
@
text
@d1 1
a1 1
/*$Id: template.c,v 1.9 1993/08/12 17:07:56 ty7777 Exp ty7777 $*/
d3 3
d34 1
a34 1
static char rcsid [] = "$Id: template.c,v 1.9 1993/08/12 17:07:56 ty7777 Exp ty7777 $";
d138 9
@


1.9
log
@Calling modified setpath ().
@
text
@d1 1
a1 1
/*$Id: template.c,v 1.8 1993/08/12 15:46:43 ty7777 Exp ty7777 $*/
d3 3
d31 1
a31 1
static char rcsid [] = "$Id: template.c,v 1.8 1993/08/12 15:46:43 ty7777 Exp ty7777 $";
d212 1
a212 1
		if (image_list->control_num != -MAXINT)
d325 1
a325 1
		image_list->activation_mean	= total_sum / total_pixel;
d327 1
a327 1
		image_list->activation_mean	= 0.0;
d329 1
a329 1
	if (image_list->control_num != -MAXINT)
d348 1
a348 1
			image_list->control_mean	= total_sum / total_pixel;
d350 1
a350 1
			image_list->control_mean	= 0.0;
d404 1
a404 1
		if (image_list->control_num != -MAXINT && control_filter_found != SUCCEED)
@


1.8
log
@Added values.h.
@
text
@d1 1
a1 1
/*$Id: template.c,v 1.7 1993/08/09 21:10:13 ty7777 Exp ty7777 $*/
d3 3
d28 1
a28 1
static char rcsid [] = "$Id: template.c,v 1.7 1993/08/09 21:10:13 ty7777 Exp ty7777 $";
d35 1
a35 2
		PARAMETER_DATA parameter_data, char *id, struct INFO_TYPE *finfo, 
		IMAGE_LIST_DATA *image_list)
d90 1
a90 1
	mskimg_filename, parameter_data, id, finfo, image_list)
a94 2
	char			*id;
	struct INFO_TYPE	*finfo;
d110 1
d130 1
d133 11
d161 2
a162 2
		if (mskfilter_found = setpath (short_filtered_mskimg, parameter_data.datapath, 
		id, finfo, filtered_mskimg, TRUE) != SUCCEED)
d194 2
a195 2
		if (activation_filter_found = setpath (short_filtered_activation, 
		parameter_data.datapath, id, finfo, filtered_activation, TRUE) != SUCCEED)
d222 2
a223 2
			if (control_filter_found = setpath (short_filtered_control, 
			parameter_data.datapath, id, finfo, filtered_control, TRUE) != SUCCEED)
d456 1
a456 12
	if (filter_type == FILTER_GAUSS)
	{
		strcat (filtered_image_name, "_g");
	}
	else if (filter_type == FILTER_BUTTERWORTH)
	{
		sprintf (cbuffer, "_%db", order);
		strcat (filtered_image_name, cbuffer);
	}

	magnified_cutoff	= ROUND (cutoff * CUTOFF_MAGNIFIER);
	sprintf (cbuffer, "%d", magnified_cutoff);
d458 1
a458 1
	strcat (filtered_image_name, ".img");
@


1.7
log
@Change FAIL to -MAXINT for non exist control number.
@
text
@d1 1
a1 1
/*$Id: template.c,v 1.6 1993/08/03 19:32:56 ty7777 Exp ty7777 $*/
d3 3
d25 1
a25 1
static char rcsid [] = "$Id: template.c,v 1.6 1993/08/03 19:32:56 ty7777 Exp ty7777 $";
d420 3
d431 3
@


1.6
log
@Searching in datapath also.
@
text
@d1 1
a1 1
/*$Id: template.c,v 1.5 1993/08/03 19:30:13 ty7777 Exp ty7777 $*/
d3 3
d22 1
a22 1
static char rcsid [] = "$Id: template.c,v 1.5 1993/08/03 19:30:13 ty7777 Exp ty7777 $";
d75 1
d193 1
a193 1
		if (image_list->control_num != FAIL)
d310 1
a310 1
	if (image_list->control_num != FAIL)
d385 1
a385 1
		if (image_list->control_num != FAIL && control_filter_found != SUCCEED)
@


1.5
log
@ Searching filtered images in local and tmp.
@
text
@d1 1
a1 1
/*$Id: template.c,v 1.4 1993/08/02 14:49:17 ty7777 Exp ty7777 $*/
d3 3
d19 1
a19 1
static char rcsid [] = "$Id: template.c,v 1.4 1993/08/02 14:49:17 ty7777 Exp ty7777 $";
a96 1
	char			datapath [MAXPATH];
d141 2
a142 2
		if (mskfilter_found = setpath (short_filtered_mskimg, datapath, id, finfo, 
		filtered_mskimg, TRUE) != SUCCEED)
d174 2
a175 2
		if (activation_filter_found = setpath (short_filtered_activation, datapath, id, finfo, 
		filtered_activation, TRUE) != SUCCEED)
d202 2
a203 2
			if (control_filter_found = setpath (short_filtered_control, datapath, id, finfo, 
			filtered_control, TRUE) != SUCCEED)
@


1.4
log
@Wroking version of template.c
@
text
@d1 1
a1 1
/*$Id: template.c,v 1.3 1993/07/30 16:57:51 ty7777 Exp ty7777 $*/
d3 3
d16 1
a16 1
static char rcsid [] = "$Id: template.c,v 1.3 1993/07/30 16:57:51 ty7777 Exp ty7777 $";
d23 2
a24 1
		PARAMETER_DATA parameter_data, IMAGE_LIST_DATA *image_list)
d56 1
a56 1
Called by:	
d58 2
a59 1
Calling:			
d61 2
d72 5
d78 1
a78 1
	mskimg_filename, parameter_data, image_list)
d83 2
d87 34
a120 27
	Image_subheader	**subheader_list;
	Main_header	*main_header;
	char		command [MAXPATH];	
	char		cbuffer [MAXNAME];
	char		activation_filtered [MAXPATH];
	char		control_filtered [MAXPATH];
	char		mskimg_filtered [MAXPATH];
	float		*image3d;
	short		*mask3d;
	float		pixel_height;
	float		pixel_width;
	float		plane_separation;
	float		total_sum;
	int		first_slice;
	int		last_slice;
	int		i;
	int		scanner;
	int		stat;
	long		end_index;
	long		image_dimension;
	long		start_index;
	long		slice_dimension;
	long		total_pixel;
	short		height;
	short		num_slices;
	short		width;
	struct Matval	matval;
d128 7
a134 13
		if (parameter_data.mskfilter_type == FILTER_GAUSS)
		{
			strcpy (command, "gauss ");
		}
		else if (parameter_data.mskfilter_type == FILTER_BUTTERWORTH)
		{
			strcpy (command, "butterworth ");
		}
		strcat (command, mskimg_filename);
		strcat (command, " ");
		strcpy (mskimg_filtered, "filtered_mask.img");
		strcat (command, mskimg_filtered);
		strcat (command, " ");
d136 5
a140 4
		sprintf (cbuffer, " %f", parameter_data.mskfilter_cutoff);
		strcat (command, cbuffer);

		if (parameter_data.mskfilter_type == FILTER_BUTTERWORTH)
d142 1
a142 3
			sprintf (cbuffer, " %d", parameter_data.mskfilter_order);
			strcat (command, cbuffer);
		}
d144 7
a150 3
		if (system (command) != 0)
		{
			fprintf (stderr, "Error in executing %s\n", command);
d154 1
a154 1
		strcpy (mskimg_filtered, mskimg_filename);
d162 12
a173 1
		if (parameter_data.imgfilter_type == FILTER_GAUSS)
d175 1
a175 11
			strcpy (command, "gauss ");
		}
		else if (parameter_data.imgfilter_type == FILTER_BUTTERWORTH)
		{
			strcpy (command, "butterworth ");
		}
		strcat (command, complete_activation_filename);
		strcat (command, " ");
		strcpy (activation_filtered, "filtered_actv.img");
		strcat (command, activation_filtered);
		strcat (command, " ");
d177 8
a184 7
		sprintf (cbuffer, " %f", parameter_data.imgfilter_cutoff);
		strcat (command, cbuffer);

		if (parameter_data.imgfilter_type == FILTER_BUTTERWORTH)
		{
			sprintf (cbuffer, " %d", parameter_data.imgfilter_order);
			strcat (command, cbuffer);
a186 5
		if (system (command) != 0)
		{
			fprintf (stderr, "Error in executing %s\n", command);
		}

d189 7
a195 13
			if (parameter_data.imgfilter_type == FILTER_GAUSS)
			{
				strcpy (command, "gauss ");
			}
			else if (parameter_data.imgfilter_type == FILTER_BUTTERWORTH)
			{
				strcpy (command, "butterworth ");
			}
			strcat (command, complete_control_filename);
			strcat (command, " ");
			strcpy (control_filtered, "filtered_control.img");
			strcat (command, control_filtered);
			strcat (command, " ");
d197 5
a201 4
			sprintf (cbuffer, " %f", parameter_data.imgfilter_cutoff);
			strcat (command, cbuffer);

			if (parameter_data.imgfilter_type == FILTER_BUTTERWORTH)
d203 1
a203 3
				sprintf (cbuffer, " %d", parameter_data.imgfilter_order);
				strcat (command, cbuffer);
			}
d205 8
a212 3
			if (system (command) != 0)
			{
				fprintf (stderr, "Error in executing %s\n", command);
d218 2
a219 2
		strcpy (activation_filtered, complete_activation_filename);
		strcpy (control_filtered, complete_control_filename);
d222 3
a230 2
printf ("activation_filename = %s\n", complete_activation_filename);
printf ("w = %d h = %d num_slices = %d\n", width, height, num_slices);
a245 2
printf ("last_slice = %d num_slices = %d\n", parameter_data.last_slice, num_slices);
printf ("first_slice = %d last_slice = %d\n", first_slice, last_slice);
d247 1
a247 1
	threshold (mskimg_filtered, scanner, parameter_data.mskpct, width, height, num_slices, 
d278 1
a278 1
	if (getrealimg (activation_filtered, scanner, matval, width, height, num_slices, image3d, 
a302 1
printf ("1: total_pixel = %d total_sum = %f\n", total_pixel, total_sum);
d306 1
a306 1
		if (getrealimg (control_filtered, scanner, matval, width, height, 
a325 1
printf ("2: total_pixel = %d total_sum = %f\n", total_pixel, total_sum);
d340 141
@


1.3
log
@ Added rcsid.
@
text
@d1 1
a1 1
/*$Id: template.c,v 1.2 1993/07/30 16:53:02 ty7777 Exp ty7777 $*/
d3 3
d13 1
a13 1
static char rcsid [] = "$Id$";
d215 2
d225 10
a234 2
	first_slice	= pkg_max (parameter_data.first_slice, 1);
	last_slice	= pkg_min (parameter_data.last_slice, num_slices);
d291 1
d315 1
@


1.2
log
@Compute the mean for any selected range of slices.
@
text
@d1 1
a1 1
/*$Id: template.c,v 1.1 1993/07/30 14:38:04 ty7777 Exp ty7777 $*/
d3 3
d9 2
@


1.1
log
@Initial revision
@
text
@d1 5
a5 2
/*$Id$*/
/*$Log$*/
d42 1
a42 1
		   compute control_mean.
d78 2
d83 4
a86 1
	long		dimension;
d208 3
a210 2
	dimension	= width * height * num_slices;
	mask3d		= (short *) pkg_malloc (dimension * sizeof (short), "template", "mask3d");
d215 4
a218 2
	threshold (mskimg_filtered, scanner, parameter_data.mskpct, width, height, 
		num_slices, &total_pixel, mask3d);	
d240 1
a240 1
	image3d		= (float *) pkg_malloc (dimension * sizeof (float), "template", "image3d");
d257 3
d261 1
a261 1
	for (i = 0; i < dimension; i++)
d264 1
d266 1
a272 1
printf ("1: %f %f\n", image_list->activation_mean, total_sum / total_pixel);
d286 1
a286 1
		for (i = 0; i < dimension; i++)
a295 1
printf ("2: %f %f\n", image_list->control_mean, total_sum / total_pixel);
@
