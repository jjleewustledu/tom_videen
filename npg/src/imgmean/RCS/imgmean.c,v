head	3.1;
access;
symbols;
locks; strict;
comment	@ * @;


3.1
date	2010.05.11.16.01.20;	author tom;	state Exp;
branches;
next	3.0;

3.0
date	2004.02.16.17.36.43;	author tom;	state Exp;
branches;
next	2.19;

2.19
date	99.10.12.13.25.42;	author tom;	state Exp;
branches;
next	2.18;

2.18
date	98.12.29.18.49.33;	author tom;	state Exp;
branches;
next	2.17;

2.17
date	98.03.12.15.03.39;	author tom;	state Exp;
branches;
next	2.16;

2.16
date	97.07.24.21.31.24;	author tom;	state Exp;
branches;
next	2.15;

2.15
date	97.01.24.18.20.46;	author tom;	state Exp;
branches;
next	2.14;

2.14
date	96.11.06.17.50.40;	author tom;	state Exp;
branches;
next	2.13;

2.13
date	96.10.21.22.30.31;	author tom;	state Exp;
branches;
next	2.12;

2.12
date	96.10.16.16.42.33;	author tom;	state Exp;
branches;
next	2.8;

2.8
date	96.10.11.16.28.18;	author tom;	state Exp;
branches;
next	2.7;

2.7
date	96.09.25.18.34.08;	author tom;	state Exp;
branches;
next	2.6;

2.6
date	96.08.21.22.37.17;	author tom;	state Exp;
branches;
next	2.5;

2.5
date	96.08.21.17.30.29;	author tom;	state Exp;
branches;
next	2.4;

2.4
date	96.08.16.19.52.01;	author tom;	state Exp;
branches;
next	2.3;

2.3
date	96.08.16.18.53.15;	author tom;	state Exp;
branches;
next	2.2;

2.2
date	96.08.05.17.15.49;	author tom;	state Exp;
branches;
next	2.1;

2.1
date	96.05.17.18.13.10;	author tom;	state Exp;
branches;
next	2.0;

2.0
date	96.05.16.19.52.32;	author tom;	state Exp;
branches;
next	1.14;

1.14
date	95.01.11.20.17.58;	author ty7777;	state Exp;
branches;
next	1.13;

1.13
date	94.10.03.16.07.58;	author tom;	state Exp;
branches;
next	1.12;

1.12
date	94.09.14.15.08.04;	author ty7777;	state Exp;
branches;
next	1.11;

1.11
date	94.04.11.20.58.22;	author ty7777;	state Exp;
branches;
next	1.10;

1.10
date	94.03.10.16.20.35;	author ty7777;	state Exp;
branches;
next	1.9;

1.9
date	93.09.09.19.00.50;	author ty7777;	state Exp;
branches;
next	1.8;

1.8
date	93.09.07.19.53.04;	author ty7777;	state Exp;
branches;
next	1.7;

1.7
date	93.09.03.21.23.47;	author ty7777;	state Exp;
branches;
next	1.6;

1.6
date	93.08.12.17.07.29;	author ty7777;	state Exp;
branches;
next	1.5;

1.5
date	93.08.09.21.08.55;	author ty7777;	state Exp;
branches;
next	1.4;

1.4
date	93.08.03.19.29.37;	author ty7777;	state Exp;
branches;
next	1.3;

1.3
date	93.07.30.16.57.37;	author ty7777;	state Exp;
branches;
next	1.2;

1.2
date	93.07.30.16.52.34;	author ty7777;	state Exp;
branches;
next	1.1;

1.1
date	93.07.30.14.37.00;	author ty7777;	state Exp;
branches;
next	;


desc
@Working version.
@


3.1
log
@revision to buildnames in libimgutil
@
text
@/*$Id: imgmean.c,v 3.0 2004/02/16 17:36:43 tom Exp tom $*/
/*$Log: imgmean.c,v $
 * Revision 3.0  2004/02/16  17:36:43  tom
 * Feb 2004
 *
 * Revision 2.19  1999/10/12  13:25:42  tom
 * new libimgutil with updated arc path
 *
 * Revision 2.18  1998/12/29  18:49:33  tom
 * add voi_order parameter
 *
 * Revision 2.17  1998/03/12  15:03:39  tom
 * write negative means (change savelist.c)
 *
 * Revision 2.16  1997/07/24  21:31:24  tom
 * fix bug in template.c
 *
 * Revision 2.15  1997/01/24  18:20:46  tom
 * add firstimgfrm to template to use frames 1-3 for mask and mean images
 *
 * Revision 2.14  1996/11/06  17:50:40  tom
 * new libimgutil with correct scaling of CMRO2 and OEF processing
 *
 * Revision 2.13  1996/10/21  22:30:31  tom
 * fix frees in template
 *
 * Revision 2.12  1996/10/16  16:42:33  tom
 * sync with Version
 * new libimage
 *
 * Revision 2.8  1996/10/11  16:28:18  tom
 * update prms to processPET and processOxygen in template.c
 *
 * Revision 2.7  1996/09/25  18:34:08  tom
 * use build_mskname to get correct mask
 *
 * Revision 2.6  1996/08/21  22:37:17  tom
 * correct some free memory omissions in template.c
 *
 * Revision 2.5  1996/08/21  17:30:29  tom
 * remove unnecessary calls to build_fname
 *
 * Revision 2.4  1996/08/16  19:52:01  tom
 * add build_fname
 *
 * Revision 2.3  1996/08/16  18:53:15  tom
 * filter mask image
 *
 * Revision 2.2  1996/08/05  17:15:49  tom
 * new libimage
 *
 * Revision 2.1  1996/05/17  18:13:10  tom
 * add filtmode
 *
 * Revision 2.0  1996/05/16  19:52:32  tom
 * new libraries
 *
 */
/*	=========================================================================
 *	Module:			imgmean.c
 *	Author:			Tom Yang
 *	Description:	imgmean computess means values for all images in an imagelist
 *	History:
 *		Created by Tom Yang on 07/23/1993.
 *		30-Sep-94	Modified TOV
 *			a) standardize format with indent;
 *			b) add 2 parameters to input:
 *				1) mskscan is the scan number to be used for masking regardless of whether
 *					or not a control scan or specified scan is named in the parameter file or
 *					imagelist.
 *				2) normslices is the range of slices over which to compute the mean.
 *					It overrides any slice range included in the parameter file (i.e., slices:)
 *			c) replace checkimg with checklst;
 *			d) read sxr file to get peakslice if it is defined and pass the peakslice to
 *				template to use for defining the threshold value used to create a mask;
 *			e) replace call to threshold in template with makemask (which allows the peakslice
 *				to be passed as a parameter);
 *		May-96	Modified TOV to run with new libraries.
 *		Dec-98	Modified TOV:
 *			voi_order = 1 will compute regional means before metabolic values
 *			voi_order = 0 (default) will compute metabolic images before regional means
 *
 *	Input Parameters:
 *		1) list file;
 *		2) parameter file which contains:
 *			mskimg
 *			mskpct
 *			mskfilter
 *			imgfilter
 *		3) scan number to use for creating the template or mask;
 *		4) slice range to use for computing the mean values;
 *
 *	Algorithm for imgmean:
 *		a) Read parameter file and image list
 *		b) Construct short image names from image list and parameters.
 *		c) Get the complete image name for each short image name.
 *		d) Determine the mask image to use for each activation/control image
 *	   		from the parameter mskimg:
 *				if (mskimg = control_image) then
 *					use the control image
 *				else if (mskimg is specified) then
 *					use the specified image
 *				endif
 *		e) Compute the activation mean and control mean by applying a template
 *	   		on the activation and control images.
 *	   		The template is created by thresholding the mask image to mskpct%.
 *		f) Update the image list file adding the computed means.
 *	=================================================================================
 */
/*@@unused@@*/
#ifndef lint
static char     rcsid[] = "$Id: imgmean.c,v 3.0 2004/02/16 17:36:43 tom Exp tom $";
#endif

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <nrutil.h>
#include <myvalues.h>
#include <imgutil.h>

int main (argc, argv)
/*@@unused@@*/
	int             argc;
	char           *argv[];
{
	int				template();
	int             oxygen;			 /* true-> OEF or CMRO2 processing */
	IMAGE_LIST_DATA *list;			 /* image list */
	PARAMETER_DATA  prm;			 /* parameters */
	SXR_DATA       *sxr;			 /* skull xray file data */
	char           *prmname;		 /* parameter filename */
	char           *listname;		 /* filename of image list */
	char           *(imgname[6]);		 /* image filenames */
	char           *sxrname;		 /* sxr filenames */
	char           *tmpname;		 /* temporary filename */
	char           *mskname;		 /* mask image filename */
	char           *mskscan;		 /* scan number to mask to for all images */
	char           *normslices;		 /* slice range to use for normalization */
	char           *dtype;			 /* data type (for archive paths to files */
	int             filtmode;
	int             nfiles;
	int             listsize;
	int             firstslice, lastslice;
	int             peakslice = 0;
	int             i, j;

/*
 *	Get command line arguments.
 */
	prmname = argv[1];
	listname = argv[2];
	mskscan = argv[3];
	normslices = argv[4];
	for (i = 0; i < 6; i++)
		imgname[i] = (char *) malloc (MAXPATH);
	sxrname = (char *) malloc (MAXPATH);
	mskname = (char *) malloc (MAXPATH);
	tmpname = (char *) malloc (MAXPATH);
	dtype = (char *) malloc (MAXPATH);
	if (sxrname == NULL) return (ERROR);
	if (mskname == NULL) return (ERROR);
	if (tmpname == NULL) return (ERROR);
	if (dtype == NULL) return (ERROR);

	filtmode = IMGFILTER_MODE;

/*
 *	Read parameter file into the structure INFO_TYPE finfo.
 */
	if (readprm (prmname, &prm) == ERROR) {
		fprintf (stderr, "ERROR [imgmean]: reading parameters from %s\n", prmname);
		return (ERROR);
	}
	prm.voi_norm = 0.;

/*
 *	Override slice range in parameter list for normalization with range from command line
 */

	if (strncmp (normslices, "all", 3) != 0) {
		if (sscanf (normslices, "%dto%d", &firstslice, &lastslice) == 2) {
			if (firstslice <= lastslice) {
				prm.first_slice = firstslice;
				prm.last_slice = lastslice;
			} else {
				prm.first_slice = lastslice;
				prm.last_slice = firstslice;
			}
		}
	}
/*
 *	Read listname into IMAGE_LIST_DATA structure
 */
	list = (IMAGE_LIST_DATA *) malloc (sizeof (IMAGE_LIST_DATA) * MAX_IMAGE_LIST_SIZE);
	if (readimglist (listname, list, &listsize) == ERROR) {
		fprintf (stderr, "ERROR [imgmean]: reading imagelist %s\n", listname);
		free (list);
		return (ERROR);
	}
/*
 *	Set additional parameters
 */
	if (prm.processing == PROC_OEF || prm.processing == PROC_CMRO2)
		oxygen = TRUE;
	else
		oxygen = FALSE;

/*
 *	Compute the mean for each image in the imagelist
 */
	for (i = 0; i < listsize; i++) {

/*
 *	If activation & control means are > 0 in the input list, skip to next
 */
		if (list[i].mean1 > 0.0 && (strlen (list[i].scanset2_id) == 0 ||
				       (strlen (list[i].scanset2_id) > 0 && list[i].mean2 > 0.0)))
			continue;

		if (buildnames (prm, list[i], filtmode, &nfiles, imgname, sxrname) == ERROR) {
			fprintf (stderr, "Error building filenames from %s %s %f %s %f %s\n",
				 list[i].subject_id, list[i].scanset1_id, list[i].mean1,
				 list[i].scanset2_id, list[i].mean2, list[i].sxrid);
		}
		if ((oxygen == TRUE && prm.imglist_mode == MULTITRACER_IMAGE_MODE
		     && nfiles != 3 && nfiles != 6)
		    || ((oxygen == FALSE || prm.imglist_mode != MULTITRACER_IMAGE_MODE)
			&& nfiles != 1 && nfiles != 2)) {
			fprintf (stderr, "ERROR [imgmean]: There are %d image files for one subject\n", nfiles);
			return (ERROR);
		}
/*
 *	Determine the mask image to use.
 *	Note: if the flag "-s" appears in command line, then that scan is used
 */
		if (strncmp (mskscan, "0", 1) != 0) {
			strcpy (tmpname, prm.species);
			strcat (tmpname, list[i].subject_id);
			strcat (tmpname, prm.tracer);
			strcat (tmpname, mskscan);
			strcat (tmpname, prm.extension);
			prm.mskimg_type = MASK_CONTROL;	/* make sure MASK_SPECIFIED is disabled */
			build_mskname (tmpname, mskname, prm);

		} else if (prm.mskimg_type == MASK_CONTROL && strlen (list[i].scanset2_id) > 0) {
			if (oxygen == TRUE)
				strcpy (mskname, imgname[3]);
			else {
				strcpy (tmpname, prm.species);
				strcat (tmpname, list[i].subject_id);
				strcat (tmpname, prm.tracer);
				strcat (tmpname, list[i].scanset2_id);
				strcat (tmpname, prm.extension);
				build_mskname (tmpname, mskname, prm);
			}

		} else if (prm.mskimg_type == MASK_CONTROL) {
			strcpy (mskname, imgname[0]);
			strcpy (tmpname, prm.species);
			strcat (tmpname, list[i].subject_id);
			strcat (tmpname, prm.tracer);
			strcat (tmpname, list[i].scanset1_id);
			strcat (tmpname, prm.extension);
			build_mskname (tmpname, mskname, prm);

		} else if (prm.mskimg_type == MASK_SPECIFIED)
			strcpy (mskname, prm.mskimg);

		else {
			fprintf (stderr, "ERROR [imgmean]: Illegal parameter for mskimg in %s\n", prmname);
			free (list);
			return (ERROR);
		}

/*
 *	Get complete paths to files
 */
		strcpy (dtype, prm.scanner);
		strcat (dtype, "_");
		strcat (dtype, prm.acquisition);
		strcat (dtype, "_");
		strcat (dtype, prm.reconstruction);
		strcat (dtype, "_");
		strcat (dtype, prm.recfilter);
		for (j = 0; j < nfiles; j++) {
			imgname[j] = getpath (imgname[j], dtype, prm);
			if (strcmp (imgname[j], "") == 0)
				return (ERROR);
		}
		mskname = getpath (mskname, dtype, prm);
		if (strcmp (mskname, "") == 0)
			return (ERROR);

/*
 *	If sxr file has a defined peak slice, use it
 */
		strcpy (dtype, "data");
		sxrname = getpath (sxrname, dtype, prm);
		if (strcmp (sxrname, "") != 0) {
			sxr = getsxr (sxrname);
			if (sxr->peakslice > 0)
				peakslice = sxr->peakslice;
		}
/*
 * Compute mean(s) and update the list
 */
		if (template (imgname, oxygen, mskname, prm, &list[i], peakslice) != 0)
			return (ERROR);
	}

	(void) savelist (listname, listsize, list);
	free (list);
	free (sxr);
	free (dtype);
	return (OK);
}
@


3.0
log
@Feb 2004
@
text
@d1 1
a1 1
/*$Id: imgmean.c,v 2.19 1999/10/12 13:25:42 tom Exp tom $*/
d3 3
d112 1
a112 1
static char     rcsid[] = "$Id: imgmean.c,v 2.19 1999/10/12 13:25:42 tom Exp tom $";
d122 1
a122 1
main (argc, argv)
@


2.19
log
@new libimgutil with updated arc path
@
text
@d1 1
a1 1
/*$Id: imgmean.c,v 2.18 1998/12/29 18:49:33 tom Exp tom $*/
d3 3
d107 1
d109 1
a109 1
static char     rcsid[] = "$Id: imgmean.c,v 2.18 1998/12/29 18:49:33 tom Exp tom $";
d120 1
d158 5
d223 1
a223 1
		if ((oxygen && prm.imglist_mode == MULTITRACER_IMAGE_MODE
d225 1
a225 1
		    || ((!oxygen || prm.imglist_mode != MULTITRACER_IMAGE_MODE)
d244 1
a244 1
			if (oxygen)
d309 1
a309 1
	savelist (listname, listsize, list);
@


2.18
log
@add voi_order parameter
@
text
@d1 1
a1 1
/*$Id: imgmean.c,v 2.17 1998/03/12 15:03:39 tom Exp tom $*/
d3 3
d105 1
a105 1
static char     rcsid[] = "$Id: imgmean.c,v 2.17 1998/03/12 15:03:39 tom Exp tom $";
@


2.17
log
@write negative means (change savelist.c)
@
text
@d1 1
a1 1
/*$Id: imgmean.c,v 2.16 1997/07/24 21:31:24 tom Exp tom $*/
d3 3
d70 3
d102 1
a102 1
static char     rcsid[] = "$Id: imgmean.c,v 2.16 1997/07/24 21:31:24 tom Exp tom $";
d106 1
d116 1
d157 1
a157 1
		exit (ERROR);
d183 1
a183 1
		exit (ERROR);
d215 1
a215 1
			exit (ERROR);
d257 1
a257 1
			exit (ERROR);
d273 1
a273 1
				exit (ERROR);
d277 1
a277 1
			exit (ERROR);
d292 2
a293 1
		template (imgname, oxygen, mskname, prm, &list[i], peakslice);
d300 1
a300 1
	exit (OK);
@


2.16
log
@fix bug in template.c
@
text
@d1 1
a1 1
/*$Id: imgmean.c,v 2.15 1997/01/24 18:20:46 tom Exp tom $*/
d3 3
d96 1
a96 1
static char     rcsid[] = "$Id: imgmean.c,v 2.15 1997/01/24 18:20:46 tom Exp tom $";
@


2.15
log
@add firstimgfrm to template to use frames 1-3 for mask and mean images
@
text
@d1 1
a1 1
/*$Id: imgmean.c,v 2.14 1996/11/06 17:50:40 tom Exp tom $*/
d3 3
d93 1
a93 1
static char     rcsid[] = "$Id: imgmean.c,v 2.14 1996/11/06 17:50:40 tom Exp tom $";
@


2.14
log
@new libimgutil with correct scaling of CMRO2 and OEF processing
@
text
@d1 1
a1 1
/*$Id: imgmean.c,v 2.13 1996/10/21 22:30:31 tom Exp tom $*/
d3 3
d90 1
a90 1
static char     rcsid[] = "$Id: imgmean.c,v 2.13 1996/10/21 22:30:31 tom Exp tom $";
@


2.13
log
@fix frees in template
@
text
@d1 1
a1 1
/*$Id: imgmean.c,v 2.12 1996/10/16 16:42:33 tom Exp tom $*/
d3 3
d87 1
a87 1
static char     rcsid[] = "$Id: imgmean.c,v 2.12 1996/10/16 16:42:33 tom Exp tom $";
@


2.12
log
@sync with Version
new libimage
@
text
@d1 1
a1 1
/*$Id: imgmean.c,v 2.8 1996/10/11 16:28:18 tom Exp tom $*/
d3 4
a82 1

d84 1
a84 2
static char     rcsid[] = "$Id: imgmean.c,v 2.8 1996/10/11 16:28:18 tom Exp tom $";

@


2.8
log
@update prms to processPET and processOxygen in template.c
@
text
@d1 1
a1 1
/*$Id: imgmean.c,v 2.7 1996/09/25 18:34:08 tom Exp tom $*/
d3 3
d81 1
a81 1
static char     rcsid[] = "$Id: imgmean.c,v 2.7 1996/09/25 18:34:08 tom Exp tom $";
@


2.7
log
@use build_mskname to get correct mask
@
text
@d1 1
a1 1
/*$Id: imgmean.c,v 2.6 1996/08/21 22:37:17 tom Exp tom $*/
d3 3
d78 1
a78 1
static char     rcsid[] = "$Id: imgmean.c,v 2.6 1996/08/21 22:37:17 tom Exp tom $";
@


2.6
log
@correct some free memory omissions in template.c
@
text
@d1 1
a1 1
/*$Id: imgmean.c,v 2.5 1996/08/21 17:30:29 tom Exp tom $*/
d3 3
d75 1
a75 1
static char     rcsid[] = "$Id: imgmean.c,v 2.5 1996/08/21 17:30:29 tom Exp tom $";
d200 1
a200 1
			build_fname (tmpname, mskname, prm);
d205 8
a212 2
			else
				strcpy (mskname, imgname[1]);
d216 6
@


2.5
log
@remove unnecessary calls to build_fname
@
text
@d1 1
a1 1
/*$Id: imgmean.c,v 2.4 1996/08/16 19:52:01 tom Exp tom $*/
d3 3
d72 1
a72 1
static char     rcsid[] = "$Id: imgmean.c,v 2.4 1996/08/16 19:52:01 tom Exp tom $";
@


2.4
log
@add build_fname
@
text
@d1 1
a1 1
/*$Id: imgmean.c,v 2.3 1996/08/16 18:53:15 tom Exp tom $*/
d3 3
d69 1
a69 1
static char     rcsid[] = "$Id: imgmean.c,v 2.3 1996/08/16 18:53:15 tom Exp tom $";
d198 1
a198 1
				strcpy (tmpname, imgname[3]);
d200 1
a200 2
				strcpy (tmpname, imgname[1]);
			build_fname (tmpname, mskname, prm);
d203 1
a203 2
			strcpy (tmpname, imgname[0]);
			build_fname (tmpname, mskname, prm);
@


2.3
log
@filter mask image
@
text
@d1 1
a1 1
/*$Id: imgmean.c,v 2.2 1996/08/05 17:15:49 tom Exp tom $*/
d3 3
d66 1
a66 1
static char     rcsid[] = "$Id: imgmean.c,v 2.2 1996/08/05 17:15:49 tom Exp tom $";
d191 1
a191 1
			build_filter_filename (tmpname, mskname, prm);
d198 1
a198 1
			build_filter_filename (tmpname, mskname, prm);
d202 1
a202 1
			build_filter_filename (tmpname, mskname, prm);
@


2.2
log
@new libimage
@
text
@d1 1
a1 1
/*$Id: imgmean.c,v 2.1 1996/05/17 18:13:10 tom Exp tom $*/
d3 3
d61 1
d63 2
a64 1
static char     rcsid[] = "$Id: imgmean.c,v 2.1 1996/05/17 18:13:10 tom Exp tom $";
d83 1
a83 1
	char           *(imgname[6]);	 /* image filenames */
d85 1
d90 1
a90 1
	int				filtmode;
d108 1
d148 1
a148 1
	if (prm.processing == PROC_OEF || prm.processing == PROC_CMRO2) 
d182 5
a186 5
			strcpy (mskname, prm.species);
			strcat (mskname, list[i].subject_id);
			strcat (mskname, prm.tracer);
			strcat (mskname, mskscan);
			strcat (mskname, prm.extension);
d188 1
d192 1
a192 1
				strcpy (mskname, imgname[3]);
d194 2
a195 1
				strcpy (mskname, imgname[1]);
d197 5
a201 3
		} else if (prm.mskimg_type == MASK_CONTROL)
			strcpy (mskname, imgname[0]);
		else if (prm.mskimg_type == MASK_SPECIFIED)
d203 1
a238 1

@


2.1
log
@add filtmode
@
text
@d1 1
a1 1
/*$Id: imgmean.c,v 2.0 1996/05/16 19:52:32 tom Exp $*/
d3 3
d59 1
a59 1
static char     rcsid[] = "$Id: imgmean.c,v 2.0 1996/05/16 19:52:32 tom Exp $";
d109 1
a109 1
		fprintf (stderr, "ERROR [imgmean]: reading parameters from %s\n, prmname");
@


2.0
log
@new libraries
@
text
@d1 1
a1 1
/*$Id: imgmean.c,v 1.14 1995/01/11 20:17:58 ty7777 Exp tom $*/
d3 3
d56 1
a56 1
static char     rcsid[] = "$Id: imgmean.c,v 1.14 1995/01/11 20:17:58 ty7777 Exp tom $";
d81 1
d100 1
d155 1
a155 1
		if (buildnames (prm, list[i], &nfiles, imgname, sxrname) == ERROR) {
@


1.14
log
@Rebuilt after new libpetarc.a.
@
text
@d1 1
a1 1
/*$Id: imgmean.c,v 1.13 1994/10/03 16:07:58 tom Exp ty7777 $*/
a2 35
 * Revision 1.13  1994/10/03  16:07:58  tom
 * standardize format with indent
 * add msk_scan and norm_slices as input parameters;
 * replace checkimg with checklst;
 * read peakslice from sxr file;
 *
 * Revision 1.12  1994/09/14  15:08:04  ty7777
 * Update the documentation.
 *
 * Revision 1.11  1994/04/11  20:58:22  ty7777
 * Added cbf, cbv, oef, tissue_activity processing.
 *
 * Revision 1.10  1994/03/10  16:20:35  ty7777
 * Same as the last version.
 *
 * Revision 1.9  1993/09/09  19:00:50  ty7777
 * Change checklst to checkimg.
 *
 * Revision 1.8  1993/09/07  19:53:04  ty7777
 * Changing the order of readparm () and readimglist ().
 *
 * Revision 1.7  1993/09/03  21:23:47  ty7777
 * Updated for new list format.
 *
 * Revision 1.6  1993/08/12  17:07:29  ty7777
 * Calling modified checkimg ().
 *
 * Revision 1.5  1993/08/09  21:08:55  ty7777
 * Added extension to checkimg.
 *
 * Revision 1.4  1993/08/03  19:29:37  ty7777
 * Searching filtered images in local and tmp.
 *
 * Revision 1.3  1993/07/30  16:57:37  ty7777
 * Added rcsid.
a3 1

d5 3
a7 4
 *	File Name:		imgmean.c
 *	Author:			Tom Yang.
 *	Description:	imagemean is a program to fill in the means for the images
 *					specified in an image list file.
d13 1
a13 1
 *				1) msk_scan is the scan number to be used for masking regardless of whether
d16 1
a16 1
 *				2) norm_slices is the range of slices over which to compute the mean.
d23 1
d26 8
a33 17
 *	1) image list file.
 *	2) image parameter file which contains:
 *		mskimg: string [string]	# e.g., mskimg: control_image;
 *								# mskimg: specified image_name
 *		mskpct: integer			# threshold percentage, in [0, 100],
 *								# e.g., mskpct 40. Recommended: 40 for
 *								# PETT VI; 50 for ECAT images.
 *		mskfilter: string [real] # e.g. mskfilter: gauss 0.2;
 *								# mskfilter: butterworth 0.7 5;
 *								# mskfilter: none.
 *								# Recommended: gauss 0.2 for ECAT;
 *								# none for PETT VI.
 *		imgfilter: string [real] # e.g. imgfilter: gauss 0.2;
 *								# imgfilter: butterworth 0.7 5;
 *								# imgfilter: none.
 *								# Recommended: butterworth 0.7 5;
 * 								# none for PETT VI.
a34 13
 *	3) scan number to use for creating the template or mask;
 *	4) slice range to use for computing the mean values;
 *
 *   Other parameters used for determining path are:
 *        species:
 *        tracer:
 *        category:
 *        datatype:
 *        scanner:
 *        acquisition:
 *        reconstruction:
 *        recfilter:
 *
d36 19
a54 28
 *	a) Read image parameter file and put parameters in a structure.
 *	b) Read image list file and put image pairs in a list of structures.
 *	c) Construct short image names from image list and parameters.
 *	d) Get the complete image name for each short image name.
 *	e) Determine the mask image to use for each activation/control
 *	   image from the parameter maskimg:
 *
 *		if (mskimg is control_image) then
 *			use the control image as the mask image
 *		else if (mskimg is specified) then
 *			use the image specified in the parameter file
 *		endif
 *
 *	f) Compute the activation mean and control mean by applying
 *	   a template on the activation and control images. The template
 *	   is createed by threshold the mask image to mskpct% of the whole
 *	   brain maximum.
 *
 *	g) Update the image list file with means added.
 *
 *	Calling:	buildfiles () in buildfiles.c
 *		pkg_malloc () in libhp.a
 *		readimglist () in readimglist.c
 *		readparm () in readparm.c
 *		savelist () in savelist.c
 *		template () in template.c
 *
 *	================================================================================= */
d56 5
a60 2
#include <values.h>
#include <petutil/imglist.h>
a61 2
static char     rcsid[] = "$Id: imgmean.c,v 1.13 1994/10/03 16:07:58 tom Exp ty7777 $";

d64 1
a64 1
	char          **argv;
d66 16
a81 17
	BOOLEAN         demigrate;
	BOOLEAN         oxygen_processing;
	IMAGE_LIST_DATA *image_list;
	PARAMETER_DATA  parameter_data;
    SXR_OUTPUT      sxr; 
	char            full_imgfile[6][MAXPATH];
	char           *image_list_file;
	char            mskimg_filename[MAXLINE];
	char           *parameter_list_file;
	char            short_imgfile[6][MAXLINE];
	char            short_sxrfile[MAXLINE];
	char      		full_sxrfile [MAXPATH];
	char           *msk_scan;	/* scan number to mask to for all images */
	char           *norm_slices;	/* slice range to use for normalization */
	char            cbuffer[MAXNAME];	/* scratch space for string conversion */
	int             filter_mode;
	int             image_mode;
a82 5
	int             peakslice;
	int             num_image_files;
	int             num_image_list;
	int             first_slice;
	int             last_slice;
d87 9
a95 4
	parameter_list_file = argv[1];
	image_list_file = argv[2];
	msk_scan = argv[3];
	norm_slices = argv[4];
d98 1
a98 1
 *	Read parameters file into the structure INFO_TYPE finfo.
d100 3
a102 4
	if (readparm (parameter_list_file, &parameter_data) == FAIL) {
		fprintf (stderr, "Error: from readparm ().\n");
		free (image_list);
		exit (FAIL);
d104 2
a105 1
	parameter_data.voi_norm = 0.;
d110 5
a114 5
	if (strncmp (norm_slices, "all", 3) != 0) {
		if (sscanf (norm_slices, "%dto%d", &first_slice, &last_slice) == 2) {
			if (first_slice <= last_slice) {
				parameter_data.first_slice = first_slice;
				parameter_data.last_slice = last_slice;
d116 2
a117 2
				parameter_data.first_slice = last_slice;
				parameter_data.last_slice = first_slice;
d122 1
a122 1
 *	Allocate memory for image list structures.
d124 5
a128 10
	image_list = (IMAGE_LIST_DATA *) pkg_malloc (sizeof (IMAGE_LIST_DATA)
						  * MAX_IMAGE_LIST_SIZE, "chklist", "image_list");

/*
 *	Read image_list_file into IMAGE_LIST_DATA structure
 */
	if (readimglist (image_list_file, image_list, &num_image_list) == FAIL) {
		fprintf (stderr, "Error: from readimglist ().\n");
		free (image_list);
		exit (FAIL);
d133 4
a136 10
	demigrate = TRUE;
	if (parameter_data.processing == PROCESSING_OEF
	    || parameter_data.processing == PROCESSING_CMRO2) {
		image_mode = parameter_data.imglist_mode;
		oxygen_processing = TRUE;
	} else {
		image_mode = STDIMAGE_MODE;
		oxygen_processing = FALSE;
	}
	filter_mode = RECFILTER_MODE;
d141 1
a141 1
	for (i = 0; i < num_image_list; i++) {
d144 1
a144 2
 *	If activation mean and control mean already exist in the image list file
 *	then skip to the next record of the image list file.
d146 2
a147 3
		if (image_list[i].mean1 > 0.0 &&
		    (strlen (image_list[i].scanset2_id) == 0 ||
		     (strlen (image_list[i].scanset2_id) > 0 && image_list[i].mean2 > 0.0)))
d150 4
a153 5
		if (build_shortnames (parameter_data, image_list[i], image_mode, filter_mode,
				    &num_image_files, short_imgfile, short_sxrfile) == FAIL) {
			fprintf (stderr, "Error in building short names from image list %s %s %f %s %f %s\n",
			 image_list[i].subject_id, image_list[i].scanset1_id, image_list[i].mean1,
			     image_list[i].scanset2_id, image_list[i].mean2, image_list[i].sxrid);
d155 6
a160 8
		if ((oxygen_processing
		     && parameter_data.imglist_mode == MULTITRACER_IMAGE_MODE
		     && num_image_files != 3 && num_image_files != 6)
		    || ((!oxygen_processing
			 || parameter_data.imglist_mode != MULTITRACER_IMAGE_MODE)
			&& num_image_files != 1 && num_image_files != 2)) {
			fprintf (stderr, "Error: there are %d image files for one subject.\n", num_image_files);
			exit (FAIL);
a162 13
 *	Clean the array of complete image files.
 */
		for (j = 0; j < num_image_files; j++)
			strcpy (full_imgfile[j], "");

    	if (checklst (parameter_data, image_list [i], image_mode, demigrate, num_image_files,
                short_imgfile, full_imgfile, short_sxrfile, full_sxrfile) == FAIL) {
			fprintf (stderr, "Error:  At least 1 file from the imagelist cannot be found\n");
			fprintf (stderr, "        %s %s %f %s %f %s\n\n", image_list[i].subject_id,
				 image_list[i].scanset1_id, image_list[i].mean1,
				 image_list[i].scanset2_id, image_list[i].mean2, image_list[i].sxrid);
		}
/*
d164 1
a164 2
 *	Note: if the flag "-s" appears on the command line, then that scan is used as the mask.
 *
d166 7
a172 7
		if (strncmp (msk_scan, "0", 1) != 0) {
			strncpy (mskimg_filename, "\0", MAXLINE);
			strcpy (mskimg_filename, parameter_data.species);
			strcat (mskimg_filename, image_list[i].subject_id);
			strcat (mskimg_filename, parameter_data.tracer);
			strcat (mskimg_filename, msk_scan);
			strcat (mskimg_filename, parameter_data.extension);
d174 5
a178 1
/* be certain MASK_SPECIFIED is disabled or the named scan will not be filtered in template.c */
d180 4
a183 11
			parameter_data.mskimg_type = MASK_CONTROL;	
		} else if (parameter_data.mskimg_type == MASK_CONTROL &&
			   strlen (image_list[i].scanset2_id) > 0) {
			if (oxygen_processing)
				strcpy (mskimg_filename, full_imgfile[3]);
			else
				strcpy (mskimg_filename, full_imgfile[1]);
		} else if (parameter_data.mskimg_type == MASK_CONTROL)
			strcpy (mskimg_filename, full_imgfile[0]);
		else if (parameter_data.mskimg_type == MASK_SPECIFIED)
			strcpy (mskimg_filename, parameter_data.mskimg);
d185 3
a187 5
			fprintf (stderr,
			 "Wrong parameter specified for keyword (mskimg) in parameter file %s.\n",
				 parameter_list_file);
			free (image_list);
			exit (FAIL);
d191 1
a191 1
 *	Check the sxr file and use the peak slice if one is identified
d193 15
a207 5
        getsxr (full_sxrfile, &sxr);
		if (sxr.peakslice > 0) {
			peakslice = sxr.peakslice;
		} else
			peakslice = 0;
d210 1
a210 1
 * Compute mean and update image_list activation_mean and control_mean fields.
d212 12
a223 2
		template (full_imgfile, num_image_files, oxygen_processing,
			  mskimg_filename, parameter_data, image_list + i, peakslice);
d226 5
a230 7
	savelist (image_list_file, num_image_list, image_list);

	free (image_list);
	free (sxr.rlpetdim);
	free (sxr.rlcenter);
	free (sxr.vertical_petdim);
	free (sxr.rlslicedim);
@


1.13
log
@standardize format with indent
add msk_scan and norm_slices as input parameters;
replace checkimg with checklst;
read peakslice from sxr file;
@
text
@d1 1
a1 1
/*$Id: imgmean.c,v 1.12 1994/09/14 15:08:04 ty7777 Exp $*/
d3 6
d126 1
a126 1
static char     rcsid[] = "$Id: imgmean.c,v 1.12 1994/09/14 15:08:04 ty7777 Exp $";
@


1.12
log
@Update the documentation.
@
text
@d1 1
a1 1
/*$Id: imgmean.c,v 1.11 1994/04/11 20:58:22 ty7777 Exp ty7777 $*/
d3 3
d32 1
a32 1
 **/
d34 83
d120 1
a120 1
static char rcsid [] = "$Id: imgmean.c,v 1.11 1994/04/11 20:58:22 ty7777 Exp ty7777 $";
a121 75
/*
File Name:	imgmean.c
 
Description:	imagemean is a program to fill in the means for the images
		specified in an image list file.

Author:		Tom Yang. 

History:	Created by Tom Yang on 07/23/1993.

Input Parameters:

1. image list file.

2. image parameter file which contains:
	mskimg: string [string]		# e.g., mskimg: control_image; 
					# mskimg: specified image_name
	mskpct: integer			# threshold percentage, in [0, 100], 
					# e.g., mskpct 40. Recommended: 40 for 
					# PETT VI; 50 for ECAT images.
	mskfilter: string [real]	# e.g. mskfilter: gauss 0.2; 
					# mskfilter: butterworth 0.7 5;  
					# mskfilter: none. 
					# Recommended: gauss 0.2 for ECAT; 
					# none for PETT VI.
	imgfilter: string [real]	# e.g. imgfilter: gauss 0.2; 
					# imgfilter: butterworth 0.7 5;  
					# imgfilter: none. 
					# Recommended: butterworth 0.7 5;
					# none for PETT VI.

   Other parameters used for determining path are:
        species:        
        tracer:         
        category:       
        datatype:       
        scanner:        
        acquisition:    
        reconstruction: 
        recfilter:      

Algorithm for imgmean:

a) Read image parameter file and put parameters in a structure.

b) Read image list file and put image pairs in a list of structures.

c) Construct short image names from image list and parameters.

d) Get the complete image name for each short image name.

e) Determine the mask image to use for each activation/control
   image from the parameter maskimg.

   if (mskimg is control_image) then
	use the control image as the mask image
   else if (mskimg is specified) then
	use the image specified in the parameter file
   endif

f) Compute the activation mean and control mean by applying
   a template on the activation and control images. The template
   is createed by threshold the mask image to mskpct% of the whole 
   brain maximum.

g) Update the image list file with means added.

Calling:	buildfiles () in buildfiles.c	
		pkg_malloc () in libhp.a
		readimglist () in readimglist.c	
		readparm () in readparm.c
		savelist () in savelist.c
		template () in template.c
*/

d123 2
a124 2
	int	argc;
	char	**argv;
d126 23
a148 16
	BOOLEAN			demigrate;
	BOOLEAN			oxygen_processing;
	IMAGE_LIST_DATA		*image_list;
	PARAMETER_DATA		parameter_data;
	char			complete_image_files [6][MAXPATH];
	char			*image_list_file;
	char			mskimg_filename [MAXLINE];
	char			*parameter_list_file;
	char			short_image_files [6][MAXLINE];
	char			short_sxrfile [MAXLINE];
	int			filter_mode;
	int			i;
	int			image_mode;
	int			j;
	int			num_image_files;
	int			num_image_list;
d150 7
d158 4
a161 12
	/*
	 * Get command line arguments.
	 */
	parameter_list_file	= argv [1];
	image_list_file		= argv [2];

	/* 
	 * Read the parameters in the image parameters file to the structure
	 * INFO_TYPE finfo.
	 */
	if (readparm (parameter_list_file, &parameter_data) == FAIL)
	{
d166 4
d171 16
a186 5
	/* 
	 * Allocate memory for an array of image list structures. 
	 */
	image_list	= (IMAGE_LIST_DATA *) pkg_malloc (sizeof (IMAGE_LIST_DATA) 
			* MAX_IMAGE_LIST_SIZE, "chklist", "image_list");
d188 4
a191 6
	/* 
	 * Read list from image_list_file to IMAGE_LIST_DATA structure list
	 * image_list for manipulation.
	 */
	if (readimglist (image_list_file, image_list, &num_image_list) == FAIL)
	{
d196 13
d210 12
a221 30
	/* 
	 * Compute the mean for each image pair.
	 */
	demigrate	= TRUE;
	if (parameter_data.processing == PROCESSING_OEF 
	|| parameter_data.processing == PROCESSING_CMRO2) 
	{
		image_mode 		= parameter_data.imglist_mode;
		oxygen_processing	= TRUE;
	}
	else
	{
		image_mode 		= STDIMAGE_MODE;
		oxygen_processing	= FALSE;
	}
	/*
	filter_mode	= IMGFILTER_MODE;
	*/
	filter_mode	= RECFILTER_MODE;
	for (i = 0; i < num_image_list; i++)
	{
		/*
		 * If activation mean and control mean already exist
		 * in the image list file, skip to the next record
		 * of the image list file.
		 */
		if (image_list [i].mean1 > 0.0 && 
		(strlen (image_list [i].scanset2_id) == 0 ||
		(strlen (image_list [i].scanset2_id) > 0 &&
		image_list [i].mean2 > 0.0)))
d224 5
a228 9
		if (build_shortnames (parameter_data, image_list [i], image_mode, filter_mode, 
		&num_image_files, short_image_files, short_sxrfile) == FAIL)
		{
			fprintf (stderr, 
				"Error in building short names from image list %s %s %f %s %f %s\n",
				image_list [i].subject_id, 
				image_list [i].scanset1_id, image_list [i].mean1, 
				image_list [i].scanset2_id, image_list [i].mean2, 
				image_list [i].sxrid);
d230 7
a236 10
		if ((oxygen_processing 
		&& parameter_data.imglist_mode == MULTITRACER_IMAGE_MODE 
		&& num_image_files != 3 && num_image_files != 6)
		|| ((!oxygen_processing 
		|| parameter_data.imglist_mode != MULTITRACER_IMAGE_MODE) 
		&& num_image_files != 1 && num_image_files != 2))
		{
			fprintf (stderr, "Error: there are %d image files for one subject.\n",
			num_image_files);

d239 3
a241 4

		/*
		 * Clean the array of complete image files.
		 */
d243 1
a243 1
			strcpy (complete_image_files [j], "");
d245 6
a250 9
		if (checkimg (parameter_data, image_list [i], image_mode, demigrate, 
		num_image_files, short_image_files, complete_image_files) == FAIL)
		{
			fprintf (stderr, 
				"Error in checking files from image list %s %s %f %s %f %s\n\n",
				image_list [i].subject_id, 
				image_list [i].scanset1_id, image_list [i].mean1, 
				image_list [i].scanset2_id, image_list [i].mean2, 
				image_list [i].sxrid);
d252 12
d265 7
a271 8
		/*
		 * Determine the mask image to use.
		 */
		if (parameter_data.mskimg_type == MASK_CONTROL && 
		strlen (image_list [i].scanset2_id) > 0)
		{
			if (oxygen_processing) 
				strcpy (mskimg_filename, complete_image_files [3]);
d273 3
a275 6
				strcpy (mskimg_filename, complete_image_files [1]);
		}
		else if (parameter_data.mskimg_type == MASK_CONTROL)
		{
			strcpy (mskimg_filename, complete_image_files [0]);
		}
d278 4
a281 5
		else
		{
			fprintf (stderr, 
				"Wrong parameter specified for keyword (mskimg) in parameter file %s.\n",
				parameter_list_file);
d286 14
a299 5
		/*
		 * Compute mean and update image_list activation_mean and control_mean fields.
		 */
		template (complete_image_files, num_image_files, oxygen_processing,
			mskimg_filename, parameter_data, image_list + i);
d305 4
@


1.11
log
@Added cbf, cbv, oef, tissue_activity processing.
@
text
@d1 1
a1 1
/*$Id: imgmean.c,v 1.10 1994/03/10 16:20:35 ty7777 Exp ty7777 $*/
d3 3
d34 1
a34 1
static char rcsid [] = "$Id: imgmean.c,v 1.10 1994/03/10 16:20:35 ty7777 Exp ty7777 $";
d42 4
d108 1
a108 6
		template () in template.c

Creator:	Tom Yang. 

History:	Created by Tom Yang on 07/23/1993.

@


1.10
log
@Same as the last version.
@
text
@d1 1
a1 1
/*$Id: imgmean.c,v 1.9 1993/09/09 19:00:50 ty7777 Exp ty7777 $*/
d3 3
d31 1
a31 1
static char rcsid [] = "$Id: imgmean.c,v 1.9 1993/09/09 19:00:50 ty7777 Exp ty7777 $";
d114 1
a116 2
	char			complete_activation_filename [MAXPATH];
	char			complete_control_filename [MAXPATH];
d169 14
a182 1
	image_mode	= STDIMAGE_MODE;	
d207 9
d217 3
a235 2
		strcpy (complete_activation_filename, complete_image_files [0]);
		strcpy (complete_control_filename, complete_image_files [1]);
d242 6
a247 1
			strcpy (mskimg_filename, complete_control_filename);
d249 3
a251 1
			strcpy (mskimg_filename, complete_activation_filename);
d266 1
a266 1
		template (complete_activation_filename, complete_control_filename, 
@


1.9
log
@Change checklst to checkimg.
@
text
@d1 1
a1 1
/*$Id: imgmean.c,v 1.8 1993/09/07 19:53:04 ty7777 Exp ty7777 $*/
d3 3
d28 1
a28 1
static char rcsid [] = "$Id: imgmean.c,v 1.8 1993/09/07 19:53:04 ty7777 Exp ty7777 $";
@


1.8
log
@Changing the order of readparm () and readimglist ().
@
text
@d1 1
a1 1
/*$Id: imgmean.c,v 1.7 1993/09/03 21:23:47 ty7777 Exp ty7777 $*/
d3 3
d25 1
a25 1
static char rcsid [] = "$Id: imgmean.c,v 1.7 1993/09/03 21:23:47 ty7777 Exp ty7777 $";
a112 1
	char			complete_sxrfile [MAXPATH];
d196 2
a197 3
		if (checklst (parameter_data, image_list [i], image_mode, demigrate, 
		num_image_files, short_image_files, complete_image_files, short_sxrfile, 
		complete_sxrfile) == FAIL)
@


1.7
log
@Updated for new list format.
@
text
@d1 1
a1 1
/*$Id: imgmean.c,v 1.6 1993/08/12 17:07:29 ty7777 Exp $*/
d3 3
d22 1
a22 1
static char rcsid [] = "$Id: imgmean.c,v 1.6 1993/08/12 17:07:29 ty7777 Exp $";
d63 1
a63 1
a) Read image list file and put image pairs in a list of structures.
d65 1
a65 1
b) Read image parameter file and put parameters in a structure.
d131 11
a153 11
		free (image_list);
		exit (FAIL);
	}

	/* 
	 * Read the parameters in the image parameters file to the structure
	 * INFO_TYPE finfo.
	 */
	if (readparm (parameter_list_file, &parameter_data) == FAIL)
	{
		fprintf (stderr, "Error: from readparm ().\n");
@


1.6
log
@Calling modified checkimg ().
@
text
@d1 1
a1 1
/*$Id: imgmean.c,v 1.5 1993/08/09 21:08:55 ty7777 Exp ty7777 $*/
d3 3
d19 1
a19 1
static char rcsid [] = "$Id: imgmean.c,v 1.5 1993/08/09 21:08:55 ty7777 Exp ty7777 $";
d106 2
d111 3
a113 1
	char			short_filename [MAXLINE];
d115 3
d120 1
d159 2
d168 4
a171 4
		if (image_list [i].activation_mean > 0.0 && 
		(image_list [i].control_num == -MAXINT ||
		(image_list [i].control_num != -MAXINT &&
		image_list [i].control_mean > 0.0)))
d174 2
a175 6
		/*
		 * Get complete activation image name.
		 */
		strcpy (complete_activation_filename, "");
		if (checkimg (parameter_data, image_list [i], STDIMAGE_MODE, ACTIVATION_SCAN,
		demigrate, short_filename, complete_activation_filename) == FAIL)
d177 6
a182 3
			fprintf (stderr, "Activation image file %s does not exist.\n", short_filename);
			free (image_list);
			exit (FAIL);
d186 1
a186 1
		 * Get complete control image name.
d188 6
a193 4
		strcpy (complete_control_filename, "");
		if (image_list [i].control_num != -MAXINT &&
		checkimg (parameter_data, image_list [i], STDIMAGE_MODE, CONTROL_SCAN,
		demigrate, short_filename, complete_control_filename) == FAIL)
d195 6
a200 3
			fprintf (stderr, "Control image file %s does not exist.\n", short_filename);
			free (image_list);
			exit (FAIL);
d202 2
d209 1
a209 1
		image_list [i].control_num != -MAXINT)
d218 1
a218 1
				"Wrong parameter specified for keywork (mskimg) in parameter file %s.\n",
@


1.5
log
@Added extension to checkimg.
@
text
@d1 1
a1 1
/*$Id: imgmean.c,v 1.4 1993/08/03 19:29:37 ty7777 Exp ty7777 $*/
d3 3
d16 1
a16 1
static char rcsid [] = "$Id: imgmean.c,v 1.4 1993/08/03 19:29:37 ty7777 Exp ty7777 $";
a106 1
	char			subject_id [MAXNAME];
a108 1
	struct INFO_TYPE	finfo;
a144 5
	 * Fill the finfo structure for searching in archive.
	 */
	get_finfo (parameter_data, &finfo);

	/* 
a161 6
		 * Construct subject id.
		 */
		strcpy (subject_id, parameter_data.species);
		strcat (subject_id, image_list [i].subject_id);

		/*
d165 2
a166 3
		if (checkimg (parameter_data.datapath, finfo, subject_id, parameter_data.tracer, 
			image_list [i].activation_num, parameter_data.extension, short_filename, 
			demigrate, complete_activation_filename) == FAIL)
d178 2
a179 3
		checkimg (parameter_data.datapath, finfo, subject_id, parameter_data.tracer, 
			image_list [i].control_num, parameter_data.extension, short_filename, 
			demigrate, complete_control_filename) == FAIL)
d209 1
a209 1
			mskimg_filename, parameter_data, subject_id, &finfo, image_list + i);
@


1.4
log
@Searching filtered images in local and tmp.
@
text
@d1 1
a1 1
/*$Id: imgmean.c,v 1.3 1993/07/30 16:57:37 ty7777 Exp ty7777 $*/
d3 3
d10 1
d13 1
a13 1
static char rcsid [] = "$Id: imgmean.c,v 1.3 1993/07/30 16:57:37 ty7777 Exp ty7777 $";
d160 2
a161 2
		(image_list [i].control_num == FAIL ||
		(image_list [i].control_num != FAIL &&
d176 2
a177 2
			image_list [i].activation_num, short_filename, demigrate, 
			complete_activation_filename) == FAIL)
d188 1
a188 1
		if (image_list [i].control_num != FAIL &&
d190 2
a191 2
			image_list [i].control_num, short_filename, demigrate, 
			complete_control_filename) == FAIL)
d202 1
a202 1
		image_list [i].control_num != FAIL)
d210 2
a211 1
			fprintf (stderr, "Wrong type for mask image in parameter file %s.\n",
@


1.3
log
@Added rcsid.
@
text
@d1 5
a5 2
/*$Id$*/
/*$Log$*/
d9 1
a9 1
static char rcsid [] = "$Id$";
d78 2
a79 3
		setpath () in libpetarc.a

Author:		Tom Yang. 
d81 2
d216 1
a216 1
			mskimg_filename, parameter_data, image_list + i);
@


1.2
log
@Compute the mean for selected slices also.
@
text
@d1 2
d5 2
@


1.1
log
@Initial revision
@
text
@a202 1
printf ("Mask File = %s\n", mskimg_filename);
@
