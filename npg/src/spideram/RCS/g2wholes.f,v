head	2.0;
access;
symbols;
locks; strict;
comment	@c @;


2.0
date	2004.02.20.14.34.10;	author tom;	state Exp;
branches;
next	1.10;

1.10
date	2002.12.02.21.26.52;	author tom;	state Exp;
branches;
next	1.9;

1.9
date	2001.05.30.20.01.40;	author tom;	state Exp;
branches;
next	1.8;

1.8
date	99.12.15.21.32.41;	author tom;	state Exp;
branches;
next	1.7;

1.7
date	99.03.05.18.49.14;	author tom;	state Exp;
branches;
next	1.6;

1.6
date	98.04.29.15.20.35;	author tom;	state Exp;
branches;
next	1.5;

1.5
date	97.10.24.21.51.52;	author tom;	state Exp;
branches;
next	1.4;

1.4
date	94.11.29.23.28.08;	author ty7777;	state Exp;
branches;
next	1.3;

1.3
date	93.10.04.21.55.32;	author tom;	state Exp;
branches;
next	1.2;

1.2
date	92.04.23.21.25.39;	author ty7777;	state Exp;
branches;
next	1.1;

1.1
date	92.04.13.19.12.07;	author tom;	state Exp;
branches;
next	;


desc
@Spideram function.
@


2.0
log
@Feb 2004
@
text
@C     $Id: g2wholes.f,v 1.10 2002/12/02 21:26:52 tom Exp tom $
C     $Log: g2wholes.f,v $
c Revision 1.10  2002/12/02  21:26:52  tom
c format changes plus fixes for g77
c
c     Revision 1.9  2001/05/30  20:01:40  tom
c     version expanded to 11 chars
c     
c     Revision 1.8  1999/12/15  21:32:41  tom
c     y2k fix in date print
c     
c     Revision 1.7  1999/03/05  18:49:14  tom
c     add CVO2
c     
c     Revision 1.6  1998/04/29  15:20:35  tom
c     allow processing for CMRGlucose
c     
c     Revision 1.5  1997/10/24  21:51:52  tom
c     add NOZEROS option
c     
c     Revision 1.4  1994/11/29  23:28:08  ty7777
c     Deleted VRMVALUE and NORMALIZE from the argument list.
c     
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C     
C     Subroutine:   G2WHOLES.FTN
C     Author:       Tom O. Videen
C     Date:         29-May-87
C     Intent:
C     .  This subroutine computes global whole slice mean values.
C     .  If RLVALUES=true, it also computes the right and left
C     .  hemisphere averages using the current value of XMIDLINE
C     .  as the midline for ALL slices.
C     History:
C     .  Modified 05-Mar-99 by TOV to allow processing for CVO2
C     .     (PROCESS may be 0-7)
C     .  Modified 28-Apr-98 by TOV to allow processing for CMRGlucose
C     .     (PROCESS may be 0-6)
C     .  Modified 26-Aug-87 by TOV to eliminate a bug in right/left
C     .     hemisphere values.
C     .  Modified 06-Oct-87 by TOV to allow processing for tissue activity
C     .     either with or without decay correction; (PROCESS may be 0-5)
C     .  Modified 13-Sep-88 by TOV:
C     .     1) change FILETP from I*4 to CH*23 in **DISPLAY common block.
C     .     2) print program VERSION date.
C     .  Modified 30-Sep-91 by Tom Yang:
C     .     1) Ported to the X Windows environment.
C     .  Modified 15-Oct-91 by TOV:
C     .     1) NRMVALUE and NORMALIZE added to calling parameters.
C     .  Modified 29-Sep-94 by Tom Yang:
C     .     1) Deleted NRMVALUE and NORMALIZE from the argument list.
C     
C     Common Blocks from SPIDERAM:
C     .  **IMAGEDAT - image arrays                   (write)
C     .  **LUINFO   - logical units (also /USRIO/)   (read only)
C     .  **DISPLAY  - display parameters             (write)
C     .  **FILES    - scan file list                 (read only)
C     .  **GLOBALAV - global averaging parameters    (read only)
C     .  **REGION   - regions of interest parameters (read only)
C     
C     Variables Passed:
C     .  SINGLE: true--> compute threshold to max value on each slice;
C     .          false-> compute threshold to max value on entire image;
C     .  RLVALUES: true--> compute right/left hemisphere averages;
C     .  PRINT:  true--> write averages to printer;
C     .  ERRTYPE = type of error in processing images;
C     
C     Local Variables:
C     .  N = number of points included on a slice;
C     .  SUM = total activity on a slice;
C     .  SOS = sum of squares on a slice;
C     .  GLBN = number of points included on all slices;
C     .  GLBSUM = total activity on all slices;
C     .  GLBSOS = sum of squares on all slices;
C     .  MEAN = mean activity of all included points;
C     .  SD = standard deviation (unbiased estimate);
C     
C     .  NR = number of points included on a slice for right hemisphere;
C     .  SUMR = total activity on a slice for right hemisphere;
C     .  SOSR = sum of squares on a slice for right hemisphere;
C     .  GLBNR = number of points included on all slices for right hemisphere;
C     .  GLBSUMR = total activity on all slices for right hemisphere;
C     .  GLBSOSR = sum of squares on all slices for right hemisphere;
C     .  MEANR = mean activity of all included points for right hemisphere;
C     .  SDR = standard deviation (unbiased estimate) for right hemisphere;
C     
C     .  NL = number of points included on a slice for left hemisphere;
C     .  SUML = total activity on a slice for left hemisphere;
C     .  SOSL = sum of squares on a slice for left hemisphere;
C     .  GLBNL = number of points included on all slices for left hemisphere;
C     .  GLBSUML = total activity on all slices for left hemisphere;
C     .  GLBSOSL = sum of squares on all slices for left hemisphere;
C     .  MEANL = mean activity of all included points for left hemisphere;
C     .  SDL = standard deviation (unbiased estimate) for left hemisphere;
C     
C     .  NI = number of points included on a half-slice;
C     .  SUMMID = total activity on a midline of pixels;
C     .  SOSMID = sum of squares on a midline of pixels;
C     .  MAXCOUNT = maximum count in the image array;
C     .  MAXSLICE = greatest slice number;
C     .  COUNT = value of a pixel in IMAGE array;
C     .  PB = parameter block used by SYSIO;
C     .  IOREADR = random access I/O wait read;
C     .  TBYTES = no. of bytes to read for a template (TIMAGE);
C     .  ADDR = random address to start reading a template from;
C     .  SIDE = set to 0 to display entire image;
C     
C     Uses Subroutines:
C     .  D2GETIMG - get an image from a disk file (HDR only);
C     .  D2IMAGE  - assemble an image slice from component image files;
C     .  D2MAXVAL - get maximum and minimum values in an image array;
C     .  D2TEMPLA - create a template;
C     .  P2AREAI  - get points within an irregular region;
C     .  P2AREAR  - get points within a rectangular region;
C     
C     FORTRAN Runtime Library
C     .  DATE
C     
C     Called by:  M2GLOBAL
C     
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C     rcsheader = "$Id: g2wholes.f,v 1.10 2002/12/02 21:26:52 tom Exp tom $"

      SUBROUTINE G2WHOLES (SINGLE, RLVALUES, PRINT, NOZEROS, ERRTYPE)

      INTEGER*4    N, SUM, GLBN, GLBSUM, SLCNUM, MAXSLICE,
     &     COUNT, MAXCOUNT, NI, SUMR, SUML,
     &     GLBSUMR, GLBSUML, SUMMID, ERRTYPE, SIDE,
     &     ADATE (3), COL, ROW, ADDR, PB (6),
     &     IOREADR, TBYTES, I, J, K, IMAX
      REAL*4       MEAN, SD, SOS, GLBSOS, SOSMID,
     &     NR, MEANR, SDR, SOSR, GLBSOSR, GLBNR,
     &     NL, MEANL, SDL, SOSL, GLBSOSL, GLBNL
      CHARACTER*1  FORMFEED
      CHARACTER*35 PROCTYPE
      LOGICAL*1    SINGLE, RLVALUES, PRINT, SUB, DIVIDE, HDRONLY, NOZEROS
      LOGICAL*1    PRINTON

      INCLUDE 'spideram.inc'

      DATA         IOREADR, TBYTES /92, 16384/
      DATA         SIDE /0/

C     Currently handles only transverse images with no comparisons

      COL = 0
      ROW = 0
      SUB = .FALSE.
      DIVIDE = .FALSE.

      ERRTYPE = 0
      FORMFEED = CHAR(12)
      FILE(1) = GLBFILE
      MAXSLICE = NMSLICES
      CALL INTDATE(ADATE)

      N = 0
      GLBN   = 0
      GLBSUM = 0
      GLBSOS = 0.0
      NR = 0.0
      GLBNR   = 0.0
      GLBSUMR = 0
      GLBSOSR = 0.0
      NL = 0.0
      GLBNL   = 0.0
      GLBSUML = 0
      GLBSOSL = 0.0

C     The following are initialized here to prevent warnings
C     when the optimizing compiler is used (compiler bug).

      SDL   = 0.0
      SDR   = 0.0
      MEANL = 0.0
      MEANR = 0.0
      SUML  = 0.0
      SUMR  = 0.0
      SOSL  = 0.0
      SOSR  = 0.0

C     Check that the printer is open

      IF (PRINT) THEN
         INQUIRE (PRINTER, OPENED = PRINTON)
         IF (.NOT. PRINTON) OPEN (PRINTER,FILE=OUTFILE,STATUS='NEW')
      END IF

C     Write summary heading with region file name and date

 8000 FORMAT(2X,'SPIDERAM {version ',A11,'}')
 8010 FORMAT(1X,'WHOLE SLICE GLOBAL AVERAGE:   (',I2,'/',I2,'/',I4,')')
 8050 FORMAT(1X,I3,'% Threshold applied to ',A5,' maximum')
 8070 FORMAT(1X,'Midline at ',F5.1)
 8100 FORMAT(55(1H_),/)
 8150 FORMAT(37X,'WHOLE',8X,'LEFT',7X,'RIGHT')
 8200 FORMAT(1X,'Slice Number ',I3)
 8210 FORMAT(3X,'Number of Pixels .............',I9,4X,F8.1,4X,F8.1)
 8220 FORMAT(3X,'Mean Value ...................',F9.2,3X,F9.2,3X,F9.2)
 8230 FORMAT(3X,'Standard Deviation ...........',F9.2,3X,F9.2,3X,F9.2)

      WRITE(USEROUT,8000) VERSION
      WRITE(USEROUT,8010) ADATE(2),ADATE(3),ADATE(1)
      IF (PROCESS.EQ.0) THEN
         PROCTYPE = 'PETT Numbers'
      ELSE IF (PROCESS.EQ.1) THEN
         SLCNUM = 1
         HDRONLY = .TRUE.
         CALL D2GETIMG(1,SLCNUM,GLBFILE,ERRTYPE,HDRONLY)
         IF (ERRTYPE.NE.0) RETURN
         IF (NTYPE(1).EQ.2 .OR. NTYPE(1).EQ.4) THEN
            PROCTYPE = 'CBF'
         ELSE IF (NTYPE(1).EQ.3) THEN
            PROCTYPE = 'CBV'
         ELSE
            PROCTYPE = ' '
         END IF
      ELSE IF (PROCESS.EQ.2) THEN
         PROCTYPE = 'OEF'
      ELSE IF (PROCESS.EQ.3) THEN
         PROCTYPE = 'CMRO2'
      ELSE IF (PROCESS.EQ.4) THEN
         PROCTYPE = 'Decay-Corrected Tissue Activity'
      ELSE IF (PROCESS.EQ.5) THEN
         PROCTYPE = 'Non-Decay-Corrected Tissue Activity'
      ELSE IF (PROCESS.EQ.6) THEN
         PROCTYPE = 'CMRGlucose'
      ELSE IF (PROCESS.EQ.7) THEN
         PROCTYPE = 'CVO2'
      ELSE
         PROCTYPE = ' '
      END IF
      WRITE(USEROUT,*) 'Image File = ',FILENAME(GLBFILE),
     &     'processed as ',PROCTYPE
      IF (GLBTEMP) THEN
         WRITE(USEROUT,*) 'Template   = ',FILETP,
     &        'with Threshold at ',THRESHTP,'%'
      ELSE IF (SINGLE) THEN
         WRITE(USEROUT,8050) THRESHLD,'slice'
      ELSE
         WRITE(USEROUT,8050) THRESHLD,'image'
      END IF
      IF (RLVALUES) WRITE(USEROUT,8070) XMIDLINE
      WRITE(USEROUT,8100)
      IF (RLVALUES) WRITE(USEROUT,8150)

      IF (PRINT) THEN
         WRITE(PRINTER,8000) VERSION
         WRITE(PRINTER,8010) ADATE(2),ADATE(3),ADATE(1)
         WRITE(PRINTER,*) 'Image File = ',FILENAME(GLBFILE), 'processed as ',PROCTYPE
         IF (GLBTEMP) THEN
            WRITE(PRINTER,*) 'Template   = ',FILETP,'with Threshold at ',THRESHTP,'%'
         ELSE IF (SINGLE) THEN
            WRITE(PRINTER,8050) THRESHLD,'slice'
         ELSE
            WRITE(PRINTER,8050) THRESHLD,'image'
         END IF
         IF (RLVALUES) WRITE(PRINTER,8070) XMIDLINE
         WRITE(PRINTER,8100)
         IF (RLVALUES) WRITE(PRINTER,8150)
      END IF

C     If not using a template and thresholding to maximum
C     value in entire image, get maximum value in image
C     to use for thresholding (max value is taken from ALL slices)

      IF (.NOT.GLBTEMP) THEN
         TEMPLATE = 1
         IF (.NOT.SINGLE) THEN
            MAXCOUNT = 0
            DO 100 SLCNUM=1,MAXSLICE
               CALL D2IMAGE(SLCNUM,COL,ROW,SUB,DIVIDE,ERRTYPE)
               IF (ERRTYPE.NE.0) THEN
                  WRITE(USEROUT,*) '*** ERROR processing slice ',SLCNUM
                  RETURN
               END IF
               CALL D2MAXVAL(COL,ROW,SIDE)
               MAXCOUNT = MAX(MAXCOUNT,DMAX)
 100        CONTINUE
            DMAX = MAXCOUNT
         END IF
      END IF

C     --------------------------------------------------------------
C     Process all selected slices

      DO 2000 K=1,GSLICES
         SLCNUM = GLBSLICE(K)
         CALL D2IMAGE(SLCNUM,COL,ROW,SUB,DIVIDE,ERRTYPE)
         IF (ERRTYPE.NE.0) THEN
            WRITE(USEROUT,*) '*** ERROR processing slice ',SLCNUM
            RETURN
         END IF

C     Get template from disk or create it  (template put in TIMAGE)

         IF (GLBTEMP) THEN
            ADDR = (SLCNUM-1)*64
            CALL SYSIO(PB,IOREADR,TDISK,TIMAGE,TBYTES,ADDR)
         ELSE IF (SINGLE) THEN
            CALL D2MAXVAL(COL,ROW,SIDE)
            CALL D2TEMPLA(0)
         ELSE
            CALL D2TEMPLA(0)
         END IF

         N    = 0
         SUM  = 0
         SOS  = 0.0
         MEAN = 0.0
         SD   = 0.0

         DO 300 J=1,128
            DO 200 I=1,128
               IF (TIMAGE(I,J)) THEN
                  IF (NOZEROS) THEN
                     IF (IMAGE(I,J,1) .NE. 0) THEN
                        COUNT = IMAGE(I,J,1)
                        N = N + 1
                        SUM = SUM + COUNT
                        SOS = SOS + (FLOAT(COUNT) * FLOAT(COUNT))
                     ENDIF
                  ELSE
                     COUNT = IMAGE(I,J,1)
                     N = N + 1
                     SUM = SUM + COUNT
                     SOS = SOS + (FLOAT(COUNT) * FLOAT(COUNT))
                  ENDIF
               END IF
 200        CONTINUE
 300     CONTINUE

C     Compute mean and SD for this slice

         IF (N.GT.0) MEAN = SCALER(1)*FLOAT(SUM)/FLOAT(N)
         SOS = SOS*SCALER(1)*SCALER(1)
         IF (N.GT.1) SD = SQRT((SOS-FLOAT(N)*MEAN*MEAN)/FLOAT(N-1))

C     ---------------------------------------------------------------
C     Right/left hemisphere values

         IF (RLVALUES) THEN
            NR   = 0.0
            SUMR = 0
            SOSR = 0.0
            MEANR= 0.0
            SDR  = 0.0
            NL   = 0.0
            SUML = 0
            SOSL = 0.0
            MEANL= 0.0
            SDL  = 0.0
            SUMMID = 0
            SOSMID = 0.0

C     Case: midline is BETWEEN pixels (XMIDLINE = nn.5)

            IF (XMIDLINE-FLOAT(INT(XMIDLINE)).GT.0.1) THEN
               IMAX = INT(XMIDLINE)
               NI = 0
               DO 500 J=1,128
                  DO 400 I=1,IMAX
                     IF (TIMAGE(I,J)) THEN
                        IF (NOZEROS) THEN
                           IF (IMAGE(I,J,1) .NE. 0) THEN
                              COUNT = IMAGE(I,J,1)
                              NI = NI + 1
                              SUML = SUML + COUNT
                              SOSL = SOSL + (FLOAT(COUNT) * FLOAT(COUNT))
                           ENDIF
                        ELSE
                           COUNT = IMAGE(I,J,1)
                           NI = NI + 1
                           SUML = SUML + COUNT
                           SOSL = SOSL + (FLOAT(COUNT) * FLOAT(COUNT))
                        ENDIF
                     END IF
 400              CONTINUE
 500           CONTINUE
               NL = FLOAT(NI)

               NI = 0
               DO 700 J=1,128
                  DO 600 I=IMAX+1,128
                     IF (TIMAGE(I,J)) THEN
                        IF (NOZEROS) THEN
                           IF (IMAGE(I,J,1) .NE. 0) THEN
                              COUNT = IMAGE(I,J,1)
                              NI = NI + 1
                              SUMR = SUMR + COUNT
                              SOSR = SOSR + (FLOAT(COUNT) * FLOAT(COUNT))
                           ENDIF
                        ELSE
                           COUNT = IMAGE(I,J,1)
                           NI = NI + 1
                           SUMR = SUMR + COUNT
                           SOSR = SOSR + (FLOAT(COUNT) * FLOAT(COUNT))
                        ENDIF
                     END IF
 600              CONTINUE
 700           CONTINUE
               NR = FLOAT(NI)

C     Case: midline is ON a pixel (XMIDLINE = nn.0)

            ELSE
               IMAX = INT(XMIDLINE)
               NI = 0
               DO 900 J=1,128
                  DO 800 I=1,IMAX-1
                     IF (TIMAGE(I,J)) THEN
                        IF (NOZEROS) THEN
                           IF (IMAGE(I,J,1) .NE. 0) THEN
                              COUNT = IMAGE(I,J,1)
                              NI = NI + 1
                              SUML = SUML + COUNT
                              SOSL = SOSL + (FLOAT(COUNT) * FLOAT(COUNT))
                           ENDIF
                        ELSE
                           COUNT = IMAGE(I,J,1)
                           NI = NI + 1
                           SUML = SUML + COUNT
                           SOSL = SOSL + (FLOAT(COUNT) * FLOAT(COUNT))
                        ENDIF
                     END IF
 800              CONTINUE
 900           CONTINUE
               NL = FLOAT(NI)

               NI = 0
               DO 1100 J=1,128
                  DO 1000 I=IMAX+1,128
                     IF (TIMAGE(I,J)) THEN
                        IF (NOZEROS) THEN
                           IF (IMAGE(I,J,1) .NE. 0) THEN
                              COUNT = IMAGE(I,J,1)
                              NI = NI + 1
                              SUMR = SUMR + COUNT
                              SOSR = SOSR + (FLOAT(COUNT) * FLOAT(COUNT))
                           ENDIF
                        ELSE
                           COUNT = IMAGE(I,J,1)
                           NI = NI + 1
                           SUMR = SUMR + COUNT
                           SOSR = SOSR + (FLOAT(COUNT) * FLOAT(COUNT))
                        ENDIF
                     END IF
 1000             CONTINUE
 1100          CONTINUE
               NR = FLOAT(NI)

               NI = 0
               DO 1200 J=1,128
                  IF (TIMAGE(IMAX,J)) THEN
                     IF (NOZEROS) THEN
                        IF (IMAGE(IMAX,J,1) .NE. 0) THEN
                           COUNT = IMAGE(IMAX,J,1)
                           NI = NI + 1
                           SUMMID = SUMMID + COUNT
                           SOSMID = SOSMID + (FLOAT(COUNT) * FLOAT(COUNT))
                        ENDIF
                     ELSE
                        COUNT = IMAGE(IMAX,J,1)
                        NI = NI + 1
                        SUMMID = SUMMID + COUNT
                        SOSMID = SOSMID + (FLOAT(COUNT) * FLOAT(COUNT))
                     ENDIF
                  END IF
 1200          CONTINUE

               NR = NR + FLOAT(NI)/2.0
               NL = NL + FLOAT(NI)/2.0
               SUMR = SUMR + SUMMID/2
               SUML = SUML + SUMMID/2
               SOSR = SOSR + SOSMID/2.0
               SOSL = SOSL + SOSMID/2.0
            END IF

C     Compute mean and SD for this slice

            IF (NL.GT.0.0) MEANL = SCALER(1)*FLOAT(SUML)/NL
            SOSL = SOSL*SCALER(1)*SCALER(1)
            IF (NL.GT.1.0) SDL = SQRT((SOSL-NL*MEANL*MEANL)/(NL-1.0))

            IF (NR.GT.0.0) MEANR = SCALER(1)*FLOAT(SUMR)/NR
            SOSR = SOSR*SCALER(1)*SCALER(1)
            IF (NR.GT.1.0) SDR = SQRT((SOSR-NR*MEANR*MEANR)/(NR-1.0))
         END IF

C     ---------------------------------------------------------------
C     Output to terminal and printer

         IF (RLVALUES) THEN
            WRITE(USEROUT,8200) SLCNUM
            WRITE(USEROUT,8210) N,NL,NR
            WRITE(USEROUT,8220) MEAN,MEANL,MEANR
            WRITE(USEROUT,8230) SD,SDL,SDR
            IF (PRINT) THEN
               WRITE(PRINTER,8200) SLCNUM
               WRITE(PRINTER,8210) N,NL,NR
               WRITE(PRINTER,8220) MEAN,MEANL,MEANR
               WRITE(PRINTER,8230) SD,SDL,SDR
            END IF
         ELSE
            WRITE(USEROUT,8200) SLCNUM
            WRITE(USEROUT,8210) N
            WRITE(USEROUT,8220) MEAN
            WRITE(USEROUT,8230) SD
            IF (PRINT) THEN
               WRITE(PRINTER,8200) SLCNUM
               WRITE(PRINTER,8210) N
               WRITE(PRINTER,8220) MEAN
               WRITE(PRINTER,8230) SD
            END IF
         END IF

         GLBN   = GLBN + N
         GLBSUM = GLBSUM + SUM
         GLBSOS = GLBSOS + SOS

         IF (RLVALUES) THEN
            GLBNL  = GLBNL + NL
            GLBSUML= GLBSUML + SUML
            GLBSOSL= GLBSOSL + SOSL
            GLBNR  = GLBNR + NR
            GLBSUMR= GLBSUMR + SUMR
            GLBSOSR= GLBSOSR + SOSR
         END IF

 2000 CONTINUE
C     --------------------------------------------------------------
C     Compute mean and SD for ALL slices

      MEAN = SCALER(1)*FLOAT(GLBSUM)/FLOAT(GLBN)
      GLBSOS = GLBSOS
      IF (N.GT.1) THEN
         SD = SQRT((GLBSOS-FLOAT(GLBN)*MEAN*MEAN)/FLOAT(GLBN-1))
      ELSE
         SD = 0.0
      END IF

      IF (RLVALUES) THEN
         MEANL = SCALER(1)*FLOAT(GLBSUML)/GLBNL
         GLBSOSL = GLBSOSL
         IF (NL.GT.1.0) THEN
            SDL = SQRT((GLBSOSL-GLBNL*MEANL*MEANL)/(GLBNL-1.0))
         ELSE
            SDL = 0.0
         END IF

         MEANR = SCALER(1)*FLOAT(GLBSUMR)/GLBNR
         GLBSOSR = GLBSOSR
         IF (NR.GT.1.0) THEN
            SDR = SQRT((GLBSOSR-GLBNR*MEANR*MEANR)/(GLBNR-1.0))
         ELSE
            SDR = 0.0
         END IF
      END IF

      WRITE(USEROUT,*)
      WRITE(USEROUT,*) 'Global Statistics for All of the Above Slices:'
      IF (RLVALUES) THEN
         WRITE(USEROUT,8210) GLBN,GLBNL,GLBNR
         WRITE(USEROUT,8220) MEAN,MEANL,MEANR
         WRITE(USEROUT,8230) SD,SDL,SDR
         IF (PRINT) THEN
            WRITE(PRINTER,*)
            WRITE(PRINTER,*) 'Global Statistics for All of the Above Slices:'
            WRITE(PRINTER,8210) GLBN,GLBNL,GLBNR
            WRITE(PRINTER,8220) MEAN,MEANL,MEANR
            WRITE(PRINTER,8230) SD,SDL,SDR
            WRITE(PRINTER,8400) FORMFEED
         END IF
      ELSE
         WRITE(USEROUT,8210) GLBN
         WRITE(USEROUT,8220) MEAN
         WRITE(USEROUT,8230) SD
         IF (PRINT) THEN
            WRITE(PRINTER,*)
            WRITE(PRINTER,*) 'Global Statistics for All of the Above Slices:'
            WRITE(PRINTER,8210) GLBN
            WRITE(PRINTER,8220) MEAN
            WRITE(PRINTER,8230) SD
            WRITE(PRINTER,8400) FORMFEED
         END IF
      END IF
 8400 FORMAT(1X,A1)

C     Compute scaling factor

      IF (NORMALIZE) THEN
         MULTFACT (GLBFILE) = NRMVALUE / MEAN
      END IF

      RETURN
      END
@


1.10
log
@format changes plus fixes for g77
@
text
@d1 1
a1 1
C     $Id: g2wholes.f,v 1.9 2001/05/30 20:01:40 tom Exp tom $
d3 3
d122 1
a122 1
C     rcsheader = "$Id: g2wholes.f,v 1.9 2001/05/30 20:01:40 tom Exp tom $"
@


1.9
log
@version expanded to 11 chars
@
text
@d1 20
a20 17
C$Id: g2wholes.f,v 1.8 1999/12/15 21:32:41 tom Exp tom $
C$Log: g2wholes.f,v $
c Revision 1.8  1999/12/15  21:32:41  tom
c y2k fix in date print
c
c Revision 1.7  1999/03/05  18:49:14  tom
c add CVO2
c
c Revision 1.6  1998/04/29  15:20:35  tom
c allow processing for CMRGlucose
c
c Revision 1.5  1997/10/24  21:51:52  tom
c add NOZEROS option
c
c Revision 1.4  1994/11/29  23:28:08  ty7777
c Deleted VRMVALUE and NORMALIZE from the argument list.
c
d22 96
a117 102
C
C  Subroutine:   G2WHOLES.FTN
C
C  Author:       Tom O. Videen
C  Date:         29-May-87
C  Written For:  SPIDERAM Super PETT Image Display Program
C
C  History:
C     Modified 05-Mar-99 by TOV to allow processing for CVO2
C        (PROCESS may be 0-7)
C     Modified 28-Apr-98 by TOV to allow processing for CMRGlucose
C        (PROCESS may be 0-6)
C     Modified 26-Aug-87 by TOV to eliminate a bug in right/left
C        hemisphere values.
C     Modified 06-Oct-87 by TOV to allow processing for tissue activity
C        either with or without decay correction; (PROCESS may be 0-5)
C     Modified 13-Sep-88 by TOV:
C        1) change FILETP from I*4 to CH*23 in **DISPLAY common block.
C        2) print program VERSION date.
C     Modified 30-Sep-91 by Tom Yang:
C        1) Ported to the X Windows environment.
C     Modified 15-Oct-91 by TOV:
C        1) NRMVALUE and NORMALIZE added to calling parameters.
C     Modified 29-Sep-94 by Tom Yang:
C        1) Deleted NRMVALUE and NORMALIZE from the argument list.
C
C  Intent:
C     This subroutine computes global whole slice mean values.
C     If RLVALUES=true, it also computes the right and left
C     hemisphere averages using the current value of XMIDLINE
C     as the midline for ALL slices.
C
C  Common Blocks from SPIDERAM:
C     **IMAGEDAT - image arrays                   (write)
C     **LUINFO   - logical units (also /USRIO/)   (read only)
C     **DISPLAY  - display parameters             (write)
C     **FILES    - scan file list                 (read only)
C     **GLOBALAV - global averaging parameters    (read only)
C     **REGION   - regions of interest parameters (read only)
C
C  Variables Passed:
C     SINGLE: true--> compute threshold to max value on each slice;
C             false-> compute threshold to max value on entire image;
C     RLVALUES: true--> compute right/left hemisphere averages;
C     PRINT:  true--> write averages to printer;
C     ERRTYPE = type of error in processing images;
C
C  Local Variables:
C     N = number of points included on a slice;
C     SUM = total activity on a slice;
C     SOS = sum of squares on a slice;
C     GLBN = number of points included on all slices;
C     GLBSUM = total activity on all slices;
C     GLBSOS = sum of squares on all slices;
C     MEAN = mean activity of all included points;
C     SD = standard deviation (unbiased estimate);
C
C     NR = number of points included on a slice for right hemisphere;
C     SUMR = total activity on a slice for right hemisphere;
C     SOSR = sum of squares on a slice for right hemisphere;
C     GLBNR = number of points included on all slices for right hemisphere;
C     GLBSUMR = total activity on all slices for right hemisphere;
C     GLBSOSR = sum of squares on all slices for right hemisphere;
C     MEANR = mean activity of all included points for right hemisphere;
C     SDR = standard deviation (unbiased estimate) for right hemisphere;
C
C     NL = number of points included on a slice for left hemisphere;
C     SUML = total activity on a slice for left hemisphere;
C     SOSL = sum of squares on a slice for left hemisphere;
C     GLBNL = number of points included on all slices for left hemisphere;
C     GLBSUML = total activity on all slices for left hemisphere;
C     GLBSOSL = sum of squares on all slices for left hemisphere;
C     MEANL = mean activity of all included points for left hemisphere;
C     SDL = standard deviation (unbiased estimate) for left hemisphere;
C
C     NI = number of points included on a half-slice;
C     SUMMID = total activity on a midline of pixels;
C     SOSMID = sum of squares on a midline of pixels;
C     MAXCOUNT = maximum count in the image array;
C     MAXSLICE = greatest slice number;
C     COUNT = value of a pixel in IMAGE array;
C     PB = parameter block used by SYSIO;
C     IOREADR = random access I/O wait read;
C     TBYTES = no. of bytes to read for a template (TIMAGE);
C     ADDR = random address to start reading a template from;
C     SIDE = set to 0 to display entire image;
C
C  Uses Subroutines:
C
C  SPIDERAM.LIB - main subroutines for SPIDERAM:
C     D2GETIMG - get an image from a disk file (HDR only);
C     D2IMAGE  - assemble an image slice from component image files;
C     D2MAXVAL - get maximum and minimum values in an image array;
C     D2TEMPLA - create a template;
C     P2AREAI  - get points within an irregular region;
C     P2AREAR  - get points within a rectangular region;
C
C  FORTRAN Runtime Library
C     DATE
C
C  Called by:  M2GLOBAL
C
d119 1
d124 4
a127 4
     &             COUNT, MAXCOUNT, NI, SUMR, SUML,
     &             GLBSUMR, GLBSUML, SUMMID, ERRTYPE, SIDE,
     &             ADATE (3), COL, ROW, ADDR, PB (6),
     &             IOREADR, TBYTES, I, J, K, IMAX
d129 2
a130 2
     &             NR, MEANR, SDR, SOSR, GLBSOSR, GLBNR,
     &             NL, MEANL, SDL, SOSL, GLBSOSL, GLBNL
a134 1
      character*256 rcsheader
a136 1
      rcsheader = "$Id: g2wholes.f,v 1.8 1999/12/15 21:32:41 tom Exp tom $"
d141 1
a141 1
C  Currently handles only transverse images with no comparisons
d167 2
a168 2
C  The following are initialized here to prevent warnings
C  when the optimizing compiler is used (compiler bug).
d179 1
a179 1
C  Check that the printer is open
d182 2
a183 2
        INQUIRE (PRINTER, OPENED = PRINTON)
        IF (.NOT. PRINTON) OPEN (PRINTER,FILE=OUTFILE,STATUS='NEW')
d186 1
a186 1
C  Write summary heading with region file name and date
d188 10
a197 10
8000  FORMAT(2X,'SPIDERAM {version ',A11,'}')
8010  FORMAT(1X,'WHOLE SLICE GLOBAL AVERAGE:   (',I2,'/',I2,'/',I4,')')
8050  FORMAT(1X,I3,'% Threshold applied to ',A5,' maximum')
8070  FORMAT(1X,'Midline at ',F5.1)
8100  FORMAT(55(1H_),/)
8150  FORMAT(37X,'WHOLE',8X,'LEFT',7X,'RIGHT')
8200  FORMAT(1X,'Slice Number ',I3)
8210  FORMAT(3X,'Number of Pixels .............',I9,4X,F8.1,4X,F8.1)
8220  FORMAT(3X,'Mean Value ...................',F9.2,3X,F9.2,3X,F9.2)
8230  FORMAT(3X,'Standard Deviation ...........',F9.2,3X,F9.2,3X,F9.2)
d202 1
a202 1
        PROCTYPE = 'PETT Numbers'
d204 11
a214 11
        SLCNUM = 1
        HDRONLY = .TRUE.
        CALL D2GETIMG(1,SLCNUM,GLBFILE,ERRTYPE,HDRONLY)
        IF (ERRTYPE.NE.0) RETURN
        IF (NTYPE(1).EQ.2 .OR. NTYPE(1).EQ.4) THEN
          PROCTYPE = 'CBF'
        ELSE IF (NTYPE(1).EQ.3) THEN
          PROCTYPE = 'CBV'
        ELSE
          PROCTYPE = ' '
        END IF
d216 1
a216 1
        PROCTYPE = 'OEF'
d218 1
a218 1
        PROCTYPE = 'CMRO2'
d220 1
a220 1
        PROCTYPE = 'Decay-Corrected Tissue Activity'
d222 1
a222 1
        PROCTYPE = 'Non-Decay-Corrected Tissue Activity'
d224 1
a224 1
        PROCTYPE = 'CMRGlucose'
d226 1
a226 1
        PROCTYPE = 'CVO2'
d228 1
a228 1
        PROCTYPE = ' '
d231 1
a231 1
     &    'processed as ',PROCTYPE
d233 2
a234 2
        WRITE(USEROUT,*) 'Template   = ',FILETP,
     &    'with Threshold at ',THRESHTP,'%'
d236 1
a236 1
        WRITE(USEROUT,8050) THRESHLD,'slice'
d238 1
a238 1
        WRITE(USEROUT,8050) THRESHLD,'image'
d245 13
a257 13
        WRITE(PRINTER,8000) VERSION
        WRITE(PRINTER,8010) ADATE(2),ADATE(3),ADATE(1)
        WRITE(PRINTER,*) 'Image File = ',FILENAME(GLBFILE), 'processed as ',PROCTYPE
        IF (GLBTEMP) THEN
          WRITE(PRINTER,*) 'Template   = ',FILETP,'with Threshold at ',THRESHTP,'%'
        ELSE IF (SINGLE) THEN
          WRITE(PRINTER,8050) THRESHLD,'slice'
        ELSE
          WRITE(PRINTER,8050) THRESHLD,'image'
        END IF
        IF (RLVALUES) WRITE(PRINTER,8070) XMIDLINE
        WRITE(PRINTER,8100)
        IF (RLVALUES) WRITE(PRINTER,8150)
d260 3
a262 3
C  If not using a template and thresholding to maximum
C    value in entire image, get maximum value in image
C    to use for thresholding (max value is taken from ALL slices)
d265 14
a278 14
        TEMPLATE = 1
        IF (.NOT.SINGLE) THEN
          MAXCOUNT = 0
          DO 100 SLCNUM=1,MAXSLICE
            CALL D2IMAGE(SLCNUM,COL,ROW,SUB,DIVIDE,ERRTYPE)
            IF (ERRTYPE.NE.0) THEN
              WRITE(USEROUT,*) '*** ERROR processing slice ',SLCNUM
              RETURN
            END IF
            CALL D2MAXVAL(COL,ROW,SIDE)
            MAXCOUNT = MAX0(MAXCOUNT,DMAX)
100       CONTINUE
          DMAX = MAXCOUNT
        END IF
d281 2
a282 2
C  --------------------------------------------------------------
C  Process all selected slices
d285 6
a290 6
        SLCNUM = GLBSLICE(K)
        CALL D2IMAGE(SLCNUM,COL,ROW,SUB,DIVIDE,ERRTYPE)
        IF (ERRTYPE.NE.0) THEN
          WRITE(USEROUT,*) '*** ERROR processing slice ',SLCNUM
          RETURN
        END IF
d292 1
a292 1
C  Get template from disk or create it  (template put in TIMAGE)
d294 9
a302 9
        IF (GLBTEMP) THEN
          ADDR = (SLCNUM-1)*64
          CALL SYSIO(PB,IOREADR,TDISK,TIMAGE,TBYTES,ADDR)
        ELSE IF (SINGLE) THEN
          CALL D2MAXVAL(COL,ROW,SIDE)
          CALL D2TEMPLA(0)
        ELSE
          CALL D2TEMPLA(0)
        END IF
d304 5
a308 5
        N    = 0
        SUM  = 0
        SOS  = 0.0
        MEAN = 0.0
        SD   = 0.0
d310 19
a328 19
        DO 300 J=1,128
          DO 200 I=1,128
            IF (TIMAGE(I,J)) THEN
              IF (NOZEROS) THEN
                IF (IMAGE(I,J,1) .NE. 0) THEN
                  COUNT = IMAGE(I,J,1)
                  N = N + 1
                  SUM = SUM + COUNT
                  SOS = SOS + (FLOAT(COUNT) * FLOAT(COUNT))
                ENDIF
              ELSE
                COUNT = IMAGE(I,J,1)
                N = N + 1
                SUM = SUM + COUNT
                SOS = SOS + (FLOAT(COUNT) * FLOAT(COUNT))
              ENDIF
            END IF
200       CONTINUE
300     CONTINUE
d330 1
a330 1
C  Compute mean and SD for this slice
d332 3
a334 3
        IF (N.GT.0) MEAN = SCALER(1)*FLOAT(SUM)/FLOAT(N)
        SOS = SOS*SCALER(1)*SCALER(1)
        IF (N.GT.1) SD = SQRT((SOS-FLOAT(N)*MEAN*MEAN)/FLOAT(N-1))
d336 2
a337 2
C  ---------------------------------------------------------------
C  Right/left hemisphere values
d339 13
a351 13
        IF (RLVALUES) THEN
          NR   = 0.0
          SUMR = 0
          SOSR = 0.0
          MEANR= 0.0
          SDR  = 0.0
          NL   = 0.0
          SUML = 0
          SOSL = 0.0
          MEANL= 0.0
          SDL  = 0.0
          SUMMID = 0
          SOSMID = 0.0
d353 1
a353 1
C  Case: midline is BETWEEN pixels (XMIDLINE = nn.5)
d355 23
a377 23
          IF (XMIDLINE-FLOAT(INT(XMIDLINE)).GT.0.1) THEN
            IMAX = INT(XMIDLINE)
            NI = 0
            DO 500 J=1,128
              DO 400 I=1,IMAX
                IF (TIMAGE(I,J)) THEN
                  IF (NOZEROS) THEN
                    IF (IMAGE(I,J,1) .NE. 0) THEN
                      COUNT = IMAGE(I,J,1)
                      NI = NI + 1
                      SUML = SUML + COUNT
                      SOSL = SOSL + (FLOAT(COUNT) * FLOAT(COUNT))
                    ENDIF
                  ELSE
                    COUNT = IMAGE(I,J,1)
                    NI = NI + 1
                    SUML = SUML + COUNT
                    SOSL = SOSL + (FLOAT(COUNT) * FLOAT(COUNT))
                  ENDIF
                END IF
400           CONTINUE
500         CONTINUE
            NL = FLOAT(NI)
d379 21
a399 21
            NI = 0
            DO 700 J=1,128
              DO 600 I=IMAX+1,128
                IF (TIMAGE(I,J)) THEN
                  IF (NOZEROS) THEN
                    IF (IMAGE(I,J,1) .NE. 0) THEN
                      COUNT = IMAGE(I,J,1)
                      NI = NI + 1
                      SUMR = SUMR + COUNT
                      SOSR = SOSR + (FLOAT(COUNT) * FLOAT(COUNT))
                    ENDIF
                  ELSE
                    COUNT = IMAGE(I,J,1)
                    NI = NI + 1
                    SUMR = SUMR + COUNT
                    SOSR = SOSR + (FLOAT(COUNT) * FLOAT(COUNT))
                  ENDIF
                END IF
600           CONTINUE
700         CONTINUE
            NR = FLOAT(NI)
d401 1
a401 1
C  Case: midline is ON a pixel (XMIDLINE = nn.0)
d403 23
a425 23
          ELSE
            IMAX = INT(XMIDLINE)
            NI = 0
            DO 900 J=1,128
              DO 800 I=1,IMAX-1
                IF (TIMAGE(I,J)) THEN
                  IF (NOZEROS) THEN
                    IF (IMAGE(I,J,1) .NE. 0) THEN
                      COUNT = IMAGE(I,J,1)
                      NI = NI + 1
                      SUML = SUML + COUNT
                      SOSL = SOSL + (FLOAT(COUNT) * FLOAT(COUNT))
                    ENDIF
                  ELSE
                    COUNT = IMAGE(I,J,1)
                    NI = NI + 1
                    SUML = SUML + COUNT
                    SOSL = SOSL + (FLOAT(COUNT) * FLOAT(COUNT))
                  ENDIF
                END IF
800           CONTINUE
900         CONTINUE
            NL = FLOAT(NI)
d427 21
a447 21
            NI = 0
            DO 1100 J=1,128
              DO 1000 I=IMAX+1,128
                IF (TIMAGE(I,J)) THEN
                  IF (NOZEROS) THEN
                    IF (IMAGE(I,J,1) .NE. 0) THEN
                      COUNT = IMAGE(I,J,1)
                      NI = NI + 1
                      SUMR = SUMR + COUNT
                      SOSR = SOSR + (FLOAT(COUNT) * FLOAT(COUNT))
                    ENDIF
                  ELSE
                    COUNT = IMAGE(I,J,1)
                    NI = NI + 1
                    SUMR = SUMR + COUNT
                    SOSR = SOSR + (FLOAT(COUNT) * FLOAT(COUNT))
                  ENDIF
                END IF
1000          CONTINUE
1100        CONTINUE
            NR = FLOAT(NI)
d449 18
a466 18
            NI = 0
            DO 1200 J=1,128
              IF (TIMAGE(IMAX,J)) THEN
                IF (NOZEROS) THEN
                  IF (IMAGE(IMAX,J,1) .NE. 0) THEN
                    COUNT = IMAGE(IMAX,J,1)
                    NI = NI + 1
                    SUMMID = SUMMID + COUNT
                    SOSMID = SOSMID + (FLOAT(COUNT) * FLOAT(COUNT))
                  ENDIF
                ELSE
                  COUNT = IMAGE(IMAX,J,1)
                  NI = NI + 1
                  SUMMID = SUMMID + COUNT
                  SOSMID = SOSMID + (FLOAT(COUNT) * FLOAT(COUNT))
                ENDIF
              END IF
1200        CONTINUE
d468 7
a474 7
            NR = NR + FLOAT(NI)/2.0
            NL = NL + FLOAT(NI)/2.0
            SUMR = SUMR + SUMMID/2
            SUML = SUML + SUMMID/2
            SOSR = SOSR + SOSMID/2.0
            SOSL = SOSL + SOSMID/2.0
          END IF
d476 1
a476 1
C  Compute mean and SD for this slice
d478 3
a480 3
          IF (NL.GT.0.0) MEANL = SCALER(1)*FLOAT(SUML)/NL
          SOSL = SOSL*SCALER(1)*SCALER(1)
          IF (NL.GT.1.0) SDL = SQRT((SOSL-NL*MEANL*MEANL)/(NL-1.0))
d482 4
a485 4
          IF (NR.GT.0.0) MEANR = SCALER(1)*FLOAT(SUMR)/NR
          SOSR = SOSR*SCALER(1)*SCALER(1)
          IF (NR.GT.1.0) SDR = SQRT((SOSR-NR*MEANR*MEANR)/(NR-1.0))
        END IF
d487 2
a488 2
C  ---------------------------------------------------------------
C  Output to terminal and printer
d490 23
a512 23
        IF (RLVALUES) THEN
          WRITE(USEROUT,8200) SLCNUM
          WRITE(USEROUT,8210) N,NL,NR
          WRITE(USEROUT,8220) MEAN,MEANL,MEANR
          WRITE(USEROUT,8230) SD,SDL,SDR
          IF (PRINT) THEN
            WRITE(PRINTER,8200) SLCNUM
            WRITE(PRINTER,8210) N,NL,NR
            WRITE(PRINTER,8220) MEAN,MEANL,MEANR
            WRITE(PRINTER,8230) SD,SDL,SDR
          END IF
        ELSE
          WRITE(USEROUT,8200) SLCNUM
          WRITE(USEROUT,8210) N
          WRITE(USEROUT,8220) MEAN
          WRITE(USEROUT,8230) SD
          IF (PRINT) THEN
            WRITE(PRINTER,8200) SLCNUM
            WRITE(PRINTER,8210) N
            WRITE(PRINTER,8220) MEAN
            WRITE(PRINTER,8230) SD
          END IF
        END IF
d514 3
a516 3
        GLBN   = GLBN + N
        GLBSUM = GLBSUM + SUM
        GLBSOS = GLBSOS + SOS
d518 8
a525 8
        IF (RLVALUES) THEN
          GLBNL  = GLBNL + NL
          GLBSUML= GLBSUML + SUML
          GLBSOSL= GLBSOSL + SOSL
          GLBNR  = GLBNR + NR
          GLBSUMR= GLBSUMR + SUMR
          GLBSOSR= GLBSOSR + SOSR
        END IF
d527 3
a529 3
2000  CONTINUE
C  --------------------------------------------------------------
C  Compute mean and SD for ALL slices
d534 1
a534 1
        SD = SQRT((GLBSOS-FLOAT(GLBN)*MEAN*MEAN)/FLOAT(GLBN-1))
d536 1
a536 1
        SD = 0.0
d540 7
a546 7
        MEANL = SCALER(1)*FLOAT(GLBSUML)/GLBNL
        GLBSOSL = GLBSOSL
        IF (NL.GT.1.0) THEN
          SDL = SQRT((GLBSOSL-GLBNL*MEANL*MEANL)/(GLBNL-1.0))
        ELSE
          SDL = 0.0
        END IF
d548 7
a554 7
        MEANR = SCALER(1)*FLOAT(GLBSUMR)/GLBNR
        GLBSOSR = GLBSOSR
        IF (NR.GT.1.0) THEN
          SDR = SQRT((GLBSOSR-GLBNR*MEANR*MEANR)/(GLBNR-1.0))
        ELSE
          SDR = 0.0
        END IF
d560 11
a570 11
        WRITE(USEROUT,8210) GLBN,GLBNL,GLBNR
        WRITE(USEROUT,8220) MEAN,MEANL,MEANR
        WRITE(USEROUT,8230) SD,SDL,SDR
        IF (PRINT) THEN
          WRITE(PRINTER,*)
          WRITE(PRINTER,*) 'Global Statistics for All of the Above Slices:'
          WRITE(PRINTER,8210) GLBN,GLBNL,GLBNR
          WRITE(PRINTER,8220) MEAN,MEANL,MEANR
          WRITE(PRINTER,8230) SD,SDL,SDR
          WRITE(PRINTER,8400) FORMFEED
        END IF
d572 11
a582 11
        WRITE(USEROUT,8210) GLBN
        WRITE(USEROUT,8220) MEAN
        WRITE(USEROUT,8230) SD
        IF (PRINT) THEN
          WRITE(PRINTER,*)
          WRITE(PRINTER,*) 'Global Statistics for All of the Above Slices:'
          WRITE(PRINTER,8210) GLBN
          WRITE(PRINTER,8220) MEAN
          WRITE(PRINTER,8230) SD
          WRITE(PRINTER,8400) FORMFEED
        END IF
d584 1
a584 1
8400  FORMAT(1X,A1)
d586 1
a586 1
C  Compute scaling factor
d589 1
a589 1
        MULTFACT (GLBFILE) = NRMVALUE / MEAN
@


1.8
log
@y2k fix in date print
@
text
@d1 1
a1 1
C$Id: g2wholes.f,v 1.7 1999/03/05 18:49:14 tom Exp tom $
d3 3
d122 1
a122 1
C
d124 1
a124 1
C
d138 1
a138 1
C
d140 1
a140 1
      rcsheader = "$Id: g2wholes.f,v 1.7 1999/03/05 18:49:14 tom Exp tom $"
d192 1
a192 1
8000  FORMAT(2X,'SPIDERAM {version ',A9,'}')
d542 1
a542 1
C
d551 1
a551 1
C
d560 1
a560 1
C
d589 1
a589 1
C
d591 1
a591 1
C
d593 1
a593 1
	MULTFACT (GLBFILE) = NRMVALUE / MEAN
d595 1
a595 1
C
@


1.7
log
@add CVO2
@
text
@d1 1
a1 1
C$Id: g2wholes.f,v 1.6 1998/04/29 15:20:35 tom Exp tom $
d3 3
d137 1
a137 1
      rcsheader = "$Id: g2wholes.f,v 1.6 1998/04/29 15:20:35 tom Exp tom $"
d190 1
a190 1
8010  FORMAT(1X,'WHOLE SLICE GLOBAL AVERAGE:   (',I2,'/',I2,'/',I2,')')
@


1.6
log
@allow processing for CMRGlucose
@
text
@d1 1
a1 1
C$Id: g2wholes.f,v 1.5 1997/10/24 21:51:52 tom Exp tom $
d3 3
d21 2
d134 2
a135 2
      rcsheader = "$Id: g2wholes.f,v 1.5 1997/10/24 21:51:52 tom Exp tom $"
C
d138 1
a138 1
C
d140 1
a140 1
C
d145 1
a145 1
C
d151 1
a151 1
C
d164 1
a164 1
C
d167 1
a167 1
C
d176 1
a176 1
C
d178 1
a178 1
C
d181 1
a181 1
        IF (.NOT. PRINTON) OPEN (PRINTER,FILE=OUTFILE,TYPE='DEVICE')
d183 1
a183 1
C
d185 1
a185 1
C
d196 1
a196 1
C
d223 2
d241 1
a241 1
C
d245 1
a245 2
        WRITE(PRINTER,*) 'Image File = ',FILENAME(GLBFILE),
     &    'processed as ',PROCTYPE
d247 1
a247 2
          WRITE(PRINTER,*) 'Template   = ',FILETP,
     &      'with Threshold at ',THRESHTP,'%'
d257 1
a257 1
C
d261 1
a261 1
C
d278 1
a278 1
C
d281 1
a281 1
C
d289 1
a289 1
C
d291 1
a291 1
C
d301 1
a301 1
C
d307 1
a307 1
C
d327 1
a327 1
C
d329 1
a329 1
C
d333 1
a333 1
C
d336 1
a336 1
C
d350 1
a350 1
C
d352 1
a352 1
C
d376 1
a376 1
C
d398 1
a398 1
C
d400 1
a400 1
C
d424 1
a424 1
C
d446 1
a446 1
C
d465 1
a465 1
C
d473 1
a473 1
C
d475 1
a475 1
C
d479 1
a479 1
C
d484 1
a484 1
C
d487 1
a487 1
C
d511 1
a511 1
C
d515 1
a515 1
C
d524 1
a524 1
C
d528 1
a528 1
C
@


1.5
log
@add NOZEROS option
@
text
@d1 1
a1 1
C$Id: g2wholes.f,v 1.4 1994/11/29 23:28:08 ty7777 Exp tom $
d3 3
d18 2
d129 1
a129 1
      rcsheader = "$Id: g2wholes.f,v 1.4 1994/11/29 23:28:08 ty7777 Exp tom $"
d216 2
d222 1
a222 1
     2    'processed as ',PROCTYPE
d225 1
a225 1
     2    'with Threshold at ',THRESHTP,'%'
d239 1
a239 1
     2    'processed as ',PROCTYPE
d242 1
a242 1
     2      'with Threshold at ',THRESHTP,'%'
d558 1
a558 2
          WRITE(PRINTER,*) 'Global Statistics for All of the Above ',
     2      'Slices:'
d570 1
a570 2
          WRITE(PRINTER,*) 'Global Statistics for All of the Above ',
     2      'Slices:'
@


1.4
log
@Deleted VRMVALUE and NORMALIZE from the argument list.
@
text
@d1 5
a5 2
C$Id$
C$Log$
d107 1
a107 1
      SUBROUTINE G2WHOLES (SINGLE, RLVALUES, PRINT, ERRTYPE)
d119 1
a119 1
      LOGICAL*1    SINGLE, RLVALUES, PRINT, SUB, DIVIDE, HDRONLY
d124 1
a124 1
      rcsheader = "$Id: g2wholes.f,v 1.3 1993/10/04 21:55:32 tom Exp ty7777 $"
d299 13
a311 4
              COUNT = IMAGE(I,J,1)
              N = N + 1
              SUM = SUM + COUNT
              SOS = SOS + (FLOAT(COUNT) * FLOAT(COUNT))
d347 13
a359 4
                  COUNT = IMAGE(I,J,1)
                  NI = NI + 1
                  SUML = SUML + COUNT
                  SOSL = SOSL + (FLOAT(COUNT) * FLOAT(COUNT))
d369 13
a381 4
                  COUNT = IMAGE(I,J,1)
                  NI = NI + 1
                  SUMR = SUMR + COUNT
                  SOSR = SOSR + (FLOAT(COUNT) * FLOAT(COUNT))
d395 13
a407 4
                  COUNT = IMAGE(I,J,1)
                  NI = NI + 1
                  SUML = SUML + COUNT
                  SOSL = SOSL + (FLOAT(COUNT) * FLOAT(COUNT))
d417 13
a429 4
                  COUNT = IMAGE(I,J,1)
                  NI = NI + 1
                  SUMR = SUMR + COUNT
                  SOSR = SOSR + (FLOAT(COUNT) * FLOAT(COUNT))
d438 13
a450 4
                COUNT = IMAGE(IMAX,J,1)
                NI = NI + 1
                SUMMID = SUMMID + COUNT
                SOSMID = SOSMID + (FLOAT(COUNT) * FLOAT(COUNT))
@


1.3
log
@added rcsheader
@
text
@d1 2
d19 2
d23 2
d104 1
a104 2
      SUBROUTINE G2WHOLES(SINGLE,RLVALUES,PRINT,NRMVALUE,NORMALIZE,
     &  ERRTYPE)
a113 1
      REAL*4       NRMVALUE
d117 1
a117 1
      LOGICAL*1    PRINTON, NORMALIZE
d121 1
a121 1
      rcsheader = "$Id$"
d520 1
a520 1
	MULTFACT(GLBFILE) = NRMVALUE/MEAN
@


1.2
log
@Save window dump. 04/23/92 by Tom Yang
@
text
@d114 1
d117 1
@


1.1
log
@Initial revision
@
text
@@
