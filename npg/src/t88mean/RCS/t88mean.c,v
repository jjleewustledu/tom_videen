head	3.49;
access;
symbols;
locks; strict;
comment	@ * @;


3.49
date	2009.07.14.15.16.52;	author tom;	state Exp;
branches;
next	3.48;

3.48
date	2004.02.20.16.15.35;	author tom;	state Exp;
branches;
next	3.47;

3.47
date	2000.09.06.19.14.17;	author tom;	state Exp;
branches;
next	3.46;

3.46
date	2000.01.25.16.25.33;	author tom;	state Exp;
branches;
next	3.45;

3.45
date	99.12.17.16.06.32;	author tom;	state Exp;
branches;
next	3.44;

3.44
date	99.10.12.13.26.52;	author tom;	state Exp;
branches;
next	3.43;

3.43
date	98.04.27.20.24.14;	author tom;	state Exp;
branches;
next	3.42;

3.42
date	98.01.30.16.51.08;	author tom;	state Exp;
branches;
next	3.41;

3.41
date	98.01.29.16.25.00;	author tom;	state Exp;
branches;
next	3.40;

3.40
date	96.11.21.17.56.00;	author tom;	state Exp;
branches;
next	3.39;

3.39
date	96.11.06.17.33.23;	author tom;	state Exp;
branches;
next	3.38;

3.38
date	96.10.16.17.18.59;	author tom;	state Exp;
branches;
next	3.28;

3.28
date	96.10.11.14.44.17;	author tom;	state Exp;
branches;
next	3.27;

3.27
date	96.09.23.17.27.03;	author tom;	state Exp;
branches;
next	3.26;

3.26
date	96.09.11.20.50.25;	author tom;	state Exp;
branches;
next	3.25;

3.25
date	96.09.03.18.22.55;	author tom;	state Exp;
branches;
next	3.24;

3.24
date	96.08.26.18.01.54;	author tom;	state Exp;
branches;
next	3.23;

3.23
date	96.08.23.17.38.18;	author tom;	state Exp;
branches;
next	3.22;

3.22
date	96.08.14.16.48.01;	author tom;	state Exp;
branches;
next	3.21;

3.21
date	96.08.13.13.27.12;	author tom;	state Exp;
branches;
next	3.20;

3.20
date	96.08.05.14.33.56;	author tom;	state Exp;
branches;
next	3.19;

3.19
date	96.05.10.22.45.47;	author tom;	state Exp;
branches;
next	3.18;

3.18
date	96.05.10.21.59.55;	author tom;	state Exp;
branches;
next	3.17;

3.17
date	95.11.10.18.48.21;	author tom;	state Exp;
branches;
next	3.16;

3.16
date	95.11.10.18.46.55;	author tom;	state Exp;
branches;
next	3.15;

3.15
date	95.09.18.20.21.16;	author tom;	state Exp;
branches;
next	3.14;

3.14
date	95.09.18.19.50.30;	author tom;	state Exp;
branches;
next	3.13;

3.13
date	95.08.31.21.59.37;	author tom;	state Exp;
branches;
next	3.12;

3.12
date	95.05.22.20.14.15;	author tom;	state Exp;
branches;
next	3.11;

3.11
date	95.05.22.15.00.32;	author tom;	state Exp;
branches;
next	3.10;

3.10
date	95.01.19.22.42.11;	author tom;	state Exp;
branches;
next	3.9;

3.9
date	95.01.19.19.17.17;	author tom;	state Exp;
branches;
next	3.8;

3.8
date	94.12.27.22.59.41;	author tom;	state Exp;
branches;
next	3.7;

3.7
date	94.10.11.21.59.03;	author tom;	state Exp;
branches;
next	3.6;

3.6
date	94.10.03.17.54.18;	author tom;	state Exp;
branches;
next	3.5;

3.5
date	94.10.03.16.17.13;	author tom;	state Exp;
branches;
next	3.4;

3.4
date	94.09.14.14.41.51;	author tom;	state Exp;
branches;
next	3.3;

3.3
date	94.05.24.22.31.27;	author tom;	state Exp;
branches;
next	3.2;

3.2
date	94.05.24.17.12.11;	author tom;	state Exp;
branches;
next	3.1;

3.1
date	94.05.18.15.53.30;	author tom;	state Exp;
branches;
next	3.0;

3.0
date	94.05.11.17.19.52;	author tom;	state Exp;
branches;
next	2.2;

2.2
date	94.05.10.15.33.34;	author tom;	state Exp;
branches;
next	2.1;

2.1
date	94.04.29.17.37.32;	author tom;	state Exp;
branches;
next	2.0;

2.0
date	94.04.28.22.31.10;	author tom;	state Exp;
branches;
next	1.99;

1.99
date	94.04.28.22.08.37;	author tom;	state Exp;
branches;
next	1.98;

1.98
date	94.04.12.22.09.06;	author tom;	state Exp;
branches;
next	1.97;

1.97
date	94.04.01.16.46.01;	author tom;	state Exp;
branches;
next	1.96;

1.96
date	94.03.30.14.55.05;	author tom;	state Exp;
branches;
next	1.95;

1.95
date	94.03.21.18.11.54;	author tom;	state Exp;
branches;
next	1.94;

1.94
date	94.02.22.16.27.27;	author tom;	state Exp;
branches;
next	1.93;

1.93
date	94.02.14.20.14.44;	author tom;	state Exp;
branches;
next	1.92;

1.92
date	94.01.18.17.19.30;	author tom;	state Exp;
branches;
next	1.91;

1.91
date	94.01.14.17.09.40;	author tom;	state Exp;
branches;
next	1.90;

1.90
date	94.01.06.19.39.46;	author tom;	state Exp;
branches;
next	1.87;

1.87
date	94.01.06.19.38.51;	author tom;	state Exp;
branches;
next	1.86;

1.86
date	94.01.05.23.48.00;	author tom;	state Exp;
branches;
next	1.85;

1.85
date	93.11.18.21.55.59;	author tom;	state Exp;
branches;
next	1.84;

1.84
date	93.11.08.15.40.32;	author tom;	state Exp;
branches;
next	1.83;

1.83
date	93.11.02.21.29.28;	author tom;	state Exp;
branches;
next	1.82;

1.82
date	93.10.19.14.03.09;	author tom;	state Exp;
branches;
next	1.81;

1.81
date	93.10.08.18.01.10;	author tom;	state Exp;
branches;
next	1.80;

1.80
date	93.10.05.21.07.02;	author tom;	state Exp;
branches;
next	1.78;

1.78
date	93.10.04.16.44.35;	author tom;	state Exp;
branches;
next	1.77;

1.77
date	93.10.01.16.41.34;	author tom;	state Exp;
branches;
next	1.76;

1.76
date	93.09.29.16.01.52;	author tom;	state Exp;
branches;
next	1.75;

1.75
date	93.08.27.20.43.19;	author tom;	state Exp;
branches;
next	1.7;

1.7
date	93.08.26.17.26.35;	author tom;	state Exp;
branches;
next	1.6;

1.6
date	93.08.20.20.24.07;	author tom;	state Exp;
branches;
next	1.5;

1.5
date	93.08.19.22.55.48;	author tom;	state Exp;
branches;
next	;


desc
@a corrected hd6mean-atlas version of t88mean
@


3.49
log
@bug in t88mean fixed to call getatlas_t88 when atlas_name is t88
@
text
@/* $Log: t88mean.c,v $
 * Revision 3.48  2004/02/20  16:15:35  tom
 * Feb 2004
 *
 * Revision 3.47  2000/09/06  19:14:17  tom
 * strcpy filename
 *
 * Revision 3.46  2000/01/25  16:25:33  tom
 * rebuild due to puzzling reversal in left-right orientation
 *
 * Revision 3.45  1999/12/17  16:06:32  tom
 * lint cleaning
 *
 * Revision 3.44  1999/10/12  13:26:52  tom
 * new libimgutil with updated arc path
 *
 * Revision 3.43  1998/04/27  20:24:14  tom
 * fix bug in noatlas_transform.c
 *
 * Revision 3.42  1998/01/30  16:51:08  tom
 * permit reading files with names like _g285.v
 *
 * Revision 3.41  1998/01/29  16:25:00  tom
 * modified filter_suffix in libimgutil
 *
 * Revision 3.40  1996/11/21  17:56:00  tom
 * change libimgutil (processOxygen.c) to restrict OEF to <=1.1 and CMRO2 to <= 100
 *
 * Revision 3.39  1996/11/06  17:33:23  tom
 * correct scaling of cbf and cbv images
 *
 * Revision 3.38  1996/10/16  17:18:59  tom
 * sync with Version
 * new libimage
 *
 * Revision 3.28  1996/10/11  14:44:17  tom
 * added zref for atlas.xdim, atlas.ydim in atlas_scalers.c
 *
 * Revision 3.27  1996/09/23  17:27:03  tom
 * allow scanner = 0
 *
 * Revision 3.26  1996/09/11  20:50:25  tom
 * set orientation of output image
 *
 * Revision 3.25  1996/09/03  18:22:55  tom
 * add imgmode to get_input_lists
 * fix bug in writehdr
 *
 * Revision 3.24  1996/08/26  18:01:54  tom
 * new libimage with fixed scaling in wrimg7
 *
 * Revision 3.23  1996/08/23  17:38:18  tom
 * new libimage
 *
 * Revision 3.22  1996/08/14  16:48:01  tom
 * *** empty log message ***
 *
 * Revision 3.21  1996/08/13  13:27:12  tom
 * atlas.z0 is set before calling getatlas_t88
 *
 * Revision 3.20  1996/08/05  14:33:56  tom
 * new libimage and libnrimg
 *
 * Revision 3.19  1996/05/10  22:45:47  tom
 * add mode='w' before wrtensor
 *
 * Revision 3.18  1996/05/10  21:59:55  tom
 * new libimage
 * indexing from 1 on images and atlas
 *
 * Revision 3.17  1995/11/10  18:48:21  tom
 * remove petutil parent directory from include statements
 *
 * Revision 3.16  1995/11/10  18:46:55  tom
 * change rec file output of matrix
 *
 * Revision 3.15  1995/09/18  20:21:16  tom
 * changed version output in rcsid
 *
 * Revision 3.14  1995/09/18  19:50:30  tom
 * corrected z0 error in version 3.12
 *
 * Revision 3.13  1995/08/31  21:59:37  tom
 * option added-- atlas: none
 *
 * Revision 3.12  1995/05/22  20:14:15  tom
 * error checking for imglist size
 *
 * Revision 3.11  1995/05/22  15:00:32  tom
 * changed IMGLIST_SIZE to a local definition of 2000
 *
 * Revision 3.10  1995/01/19  22:42:11  tom
 * weights.
 *
 * Revision 3.9  1995/01/19  19:17:17  tom
 * weights
 *
 * Revision 3.8  1994/12/27  22:59:41  tom
 * free mask in imgrot.c
 *
 * Revision 3.7  1994/10/11  21:59:03  tom
 * Fix bug in creating filenames (sd and n) when output file has no "."
 *
 * Revision 3.6  1994/10/03  17:54:18  tom
 * set EOT to 0 on exit
 *
 * Revision 3.5  1994/10/03  16:17:13  tom
 * Changed atlas_transform to compute the x-scaling factor from the nearest slice
 * to the AC-PC plane if no slice contains the AC-PC plane;
 * The transformation matrix (and scaling factors) are written to the rec file;
 * Change calling parameters to sxr_center;
 * Separate functions atlas_scalers and matrix_transform;
 *
 * Revision 3.4  1994/09/14  14:41:51  tom
 * Allow > 49 slices in atlas and any z-origin
 *
 * Revision 3.3  1994/05/24  22:31:27  tom
 * fixed nmask comparison in image_scale.c
 *
 * Revision 3.2  1994/05/24  17:12:11  tom
 * image_scale fixed to use nmask properly
 *
 * Revision 3.1  1994/05/18  15:53:30  tom
 * changed $Id: t88mean.c,v 3.48 2004/02/20 16:15:35 tom Exp tom $ to $Header: /home/npggw/tom/src/t88mean/RCS/t88mean.c,v 3.48 2004/02/20 16:15:35 tom Exp tom $
 *
 * Revision 3.0  1994/05/11  17:19:52  tom
 * Corrected Version with proper matrix concatenation
 *
 * Revision 2.2  1994/05/10  15:33:34  tom
 * fixed bug in atlas_transform.c
 * eliminate use_pet
 *
 * Revision 2.1  1994/04/29  17:37:32  tom
 * correct y-scaling when use_pet = true
 *
 * Revision 2.0  1994/04/28  22:31:10  tom
 * last_slice must be <= number of slices
 *
 * Revision 1.99  1994/04/28  22:08:37  tom
 * added parameter slices:
 *
 * Revision 1.98  1994/04/12  22:09:06  tom
 * added nmask option in smg_include (changed image_scale.c)
 *
 * Revision 1.97  1994/04/01  16:46:01  tom
 * added copyright
 *
 * Revision 1.96  1994/03/30  14:55:05  tom
 * correct plane_separation in main_header of output image
 *
 * Revision 1.95  1994/03/21  18:11:54  tom
 * new libpetarc.a
 *
 * Revision 1.94  1994/02/22  16:27:27  tom
 * use getatlas_t88 from libhp.a
 * write pixel_size and slice_separation to output files
 *
 * Revision 1.93  1994/02/14  20:14:44  tom
 * fixed {} in symmetry
 *
 * Revision 1.92  1994/01/18  17:19:30  tom
 * new libhp
 *
 * Revision 1.91  1994/01/14  17:09:40  tom
 * OEF forced to fall 0-1.
 *
 * Revision 1.90  1994/01/06  19:39:46  tom
 * new libhp.a
 *
 * Revision 1.87  1994/01/06  19:38:51  tom
 * new libph.a
 *
 * Revision 1.86  1994/01/05  23:48:00  tom
 * fixed process_oxygen
 *
 * Revision 1.85  1993/11/18  21:55:59  tom
 * Rebuilt with updated libhp (to read ml-reconstructed images)
 *
 * Revision 1.84  1993/11/08  15:40:32  tom
 * check for sqrt(0) in image_scale.c
 *
 * Revision 1.83  1993/11/02  21:29:28  tom
 * Rebuilt with new libhp which allows parameter "suffix" to be used
 *
 * Revision 1.82  1993/10/19  14:03:09  tom
 * symmetry is working for single and paired imagelists
 *
 * Revision 1.81  1993/10/08  18:01:10  tom
 * libhp has been fixed to read PETT VI images in ECAT format in correct orientation
 *
 * Revision 1.80  1993/10/05  21:07:02  tom
 * new version to flip ecat images on x-axis
 *
 * Revision 1.78  1993/10/04  16:44:35  tom
 * eliminated atl = undefined from atlas_transform
 *
 * Revision 1.77  1993/10/01  16:41:34  tom
 * fixed calculation of sdimage
 *
 * Revision 1.76  1993/09/29  16:01:52  tom
 * added metabolic processing and hdr files (cbf, cbv, oef, cmor2)
 *
 * Revision 1.75  1993/08/27  20:43:19  tom
 * added pixel_size and plane_separation to prm file list
 *
 * Revision 1.7  1993/08/26  17:26:35  tom
 * changed atlas y-dim to used 5 mm between brain and skull
 *
 * Revision 1.6  1993/08/20  20:24:07  tom
 * first version with Talairach 1988 atlas
 *
 * Revision 1.5  1993/08/19  22:55:48  tom
 * a corrected hd6mean-atlas version of t88mean
 *
 * Revision 1.4  1993/08/12  22:58:02  tom
 * equivalent to hd6mean
 *
 * Revision 1.3  1993/08/06  15:16:49  tom
 * reads prm and list files
 *
 * Revision 1.1  1993/06/24  18:57:01  tom
 * Initial revision
 *
 */
/*	===============================================================================
 *	Module:			t88mean.c
 *	Date:			Jun 1993
 *	Author:			Tom Videen
 *	Description:
 *		Transform PET images (PETT VI or ECAT) into atlas space (Talairach 1988).
 *		Optionally create summed images (difference, mean, or single).
 *		Optionally process images as cvf, cbv, oef, cmro2.
 *
 *	Command line parameters:
 *		parameter file
 *		image list
 *		output filename
 *
 *	Input Files:
 *		parameter file  (prm (5))
 *		image list      (imagelist (5))
 *		PET image files (PETT VI, ECAT image format; any readable by getrealimg)
 *		hdr files       (hdr (5))
 *		image mask      (PETT VI, ECAT image format; any readable by getrealimg)
 *		sxr files       (xray (1))
 *
 *	Output Files:
 *		atlas image     (ECAT image format)
 *		rec file        (rec (5))
 *		hdr file        (hdr (5))
 *		sd image        (ECAT image format)
 *		n image         (ECAT image format)
 *
 *	History:
 *		Version 1.1 (24-Jun 1993) was a replication of the current hd6mean (SARP) algorithm.
 *		Version 1.4 (11-Aug 1993) read prm and lst files; paired image processing.
 *			Read mask file for each activation image.
 *			Create sd and n images.
 *			Output images are equivalent to hd6mean (setting x_trans in each slice).
 *		Version 1.5 (19-Aug 1993)
 *			if smg_mode = diff, no scalers are read from the inputlist;
 *			add smg_symmetry as option to rotate about Y and Z axes;
 *			renamed as t88mean;
 *			add sxr_xcenter;
 *			add recfile;
 *		Version 1.6 (20-Aug 1993)
 *			switched to Talairach 1988 atlas  (getatlas_t88 replaces getatlas_hd6);
 *			changed atlas_transform to shift atlas origin anterior;
 *			added 5 mm between brain and skull at front, back, and top in calculations
 *		Version 1.7 (24-Aug 1993)
 *			added option smg_scaletopet
 *			changed: 5 mm between brain and skull at front, back, and 0 at top in calculations
 *			changed signs of angles passed to and from imgrot (needs valildation)
 *		Version 1.75 (27-Aug 1993)
 *			added parameters for default_pixel_size and default_plane_separation;
 *		Version 1.76 (28-Sep 1993)
 *			can read image lists in 3 modes (standard, difference, or multitracer);
 *			modified get_input_lists;
 *			eliminated list.h; replaced INPUT_FILE_LIST structure with scan and sxrfile;
 *			added writehdr for creating hdr files for metabolic images;
 *			added process_pet and process_oxygen;
 *		Version 1.78 (04-Oct 1993)
 *			fix algorithm for computing SD image (image_scale);
 *			eliminated array imagesum; atlas_image is used instead with summing
 *				executed within atlas_transform instead of in a separate function;
 *			eliminated function image_sum;
 *		Version 1.80 (05-Oct 1993)
 *			output image files will now always have right brain on right
 *		Version 1.81 (08-Oct 1993) New libraries.
 *		Version 1.82 (14-Oct 1993)
 *			Symmetry correction (angles) debugged (atlas_transform and imgrot)
 *		Version 1.84 (08-Nov 1993)
 *			Check for sqrt(0) in image_scale.c
 *		Version 1.85 (05-Jan 1994)
 *			Fix bug in process_oxygen.c
 *		Version 1.91 (14-Jan 1994)
 *			OEF forced to be 0.0-1.0 (process_oxygen.c)
 *		Version 1.92 (18-Jan 1994)
 *			New libhp (bug in readimglist.c to construct sxr short names)
 *		Version 1.93 (14-Feb 1994)
 *			Correct {} is symmetry loop.
 *		Version 1.94 (22-Feb 1994)
 *			Use getatlas_t88 in libhp.a.
 *			Set pixel_size in output file subheaders.
 *		Version 1.95 (21-Mar 1994)
 *			Rebuild with new libpetarc to recognize wobbled images with filter cutoff.
 *		Version 1.96 (30-Mar 1994)
 *			add correct plane_separation to main_header
 *		Version 1.97 (12-Apr 1994)
 *			added nmask to image_scale to allow selective masking of output image to n subjects
 *		Version 1.99 (28-Apr 1994)
 *			added first_slice, last_slice to getprms_t88 and atlas_transform
 *		Version 2.00 (28-Apr 1994)
 *			last_slice cannot be greater than number of slices
 *		Version 2.1 (29-Apr 1994)
 *			fixed bug in atlas_transform when using PET for scaling y_dim
 *		Version 3.0 (11-May 1994)
 *			fixed major bug in atlas_transform!
 *		Version 3.1 (18-May 1994)
 *			changed Id to Header and added ifdef to allow proper compiling on HPs
 *		Version 3.2 (24-May 1994)
 *			fixed nmask option in image_scale.  Ran t88mean.c through indent.
 *		Version 3.3 (24-May 1994)
 *			fixed nmask again (changed > nmask to >= nmask in image_scale.c)
 *		Version 3.4 (13-Sep 1994)
 *			allow the origin and number of slices in the output images to vary:
 *			added zorigin and zmax as parameters (getprms_t88)
 *			changed references to ZATL to atlas.nz (t88mean, atlas_transform)
 *		Version 3.5 (03-Oct 1994)
 *			Changed atlas_transform to compute the x-scaling factor from the nearest slice
 *			to the AC-PC plane if no slice contains the AC-PC plane;
 *			The transformation matrix (and scaling factors) are written to the rec file;
 *			Change calling parameters to sxr_center;
 *			Separate functions atlas_scalers and matrix_transform;
 *		Version 3.6 (03-Oct 1994)
 *			Set EOT to 0 on exit.
 *		Version 3.7 (11-Oct 1994)
 *			Fix bug in creating filenames (sd and n) when output file has no "."
 *		Version 3.8 (27-Dec 1994)
 *			Add free mask to imgrot.c
 *		Version 3.?	(23-Aug 1995)
 *			Add atlas parameter (with options t88 or none)
 *	===============================================================================
 */
static char     rcsid[] = "$Header: /home/npggw/tom/src/t88mean/RCS/t88mean.c,v 3.48 2004/02/20 16:15:35 tom Exp tom $";

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <math.h>				 /* M_PI */
#include <image.h>
#include <libimage.h>
#include <nrutil.h>
#include <libnrimg.h>			 /* rdtensor, wrtensor */
#include <imgutil.h>			 /* IMAGE_LIST_DATA, MAXPATH, SXR_DATA, HEADER_DATA */
#include <atlas.h>				 /* BRAIN_ATLAS */

#define  EARLY_EXIT	3			 /* exit status to delete the rec file */
#define  IMGLIST_SIZE 2000		 /* max size of imglist */

/*	----------------------------
 *	Function:	t88mean
 *	----------------------------
 */
int main (argc, argv)
	int             argc;
	char           *argv[];
{
	int             atlas_scalers ();
	int             getatlas_none ();
	int             getprms_t88 ();
	int             get_input_lists ();
	int             matrix_transform ();
	void            adjust_markers ();
	void            atlas_transform ();
	void            image_scale ();
	void            noatlas_transform ();
	void            sxr_xcenter ();

	ImageFile      *file1;
	Index           indx;
	FILE           *recfp;			 /* rec file */
	SXR_DATA       *sxr;			 /* xray & PET measurements */
	BRAIN_ATLAS     atlas;			 /* brain atlas definition */
	PARAMETER_DATA  prm;			 /* processing parameters */
	IMAGE_LIST_DATA *imglist;		 /* list of images to process */
	HEADER_DATA    *hdr;			 /* hdr structure */
	float         **map;			 /* conversion matrix Atlas -> PET   */

	char           *lstfile;
	char           *prmfile;
	char           *outfile;
	char           *recfile;
	char            maskfile[MAXPATH];
	char            sdfile[MAXPATH];
	char            wtfile[MAXPATH];
	char           *ext;
	char            runstamp[40];		 /* version, date and userid info */
	char           *today;
	char           *userid;
	char           *activation_scan;
	char           *control_scan;
	char           *flow_scan1;
	char           *vol_scan1;
	char           *flow_scan2;
	char           *vol_scan2;
	int             lstsize = 0;
	int             filtmode;
	int             imgmode;
	int             i, j, k, m;		 /* array indices */
	float           scaler;			 /* scale individual PET images */
	float           pixel_size = 0.;
	float           plane_separation = 0.;
	float           default_pixel_size;
	float           default_plane_separation;
	float           angle[3];
	float           center[3];
	float           scale[3];
	double          weight;
	double          maxwt;
	int             scanner;		 /* 6, 953, 961 */
	long            odim[3];		 /* dimensions of output atlas images */
	long            idim[3];		 /* dimensions of input images */
	float        ***image1;			 /* first (activation) PET image */
	float        ***image2;			 /* second (control) PET image */
	float        ***image3;			 /* flow PET image for oxygen processing */
	float        ***image4;			 /* volume PET image for oxygen processing */
	float        ***sdimage;		 /* SD image */
	float        ***mask;			 /* mask for PET images */
	float        ***atlas_image;	 /* atlas-transformed image */
	float        ***totwt;			 /* total of weighted images contributing to each
						  * element of atlas_image */
	char         ***scan;			 /* scan filenames */
	char          **sxrfile;		 /* sxr filenames */

	int				use_mask = 0;
	int				compute_sd = 0;
	int				paired_images = 0;
	int				oxygen_mode = 0;

/*
 *	parameters read from prm file
 */

	float           smg_norm;
	float           smg_mskpct;
	int             first_slice;
	int             last_slice;
	int             zorigin;	 	 /* atlas.z0 from prm file */
	int             zmax;			 /* atlas.nz from prm file */
	int             processing;
	char            smg_mode[10] = "";
	char            smg_divisor[10] = "";
	char            smg_included[10] = "";
	char            smg_mask[10] = "";
	char            smg_compute[10] = "";
	char            smg_sdimage[10] = "";
	char            smg_nimage[10] = "";
	char            smg_symmetry[10] = "";
	char            atlas_name[10] = "";

	filtmode = IMGFILTER_MODE;
	maxwt = 0;
	prm.processing = 0;

/*
 *	Read command line arguments and initialize filenames.
 *	---------------------------------------------------
 */
	printf ("Copyright 1991-2004, Washington University\n");
	printf ("All rights reserved. Unauthorized reproduction prohibited.\n");
	if (argc != 13) {
		printf ("Usage: t88mean prmlist imglist outfile recfile date\n");
		return(ERROR);
	}
	prmfile = argv[1];
	lstfile = argv[2];
	outfile = argv[3];
	recfile = argv[4];
	sprintf (runstamp, "%s %s %s %s %s %s", argv[5], argv[6], argv[7], argv[9], argv[10], argv[11]);
	today = argv[11];
	userid = argv[12];

	strcpy (sdfile, outfile);
	ext = strrchr (sdfile, '.');
	if (ext != NULL)
		strcpy (ext, ".sd");
	else
		strcat (sdfile, ".sd");

	strcpy (wtfile, outfile);
	ext = strrchr (wtfile, '.');
	if (ext != NULL)
		strcpy (ext, ".n");
	else
		strcat (wtfile, ".n");

	recfp = fopen (recfile, "a");
	if (recfp == (FILE *) NULL) {
		fprintf (stderr, "ERROR [t88mean]: cannot open %s\n", recfile);
		return(ERROR);
	}
	indx.frm = 1;
	indx.pln = 1;
	indx.gate = 1;
	indx.data = 0;
	indx.bed = 0;

/*
 *	Read imagelist into structure imglist
 *	----------------------------------------
 */

	imglist = (IMAGE_LIST_DATA *) malloc (IMGLIST_SIZE * sizeof (IMAGE_LIST_DATA));
	if (imglist == NULL)
		return (ERROR);
	if (readimglist (lstfile, imglist, &lstsize) == ERROR) {
		fprintf (stderr, "ERROR [t88mean]: reading %s\n", lstfile);
		return(ERROR);
	}
	if (lstsize > IMGLIST_SIZE) {
		fprintf (stderr, "ERROR [t88mean]: imglist size %d > %d\n", lstsize, IMGLIST_SIZE);
		return(ERROR);
	}
/*
 *	Read parameters into structure prm
 *	---------------------------------------------
 */

	scan = (char ***) malloc (lstsize * sizeof (char **));
	if (scan == NULL)
		return (ERROR);
	for (i = 0; i < lstsize; i++) {
		scan[i] = (char **) malloc (6 * sizeof (char *));
		if (scan[i] == NULL)
			return (ERROR);
		for (j = 0; j < 6; j++) {
			scan[i][j] = (char *) malloc (sizeof (MAXPATH));
			if (scan[i][j] == NULL)
				return (ERROR);
		}
	}
	sxrfile = (char **) malloc (lstsize * sizeof (char *));
	if (sxrfile == NULL)
		return (ERROR);
	for (i = 0; i < lstsize; i++) {
		sxrfile[i] = (char *) malloc (sizeof (MAXPATH));
		if (sxrfile[i] == NULL)
			return (ERROR);
	}

	if (getprms_t88 (prmfile, &smg_norm, smg_divisor, smg_included, &processing, smg_mode, smg_mask,
	     smg_sdimage, smg_nimage, smg_symmetry, &smg_mskpct, smg_compute, &default_pixel_size,
			 &default_plane_separation, &first_slice, &last_slice, &zorigin, &zmax,
			 atlas_name) == ERROR) {
		fprintf (stderr, "ERROR [t88mean]: reading parameter file %s\n", prmfile);
		return(ERROR);
	}
	if (strcmp (smg_mode, "paired") == 0)
		paired_images = 1;

	if (processing == PROC_OEF || processing == PROC_CMRO2) {
		oxygen_mode = 1;
		imgmode = MULTITRACER_IMAGE_MODE;
	} else if (strcmp (smg_mode, "diff") == 0)
		imgmode = DIFIMAGE_MODE;
	else
		imgmode = STDIMAGE_MODE;

/*
 * Get full names of activation, control and .sxr files.
 */

	if (get_input_lists (prmfile, lstsize, imgmode, filtmode, scan, sxrfile, &prm, imglist) == ERROR) {
		fprintf (stderr, "ERROR [t88mean]: building image names\n");
		return(ERROR);
	}

/*
 *	Get atlas values and allocate memory
 *	------------------------------------
 */

	if (strcmp (atlas_name, "t88") == 0) {
		getatlas_t88 (&atlas);
		if (zorigin > 0)
			atlas.z0 = zorigin;
		if (zmax > 0)
			atlas.nz = zmax;
	} else {
		activation_scan = scan[0][0];
		if (getatlas_none (&atlas, activation_scan) != 0)
			return (ERROR);
		if (default_pixel_size > 0)
			atlas.pixel_size = default_pixel_size;
		if (default_plane_separation > 0)
			atlas.slice_separation = default_plane_separation;
	}

	odim[0] = (long) atlas.nx;
	odim[1] = (long) atlas.ny;
	odim[2] = (long) atlas.nz;
	if ((atlas_image = f3tensor (1, odim[2], 1, odim[1], 1, odim[0])) == NULL) {
		fprintf (stderr, "ERROR [t88mean]: Cannot malloc image for atlas_image\n");
		return(ERROR);
	}
	if ((totwt = f3tensor (1, odim[2], 1, odim[1], 1, odim[0])) == NULL) {
		fprintf (stderr, "ERROR [t88mean]: Cannot malloc image for totwt\n");
		return(ERROR);
	}
	hdr = (HEADER_DATA *) malloc (sizeof (HEADER_DATA));
	if (hdr == NULL)
		return (ERROR);
	map = matrix (1, 4, 1, 4);

/*
 *	LOOP for each image or image-pair in the list:
 *	---------------------------------------------
 */

	for (i = 0; i < lstsize; ++i) {
		activation_scan = scan[i][0];
		if (oxygen_mode == 1) {
			flow_scan1 = scan[i][1];
			vol_scan1 = scan[i][2];
			if (paired_images == 1) {
				control_scan = scan[i][3];
				flow_scan2 = scan[i][4];
				vol_scan2 = scan[i][5];
			}
		} else if (paired_images == 1) {
			control_scan = scan[i][1];
		}
/*
 *	First image, first time -- get scanner and dimensions; zero arrays (atlas_image, totwt, sdimage)
 *	------------------------------------------------------------------
 */
		if (i == 0) {
			file1 = make_imgfile (activation_scan);
            if (file1 == NULL) {
                fprintf (stderr, "ERROR [t88mean]: making file\n");
                return (ERROR);
            }
            if (get_imgh (file1, &indx) == ERROR) {
                fprintf (stderr, "ERROR [t88mean]: Cannot open %s\n", activation_scan);
                return (ERROR);
            }

			scanner = file1->mh->scanner_type;
			if (scanner != 6 && scanner != 953 && scanner != 961 && scanner != 0) {
				fprintf (stderr, "ERROR [t88mean]: file is not a recognized PET image\n");
				return(ERROR);
			}
			idim[0] = odim[0];
			idim[1] = odim[1];
			idim[2] = (long) file1->sh->dim3;
			pixel_size = file1->sh->sample_size_1;
			plane_separation = file1->sh->sample_size_3;

			if (default_pixel_size > 0)
				pixel_size = default_pixel_size;
			if (default_plane_separation > 0)
				plane_separation = default_plane_separation;

			if (strcmp (smg_mask, "yes") == 0)
				use_mask = 1;
			if (strcmp (smg_sdimage, "yes") == 0) {
				compute_sd = 1;
				if ((sdimage = f3tensor (1, odim[2], 1, odim[1], 1, odim[0])) == NULL) {
					fprintf (stderr, "ERROR [t88mean]: Cannot malloc image for sdimage\n");
					return(ERROR);
				}
			}
			for (m = 1; m <= odim[2]; ++m) {
				for (j = 1; j <= odim[1]; ++j) {
					for (k = 1; k <= odim[0]; ++k) {
						atlas_image[m][j][k] = 0.;
						totwt[m][j][k] = 0.;
						if (compute_sd == 1)
							sdimage[m][j][k] = 0.;
					}
				}
			}
		}
/*
 *	Read and process First (activation) image
 *	-----------------------------------------
 */
		if (oxygen_mode == 1) {
			if ((image3 = rdtensor1 (flow_scan1, odim)) == NULL) {
				fprintf (stderr, "ERROR [t88mean] reading %s\n", flow_scan1);
				return(ERROR);
			}
			recout (recfp, flow_scan1);
			printf ("Flow = %s\n", flow_scan1);

			if ((image4 = rdtensor1 (vol_scan1, odim)) == NULL) {
				fprintf (stderr, "ERROR [t88mean]: Cannot open %s\n", vol_scan1);
				return (ERROR);
			}
			recout (recfp, vol_scan1);
			printf ("Vol  = %s\n", vol_scan1);
		}
		if ((image1 = rdtensor (file1, indx, odim)) == NULL) {
			fprintf (stderr, "ERROR [t88mean] reading %s\n", activation_scan);
			return(ERROR);
		}
		close_imgfile (file1);
		recout (recfp, activation_scan);
		printf ("Activation  = %s\n", activation_scan);

		if (strcmp (smg_compute, "no") != 0) {
			if (imgmode == DIFIMAGE_MODE)
				scaler = 1.0;
			else if (smg_norm == 0) {
				fprintf (stderr, "ERROR [t88mean]: Parameter smg_norm in parameter list is 0\n");
				return(ERROR);
			} else if (imglist[i].mean1 == 0) {
				fprintf (stderr, "ERROR [t88mean]: Normalization factor in image list is 0\n");
				return(ERROR);
			} else
				scaler = smg_norm / imglist[i].mean1;
			printf ("%f  %f\n", smg_norm, imglist[i].mean1);
			printf ("Scale %s by %f\n", activation_scan, scaler);
			fprintf (recfp, "Scale %s by %f\n", activation_scan, scaler);
		} else
			scaler = 1.0;

		if (oxygen_mode == 1) {
			if (processOxygen (image1, image3, image4, idim, scaler,
			    processing, activation_scan, flow_scan1, vol_scan1, recfp, hdr) > 0) {
				fprintf (stderr, "ERROR [t88mean] processing %s %s %s\n", activation_scan,
					 flow_scan1, vol_scan1);
				return(ERROR);
			}
			if (image3 != NULL)
				free_f3tensor (image3, 1, idim[2], 1, idim[1], 1, idim[0]);
			if (image4 != NULL)
				free_f3tensor (image4, 1, idim[2], 1, idim[1], 1, idim[0]);
		} else if (processPET (image1, idim, scaler, processing,
				       activation_scan, recfp, hdr) > 0) {
			fprintf (stderr, "ERROR [t88mean] processing %s\n", activation_scan);
			return(ERROR);
		}
/*
 *	Read and process second (control) image (for paired lists)
 *	----------------------------------------------------------
 */

		if (paired_images == 1) {
			if (oxygen_mode == 1) {
				if ((image3 = rdtensor1 (flow_scan2, odim)) == NULL) {
					fprintf (stderr, "ERROR [t88mean] reading %s\n", flow_scan2);
					return(ERROR);
				}
				recout (recfp, flow_scan2);
				printf ("Flow = %s\n", flow_scan2);

				if ((image4 = rdtensor1 (vol_scan2, odim)) == NULL) {
					fprintf (stderr, "ERROR [t88mean] reading %s\n", vol_scan2);
					return(ERROR);
				}
				recout (recfp, vol_scan2);
				printf ("Vol  = %s\n", vol_scan2);
			}
			if ((image2 = rdtensor1 (control_scan, odim)) == NULL) {
				fprintf (stderr, "ERROR [t88mean] reading %s\n", control_scan);
				return(ERROR);
			}
			recout (recfp, control_scan);
			printf ("Control  = %s\n", control_scan);

			if (imgmode == DIFIMAGE_MODE)
				scaler = 1.0;
			else if (imglist[i].mean2 == 0) {
				fprintf (stderr, "ERROR [t88mean]: Normalization factor in image list is 0\n");
				return(ERROR);
			} else
				scaler = smg_norm / imglist[i].mean2;
			fprintf (recfp, "Scale %s by %f\n", control_scan, scaler);

			if (oxygen_mode == 1) {
				if (processOxygen (image2, image3, image4, idim, scaler,
				processing, control_scan, flow_scan2, vol_scan2, recfp, hdr) > 0) {
					fprintf (stderr, "ERROR [t88mean] processing %s %s %s\n", control_scan,
						 flow_scan2, vol_scan2);
					return(ERROR);
				}
				free_f3tensor (image3, 1, idim[2], 1, idim[1], 1, idim[0]);
				free_f3tensor (image4, 1, idim[2], 1, idim[1], 1, idim[0]);
			} else if (processPET (image2, idim, scaler, processing,
					       control_scan, recfp, hdr) > 0) {
				fprintf (stderr, "ERROR [t88mean] processing %s\n", control_scan);
				return(ERROR);
			}
		}
/*
 *	Read the mask file (optional)
 *	-----------------------------
 */

		if (use_mask == 1) {
			strcpy (maskfile, activation_scan);
			ext = strrchr (maskfile, '.');
			if (ext != NULL)
				strcpy (ext, ".msk");
			else
				strcat (maskfile, ".msk");
			if ((mask = rdtensor1 (maskfile, odim)) == NULL) {
				fprintf (stderr, "ERROR [t88mean] reading %s\n", maskfile);
				return(ERROR);
			}
			recout (recfp, maskfile);
		}
		if (strcmp (atlas_name, "none") == 0) {
			if (paired_images == 1)
				subtensors (image1, image2, idim);
			weight = imglist[i].weight;
			maxwt += weight;
			noatlas_transform (image1, idim, atlas_image, odim, sdimage, weight, totwt, mask,
					   use_mask, compute_sd);

		} else {
/*
 *	Read sxr file information
 *	-------------------------
 */

			sxr = getsxr (sxrfile[i]);
			fprintf (recfp, "%s\n", sxrfile[i]);
			adjust_markers (*sxr);	 /* Correct sxr->dz to specific geometry */
			sxr->pixel_size = pixel_size;	/* Correct for error in sxr file for PETT
							 * VI */
			sxr->slice_separation = plane_separation;

/*
 *	Get y,z origin (pixel indices for Numerical Recipes' arrays) and x-angle (radians) from sxr.
 *	Note: for this first step, the y-origin is the bisection of the ac-pc line.
 *		The shift from the brain origin to the atlas origin (anterior shift)
 *		is performed in atlas_transform in atlas space.
 */

			center[0] = 0;
			center[1] = (sxr->apcenter) + (sxr->dap * sxr->magnification_factor / sxr->pixel_size);
			center[2] = (sxr->reference_slice) - (sxr->dz / sxr->slice_separation);
			angle[0] = -M_PI * sxr->degx / 180;
			angle[1] = 0;
			angle[2] = 0;
			scale[0] = 0;
			scale[1] = 0;
			scale[2] = 0;

/*
 *	Get translation values (center):
 *		If smg_symmetry, compute y and z-angles and use x center-of-mass for x-origin
 *			(for paired images, use the control scan for symmetry)
 *		Otherwise, get x-origin from mean center of PET slices
 */

			if (strcmp (smg_symmetry, "yes") == 0) {
				fprintf (recfp, "Symmetry operation is no longer supported\n");
				fprintf (stdout, "Symmetry operation is no longer supported\n");
			} else
				sxr_xcenter (*sxr, center);

/*
 *	If smg_compute = no, then set sxr->xscale to 0 and recompute it
 */

			if (strcmp (smg_compute, "no") == 0)
				sxr->xscale = 0;

/*
 *  Get the transformation scalers
 */

			if (atlas_scalers (*sxr, atlas, center, angle, scale, &last_slice) == ERROR) {
				fprintf (stderr, "ERROR [t88mean]: PET does not overlap Atlas space.\n");
				return(ERROR);
			} else {
				fprintf (recfp, "Center: %9.3f %9.3f %9.3f   pixels\n", center[0], center[1], center[2]);
				fprintf (recfp, "Angle:  %9.3f %9.3f %9.3f   radians\n", angle[0], angle[1], angle[2]);
				fprintf (recfp, "Scale:  %9.3f %9.3f %9.3f\n", scale[0], scale[1], scale[2]);
				fprintf (stdout, "Center: %9.3f %9.3f %9.3f   pixels\n", center[0], center[1], center[2]);
				fprintf (stdout, "Angle:  %9.3f %9.3f %9.3f   radians\n", angle[0], angle[1], angle[2]);
				fprintf (stdout, "Scale:  %9.3f %9.3f %9.3f\n", scale[0], scale[1], scale[2]);
			}
/*
 *	If smg_compute = no, then exit
 */

			if (strcmp (smg_compute, "no") == 0) {
				fprintf (stdout, "-------------------------------------\n");
				fprintf (stdout, "X-SCALE =%8.3f\n", scale[0]);
				return(EARLY_EXIT);
			}
/*
 *  Build the transformation matrix MAP
 */

			if ((matrix_transform (*sxr, atlas, center, angle, scale, map)) == ERROR)
				return(ERROR);

			fprintf (recfp, "Matrix Transform:  Matrix*Atlas -> PET\n");
			fprintf (recfp, "Matrix: %9.3f %9.3f %9.3f %9.3f\n", map[1][1], map[1][2], map[1][3], map[1][4]);
			fprintf (recfp, "Matrix: %9.3f %9.3f %9.3f %9.3f\n", map[2][1], map[2][2], map[2][3], map[2][4]);
			fprintf (recfp, "Matrix: %9.3f %9.3f %9.3f %9.3f\n", map[3][1], map[3][2], map[3][3], map[3][4]);
			fprintf (recfp, "Matrix: %9.3f %9.3f %9.3f %9.3f\n", map[4][1], map[4][2], map[4][3], map[4][4]);

/*
 *	Subtract, transform to atlas space, and sum
 */

			if (paired_images == 1)
				subtensors (image1, image2, idim);
			weight = imglist[i].weight;
			maxwt += weight;
			atlas_transform (image1, idim, atlas_image, odim, sdimage, weight, totwt,
					 mask, map, use_mask, compute_sd, first_slice, last_slice);
			if (paired_images == 1)
				free_f3tensor (image2, 1, idim[2], 1, idim[1], 1, idim[0]);
		}
		if (strcmp (atlas_name, "none") != 0) 
			freesxr (sxr);
		free_f3tensor (image1, 1, idim[2], 1, idim[1], 1, idim[0]);
		if (use_mask == 1)
			free_f3tensor (mask, 1, idim[2], 1, idim[1], 1, idim[0]);
	}

/*	End LOOP
 *	--------
 *
 *	Scale final atlas image and mask pixels
 *	---------------------------------------
 */
	image_scale (atlas_image, totwt, odim, maxwt, smg_divisor, smg_included,
		     compute_sd, sdimage);

	scaler = 1.0;
	if (prm.processing == PROC_CBF)
		scaler = SCALE_CBF;
	else if (prm.processing == PROC_CBV)
		scaler = SCALE_CBV;
	else if (prm.processing == PROC_OEF)
		scaler = SCALE_OEF;
	else if (prm.processing == PROC_CMRO2)
		scaler = SCALE_CMRO2;
	if (scaler != 1.0) {
		for (i = 1; i <= odim[2]; ++i) {
			for (j = 1; j <= odim[1]; ++j) {
				for (k = 1; k <= odim[0]; ++k) {
					atlas_image[i][j][k] *= scaler;
				}
			}
		}
	}
/*
 *	Write Summed Image to outfile
 *	-----------------------------
 */
	strcpy (file1->name, outfile);
	strcpy (file1->mode, "w");
	file1->mh->nplane = odim[2];
	file1->mh->slicesep = atlas.slice_separation;
	file1->mh->zorigin = atlas.z0;
	file1->mh->orientation = 0;
	file1->sh->sample_size_1 = atlas.pixel_size;
	file1->sh->sample_size_2 = atlas.pixel_size;
	file1->sh->sample_size_3 = atlas.slice_separation;
	file1->sh->dim1 = (short) odim[0];
	file1->sh->dim2 = (short) odim[1];
	file1->sh->dim3 = (short) odim[2];
	(void) save_rcs (file1, rcsid, runstamp);
	if (wrtensor (file1, indx, atlas_image) == ERROR) {
		fprintf (stderr, "ERROR [t88mean] writing %s\n", outfile);
		return(ERROR);
	}
/*
 *	Write HDR file
 *	--------------
 */
	if (processing != PROC_NONE) {
		if (writehdr (hdr, outfile, userid, today, processing, (short) atlas.nz) == ERROR) {
			fprintf (stderr, "ERROR [t88mean] writing hdr file\n");
		}
	}
/*
 *	Write SD Image to sdfile
 *	------------------------
 */
	if (compute_sd == 1) {
		strcpy (file1->name, sdfile);
		strcpy (file1->mode, "w");
		if (wrtensor (file1, indx, sdimage) == ERROR) {
			fprintf (stderr, "ERROR [t88mean] writing %s\n", sdfile);
			return(ERROR);
		}
	}
/*
 *	Write Total Weight Image to wtfile
 *	----------------------------------
 */
	if (strcmp (smg_nimage, "yes") == 0) {
		strcpy (file1->name, wtfile);
		strcpy (file1->mode, "w");
		if (wrtensor (file1, indx, totwt) == ERROR) {
			fprintf (stderr, "ERROR [t88mean] writing %s\n", wtfile);
			return(ERROR);
		}
	}

/*	Free memory	*/

	(void) fclose (recfp);
	if (sdimage != NULL)
		free_f3tensor (sdimage, 1, odim[2], 1, odim[1], 1, odim[0]);
	free_f3tensor (totwt, 1, odim[2], 1, odim[1], 1, odim[0]);
	free_f3tensor (atlas_image, 1, odim[2], 1, odim[1], 1, odim[0]);
	free (atlas.xdim);
	free (atlas.ydim);
	free (imglist);
	for (i = 0; i < lstsize; i++) {
		for (j = 0; j < 6; j++)
			free (scan[i][j]);
		free (scan[i]);
	}
	free (scan);
	for (i = 0; i < lstsize; i++)
		free (sxrfile[i]);
	free (sxrfile);
	free (hdr);
	free_imgfile (file1);
	return (0);
}
@


3.48
log
@Feb 2004
@
text
@d2 3
d124 1
a124 1
 * changed $Id: t88mean.c,v 3.47 2000/09/06 19:14:17 tom Exp tom $ to $Header: /home/npggw/tom/src/t88mean/RCS/t88mean.c,v 3.47 2000/09/06 19:14:17 tom Exp tom $
d345 1
a345 1
static char     rcsid[] = "$Header: /home/npggw/tom/src/t88mean/RCS/t88mean.c,v 3.47 2000/09/06 19:14:17 tom Exp tom $";
d366 1
a366 1
main (argc, argv)
d585 1
a585 1
	if (strcmp (atlas_name, "t88") != 0) {
@


3.47
log
@strcpy filename
@
text
@d2 3
d121 1
a121 1
 * changed $Id: t88mean.c,v 3.46 2000/01/25 16:25:33 tom Exp tom $ to $Header: /home/npggw/tom/src/t88mean/RCS/t88mean.c,v 3.46 2000/01/25 16:25:33 tom Exp tom $
d224 1
a224 1
 *	Date:			24-Jun-93
d252 2
a253 2
 *		Version 1.1 (24-Jun-93) was a replication of the current hd6mean (SARP) algorithm.
 *		Version 1.4 (11-Aug-93) read prm and lst files; paired image processing.
d257 1
a257 1
 *		Version 1.5 (19-Aug-93)
d263 1
a263 1
 *		Version 1.6 (20-Aug-93)
d267 1
a267 1
 *		Version 1.7 (24-Aug-93)
d271 1
a271 1
 *		Version 1.75 (27-Aug-93)
d273 1
a273 1
 *		Version 1.76 (28-Sep-93)
d279 1
a279 1
 *		Version 1.78 (04-Oct-93)
d284 1
a284 1
 *		Version 1.80 (05-Oct-93)
d286 2
a287 2
 *		Version 1.81 (08-Oct-93) New libraries.
 *		Version 1.82 (14-Oct-93)
d289 1
a289 1
 *		Version 1.84 (08-Nov-93)
d291 1
a291 1
 *		Version 1.85 (05-Jan-94)
d293 1
a293 1
 *		Version 1.91 (14-Jan-94)
d295 1
a295 1
 *		Version 1.92 (18-Jan-94)
d297 1
a297 1
 *		Version 1.93 (14-Feb-94)
d299 1
a299 1
 *		Version 1.94 (22-Feb-94)
d302 1
a302 1
 *		Version 1.95 (21-Mar-94)
d304 1
a304 1
 *		Version 1.96 (30-Mar-94)
d306 1
a306 1
 *		Version 1.97 (12-Apr-94)
d308 1
a308 1
 *		Version 1.99 (28-Apr-94)
d310 1
a310 1
 *		Version 2.00 (28-Apr-94)
d312 1
a312 1
 *		Version 2.1 (29-Apr-94)
d314 1
a314 1
 *		Version 3.0 (11-May-94)
d316 1
a316 1
 *		Version 3.1 (18-May-94)
d318 1
a318 1
 *		Version 3.2 (24-May-94)
d320 1
a320 1
 *		Version 3.3 (24-May-94)
d322 1
a322 1
 *		Version 3.4 (13-Sep-94)
d326 1
a326 1
 *		Version 3.5 (03-Oct-94)
d332 1
a332 1
 *		Version 3.6 (03-Oct-94)
d334 1
a334 1
 *		Version 3.7 (11-Oct-94)
d336 1
a336 1
 *		Version 3.8 (27-Dec-94)
d338 1
a338 1
 *		Version 3.?	(23-Aug-95)
d342 1
a342 1
static char     rcsid[] = "$Header: /home/npggw/tom/src/t88mean/RCS/t88mean.c,v 3.46 2000/01/25 16:25:33 tom Exp tom $";
d368 1
a373 1
	void            getatlas_none ();
d378 1
a378 1
	ImageFile      *file;
a387 4
	BOOLEAN         use_mask = FALSE;
	BOOLEAN         compute_sd = FALSE;
	BOOLEAN         paired_images = FALSE;
	BOOLEAN         oxygen_mode = FALSE;
d434 5
d468 1
a468 1
	printf ("Copyright 1991-1996, Washington University\n");
d513 2
a514 1

d529 2
d533 3
a535 1
		for (j = 0; j < 6; j++)
d537 3
d542 3
a544 1
	for (i = 0; i < lstsize; i++)
d546 3
d582 1
a582 1
	if (!(strcmp (atlas_name, "t88"))) {
d590 2
a591 1
		getatlas_none (&atlas, activation_scan);
d610 2
d621 1
a621 1
		if (oxygen_mode) {
d624 1
a624 1
			if (paired_images) {
d629 1
a629 1
		} else if (paired_images) {
d637 11
a647 26
			file = make_imgfile (activation_scan);
			if (open_imgfile (file) == ERROR) {
				fprintf (stderr, "ERROR [t88mean]: Cannot open %s\n", activation_scan);
				return (ERROR);
			}
			if (get_mh (file) == ERROR) {
				fprintf (stderr, "ERROR [t88mean]: Cannot get MainHeader from %s\n", activation_scan);
				return (ERROR);
			}
			if (existimgfrm (file, &indx) == ERROR) {
				if (indx.frm == 1) {
					indx.frm = 2;
					if (existimgfrm (file, &indx) == ERROR) {
						fprintf (stderr, "ERROR [t88mean]: cannot find %s frame 1 or 2\n", activation_scan);
						return (ERROR);
					}
				} else {
					fprintf (stderr, "ERROR [t88mean]: cannot find %s frame %d\n", activation_scan, indx.frm);
					return (ERROR);
				}
			}
			if (get_sh (file, &indx) == ERROR) {
				fprintf (stderr, "ERROR [t88mean]: Cannot read file subheader in %s\n", activation_scan);
				return (ERROR);
			}
			scanner = file->mh->scanner_type;
d654 3
a656 4
			idim[2] = (long) file->sh->dim3;
			pixel_size = file->sh->sample_size_1;
			plane_separation = file->sh->sample_size_3;
			close_imgfile (file);
d666 1
a666 1
				compute_sd = TRUE;
d671 1
a671 2
			} else
				sdimage = (float ***) NULL;
d677 1
a677 1
						if (compute_sd)
d687 2
a688 2
		if (oxygen_mode) {
			if ((image3 = rdtensor (flow_scan1, indx, odim)) == NULL) {
d695 1
a695 1
			if ((image4 = rdtensor (vol_scan1, indx, odim)) == NULL) {
d702 1
a702 1
		if ((image1 = rdtensor (activation_scan, indx, odim)) == NULL) {
d706 1
d727 1
a727 1
		if (oxygen_mode) {
d734 4
a737 2
			free_f3tensor (image3, 1, idim[2], 1, idim[1], 1, idim[0]);
			free_f3tensor (image4, 1, idim[2], 1, idim[1], 1, idim[0]);
d748 3
a750 3
		if (paired_images) {
			if (oxygen_mode) {
				if ((image3 = rdtensor (flow_scan2, indx, odim)) == NULL) {
d757 1
a757 1
				if ((image4 = rdtensor (vol_scan2, indx, odim)) == NULL) {
d764 1
a764 1
			if ((image2 = rdtensor (control_scan, indx, odim)) == NULL) {
d780 1
a780 1
			if (oxygen_mode) {
d800 1
a800 1
		if (use_mask) {
d807 1
a807 1
			if ((mask = rdtensor (maskfile, indx, odim)) == NULL) {
d814 1
a814 1
			if (paired_images)
d829 1
a829 1
			adjust_markers (sxr);	 /* Correct sxr->dz to specific geometry */
d862 1
a862 1
				sxr_xcenter (sxr, center);
d875 1
a875 1
			if (atlas_scalers (sxr, atlas, center, angle, scale, &last_slice) == ERROR) {
d899 1
a899 1
			if ((matrix_transform (sxr, atlas, center, angle, scale, map)) == ERROR)
d912 1
a912 1
			if (paired_images)
d918 1
a918 1
			if (paired_images)
d924 1
a924 1
		if (use_mask)
d959 14
a972 14
	strcpy (file->name, outfile);
	strcpy (file->mode, "w");
	file->mh->nplane = odim[2];
	file->mh->slicesep = atlas.slice_separation;
	file->mh->zorigin = atlas.z0;
	file->mh->orientation = 0;
	file->sh->sample_size_1 = atlas.pixel_size;
	file->sh->sample_size_2 = atlas.pixel_size;
	file->sh->sample_size_3 = atlas.slice_separation;
	file->sh->dim1 = (short) odim[0];
	file->sh->dim2 = (short) odim[1];
	file->sh->dim3 = (short) odim[2];
	save_rcs (file, rcsid, runstamp);
	if (wrtensor (file, indx, atlas_image) == ERROR) {
d989 4
a992 4
	if (compute_sd) {
		strcpy (file->name, sdfile);
		strcpy (file->mode, "w");
		if (wrtensor (file, indx, sdimage) == ERROR) {
d1002 3
a1004 3
		strcpy (file->name, wtfile);
		strcpy (file->mode, "w");
		if (wrtensor (file, indx, totwt) == ERROR) {
d1009 5
a1013 5
/*
 *	Free memory
 *	-----------
 */
	if (compute_sd)
d1030 1
a1030 2
	free_imgfile (file);
	fclose (recfp);
@


3.46
log
@rebuild due to puzzling reversal in left-right orientation
@
text
@d2 3
d118 1
a118 1
 * changed $Id: t88mean.c,v 3.45 1999/12/17 16:06:32 tom Exp tom $ to $Header: /home/npggw/tom/src/t88mean/RCS/t88mean.c,v 3.45 1999/12/17 16:06:32 tom Exp tom $
d339 1
a339 1
static char     rcsid[] = "$Header: /home/npggw/tom/src/t88mean/RCS/t88mean.c,v 3.45 1999/12/17 16:06:32 tom Exp tom $";
d953 1
a953 1
	file->name = outfile;
d984 1
a984 1
		file->name = sdfile;
d996 1
a996 1
		file->name = wtfile;
@


3.45
log
@lint cleaning
@
text
@d2 3
d115 1
a115 1
 * changed $Id: t88mean.c,v 3.44 1999/10/12 13:26:52 tom Exp tom $ to $Header: /home/npggw/tom/src/t88mean/RCS/t88mean.c,v 3.44 1999/10/12 13:26:52 tom Exp tom $
d336 1
a336 1
static char     rcsid[] = "$Header: /home/npggw/tom/src/t88mean/RCS/t88mean.c,v 3.44 1999/10/12 13:26:52 tom Exp tom $";
@


3.44
log
@new libimgutil with updated arc path
@
text
@d2 3
d112 1
a112 1
 * changed $Id: t88mean.c,v 3.43 1998/04/27 20:24:14 tom Exp tom $ to $Header: /home/npggw/tom/src/t88mean/RCS/t88mean.c,v 3.43 1998/04/27 20:24:14 tom Exp tom $
d333 1
a333 1
static char     rcsid[] = "$Header: /home/npggw/tom/src/t88mean/RCS/t88mean.c,v 3.43 1998/04/27 20:24:14 tom Exp tom $";
a341 1
#include <nr.h>
d343 2
a344 2
#include <libnrimg.h>				 /* rdtensor, wrtensor */
#include <imgutil.h>				 /* IMAGE_LIST_DATA, MAXPATH, SXR_DATA, HEADER_DATA */
d348 1
a348 1
#define  IMGLIST_SIZE 2000			 /* max size of imglist */
d359 2
d362 1
d364 4
d379 4
a382 4
	BOOLEAN         use_mask = 0;
	BOOLEAN         compute_sd = 0;
	BOOLEAN         paired_images = 0;
	BOOLEAN         oxygen_mode = 0;
d400 1
a400 1
	int             lstsize;
d405 2
a406 2
	float           pixel_size;
	float           plane_separation;
d412 2
a413 2
	float           weight;
	float           maxwt;
d423 1
a423 1
	float        ***atlas_image;		 /* atlas-transformed image */
d437 1
a437 1
	int             zorigin;		 /* atlas.z0 from prm file */
d440 9
a448 9
	char            smg_mode[10];
	char            smg_divisor[10];
	char            smg_included[10];
	char            smg_mask[10];
	char            smg_compute[10];
	char            smg_sdimage[10];
	char            smg_nimage[10];
	char            smg_symmetry[10];
	char            atlas_name[10];
d452 1
d462 1
a462 1
		exit (ERROR);
d489 1
a489 1
		exit (ERROR);
d506 1
a506 1
		exit (ERROR);
d510 1
a510 1
		exit (ERROR);
d532 1
a532 1
		exit (ERROR);
d549 3
a551 22
	get_input_lists (prmfile, lstsize, imgmode, filtmode, scan, sxrfile, &prm, imglist);

#if DEBUG
	if (imgmode == MULTITRACER_IMAGE_MODE) {
		for (i = 0; i < lstsize; i++) {
			printf ("Set %d\n", i + 1);
			for (j = 0; j < 3; j++) {
				printf ("%s\n", scan[i][j]);
			}
			if (paired_images) {
				for (j = 3; j < 6; j++) {
					printf ("%s\n", scan[i][j]);
				}
			}
		}
	} else {
		for (i = 0; i < lstsize; i++) {
			printf ("Activation = %s\n", scan[i][0]);
			if (strcmp (smg_mode, "paired") == 0)
				printf ("Control    = %s\n", scan[i][1]);
			printf ("SXR        = %s\n", sxrfile[i]);
		}
a552 1
#endif
a567 1
		zorigin = 1;
d579 1
a579 1
		exit (ERROR);
d583 1
a583 1
		exit (ERROR);
d624 1
a624 1
						fprintf (stderr, "ERROR [t88mean]: cannot find %s frame 1 or 2\n", file);
d628 1
a628 1
					fprintf (stderr, "ERROR [t88mean]: cannot find %s frame %d\n", file, indx.frm);
d639 1
a639 1
				exit (ERROR);
d656 1
a656 1
				compute_sd = 1;
d659 1
a659 1
					exit (ERROR);
d681 1
a681 1
				exit (ERROR);
d695 1
a695 1
			exit (ERROR);
d705 1
a705 1
				exit (ERROR);
d708 1
a708 1
				exit (ERROR);
d722 1
a722 1
				exit (ERROR);
d729 1
a729 1
			exit (ERROR);
d740 1
a740 1
					exit (ERROR);
d747 1
a747 1
					exit (ERROR);
d754 1
a754 1
				exit (ERROR);
d763 1
a763 1
				exit (ERROR);
d773 1
a773 1
					exit (ERROR);
d780 1
a780 1
				exit (ERROR);
d797 1
a797 1
				exit (ERROR);
d865 1
a865 1
				exit (ERROR);
d881 1
a881 1
				exit (EARLY_EXIT);
d888 1
a888 1
				exit (ERROR);
d962 1
a962 1
		exit (ERROR);
d982 1
a982 1
			exit (ERROR);
d994 1
a994 1
			exit (ERROR);
d1020 1
a1020 1
	exit (0);
@


3.43
log
@fix bug in noatlas_transform.c
@
text
@d2 3
d109 1
a109 1
 * changed $Id: t88mean.c,v 3.42 1998/01/30 16:51:08 tom Exp $ to $Header: /home/npggw/tom/src/t88mean/RCS/t88mean.c,v 3.42 1998/01/30 16:51:08 tom Exp $
d330 1
a330 1
static char     rcsid[] = "$Header: /home/npggw/tom/src/t88mean/RCS/t88mean.c,v 3.42 1998/01/30 16:51:08 tom Exp $";
@


3.42
log
@permit reading files with names like _g285.v
@
text
@d2 3
d106 1
a106 1
 * changed $Id: t88mean.c,v 3.41 1998/01/29 16:25:00 tom Exp tom $ to $Header: /home/npggw/tom/src/t88mean/RCS/t88mean.c,v 3.41 1998/01/29 16:25:00 tom Exp tom $
d327 1
a327 1
static char     rcsid[] = "$Header: /home/npggw/tom/src/t88mean/RCS/t88mean.c,v 3.41 1998/01/29 16:25:00 tom Exp tom $";
d917 2
a918 1
		freesxr (sxr);
@


3.41
log
@modified filter_suffix in libimgutil
@
text
@d2 3
d103 1
a103 1
 * changed $Id: t88mean.c,v 3.40 1996/11/21 17:56:00 tom Exp tom $ to $Header: /home/npggw/tom/src/t88mean/RCS/t88mean.c,v 3.40 1996/11/21 17:56:00 tom Exp tom $
d324 1
a324 1
static char     rcsid[] = "$Header: /home/npggw/tom/src/t88mean/RCS/t88mean.c,v 3.40 1996/11/21 17:56:00 tom Exp tom $";
@


3.40
log
@change libimgutil (processOxygen.c) to restrict OEF to <=1.1 and CMRO2 to <= 100
@
text
@d2 3
d100 1
a100 1
 * changed $Id: t88mean.c,v 3.39 1996/11/06 17:33:23 tom Exp tom $ to $Header: /home/npggw/tom/src/t88mean/RCS/t88mean.c,v 3.39 1996/11/06 17:33:23 tom Exp tom $
d321 1
a321 1
static char     rcsid[] = "$Header: /home/npggw/tom/src/t88mean/RCS/t88mean.c,v 3.39 1996/11/06 17:33:23 tom Exp tom $";
@


3.39
log
@correct scaling of cbf and cbv images
@
text
@d2 3
d97 1
a97 1
 * changed $Id: t88mean.c,v 3.38 1996/10/16 17:18:59 tom Exp tom $ to $Header: /home/npggw/tom/src/t88mean/RCS/t88mean.c,v 3.38 1996/10/16 17:18:59 tom Exp tom $
d318 1
a318 1
static char     rcsid[] = "$Header: /home/npggw/tom/src/t88mean/RCS/t88mean.c,v 3.38 1996/10/16 17:18:59 tom Exp tom $";
@


3.38
log
@sync with Version
new libimage
@
text
@d2 4
d94 1
a94 1
 * changed $Id: t88mean.c,v 3.28 1996/10/11 14:44:17 tom Exp tom $ to $Header: /home/npggw/tom/src/t88mean/RCS/t88mean.c,v 3.28 1996/10/11 14:44:17 tom Exp tom $
d315 1
a315 1
static char     rcsid[] = "$Header: /home/npggw/tom/src/t88mean/RCS/t88mean.c,v 3.28 1996/10/11 14:44:17 tom Exp tom $";
d326 2
a327 2
#include <libnrimg.h>			 /* rdtensor, wrtensor */
#include <imgutil.h>			 /* IMAGE_LIST_DATA, MAXPATH, SXR_DATA, HEADER_DATA */
d331 1
a331 1
#define  IMGLIST_SIZE 2000		 /* max size of imglist */
d399 1
a399 1
	float        ***atlas_image;	 /* atlas-transformed image */
d401 1
a401 1
									  * element of atlas_image */
d920 18
@


3.28
log
@added zref for atlas.xdim, atlas.ydim in atlas_scalers.c
@
text
@d2 3
d90 1
a90 1
 * changed $Id: t88mean.c,v 3.27 1996/09/23 17:27:03 tom Exp tom $ to $Header: /home/npggw/tom/src/t88mean/RCS/t88mean.c,v 3.27 1996/09/23 17:27:03 tom Exp tom $
d311 1
a311 1
static char     rcsid[] = "$Header: /home/npggw/tom/src/t88mean/RCS/t88mean.c,v 3.27 1996/09/23 17:27:03 tom Exp tom $";
@


3.27
log
@allow scanner = 0
@
text
@d2 3
d87 1
a87 1
 * changed $Id: t88mean.c,v 3.26 1996/09/11 20:50:25 tom Exp tom $ to $Header: /home/npggw/tom/src/t88mean/RCS/t88mean.c,v 3.26 1996/09/11 20:50:25 tom Exp tom $
d308 1
a308 1
static char     rcsid[] = "$Header: /home/npggw/tom/src/t88mean/RCS/t88mean.c,v 3.26 1996/09/11 20:50:25 tom Exp tom $";
d549 1
a549 2
		if (zorigin > 0) {
			atlas.ydim[zorigin] = atlas.ydim[atlas.z0];
a550 1
		}
@


3.26
log
@set orientation of output image
@
text
@d2 3
d84 1
a84 1
 * changed $Id: t88mean.c,v 3.25 1996/09/03 18:22:55 tom Exp tom $ to $Header: /home/npggw/tom/src/t88mean/RCS/t88mean.c,v 3.25 1996/09/03 18:22:55 tom Exp tom $
d305 1
a305 1
static char     rcsid[] = "$Header: /home/npggw/tom/src/t88mean/RCS/t88mean.c,v 3.25 1996/09/03 18:22:55 tom Exp tom $";
d625 1
a625 1
			if (scanner != 6 && scanner != 953 && scanner != 961) {
@


3.25
log
@add imgmode to get_input_lists
fix bug in writehdr
@
text
@d2 4
d81 1
a81 1
 * changed $Id: t88mean.c,v 3.24 1996/08/26 18:01:54 tom Exp tom $ to $Header: /home/npggw/tom/src/t88mean/RCS/t88mean.c,v 3.24 1996/08/26 18:01:54 tom Exp tom $
d302 1
a302 1
static char     rcsid[] = "$Header: /home/npggw/tom/src/t88mean/RCS/t88mean.c,v 3.24 1996/08/26 18:01:54 tom Exp tom $";
d918 1
@


3.24
log
@new libimage with fixed scaling in wrimg7
@
text
@d2 3
d77 1
a77 1
 * changed $Id: t88mean.c,v 3.23 1996/08/23 17:38:18 tom Exp tom $ to $Header: /home/npggw/tom/src/t88mean/RCS/t88mean.c,v 3.23 1996/08/23 17:38:18 tom Exp tom $
d298 1
a298 1
static char     rcsid[] = "$Header: /home/npggw/tom/src/t88mean/RCS/t88mean.c,v 3.23 1996/08/23 17:38:18 tom Exp tom $";
d304 1
a304 1
#include <math.h>			 /* M_PI */
d309 3
a311 3
#include <libnrimg.h>		 /* rdtensor, wrtensor */
#include <imgutil.h>		 /* IMAGE_LIST_DATA, MAXPATH, SXR_DATA, HEADER_DATA */
#include <atlas.h>			 /* BRAIN_ATLAS */
d313 2
a314 2
#define  EARLY_EXIT	3		 /* exit status to delete the rec file */
#define  IMGLIST_SIZE 2000	 /* max size of imglist */
d360 1
a361 1
	int             filtmode;
d384 1
a384 1
						  			  * element of atlas_image */
d507 1
a507 1
	get_input_lists (prmfile, lstsize, filtmode, scan, sxrfile, &prm, imglist);
d600 12
@


3.23
log
@new libimage
@
text
@d2 3
d74 1
a74 1
 * changed $Id: t88mean.c,v 3.22 1996/08/14 16:48:01 tom Exp tom $ to $Header: /home/npggw/tom/src/t88mean/RCS/t88mean.c,v 3.22 1996/08/14 16:48:01 tom Exp tom $
d295 1
a295 1
static char     rcsid[] = "$Header: /home/npggw/tom/src/t88mean/RCS/t88mean.c,v 3.22 1996/08/14 16:48:01 tom Exp tom $";
@


3.22
log
@*** empty log message ***
@
text
@d2 3
d71 1
a71 1
 * changed $Id: t88mean.c,v 3.21 1996/08/13 13:27:12 tom Exp tom $ to $Header: /home/npggw/tom/src/t88mean/RCS/t88mean.c,v 3.21 1996/08/13 13:27:12 tom Exp tom $
d292 1
a292 1
static char     rcsid[] = "$Header: /home/npggw/tom/src/t88mean/RCS/t88mean.c,v 3.21 1996/08/13 13:27:12 tom Exp tom $";
@


3.21
log
@atlas.z0 is set before calling getatlas_t88
@
text
@d2 3
d68 1
a68 1
 * changed $Id: t88mean.c,v 3.20 1996/08/05 14:33:56 tom Exp tom $ to $Header: /home/npggw/tom/src/t88mean/RCS/t88mean.c,v 3.20 1996/08/05 14:33:56 tom Exp tom $
d289 1
a289 1
static char     rcsid[] = "$Header: /home/npggw/tom/src/t88mean/RCS/t88mean.c,v 3.20 1996/08/05 14:33:56 tom Exp tom $";
d295 1
a295 1
#include <math.h>			/* M_PI */
d300 3
a302 3
#include <libnrimg.h>		/* writetensor */
#include <imgutil.h>		/* IMAGE_LIST_DATA, MAXPATH, SXR_DATA, HEADER_DATA, buildnames */
#include <atlas.h>			/* BRAIN_ATLAS */
d387 2
a388 2
	int             zorigin;
	int             zmax;
d529 3
a531 1
		if (zorigin > 0)
d533 1
a535 3
		else
			atlas.nz = 49;
		getatlas_t88 (&atlas);
@


3.20
log
@new libimage and libnrimg
@
text
@d2 3
d65 1
a65 1
 * changed $Id: t88mean.c,v 3.19 1996/05/10 22:45:47 tom Exp tom $ to $Header: /home/npggw/tom/src/t88mean/RCS/t88mean.c,v 3.19 1996/05/10 22:45:47 tom Exp tom $
d286 1
a286 1
static char     rcsid[] = "$Header: /home/npggw/tom/src/t88mean/RCS/t88mean.c,v 3.19 1996/05/10 22:45:47 tom Exp tom $";
a525 1
		getatlas_t88 (&atlas);
d532 1
@


3.19
log
@add mode='w' before wrtensor
@
text
@d2 3
d62 1
a62 1
 * changed $Id: t88mean.c,v 3.18 1996/05/10 21:59:55 tom Exp tom $ to $Header: /home/petsun19/tom/src/t88mean/RCS/t88mean.c,v 3.18 1996/05/10 21:59:55 tom Exp tom $
d283 1
a283 1
static char     rcsid[] = "$Header: /home/petsun19/tom/src/t88mean/RCS/t88mean.c,v 3.18 1996/05/10 21:59:55 tom Exp tom $";
@


3.18
log
@new libimage
indexing from 1 on images and atlas
@
text
@d2 4
d59 1
a59 1
 * changed $Id: t88mean.c,v 3.17 1995/11/10 18:48:21 tom Exp tom $ to $Header: /home/npggw/tom/src/t88mean/RCS/t88mean.c,v 3.17 1995/11/10 18:48:21 tom Exp tom $
d280 1
a280 1
static char     rcsid[] = "$Header: /home/npggw/tom/src/t88mean/RCS/t88mean.c,v 3.17 1995/11/10 18:48:21 tom Exp tom $";
d286 1
a286 1
#include <math.h>		 /* M_PI */
d291 3
a293 3
#include <libnrimg.h>	 /* writetensor */
#include <imgutil.h>	 /* IMAGE_LIST_DATA, MAXPATH, SXR_DATA, HEADER_DATA, buildnames */
#include <atlas.h>		 /* BRAIN_ATLAS */
d295 1
a295 1
#define  EARLY_EXIT	3	 /* exit status to delete the rec file */
d611 3
a613 3
				} else
					sdimage = (float ***) NULL;
			}
d675 2
a676 2
        	free_f3tensor (image3, 1, idim[2], 1, idim[1], 1, idim[0]);
        	free_f3tensor (image4, 1, idim[2], 1, idim[1], 1, idim[0]);
d726 2
a727 2
        		free_f3tensor (image3, 1, idim[2], 1, idim[1], 1, idim[0]);
        		free_f3tensor (image4, 1, idim[2], 1, idim[1], 1, idim[0]);
d768 3
a770 2
			adjust_markers (sxr);	 		/* Correct sxr->dz to specific geometry */
			sxr->pixel_size = pixel_size;	/* Correct for error in sxr file for PETT VI */
d858 1
a858 1
        		free_f3tensor (image2, 1, idim[2], 1, idim[1], 1, idim[0]);
d861 1
a861 1
        free_f3tensor (image1, 1, idim[2], 1, idim[1], 1, idim[0]);
d863 1
a863 1
        	free_f3tensor (mask, 1, idim[2], 1, idim[1], 1, idim[0]);
d910 1
d922 1
d935 1
a935 1
    free_f3tensor (atlas_image, 1, odim[2], 1, odim[1], 1, odim[0]);
@


3.17
log
@remove petutil parent directory from include statements
@
text
@d2 3
d55 1
a55 1
 * changed $Id: t88mean.c,v 3.16 1995/11/10 18:46:55 tom Exp tom $ to $Header: /export/home/npggw/tom/src/t88mean/RCS/t88mean.c,v 3.16 1995/11/10 18:46:55 tom Exp tom $
d276 1
d282 8
a289 7
#include <matrix.h>
#include <package.h>			 /* BOOLEAN */
#include <petutil.h>			 /* SXR_OUTPUT */
#include <imglist.h>			 /* IMAGE_LIST_DATA, MAXPATH */
#include "atlas.h"				 /* BRAIN_ATLAS, MATRIX */
#define  EARLY_EXIT	3			 /* exit status to delete the rec file */
#define  IMGLIST_SIZE 2000			 /* max size of imglist */
d291 2
a292 1
static char     rcsid[] = "$Header: /export/home/npggw/tom/src/t88mean/RCS/t88mean.c,v 3.16 1995/11/10 18:46:55 tom Exp tom $";
a293 6
char            list[] = "*;*;*;*";		 /* any frame plane gate bed */

REAL_SLICE     *atlas_image;			 /* atlas-transformed image */
REAL_SLICE     *totwt;				 /* total of weighted images contributing to each
						  * element of atlas_image */

d303 1
a303 2
	void            matrix_transform ();
	void            get_input_lists ();
d306 4
a309 6
	Image_subheader **subheader;
	Main_header    *main_header;
	MatrixFile     *fptr;
	FILE           *listfp;
	FILE           *recfp;
	SXR_OUTPUT      sxr;			 /* xray & PET measurements */
d311 2
a312 2
	PARAMETER_DATA  parameter_data;
	IMAGE_LIST_DATA *image_list;
d314 1
a314 1
	MATRIX          map;			 /* conversion matrix Atlas -> PET   */
a315 1
	BOOLEAN         encoded_flag;
a319 1
	COMMENT_INFO    comment_info_data;
d328 1
a328 1
	char            date[40];
d338 2
a339 3
	int             image_mode;
	int             filter_mode;
	int             fd;
d351 14
a364 13
	int             scanner;		 /* 6 = PETT VI;  10 = 953B */
	short           nx;
	short           ny;
	short           num_slices;
	struct Matval   matval;
	REAL_SLICE     *image1;			 /* first (activation) PET image */
	REAL_SLICE     *image2;			 /* second (control) PET image */
	REAL_SLICE     *image3;			 /* flow PET image for oxygen processing */
	REAL_SLICE     *image4;			 /* volume PET image for oxygen processing */
	REAL_SLICE     *sdimage;		 /* SD image */
	REAL_SLICE     *mask;			 /* mask for PET images */
	SCANLIST_ARRAY *scan;
	SXRLIST_ARRAY  *sxrfile;
d376 1
a379 1
	char            processing[10];
d387 1
a387 7
	matval.frame = 1;			 /* default values for matval */
	matval.plane = 1;
	matval.gate = 1;
	matval.data = 0;
	matval.bed = 0;

	filter_mode = IMGFILTER_MODE;
d394 1
a394 2

	printf ("Copyright 1991-1994, Washington University\n");
d398 1
a398 1
		exit (FAIL);
d404 1
a404 1
	sprintf (date, "%s %s %s %s %s %s", argv[5], argv[6], argv[7], argv[8], argv[9], argv[10]);
d424 2
a425 2
		fprintf (stderr, "Error: cannot open %s\n", recfile);
		exit (FAIL);
d427 6
d434 1
a434 1
 *	Read imagelist into structure image_list
d438 1
a438 1
	image_list = (IMAGE_LIST_DATA *) malloc (sizeof (IMAGE_LIST_DATA) * IMGLIST_SIZE);
d440 3
a442 3
	if (readimglist (lstfile, image_list, &lstsize) == FAIL) {
		fprintf (stderr, "Error: reading %s\n", lstfile);
		exit (FAIL);
d445 2
a446 2
		fprintf (stderr, "Error: imglist size %d > %d\n", lstsize, IMGLIST_SIZE);
		exit (FAIL);
d449 1
a449 1
 *	Read parameters into structure parameter_data
d453 9
a461 2
	scan = (SCANLIST_ARRAY *) malloc (lstsize * sizeof (SCANLIST_ARRAY));
	sxrfile = (SXRLIST_ARRAY *) malloc (lstsize * sizeof (SXRLIST_ARRAY));
d463 1
a463 1
	if (getprms_t88 (prmfile, &smg_norm, smg_divisor, smg_included, processing, smg_mode, smg_mask,
d466 3
a468 3
			 atlas_name) == FAIL) {
		fprintf (stderr, "Error: reading parameter file %s\n", prmfile);
		exit (FAIL);
d473 1
a473 1
	if ((strcmp (processing, "oef") == 0) || (strcmp (processing, "cmro2") == 0)) {
d475 1
a475 1
		image_mode = MULTITRACER_IMAGE_MODE;
d477 1
a477 1
		image_mode = DIFIMAGE_MODE;
d479 1
a479 1
		image_mode = STDIMAGE_MODE;
d482 1
a482 1
 *	Construct full path names in scan
a483 2
	get_input_lists (prmfile, lstfile, lstsize, image_mode, filter_mode, scan, sxrfile,
			 &parameter_data, image_list);
d485 2
d488 1
a488 1
	if (image_mode == MULTITRACER_IMAGE_MODE) {
d518 1
a518 1
        	atlas.z0 = zorigin - 1;
d522 1
a522 1
			atlas.nz = ZATL;
d532 12
a543 4
	main_header = (Main_header *) calloc (1, sizeof (Main_header));
	subheader = (Image_subheader **) malloc (atlas.nz * sizeof (caddr_t));
	atlas_image = (REAL_SLICE *) malloc (atlas.nz * sizeof (REAL_SLICE));
	totwt = (REAL_SLICE *) malloc (atlas.nz * sizeof (REAL_SLICE));
d545 1
d570 4
a573 4
			fd = open (activation_scan, O_RDONLY, 0);
			if (fd == -1) {
				fprintf (stderr, "Error opening %s\n", activation_scan);
				exit (FAIL);
d575 3
a577 5
			scanner = getimage_type (fd, activation_scan, &encoded_flag, &num_slices);
			close (fd);
			if (scanner == ERROR_SCANNER) {
				fprintf (stderr, "Error: file is not a recognized PET image\n");
				exit (FAIL);
d579 3
a581 13
			if (scanner == ECAT_SCANNER) {
				fptr = OpenEcat (activation_scan, &num_slices, &nx, &ny, &pixel_size,
						 &plane_separation, matval);
				if (fptr == (MatrixFile *) NULL) {
					fprintf (stderr, "Error: cannot open %s as an ECAT image file\n", activation_scan);
					exit (FAIL);
				}
				matrix_close (fptr);
			} else {
				nx = DIM;
				ny = DIM;
				pixel_size = 0.286;
				plane_separation = 1.44;
d583 11
d600 1
a600 8
			image1 = (REAL_SLICE *) calloc (num_slices, sizeof (REAL_SLICE));
			if (paired_images)
				image2 = (REAL_SLICE *) calloc (num_slices, sizeof (REAL_SLICE));
			if (oxygen_mode) {
				image3 = (REAL_SLICE *) calloc (num_slices, sizeof (REAL_SLICE));
				image4 = (REAL_SLICE *) calloc (num_slices, sizeof (REAL_SLICE));
			}
			if (strcmp (smg_mask, "yes") == 0) {
a601 2
				mask = (REAL_SLICE *) calloc (num_slices, sizeof (REAL_SLICE));
			}
d604 11
a614 9
				sdimage = (REAL_SLICE *) calloc (atlas.nz, sizeof (REAL_SLICE));
			} else
				sdimage = (REAL_SLICE *) calloc (1, sizeof (float));

			for (m = 0; m < atlas.nz; ++m) {
				for (j = 0; j < DIM; ++j) {
					for (k = 0; k < DIM; ++k) {
						atlas_image[m][j][k] = 0;
						totwt[m][j][k] = 0;
d616 1
a616 1
							sdimage[m][j][k] = 0;
d626 3
a628 4
			if (getrealimg (flow_scan1, scanner, matval, nx, ny, num_slices, image3,
					main_header, subheader) == FAIL) {
				fprintf (stderr, "Error reading %s\n", flow_scan1);
				exit (FAIL);
d633 3
a635 4
			if (getrealimg (vol_scan1, scanner, matval, nx, ny, num_slices, image4,
					main_header, subheader) == FAIL) {
				fprintf (stderr, "Error reading %s\n", vol_scan1);
				exit (FAIL);
d640 3
a642 4
		if (getrealimg (activation_scan, scanner, matval, nx, ny, num_slices, image1,
				main_header, subheader) == FAIL) {
			fprintf (stderr, "Error reading %s\n", activation_scan);
			exit (FAIL);
d648 1
a648 1
			if (image_mode == DIFIMAGE_MODE)
d651 5
a655 5
				fprintf (stderr, "Error: Parameter smg_norm in parameter list is 0\n");
				exit (FAIL);
			} else if (image_list[i].mean1 == 0) {
				fprintf (stderr, "Error: Normalization factor in image list is 0\n");
				exit (FAIL);
d657 3
a659 1
				scaler = smg_norm / image_list[i].mean1;
d665 1
a665 1
			if (process_oxygen (image1, image3, image4, nx, ny, num_slices, scaler,
d667 1
a667 1
				fprintf (stderr, "Error processing %s %s %s\n", activation_scan,
d669 1
a669 1
				exit (FAIL);
d671 6
a676 4
		} else if (process_pet (image1, nx, ny, num_slices, scaler, processing,
					activation_scan, recfp, hdr) > 0) {
			fprintf (stderr, "Error processing %s\n", activation_scan);
			exit (FAIL);
d685 3
a687 4
				if (getrealimg (flow_scan2, scanner, matval, nx, ny, num_slices, image3,
						main_header, subheader) == FAIL) {
					fprintf (stderr, "Error reading %s\n", flow_scan2);
					exit (FAIL);
d692 3
a694 4
				if (getrealimg (vol_scan2, scanner, matval, nx, ny, num_slices, image4,
						main_header, subheader) == FAIL) {
					fprintf (stderr, "Error reading %s\n", vol_scan2);
					exit (FAIL);
d699 3
a701 4
			if (getrealimg (control_scan, scanner, matval, nx, ny, num_slices, image2,
					main_header, subheader) == FAIL) {
				fprintf (stderr, "Error reading %s\n", control_scan);
				exit (FAIL);
d706 1
a706 1
			if (image_mode == DIFIMAGE_MODE)
d708 3
a710 3
			else if (image_list[i].mean2 == 0) {
				fprintf (stderr, "Error: Normalization factor in image list is 0\n");
				exit (FAIL);
d712 1
a712 1
				scaler = smg_norm / image_list[i].mean2;
d716 1
a716 1
				if (process_oxygen (image2, image3, image4, nx, ny, num_slices, scaler,
d718 1
a718 1
					fprintf (stderr, "Error processing %s %s %s\n", control_scan,
d720 1
a720 1
					exit (FAIL);
d722 6
a727 4
			} else if (process_pet (image2, nx, ny, num_slices, scaler, processing,
						control_scan, recfp, hdr) > 0) {
				fprintf (stderr, "Error processing %s\n", control_scan);
				exit (FAIL);
d742 3
a744 4
			if (getrealimg (maskfile, scanner, matval, nx, ny, num_slices, mask,
					main_header, subheader) == FAIL) {
				fprintf (stderr, "Error reading %s\n", maskfile);
				exit (FAIL);
d750 2
a751 2
				image_diff (image1, image2, num_slices);
			weight = image_list[i].weight;
d753 1
a753 1
			noatlas_transform (image1, atlas_image, sdimage, weight, totwt, atlas, mask,
d762 1
a762 1
			getsxr (sxrfile[i], &sxr);
d764 3
a766 4
			adjust_markers (sxr);	 /* Correct sxr.dz to specific geometry */
			sxr.pixel_size = pixel_size;	/* Correct for error in sxr file for PETT
							 * VI */
			sxr.slice_separation = plane_separation;
d769 1
a769 1
 *	Get y,z origin (pixel indices for C-arrays) and x-angle (radians) from sxr.
d776 3
a778 3
			center[1] = (sxr.apcenter - 1) + (sxr.dap * sxr.magnification_factor / sxr.pixel_size);
			center[2] = (sxr.reference_slice - 1) - (sxr.dz / sxr.slice_separation);
			angle[0] = -PI * sxr.degx / 180;
d793 2
a794 9
				if (paired_images)
					imgrot (image2, center, angle, sxr, nx, ny, num_slices, smg_mskpct);
				else if (strcmp (smg_mode, "single") == 0)
					imgrot (image1, center, angle, sxr, nx, ny, num_slices, smg_mskpct);
				else {
					fprintf (recfp, "Symmetry operation is not implemented for diff images\n");
					fprintf (stdout, "Symmetry operation is not implemented for diff images\n");
					sxr_xcenter (sxr, center);
				}
d799 1
a799 1
 *	If smg_compute = no, then set sxr.xscale to 0 and recompute it
d803 1
a803 1
				sxr.xscale = 0;
d809 3
a811 3
			if (atlas_scalers (sxr, atlas, center, angle, scale, first_slice, last_slice) == FAIL) {
				fprintf (stderr, "Error: PET does not overlap Atlas space.\n");
				exit (FAIL);
d833 2
a834 1
			matrix_transform (sxr, atlas, center, angle, scale, map);
d837 4
a840 4
			fprintf (recfp, "Matrix: %9.3f %9.3f %9.3f %9.3f\n", map[0][0], map[0][1], map[0][2], map[0][3]);
			fprintf (recfp, "Matrix: %9.3f %9.3f %9.3f %9.3f\n", map[1][0], map[1][1], map[1][2], map[1][3]);
			fprintf (recfp, "Matrix: %9.3f %9.3f %9.3f %9.3f\n", map[2][0], map[2][1], map[2][2], map[2][3]);
			fprintf (recfp, "Matrix: %9.3f %9.3f %9.3f %9.3f\n", map[3][0], map[3][1], map[3][2], map[3][3]);
d847 2
a848 2
				image_diff (image1, image2, num_slices);
			weight = image_list[i].weight;
d850 4
a853 2
			atlas_transform (image1, atlas_image, sdimage, weight, totwt, sxr, atlas, mask, map,
					 use_mask, compute_sd, first_slice, last_slice);
d855 4
d867 1
a867 2

	image_scale (atlas_image, totwt, atlas.nz, maxwt, smg_divisor, smg_included,
a872 1
 *	pixel_size and slice_separation must be set in all subheaders
d874 15
a888 3

	for (i = num_slices; i < atlas.nz; i++) {
		subheader[i] = matrixx_init_image_subheader (subheader[0]);
a889 16
	for (i = 0; i < atlas.nz; i++) {
		subheader[i]->pixel_size = atlas.pixel_size;
		subheader[i]->slice_width = atlas.slice_separation;
	}
	main_header->plane_separation = atlas.slice_separation;
	strncpy (main_header->physician_name, &rcsid[48], sizeof (main_header->physician_name) - 1);
	strncpy (main_header->operator_name, date, sizeof (main_header->operator_name) - 1);

	comment_info (main_header->study_description, &comment_info_data);
	comment_info_data.zorigin = atlas.z0 + 1;
	info2comment (comment_info_data, main_header->study_description);

	if (writerealimg (outfile, matval, DIM, DIM, atlas.nz, atlas_image, main_header, subheader)
	    == FAIL) {
		fprintf (stderr, "Error writing %s\n", outfile);
	}
d894 3
a896 4

	if (strcmp (processing, "none") != 0) {
		if (writehdr (hdr, outfile, userid, today, processing, (short) atlas.nz) == FAIL) {
			fprintf (stderr, "Error writing hdr file\n");
a902 1

d904 4
a907 3
		if (writerealimg (sdfile, matval, DIM, DIM, atlas.nz, sdimage, main_header, subheader)
		    == FAIL) {
			fprintf (stderr, "Error writing %s\n", sdfile);
a913 1

d915 4
a918 3
		if (writerealimg (wtfile, matval, DIM, DIM, atlas.nz, totwt, main_header, subheader)
		    == FAIL) {
			fprintf (stderr, "Error writing %s\n", wtfile);
d925 4
a928 15

	for (i = 0; i < atlas.nz; i++)
		free (subheader[i]);
	free (subheader);
	free (main_header);
	free (image1);
	if (paired_images)
		free (image2);
	if (oxygen_mode) {
		free (image3);
		free (image4);
	}
	free (sdimage);
	if (use_mask)
		free (mask);
d931 6
a936 1
	free (image_list);
d938 2
d942 1
@


3.16
log
@change rec file output of matrix
@
text
@d2 3
d52 1
a52 1
 * changed $Id: t88mean.c,v 3.15 1995/09/18 20:21:16 tom Exp $ to $Header: /export/home/npggw/tom/src/t88mean/RCS/t88mean.c,v 3.15 1995/09/18 20:21:16 tom Exp $
d278 4
a281 4
#include <petutil/matrix.h>
#include <petutil/package.h>			 /* BOOLEAN */
#include <petutil/petutil.h>			 /* SXR_OUTPUT */
#include <petutil/imglist.h>			 /* IMAGE_LIST_DATA, MAXPATH */
d286 1
a286 1
static char     rcsid[] = "$Header: /export/home/npggw/tom/src/t88mean/RCS/t88mean.c,v 3.15 1995/09/18 20:21:16 tom Exp $";
@


3.15
log
@changed version output in rcsid
@
text
@d2 3
d49 1
a49 1
 * changed $Id: t88mean.c,v 3.14 1995/09/18 19:50:30 tom Exp tom $ to $Header: /export/home/npggw/tom/src/t88mean/RCS/t88mean.c,v 3.14 1995/09/18 19:50:30 tom Exp tom $
d283 1
a283 1
static char     rcsid[] = "$Header: /export/home/npggw/tom/src/t88mean/RCS/t88mean.c,v 3.14 1995/09/18 19:50:30 tom Exp tom $";
d840 4
a843 3
			fprintf (recfp, "Matrix: %9.3f %9.3f %9.3f\n", map[0][0], map[0][1], map[0][2]);
			fprintf (recfp, "Matrix: %9.3f %9.3f %9.3f\n", map[1][0], map[1][1], map[1][2]);
			fprintf (recfp, "Matrix: %9.3f %9.3f %9.3f\n", map[2][0], map[2][1], map[2][2]);
@


3.14
log
@corrected z0 error in version 3.12
@
text
@d2 3
d46 1
a46 1
 * changed $Id: t88mean.c,v 3.13 1995/08/31 21:59:37 tom Exp $ to $Header: /home/npggw/tom/src/t88mean/RCS/t88mean.c,v 3.13 1995/08/31 21:59:37 tom Exp $
d280 1
a280 1
static char     rcsid[] = "$Header: /home/npggw/tom/src/t88mean/RCS/t88mean.c,v 3.13 1995/08/31 21:59:37 tom Exp $";
d878 1
a878 1
	strncpy (main_header->physician_name, &rcsid[9], sizeof (main_header->physician_name) - 1);
@


3.13
log
@option added-- atlas: none
@
text
@d2 3
d43 1
a43 1
 * changed $Id: t88mean.c,v 3.12 1995/05/22 20:14:15 tom Exp tom $ to $Header: /home/npggw/tom/src/t88mean/RCS/t88mean.c,v 3.12 1995/05/22 20:14:15 tom Exp tom $
d277 1
a277 1
static char     rcsid[] = "$Header: /home/npggw/tom/src/t88mean/RCS/t88mean.c,v 3.12 1995/05/22 20:14:15 tom Exp tom $";
d507 2
@


3.12
log
@error checking for imglist size
@
text
@d2 3
d40 1
a40 1
 * changed $Id: t88mean.c,v 3.11 1995/05/22 15:00:32 tom Exp tom $ to $Header: /export/home/npggw/tom/src/t88mean/RCS/t88mean.c,v 3.11 1995/05/22 15:00:32 tom Exp tom $
d145 1
a145 1
 *	Description:	
d154 1
a154 1
 *		 
d162 1
a162 1
 *		 
d257 2
d267 6
a272 6
#include <petutil/package.h>    /* BOOLEAN */
#include <petutil/petutil.h>    /* SXR_OUTPUT */
#include <petutil/imglist.h>	/* IMAGE_LIST_DATA, MAXPATH */
#include "atlas.h"		/* BRAIN_ATLAS, MATRIX */
#define  EARLY_EXIT	3	/* exit status to delete the rec file */
#define  IMGLIST_SIZE 2000	/* max size of imglist */
d274 1
a274 1
static char     rcsid[] = "$Header: /export/home/npggw/tom/src/t88mean/RCS/t88mean.c,v 3.11 1995/05/22 15:00:32 tom Exp tom $";
d276 1
a276 1
char            list[] = "*;*;*;*";	/* any frame plane gate bed */
d278 3
a280 2
REAL_SLICE      *atlas_image;	/* atlas-transformed image */
REAL_SLICE      *totwt;	/* total of weighted images contributing to each element of atlas_image */
d290 2
a291 2
    int             atlas_scalers ();
    void            matrix_transform ();
d300 2
a301 2
	SXR_OUTPUT      sxr;	/* xray & PET measurements */
	BRAIN_ATLAS     atlas;	/* brain atlas definition */
d304 2
a305 2
	HEADER_DATA    *hdr;	/* hdr structure */
    MATRIX          map;    /* conversion matrix Atlas -> PET   */
d312 1
a312 1
    COMMENT_INFO    comment_info_data;
d334 2
a335 2
	int             i, j, k, m;	/* array indices */
	float           scaler;	/* scale individual PET images */
d345 1
a345 1
	int             scanner;/* 6 = PETT VI;  10 = 953B */
d350 6
a355 6
	REAL_SLICE     *image1;	/* first (activation) PET image */
	REAL_SLICE     *image2;	/* second (control) PET image */
	REAL_SLICE     *image3;	/* flow PET image for oxygen processing */
	REAL_SLICE     *image4;	/* volume PET image for oxygen processing */
	REAL_SLICE     *sdimage;/* SD image */
	REAL_SLICE     *mask;	/* mask for PET images */
d378 1
d380 1
a380 1
	matval.frame = 1;	/* default values for matval */
d417 1
a417 1
    if (ext != NULL)
d451 3
a453 2
		smg_sdimage, smg_nimage, smg_symmetry, &smg_mskpct, smg_compute, &default_pixel_size,
			 &default_plane_separation, &first_slice, &last_slice, &zorigin, &zmax) == FAIL) {
d502 15
a516 7
	getatlas_t88 (&atlas);
	if (zorigin > 0)
		atlas.z0 = zorigin - 1;
	if (zmax > 0)
		atlas.nz = zmax;
	else
		atlas.nz = ZATL;
d733 9
d747 6
a752 5
		getsxr (sxrfile[i], &sxr);
		fprintf (recfp, "%s\n", sxrfile[i]);
		adjust_markers (sxr);	/* Correct sxr.dz to specific geometry */
		sxr.pixel_size = pixel_size;	/* Correct for error in sxr file for PETT VI */
		sxr.slice_separation = plane_separation;
d761 9
a769 9
		center[0] = 0;
		center[1] = (sxr.apcenter - 1) + (sxr.dap * sxr.magnification_factor / sxr.pixel_size);
		center[2] = (sxr.reference_slice - 1) - (sxr.dz / sxr.slice_separation);
		angle[0] = -PI * sxr.degx / 180;
		angle[1] = 0;
		angle[2] = 0;
	    scale[0] = 0;
    	scale[1] = 0;
    	scale[2] = 0;
d778 11
a788 8
		if (strcmp (smg_symmetry, "yes") == 0) {
			if (paired_images)
				imgrot (image2, center, angle, sxr, nx, ny, num_slices, smg_mskpct);
			else if (strcmp (smg_mode, "single") == 0)
				imgrot (image1, center, angle, sxr, nx, ny, num_slices, smg_mskpct);
			else {
				fprintf (recfp, "Symmetry operation is not implemented for diff images\n");
				fprintf (stdout, "Symmetry operation is not implemented for diff images\n");
a789 3
			}
		} else
			sxr_xcenter (sxr, center);
a793 3
 
		if (strcmp (smg_compute, "no") == 0)
			sxr.xscale = 0;
d795 3
d801 12
a812 12
 
	    if (atlas_scalers (sxr, atlas, center, angle, scale, first_slice, last_slice) == FAIL) {
        	fprintf (stderr, "Error: PET does not overlap Atlas space.\n");
        	exit (FAIL);
    	} else {
        	fprintf (recfp, "Center: %9.3f %9.3f %9.3f   pixels\n", center[0], center[1], center[2]);
        	fprintf (recfp, "Angle:  %9.3f %9.3f %9.3f   radians\n", angle[0], angle[1], angle[2]);
        	fprintf (recfp, "Scale:  %9.3f %9.3f %9.3f\n", scale[0], scale[1], scale[2]);
        	fprintf (stdout, "Center: %9.3f %9.3f %9.3f   pixels\n", center[0], center[1], center[2]);
        	fprintf (stdout, "Angle:  %9.3f %9.3f %9.3f   radians\n", angle[0], angle[1], angle[2]);
        	fprintf (stdout, "Scale:  %9.3f %9.3f %9.3f\n", scale[0], scale[1], scale[2]);
    	}
d816 6
a821 7
 
		if (strcmp (smg_compute, "no") == 0) {
			fprintf (stdout, "-------------------------------------\n");
			fprintf (stdout, "X-SCALE =%8.3f\n", scale[0]);
			exit (EARLY_EXIT);
		}
 
d826 1
a826 6
	    matrix_transform (sxr, atlas, center, angle, scale, map);
	 
    	fprintf (recfp, "Matrix Transform:  Matrix*Atlas -> PET\n");
    	fprintf (recfp, "Matrix: %9.3f %9.3f %9.3f\n", map[0][0], map[0][1], map[0][2]);
    	fprintf (recfp, "Matrix: %9.3f %9.3f %9.3f\n", map[1][0], map[1][1], map[1][2]);
    	fprintf (recfp, "Matrix: %9.3f %9.3f %9.3f\n", map[2][0], map[2][1], map[2][2]);
d828 5
d837 7
a843 6
		if (paired_images)
			image_diff (image1, image2, num_slices);
		weight = image_list[i].weight;
		maxwt += weight;
		atlas_transform (image1, atlas_image, sdimage, weight, totwt, sxr, atlas, mask, map,
			use_mask, compute_sd, first_slice, last_slice);
d854 1
a854 1
	     compute_sd, sdimage);
d875 1
a875 1
    info2comment (comment_info_data, main_header->study_description);
a880 1

@


3.11
log
@changed IMGLIST_SIZE to a local definition of 2000
@
text
@d2 3
d37 1
a37 1
 * changed $Id: t88mean.c,v 3.10 1995/01/19 22:42:11 tom Exp tom $ to $Header: /home/npggw/tom/src/t88mean/RCS/t88mean.c,v 3.10 1995/01/19 22:42:11 tom Exp tom $
d269 1
a269 1
static char     rcsid[] = "$Header: /home/npggw/tom/src/t88mean/RCS/t88mean.c,v 3.10 1995/01/19 22:42:11 tom Exp tom $";
d429 4
@


3.10
log
@weights.
@
text
@d2 3
d34 1
a34 1
 * changed $Id: t88mean.c,v 3.9 1995/01/19 19:17:17 tom Exp tom $ to $Header: /export/home/npggw/tom/src/t88mean/RCS/t88mean.c,v 3.9 1995/01/19 19:17:17 tom Exp tom $
d264 1
d266 1
a266 1
static char     rcsid[] = "$Header: /export/home/npggw/tom/src/t88mean/RCS/t88mean.c,v 3.9 1995/01/19 19:17:17 tom Exp tom $";
d422 1
a422 1
	image_list = (IMAGE_LIST_DATA *) malloc (sizeof (IMAGE_LIST_DATA) * MAX_IMAGE_LIST_SIZE);
@


3.9
log
@weights
@
text
@d2 3
d31 1
a31 1
 * changed $Id: t88mean.c,v 3.8 1994/12/27 22:59:41 tom Exp tom $ to $Header: /home/npggw/tom/src/t88mean/RCS/t88mean.c,v 3.8 1994/12/27 22:59:41 tom Exp tom $
d262 1
a262 1
static char     rcsid[] = "$Header: /home/npggw/tom/src/t88mean/RCS/t88mean.c,v 3.8 1994/12/27 22:59:41 tom Exp tom $";
d816 1
a816 1
	image_scale (atlas_image, totwt, atlas.nz, totwt, smg_divisor, smg_included,
@


3.8
log
@free mask in imgrot.c
@
text
@d2 3
d28 1
a28 1
 * changed $Id: t88mean.c,v 3.7 1994/10/11 21:59:03 tom Exp tom $ to $Header: /home/npggw/tom/src/t88mean/RCS/t88mean.c,v 3.7 1994/10/11 21:59:03 tom Exp tom $
d259 1
a259 1
static char     rcsid[] = "$Header: /home/npggw/tom/src/t88mean/RCS/t88mean.c,v 3.7 1994/10/11 21:59:03 tom Exp tom $";
d264 1
a264 1
SHORT_SLICE     *nin;	/* number of images contributing to each element of atlas_image */
d303 1
a303 1
	char            nfile[MAXPATH];
d327 2
d370 1
d398 2
a399 2
	strcpy (nfile, outfile);
	ext = strrchr (nfile, '.');
d403 1
a403 1
		strcat (nfile, ".n");
d490 1
a490 1
	nin = (SHORT_SLICE *) malloc (atlas.nz * sizeof (SHORT_SLICE));
d512 1
a512 1
 *	First image, first time -- get scanner and dimensions; zero arrays (atlas_image, nin, sdimage)
d568 1
a568 1
						nin[m][j][k] = 0;
d800 3
a802 1
		atlas_transform (image1, atlas_image, sdimage, nin, sxr, atlas, mask, map,
d813 1
a813 1
	image_scale (atlas_image, nin, atlas.nz, lstsize, smg_divisor, smg_included,
d864 2
a865 2
 *	Convert nin to float and Write N Image to nfile
 *	-----------------------------------------------
d869 1
a869 8
		for (i = 0; i < atlas.nz; i++) {
			for (j = 0; j < DIM; j++) {
				for (k = 0; k < DIM; k++) {
					atlas_image[i][j][k] = nin[i][j][k];
				}
			}
		}
		if (writerealimg (nfile, matval, DIM, DIM, atlas.nz, atlas_image, main_header, subheader)
d871 1
a871 1
			fprintf (stderr, "Error writing %s\n", nfile);
@


3.7
log
@Fix bug in creating filenames (sd and n) when output file has no "."
@
text
@d2 3
d25 1
a25 1
 * changed $Id: t88mean.c,v 3.6 1994/10/03 17:54:18 tom Exp tom $ to $Header: /home/npggw/tom/src/t88mean/RCS/t88mean.c,v 3.6 1994/10/03 17:54:18 tom Exp tom $
d240 2
d256 1
a256 1
static char     rcsid[] = "$Header: /home/npggw/tom/src/t88mean/RCS/t88mean.c,v 3.6 1994/10/03 17:54:18 tom Exp tom $";
@


3.6
log
@set EOT to 0 on exit
@
text
@d2 3
d22 1
a22 1
 * changed $Id: t88mean.c,v 3.5 1994/10/03 16:17:13 tom Exp tom $ to $Header: /export/home/npggw/tom/src/t88mean/RCS/t88mean.c,v 3.5 1994/10/03 16:17:13 tom Exp tom $
d235 2
d251 1
a251 1
static char     rcsid[] = "$Header: /export/home/npggw/tom/src/t88mean/RCS/t88mean.c,v 3.5 1994/10/03 16:17:13 tom Exp tom $";
d382 4
a385 1
	strcpy (ext, ".sd");
d389 4
a392 1
	strcpy (ext, ".n");
d605 2
a606 1
		}
d681 4
a684 1
			strcpy (ext, ".msk");
@


3.5
log
@Changed atlas_transform to compute the x-scaling factor from the nearest slice
to the AC-PC plane if no slice contains the AC-PC plane;
The transformation matrix (and scaling factors) are written to the rec file;
Change calling parameters to sxr_center;
Separate functions atlas_scalers and matrix_transform;
@
text
@d2 7
d19 1
a19 1
 * changed $Id: t88mean.c,v 3.4 1994/09/14 14:41:51 tom Exp tom $ to $Header: /export/home/npggw/tom/src/t88mean/RCS/t88mean.c,v 3.4 1994/09/14 14:41:51 tom Exp tom $
d230 2
d246 1
a246 1
static char     rcsid[] = "$Header: /export/home/npggw/tom/src/t88mean/RCS/t88mean.c,v 3.4b 1994/09/14 14:41:51 tom Exp tom $";
d879 1
@


3.4
log
@Allow > 49 slices in atlas and any z-origin
@
text
@d2 3
d12 1
a12 1
 * changed $Id: t88mean.c,v 3.3 1994/05/24 22:31:27 tom Exp tom $ to $Header: /home/npggw/tom/src/t88mean/RCS/t88mean.c,v 3.3 1994/05/24 22:31:27 tom Exp tom $
d114 28
a141 5
 *	Module:				t88mean.c
 *	Date:					24-Jun-93
 *	Author:				Tom Videen
 *	Description:	Transform PETT VI or ECAT images into Talairach 1988 space.
 *								Create summed images (difference, mean, or single)
d215 8
a222 2
 *				added zorigin and zmax as parameters (getprms_t88)
 *				changed references to ZATL to atlas.nz (t88mean, atlas_transform)
d231 2
a232 1
#include <petutil/petutil.h>
d234 2
a235 1
#include "atlas.h"		/* BRAIN_ATLAS */
d237 1
a237 1
static char     rcsid[] = "$Header: /home/npggw/tom/src/t88mean/RCS/t88mean.c,v 3.3 1994/05/24 22:31:27 tom Exp tom $";
d245 1
a245 1
 *	Function:			tal88
d252 2
d256 1
d267 1
d304 1
d334 1
d348 1
a348 1
 *	Get command line arguments and initialize filenames:
d380 2
a381 2
 *	Read imagelist into image_list.
 *	------------------------------
d391 2
a392 2
 *	Read parameters into parameter_data and get full path names in scan
 *	-------------------------------------------------------------------
d398 2
a399 2
	if (getprms_t88 (prmfile, &smg_norm, smg_divisor, smg_included, processing, smg_mode,
		smg_mask, smg_sdimage, smg_nimage, smg_symmetry, &smg_mskpct, &default_pixel_size,
d415 3
d545 2
a546 2
 *	First (activation) image
 *	------------------------
d573 13
a585 11
		if (image_mode == DIFIMAGE_MODE)
			scaler = 1.0;
		else if (smg_norm == 0) {
			fprintf (stderr, "Error: Parameter smg_norm in parameter list is 0\n");
			exit (FAIL);
		} else if (image_list[i].mean1 == 0) {
			fprintf (stderr, "Error: Normalization factor in image list is 0\n");
			exit (FAIL);
		} else
			scaler = smg_norm / image_list[i].mean1;
		fprintf (recfp, "Scale %s by %f\n", activation_scan, scaler);
d600 2
a601 2
 *	Second (control) image:
 *	----------------------
d653 2
a654 2
 *	Optional smg_mask
 *	-----------------
d669 2
a670 4
 *	Transform to atlas
 *	------------------
 *
 *	Get sxr file information
d692 3
d697 4
a700 3
 *	If smg_symmetry, compute y and z-angles and use x center-of-mass for x-origin
 *	  (for paired images, use the control scan for symmetry)
 *	Otherwise, get x-origin from mean center of PET slices
d711 1
a711 1
				sxr_xcenter (sxr, center, num_slices);
d714 1
a714 1
			sxr_xcenter (sxr, center, num_slices);
d716 6
a721 4
		fprintf (recfp, "Center: %9.3f %9.3f %9.3f   pixels\n", center[0], center[1], center[2]);
		fprintf (recfp, "Angle:  %9.3f %9.3f %9.3f   radians\n", angle[0], angle[1], angle[2]);
		fprintf (stdout, "Center: %9.3f %9.3f %9.3f   pixels\n", center[0], center[1], center[2]);
		fprintf (stdout, "Angle:  %9.3f %9.3f %9.3f   radians\n", angle[0], angle[1], angle[2]);
d724 1
a724 1
 *	Now, subtract, transform to atlas space, and sum
d726 25
d752 11
d765 2
a766 2
		atlas_transform (image1, atlas_image, sdimage, nin, sxr, atlas, mask, center, angle,
				 use_mask, compute_sd, first_slice, last_slice);
d769 5
a773 3
/*
 *	Scale image and mask pixels before saving
 *	-----------------------------------------
d776 2
a777 2
	image_scale (atlas_image, nin, atlas.nz, lstsize, smg_divisor, smg_included, paired_images,
		     compute_sd, sdimage);
@


3.3
log
@fixed nmask comparison in image_scale.c
@
text
@d2 3
d9 1
a9 1
 * changed $Id: t88mean.c,v 3.2 1994/05/24 17:12:11 tom Exp tom $ to $Header: /home/petsun2/tom/src/t88mean/RCS/t88mean.c,v 3.2 1994/05/24 17:12:11 tom Exp tom $
d187 4
d203 1
a203 1
static char     rcsid[] = "$Header: /home/petsun2/tom/src/t88mean/RCS/t88mean.c,v 3.2 1994/05/24 17:12:11 tom Exp tom $";
d207 2
a208 2
REAL_SLICE      atlas_image[ZATL];	/* atlas-transformed image */
SHORT_SLICE     nin[ZATL];	/* number of images contributing to each element of atlas_image */
d236 1
d288 2
d360 1
a360 1
			 &default_plane_separation, &first_slice, &last_slice) == FAIL) {
d402 2
a403 2
 *	Get atlas values
 *	----------------
d407 6
d414 3
a416 6
	subheader = (Image_subheader **) malloc (ZATL * sizeof (caddr_t));

/*
 *	Allocate hdr
 */

d486 1
a486 1
				sdimage = (REAL_SLICE *) calloc (ZATL, sizeof (REAL_SLICE));
d490 1
a490 1
			for (m = 0; m < ZATL; ++m) {
d689 1
a689 1
	image_scale (atlas_image, nin, ZATL, lstsize, smg_divisor, smg_included, paired_images,
d698 1
a698 1
	for (i = num_slices; i < ZATL; i++) {
d701 1
a701 1
	for (i = 0; i < ZATL; i++) {
d706 1
a706 1
	strncpy (main_header->physician_name, &rcsid[5], sizeof (main_header->physician_name) - 1);
d709 5
a713 1
	if (writerealimg (outfile, matval, DIM, DIM, ZATL, atlas_image, main_header, subheader)
d717 1
d724 1
a724 1
		if (writehdr (hdr, outfile, userid, today, processing, (short) ZATL) == FAIL) {
d734 1
a734 1
		if (writerealimg (sdfile, matval, DIM, DIM, ZATL, sdimage, main_header, subheader)
d745 1
a745 1
		for (i = 0; i < ZATL; i++) {
d752 1
a752 1
		if (writerealimg (nfile, matval, DIM, DIM, ZATL, atlas_image, main_header, subheader)
d762 1
a762 1
	for (i = 0; i < ZATL; i++)
@


3.2
log
@image_scale fixed to use nmask properly
@
text
@d2 3
d6 1
a6 1
 * changed $Id$ to $Header$
d182 2
d196 1
a196 1
static char     rcsid[] = "$Header: /home/petsun2/tom/src/t88mean/RCS/t88mean.c,v 3.1 1994/05/18 15:53:30 tom Exp tom $";
@


3.1
log
@changed $Id$ to $Header$
@
text
@d1 4
a4 1
/* $Log:	t88mean.c,v $
d113 1
a113 1
 *			Read mask file for each activation image. 
d128 1
a128 1
 *			changed: 5 mm between brain and skull at front, back, and 0 at top in calculations			
d170 1
a170 1
 *			last_slice cannot be greater than number of slices 
d176 3
a178 1
 *			changed $Id$ to $Header$ and added ifdef to allow proper compiling on HPs
d188 2
a189 2
#include <petutil/imglist.h>      /* IMAGE_LIST_DATA, MAXPATH */
#include "atlas.h"								/* BRAIN_ATLAS */
d191 1
a191 1
static char rcsid []= "$Header: t88mean.c,v 1.1 92/12/30 04:19:56 tom Exp $";
d193 1
a193 1
char list [] = "*;*;*;*"; 			/* any frame plane gate bed */
d195 2
a196 2
REAL_SLICE	atlas_image [ZATL];	/* atlas-transformed image */
SHORT_SLICE	nin [ZATL];					/* number of images contributing to each element of atlas_image */
d201 1
a201 1
 */	
d203 2
a204 2
	int	argc;
	char	*argv[];
d206 12
a217 12
	void		get_input_lists();
	void		atlas_transform();
	Image_subheader		**subheader;
	Main_header				*main_header;
	MatrixFile				*fptr;
	FILE							*listfp;
	FILE							*recfp;
	SXR_OUTPUT				sxr;					/* xray & PET measurements */
	BRAIN_ATLAS				atlas;				/* brain atlas definition */
	PARAMETER_DATA		parameter_data;
	IMAGE_LIST_DATA		*image_list;
  HEADER_DATA 			*hdr;       	/* hdr structure */
d219 47
a265 47
	BOOLEAN	encoded_flag;
	BOOLEAN	use_mask = 0;
	BOOLEAN	compute_sd = 0;
	BOOLEAN	paired_images = 0;
	BOOLEAN	oxygen_mode = 0;
	char		*lstfile;
	char		*prmfile;
	char		*outfile;
	char		*recfile;
	char		maskfile[MAXPATH];
	char		sdfile[MAXPATH];
	char		nfile[MAXPATH];
	char		*ext;
	char		date[40];
	char		*today;
	char		*userid;
	char		*activation_scan;
	char		*control_scan;
	char		*flow_scan1;
	char		*vol_scan1;
	char		*flow_scan2;
	char		*vol_scan2;
	int			lstsize;
	int			image_mode;
  int     filter_mode;
	int			fd;
	int			i, j, k, m;				/* array indices */
	float		scaler;						/* scale individual PET images */
	float		pixel_size;
	float		plane_separation;
	float		default_pixel_size;
	float		default_plane_separation;
	float		angle[3];
	float		center[3];
	int			scanner;					/* 6 = PETT VI;  10 = 953B */
	short		nx;
	short		ny;
	short		num_slices;
	struct	Matval	matval;
	REAL_SLICE	*image1;			/* first (activation) PET image */
  REAL_SLICE  *image2;			/* second (control) PET image */
  REAL_SLICE  *image3;			/* flow PET image for oxygen processing */
  REAL_SLICE  *image4;			/* volume PET image for oxygen processing */
	REAL_SLICE	*sdimage;			/* SD image */
	REAL_SLICE	*mask;				/* mask for PET images */
	SCANLIST_ARRAY	*scan;
	SXRLIST_ARRAY		*sxrfile;
d271 12
a282 12
	float		smg_norm;
	float		smg_mskpct;
	int     first_slice;
	int     last_slice;
	char		smg_mode [10];
	char		smg_divisor [10];
	char		smg_included [10];
	char		processing [10];
	char		smg_mask [10];
	char		smg_sdimage[10];
	char		smg_nimage[10];
	char		smg_symmetry[10];
d284 5
a288 5
	matval.frame	= 1;				/* default values for matval */
	matval.plane	= 1;
	matval.gate		= 1;
	matval.data		= 0;
	matval.bed		= 0;
d301 1
a301 1
		exit(FAIL);
d303 4
a306 4
	prmfile	= argv [1];
	lstfile	= argv [2];
	outfile = argv [3];
	recfile = argv [4];
d322 1
a322 1
		exit(FAIL);
d324 1
a324 2

/* 
d329 1
a329 1
	image_list	= (IMAGE_LIST_DATA *) malloc (sizeof (IMAGE_LIST_DATA) * MAX_IMAGE_LIST_SIZE);
d332 1
a332 1
		fprintf (stderr, "Error: reading %s\n",lstfile);
a334 1

d342 1
a342 1
	
d344 3
a346 3
			smg_mask, smg_sdimage, smg_nimage, smg_symmetry, &smg_mskpct, &default_pixel_size,
			&default_plane_separation, &first_slice, &last_slice) == FAIL) {
		fprintf (stderr, "Error: reading parameter file %s\n",prmfile);
a348 1

d361 1
a361 1
		&parameter_data, image_list);
d366 1
a366 1
			printf ("Set %d\n", i+1);
d379 2
a380 1
			if (strcmp (smg_mode, "paired") == 0) printf ("Control    = %s\n", scan[i][1]);
d392 2
a393 2
	main_header	= (Main_header *) calloc (1, sizeof (Main_header));
	subheader		= (Image_subheader **) malloc (ZATL * sizeof (caddr_t));
d399 1
a399 1
  hdr = (HEADER_DATA *) malloc (sizeof (HEADER_DATA));
d406 1
a406 1
	for (i=0; i < lstsize; ++i) {
d410 1
a410 1
			vol_scan1  = scan[i][2];
d413 2
a414 2
				flow_scan2   = scan[i][4];
				vol_scan2    = scan[i][5];
a418 1

d437 2
a438 2
					&plane_separation, matval);
				if (fptr  == (MatrixFile *) NULL) {
d450 1
a450 1
			if (default_pixel_size > 0 )
d473 3
a475 3
    		for (j = 0 ; j < DIM; ++j) {
      		for (k = 0; k < DIM; ++k) {
     		  	atlas_image[m][j][k] = 0;
d477 5
a481 4
     		   	if (compute_sd) sdimage[m][j][k] = 0;
    		  }
   			}
  		}
a482 1

d488 6
a493 6
	    if (getrealimg (flow_scan1, scanner, matval, nx, ny, num_slices, image3,
        	main_header, subheader) == FAIL) {
      	fprintf (stderr, "Error reading %s\n", flow_scan1);
      	exit (FAIL);
    	}
    	recout (recfp, flow_scan1);
d496 6
a501 6
	    if (getrealimg (vol_scan1, scanner, matval, nx, ny, num_slices, image4,
        	main_header, subheader) == FAIL) {
      	fprintf (stderr, "Error reading %s\n", vol_scan1);
      	exit (FAIL);
    	}
    	recout (recfp, vol_scan1);
d504 1
a504 2

		if (getrealimg (activation_scan, scanner, matval, nx, ny, num_slices, image1, 
d511 1
a511 1
 
d518 2
a519 2
      fprintf (stderr, "Error: Normalization factor in image list is 0\n");
      exit (FAIL);
d526 1
a526 1
					processing, activation_scan, flow_scan1, vol_scan1, recfp, hdr) > 0) {
d528 1
a528 1
					flow_scan1, vol_scan1);
d532 1
a532 1
				activation_scan, recfp, hdr) > 0) {
a535 1

d543 6
a548 6
	    	if (getrealimg (flow_scan2, scanner, matval, nx, ny, num_slices, image3,
        		main_header, subheader) == FAIL) {
      		fprintf (stderr, "Error reading %s\n", flow_scan2);
      		exit (FAIL);
    		}
    		recout (recfp, flow_scan2);
d551 6
a556 6
	    	if (getrealimg (vol_scan2, scanner, matval, nx, ny, num_slices, image4,
        		main_header, subheader) == FAIL) {
      		fprintf (stderr, "Error reading %s\n", vol_scan2);
      		exit (FAIL);
    		}
    		recout (recfp, vol_scan2);
d559 1
a559 2

			if (getrealimg (control_scan, scanner, matval, nx, ny, num_slices, image2, 
d566 1
a566 1
 
d569 4
a572 4
	    else if (image_list[i].mean2 == 0) {
	      fprintf (stderr, "Error: Normalization factor in image list is 0\n");
	      exit (FAIL);
	    } else
d578 1
a578 1
						processing, control_scan, flow_scan2, vol_scan2, recfp, hdr) > 0) {
d580 1
a580 1
						flow_scan2, vol_scan2);
d584 1
a584 1
					control_scan, recfp, hdr) > 0) {
a588 1

d596 1
a596 1
			ext = strrchr (maskfile,'.');
d598 1
a598 1
			if (getrealimg (maskfile, scanner, matval, nx, ny, num_slices, mask, 
a604 1

d613 3
a615 3
		fprintf (recfp,"%s\n", sxrfile[i]);
		adjust_markers (sxr);											/* Correct sxr.dz to specific geometry */
		sxr.pixel_size = pixel_size;							/* Correct for error in sxr file for PETT VI */
d628 3
a630 3
		angle [0] = -PI * sxr.degx / 180;
		angle [1] = 0;
		angle [2] = 0;
d646 1
a646 1
      	sxr_xcenter (sxr, center, num_slices);
d652 1
a652 1
		fprintf (recfp, "Angle:  %9.3f %9.3f %9.3f   radians\n", angle [0], angle [1], angle [2]);
d654 1
a654 1
		fprintf (stdout, "Angle:  %9.3f %9.3f %9.3f   radians\n", angle [0], angle [1], angle [2]);
d660 2
a661 1
		if (paired_images) image_diff (image1, image2, num_slices);
d663 1
a663 1
			use_mask, compute_sd, first_slice, last_slice);
d672 1
a672 1
		compute_sd, sdimage);
d684 2
a685 2
		subheader[i]->pixel_size	= atlas.pixel_size;
		subheader[i]->slice_width	= atlas.slice_separation;
d691 2
a692 2
	if (writerealimg (outfile, matval, DIM, DIM, ZATL, atlas_image, main_header, subheader) 
			== FAIL) {
a694 1

d701 1
a701 1
		if (writehdr (hdr, outfile, userid, today, processing, (short) ZATL ) == FAIL) {
a704 1

d712 1
a712 1
			== FAIL) {
a715 1

d721 1
a721 1
	if (strcmp (smg_nimage,"yes") == 0) {
d725 1
a725 1
					atlas_image [i][j][k] = nin [i][j][k];
d730 1
a730 1
				== FAIL) {
a733 1

d740 1
a740 1
		free (subheader [i]);
d753 2
a754 2
  free (atlas.xdim);
  free (atlas.ydim);
@


3.0
log
@Corrected Version with proper matrix concatenation
@
text
@d1 4
a4 1
/* $Log: t88mean.c,v $
d172 2
d186 1
a186 1
static char rcsid []= "$Id: t88mean.c,v 2.2 1994/05/10 15:33:34 tom Exp tom $"; 
@


2.2
log
@fixed bug in atlas_transform.c
eliminate use_pet
@
text
@d2 4
d167 1
a167 1
 *		Version 2.2 (10-May-94)
d181 1
a181 1
static char rcsid []= "$Id: t88mean.c,v 2.1 1994/04/29 17:37:32 tom Exp tom $"; 
a235 1
	int			temp;
@


2.1
log
@correct y-scaling when use_pet = true
@
text
@d2 3
d163 2
d177 1
a177 1
static char rcsid []= "$Id: t88mean.c,v 2.0 1994/04/28 22:31:10 tom Exp tom $"; 
a206 1
	BOOLEAN	use_pet = 0;
a269 1
	char		smg_scaletopet[10];
d334 1
a334 1
			&default_plane_separation, smg_scaletopet, &first_slice, &last_slice) == FAIL) {
d459 2
a460 3
			}
			if (strcmp (smg_scaletopet, "yes") == 0)
				use_pet = 1;
d657 1
a657 1
			use_pet, use_mask, compute_sd, first_slice, last_slice);
d748 1
a748 2
	if (compute_sd)
		free (sdimage);
d756 1
@


2.0
log
@last_slice must be <= number of slices
@
text
@d2 3
d158 2
d172 1
a172 1
static char rcsid []= "$Id: t88mean.c,v 1.99 1994/04/28 22:08:37 tom Exp tom $"; 
@


1.99
log
@added parameter slices:
@
text
@d2 3
d153 2
d167 1
a167 1
static char rcsid []= "$Id: t88mean.c,v 1.98 1994/04/12 22:09:06 tom Exp tom $"; 
@


1.98
log
@added nmask option in smg_include (changed image_scale.c)
@
text
@d2 3
d148 2
a149 1

d162 1
a162 1
static char rcsid []= "$Id: t88mean.c,v 1.97 1994/04/01 16:46:01 tom Exp tom $"; 
d246 2
d321 1
a321 1
			&default_plane_separation, smg_scaletopet) == FAIL) {
d645 1
a645 1
			use_pet, use_mask, compute_sd);
@


1.97
log
@added copyright
@
text
@d2 3
d143 3
d158 1
a158 1
static char rcsid []= "$Id: t88mean.c,v 1.96 1994/03/30 14:55:05 tom Exp $"; 
d173 2
@


1.96
log
@correct plane_separation in main_header of output image
@
text
@d2 3
d152 1
a152 1
static char rcsid []= "$Id: t88mean.c,v 1.95 1994/03/21 18:11:54 tom Exp tom $"; 
d257 2
@


1.95
log
@new libpetarc.a
@
text
@d2 3
d134 3
a136 2
 *			Rebuild with new libpetarc to recognize wobbled images with filter
cutoff.
d149 1
a149 1
static char rcsid []= "$Id: t88mean.c,v 1.94 1994/02/22 16:27:27 tom Exp tom $"; 
d650 1
@


1.94
log
@use getatlas_t88 from libhp.a
write pixel_size and slice_separation to output files
@
text
@d2 4
d130 3
d145 1
a145 1
static char rcsid []= "$Id: t88mean.c,v 1.93 1994/02/14 20:14:44 tom Exp tom $"; 
@


1.93
log
@fixed {} in symmetry
@
text
@d2 3
d123 3
d138 1
a138 1
static char rcsid []= "$Id: t88mean.c,v 1.92 1994/01/18 17:19:30 tom Exp tom $"; 
d629 1
a629 1
 *	frame_duration must be set in all subheaders
d635 4
d709 2
@


1.92
log
@new libhp
@
text
@d2 3
d118 2
d132 1
a132 1
static char rcsid []= "$Id: t88mean.c,v 1.91 1994/01/14 17:09:40 tom Exp tom $"; 
d590 1
a590 1
			else
d594 1
@


1.91
log
@OEF forced to fall 0-1.
@
text
@d2 3
d113 2
d127 1
a127 1
static char rcsid []= "$Id: t88mean.c,v 1.90 1994/01/06 19:39:46 tom Exp tom $"; 
@


1.90
log
@new libhp.a
@
text
@d2 3
d108 2
d122 1
a122 1
static char rcsid []= "$Id: t88mean.c,v 1.87 1994/01/06 19:38:51 tom Exp tom $"; 
@


1.87
log
@new libph.a
@
text
@d2 3
d117 1
a117 1
static char rcsid []= "$Id: t88mean.c,v 1.86 1994/01/05 23:48:00 tom Exp tom $"; 
@


1.86
log
@fixed process_oxygen
@
text
@d2 3
d114 1
a114 1
static char rcsid []= "$Id: t88mean.c,v 1.85 1993/11/18 21:55:59 tom Exp tom $"; 
@


1.85
log
@Rebuilt with updated libhp (to read ml-reconstructed images)
@
text
@d2 3
d97 2
d111 1
a111 1
static char rcsid []= "$Id: t88mean.c,v 1.84 1993/11/08 15:40:32 tom Exp tom $"; 
@


1.84
log
@check for sqrt(0) in image_scale.c
@
text
@d2 3
d106 1
a106 1
static char rcsid []= "$Id: t88mean.c,v 1.83 1993/11/02 21:29:28 tom Exp tom $"; 
@


1.83
log
@Rebuilt with new libhp which allows parameter "suffix" to be used
@
text
@d2 3
d89 2
d103 1
a103 1
static char rcsid []= "$Id: t88mean.c,v 1.82 1993/10/19 14:03:09 tom Exp tom $"; 
@


1.82
log
@symmetry is working for single and paired imagelists
@
text
@d2 3
d98 1
a98 1
static char rcsid []= "$Id: t88mean.c,v 1.81 1993/10/08 18:01:10 tom Exp tom $"; 
@


1.81
log
@libhp has been fixed to read PETT VI images in ECAT format in correct orientation
@
text
@d2 3
d80 3
d95 1
a95 1
static char rcsid []= "$Id: t88mean.c,v 1.80 1993/10/05 21:07:02 tom Exp tom $"; 
d551 2
d554 3
a556 1
				imgrot (image1, center, angle, sxr, nx, ny, num_slices, smg_mskpct);
@


1.80
log
@new version to flip ecat images on x-axis
@
text
@d2 3
d89 1
a89 1
static char rcsid []= "$Id: t88mean.c,v 1.78 1993/10/04 16:44:35 tom Exp tom $"; 
@


1.78
log
@eliminated atl = undefined from atlas_transform
@
text
@d2 3
d72 2
d86 1
a86 1
static char rcsid []= "$Id: t88mean.c,v 1.77 1993/10/01 16:41:34 tom Exp $"; 
@


1.77
log
@fixed calculation of sdimage
@
text
@d2 3
d64 1
a64 1
 *		Version 1.77 (30-Sep-93)
d81 1
a81 1
static char rcsid []= "$Id: t88mean.c,v 1.76 1993/09/29 16:01:52 tom Exp tom $"; 
d134 1
a134 1
	int			i, j, k, l;				/* array indices */
d363 1
a363 1
			for (l = 0; l < ZATL; ++l) {
d366 3
a368 3
     		  	atlas_image[l][j][k] = 0;
						nin[l][j][k] = 0;
     		   	if (compute_sd) sdimage[l][j][k] = 0;
@


1.76
log
@added metabolic processing and hdr files (cbf, cbv, oef, cmor2)
@
text
@d2 3
d55 1
a55 1
 *		Version 1.8 (28-Sep-93)
d61 5
d78 1
a78 1
static char rcsid []= "$Id: t88mean.c,v 1.75 1993/08/27 20:43:19 tom Exp tom $"; 
a81 1
REAL_SLICE	imagesum [ZATL];		/* sum of atlas images */
d83 1
a83 1
SHORT_SLICE	nin [ZATL];					/* number of images contributing to each element of imagesum */
d131 1
a131 1
	int			i, j, k;
d307 2
a308 2
 *	First image, first time -- get scanner and dimensions
 *	-----------------------------------------------------
d359 10
d391 1
a391 1
	}
d549 2
a550 3
		atlas_transform (image1, atlas_image, nin, sxr, atlas, use_mask, mask, center,
			angle, use_pet);
		image_sum (imagesum, atlas_image, ZATL, use_mask, mask, compute_sd, sdimage);
d558 1
a558 1
	image_scale (imagesum, nin, ZATL, lstsize, smg_divisor, smg_included, paired_images,
d573 1
a573 1
	if (writerealimg (outfile, matval, DIM, DIM, ZATL, imagesum, main_header, subheader) 
d610 1
a610 1
					imagesum [i][j][k] = nin [i][j][k];
d614 1
a614 1
		if (writerealimg (nfile, matval, DIM, DIM, ZATL, imagesum, main_header, subheader)
@


1.75
log
@added pixel_size and plane_separation to prm file list
@
text
@d2 3
d52 6
d65 1
d67 2
a68 4
#include <petutil/matrix.h>
#include <petutil/imglist.h>
#include "atlas.h"
#include "list.h"
d70 1
a70 1
static char rcsid []= "$Id: t88mean.c,v 1.7 1993/08/26 17:26:35 tom Exp tom $"; 
d95 1
a95 1
	INPUT_FILE_LIST		*scan;
d102 1
d112 8
d122 1
d140 2
d144 2
d169 2
d176 1
a176 1
	if (argc != 11) {
d185 2
d219 2
a220 1
	scan = (INPUT_FILE_LIST *) malloc (lstsize * sizeof (INPUT_FILE_LIST));
d223 2
a224 2
			smg_mask, smg_sdimage, smg_nimage, smg_symmetry, &smg_mskpct, default_pixel_size,
			default_plane_separation, smg_scaletopet) == FAIL) {
d229 7
a235 1
	if (strcmp (smg_mode, "diff") == 0)
d240 2
a241 1
	get_input_lists (prmfile, lstfile, lstsize, image_mode, &parameter_data, image_list, scan);
d243 19
a261 6

#if debug
	for (i = 0; i < lstsize; i++) {
		printf ("Activation = %s\n", scan [i].activation);
		if (strcmp (smg_mode, "paired") == 0) printf ("Control    = %s\n", scan [i].control);
		printf ("SXR        = %s\n", scan [i].sxr);
d275 6
d286 12
d304 1
a304 1
			fd = open (scan[i].activation, O_RDONLY, 0);
d306 1
a306 1
				fprintf (stderr, "Error opening %s\n", scan[i].activation);
d309 1
a309 1
			scanner = getimage_type (fd, scan[i].activation, &encoded_flag, &num_slices);
d316 1
a316 1
				fptr = OpenEcat (scan[i].activation, &num_slices, &nx, &ny, &pixel_size,
d319 1
a319 1
					fprintf (stderr, "Error: cannot open %s as an ECAT image file\n", scan[i].activation);
d336 1
a336 2
			if (strcmp (smg_mode, "paired") == 0) {
				paired_images = 1;
d338 3
d358 19
a376 1
		if (getrealimg (scan[i].activation, scanner, matval, nx, ny, num_slices, image1, 
d378 1
a378 1
			fprintf (stderr, "Error reading %s\n", scan[i].activation);
d381 3
a383 1
		recout (recfp, scan[i].activation);
d386 2
a387 5
		else
			scaler = smg_norm / image_list[i].activation_mean;
		fprintf (recfp, "Scale %s by %f\n", scan[i].activation, scaler);
		if (process_pet (image1, nx, ny, num_slices, scaler, processing, scan[i].activation) > 0) {
			fprintf (stderr, "Error processing %s\n", scan[i].activation);
d389 18
d415 19
a433 1
			if (getrealimg (scan[i].control, scanner, matval, nx, ny, num_slices, image2, 
d435 1
a435 1
				fprintf (stderr, "Error reading %s\n", scan[i].control);
d438 3
a440 1
			recout (recfp, scan[i].control);
d443 17
a459 5
			else
				scaler = smg_norm / image_list[i].control_mean;
			fprintf (recfp, "Scale %s by %f\n", scan[i].control, scaler);
			if (process_pet (image2, nx, ny, num_slices, scaler, processing, scan[i].control) > 0) {
				fprintf (stderr, "Error processing %s\n", scan[i].control);
d470 1
a470 1
			strcpy (maskfile, scan[i].activation);
d488 2
a489 2
		getsxr (scan[i].sxr, &sxr);
		fprintf (recfp,"%s\n", scan[i].sxr);
d532 2
a533 1
		atlas_transform (image1, atlas_image, nin, sxr, atlas, use_mask, mask, center, angle, use_pet);
d563 11
d614 1
a614 1
	if (strcmp (smg_mode, "paired") == 0)
d616 4
d626 1
@


1.7
log
@changed atlas y-dim to used 5 mm between brain and skull
@
text
@d2 3
d47 2
d62 1
a62 1
static char rcsid []= "$Id: t88mean.c,v 1.6 1993/08/20 20:24:07 tom Exp tom $"; 
d111 2
d196 2
a197 1
		smg_mask, smg_sdimage, smg_nimage, smg_symmetry, &smg_mskpct, smg_scaletopet) == FAIL) {
d264 6
@


1.6
log
@first version with Talairach 1988 atlas
@
text
@d2 3
d40 4
d57 1
a57 1
static char rcsid []= "$Id: t88mean.c,v 1.5 1993/08/19 22:55:48 tom Exp tom $"; 
d86 1
d132 1
d188 2
a189 2
	if (getprms_t88 (prmfile, &smg_norm, smg_divisor, smg_included, processing, 
		smg_mode, smg_mask, smg_sdimage, smg_nimage, smg_symmetry, &smg_mskpct) == FAIL) {
d269 2
d384 1
a384 1
		atlas_transform (image1, atlas_image, nin, sxr, atlas, use_mask, mask, center, angle);
@


1.5
log
@a corrected hd6mean-atlas version of t88mean
@
text
@d1 4
a4 1
/* $Log: tal88.c,v $
d33 4
d50 1
a50 1
static char rcsid []= "$Id: t88mean.c,v 1.5 1993/08/19 13:00:00 tom Exp $"; 
a144 1
	printf ("%s\n", date);
d168 1
a168 1
		printf ("Error: reading %s\n",lstfile);
d181 1
a181 1
		printf ("Error: reading parameter file %s\n",prmfile);
d206 1
a206 1
	getatlas_hd6 (&atlas);
d224 1
a224 1
				printf ("Error opening %s\n", scan[i].activation);
d230 1
a230 1
				printf ("Error: file is not a recognized PET image\n");
d237 1
a237 1
					printf ("Error: cannot open %s as an ECAT image file\n", scan[i].activation);
d268 1
a268 1
			printf ("Error reading %s\n", scan[i].activation);
d336 4
a339 4
 *	Get y,z origin (pixel indices for C-arrays) and x-angle (radians) from sxr
 *	Note:
 *		2.0 mm ought to be (but is not) subtracted from center[1] to move from the bisection of
 *		the ac-pc line to the HD6 origin, which is 2 mm anterior to the bisection. 
d363 4
a366 4
		fprintf (recfp, "Center: %9.3f %9.3f %9.3f\n", center[0], center[1], center[2]);
		fprintf (recfp, "Angle:  %9.3f %9.3f %9.3f\n", angle [0], angle [1], angle [2]);
		printf ("Center: %9.3f %9.3f %9.3f\n", center[0], center[1], center[2]);
		printf ("Angle:  %9.3f %9.3f %9.3f\n", angle [0], angle [1], angle [2]);
@
