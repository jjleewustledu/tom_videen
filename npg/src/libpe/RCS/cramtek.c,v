head	2.0;
access;
symbols;
locks; strict;
comment	@ * @;


2.0
date	2004.02.12.22.21.45;	author tom;	state Exp;
branches;
next	1.23;

1.23
date	2002.12.12.22.01.27;	author tom;	state Exp;
branches;
next	1.22;

1.22
date	99.12.14.15.56.50;	author tom;	state Exp;
branches;
next	1.21;

1.21
date	94.06.16.21.02.44;	author ty7777;	state Exp;
branches;
next	1.20;

1.20
date	94.06.14.19.54.22;	author ty7777;	state Exp;
branches;
next	1.19;

1.19
date	94.06.09.20.15.59;	author ty7777;	state Exp;
branches;
next	1.18;

1.18
date	94.06.09.19.07.32;	author ty7777;	state Exp;
branches;
next	1.17;

1.17
date	94.06.06.19.03.13;	author ty7777;	state Exp;
branches;
next	1.16;

1.16
date	94.06.06.16.49.34;	author ty7777;	state Exp;
branches;
next	1.15;

1.15
date	94.01.21.18.09.41;	author ty7777;	state Exp;
branches;
next	1.14;

1.14
date	94.01.06.21.19.08;	author ty7777;	state Exp;
branches;
next	1.13;

1.13
date	93.11.24.20.26.52;	author ty7777;	state Exp;
branches;
next	1.12;

1.12
date	93.11.24.18.46.52;	author ty7777;	state Exp;
branches;
next	1.11;

1.11
date	93.11.24.18.08.57;	author ty7777;	state Exp;
branches;
next	1.10;

1.10
date	93.11.24.17.15.52;	author ty7777;	state Exp;
branches;
next	1.9;

1.9
date	93.11.18.19.45.38;	author ty7777;	state Exp;
branches;
next	1.8;

1.8
date	93.11.18.16.54.00;	author ty7777;	state Exp;
branches;
next	1.7;

1.7
date	93.08.06.15.04.00;	author ty7777;	state Exp;
branches;
next	1.6;

1.6
date	93.03.26.21.32.29;	author ty7777;	state Exp;
branches;
next	1.5;

1.5
date	93.01.27.22.19.12;	author ty7777;	state Exp;
branches;
next	1.4;

1.4
date	92.08.21.18.57.56;	author ty7777;	state Exp;
branches;
next	1.3;

1.3
date	92.04.22.17.57.14;	author ty7777;	state Exp;
branches;
next	1.2;

1.2
date	92.04.22.15.50.53;	author ty7777;	state Exp;
branches;
next	1.1;

1.1
date	92.04.13.19.09.40;	author tom;	state Exp;
branches;
next	;


desc
@Ramtek function for spideram.
@


2.0
log
@Feb 2004
@
text
@/*$Id: cramtek.c,v 1.23 2002/12/12 22:01:27 tom Exp tom $*/
/*$Log: cramtek.c,v $
 * Revision 1.23  2002/12/12  22:01:27  tom
 * correct number of parameters in calls to XCreateSimpleWindow, XDrawArc
 *
 * Revision 1.22  1999/12/14  15:56:50  tom
 * lint cleaning
 *
 * Revision 1.21  1994/06/16  21:02:44  ty7777
 * Added libpath for assign_colors () and mapcolor ().
 *
 * Revision 1.20  1994/06/14  19:54:22  ty7777
 * Added the default colormap for PC display.
 *
 * Revision 1.19  1994/06/09  20:15:59  ty7777
 * Deleted debugging messages.
 *
 * Revision 1.18  1994/06/09  19:07:32  ty7777
 * Added processing for display image in the PC environment.
 *
 * Revision 1.17  1994/06/06  19:03:13  ty7777
 * Use pointers to pass integer values.
 *
 * Revision 1.16  1994/06/06  16:49:34  ty7777
 * Introduces x, y, width, and height for ramini ().
 *
 * Revision 1.15  1994/01/21  18:09:41  ty7777
 * Changed the window name for the display window.
 * ./
 *
 * Revision 1.14  1994/01/06  21:19:08  ty7777
 * Added ButtonReleaseMask for capturing events.
 *
 * Revision 1.13  1993/11/24  20:26:52  ty7777
 * Changed xramini ().
 *
 * Revision 1.12  1993/11/24  18:46:52  ty7777
 * Fixed error in ramexit.
 *
 * Revision 1.11  1993/11/24  18:08:57  ty7777
 * Changed ramexit.
 *
 * Revision 1.10  1993/11/24  17:15:52  ty7777
 * Added exec_command to xramexit.
 **/

/*____________________________________________________________________________
 *
 *	File Name:	cramtek.c
 *	Description:	This file contains a list of C functions to be used with
 *			FORTRAN mains for displaying images.
 *	Authors:	Tom Yang and Todd Gamble.
 *	History:	Created by Tom Yang on 01/25/1991.
 ____________________________________________________________________________*/

#ifndef lint
static char     rcsid[] = "$Header: /home/npggw/tom/src/libpe/RCS/cramtek.c,v 1.23 2002/12/12 22:01:27 tom Exp tom $";
#endif

#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>
#include <X11/Xos.h>
#include <X11/Xlib.h>
#include <X11/Xutil.h>
#include <X11/XWDFile.h>
#define  XK_LATIN1

#define lowbit(x) ((x) & (~(x) + 1))
#define BEEP_VOLUME 0

unsigned        Image_Size ();

#define RAMFONT1			"12x24romankana"
#define RAMFONT2			"-adobe-times-bold-r-normal--14-140-75-75-p-77-iso8859-1"
#define RAMTEXTHT1			24
#define RAMTEXTHT2			14
#define OVERLAY_MASK		0xFFFF
#define RAPTUREPLANE		1024
#define REGPLANE			2048
#define FIXPLANE			4095
#define TEMPPLANE			4096
#define GXOVERLAY			GXxor
#define GXSTANDARD			GXcopy
#define MAXLINE				256
#define TOTAL_COLOR_CELLS	256
#define NUM_PET_COLORS		20
#define NUM_REL_COLORS		20
#define NUM_COLORS			NUM_REL_COLORS + NUM_PET_COLORS
#define PET_COLOR_PLANES	12
#define REL_COLOR_PLANES	8
#define REL_MINIMUM			320
#define REL_ZERO			10
#define PCPET_COLOR_START	20
#define PET_COLOR_START		TOTAL_COLOR_CELLS - NUM_PET_COLORS
#define REL_COLOR_START		PET_COLOR_START - NUM_REL_COLORS

static Display *display;
static int      screen;
static GC       gc;
static Window   ramtek;
static int		border_width;
static u_long   border;
static u_long   background;
static XSetWindowAttributes ramtekA;
static XFontStruct *font_struct1;
static XFontStruct *font_struct2;
static XEvent   event;
static Colormap AppColormap;
static u_long   pc_colors[NUM_COLORS];

void            assign_colors_ ();
void            mapcolor_ ();

void            xramini_ (xstart, ystart, width, height, tbl_number, pcflag, libpath)
	int            *xstart;
	int            *ystart;
	int            *width;
	int            *height;
	int            *tbl_number;
	int            *pcflag;			 /* 1: Displayed on PC */
	char           *libpath;
{
	XSizeHints      myhint;
	int             err;

	display = XOpenDisplay (0);
	if (display == NULL) {
		fprintf (stderr, "Can't create window on %s\n", getenv ("DISPLAY"));
		exit (1);
	}
	screen = DefaultScreen (display);
	border = BlackPixel (display, screen);
	background = BlackPixel (display, screen);

	/* default program-specified window position and size */
	myhint.x = *xstart;
	myhint.y = *ystart;
	myhint.width = *width;
	myhint.height = *height;
	myhint.flags = PPosition | PSize;

	ramtek = XCreateSimpleWindow (display, RootWindow (display, screen),
				      *xstart, *ystart, *width, *height, border_width, border, background);

	XSetStandardProperties (display, ramtek, "Washington University Neuroscience PET Group",
				"Ramtek", None, None, 0, &myhint);

	ramtekA.backing_store = WhenMapped;
	ramtekA.background_pixel = background;
	XChangeWindowAttributes (display, ramtek, CWBackingStore | CWBackPixel, &ramtekA);

	/*
	 * Input event selection
	 */
	XSelectInput (display, ramtek, ButtonPressMask | PointerMotionHintMask
		      | KeyPressMask | ButtonMotionMask | ButtonReleaseMask);

	XMapRaised (display, ramtek);

	gc = XCreateGC (display, ramtek, 0, 0);

	font_struct1 = XLoadQueryFont (display, RAMFONT1);
	font_struct2 = XLoadQueryFont (display, RAMFONT2);

	if (*tbl_number != -1 && *tbl_number != 40 && *tbl_number != 41
	    && *tbl_number != 42 && *tbl_number != 46)
		*tbl_number = -1;
	if (*pcflag)
		assign_colors_ (tbl_number, &err, libpath);
	else
		mapcolor_ (tbl_number, &err, libpath);
}

void            xramrst_ ()
{
	XWindowAttributes attribs;		 /* window attributes */

	XSetFunction (display, gc, GXSTANDARD);
	XSetForeground (display, gc, BlackPixel (display, screen));
	XGetWindowAttributes (display, ramtek, &attribs);
	XFillRectangle (display, ramtek, gc, 0, 0, attribs.width, attribs.height);
	XFlush (display);
}

void            xramexit_ (sys_command, exec_command)
	char           *sys_command;
	int            *exec_command;
{
	XFreeFont (display, font_struct1);
	XFreeFont (display, font_struct2);
	XFreeGC (display, gc);
	XDestroyWindow (display, ramtek);
	XCloseDisplay (display);

	if (*exec_command == 1)
		(void) system (sys_command);
	exit (0);
}

/*_______________________________________________________________________________
	Called by:	RAMWRITE in framtex.f
	Author:		Tom Yang
	Date:		09/25/1991
  _______________________________________________________________________________*/
void            xramwrite_ (p_x, p_y, p_orientation, p_planes, p_text, p_fcode)
	int            *p_x, *p_y;		 /* location to start string */
	int            *p_orientation;		 /* horizonatal=0 or vertical=4 */
	int            *p_planes;		 /* color to write */
	char           *p_text;			 /* text to write, terminated by "~" */
	short          *p_fcode;		 /* 1: font1; 2: font2 */
{
	int             x, y, cx, cy, orientation, planes;
	unsigned int    cwidth, cheight;
	char           *text;
	short           fcode;
	int             i;
	int             length;
	unsigned long   foreground;
	XFontStruct    *font_struct;
	int             direction_hint;
	int             font_ascent;
	int             font_descent;
	XCharStruct     overall;
	short           font_height;

	x = *p_x;
	y = *p_y;
	orientation = *p_orientation;
	planes = *p_planes;
	text = (char *) p_text;
	fcode = *p_fcode;

	length = strcspn (text, "~");
	if (length == 0)
		return;

	if (fcode == 1) {
		font_struct = font_struct1;
		font_height = RAMTEXTHT1;
	} else {
		font_struct = font_struct2;
		font_height = RAMTEXTHT2;
	}

	XSetFont (display, gc, font_struct->fid);
	XTextExtents (font_struct, text, length, &direction_hint, &font_ascent,
		      &font_descent, &overall);

	switch (planes) {
	case REGPLANE:
	case TEMPPLANE:
		XSetFunction (display, gc, GXOVERLAY);
		foreground = OVERLAY_MASK;
		break;
	case RAPTUREPLANE:
		XSetFunction (display, gc, GXOVERLAY);
		foreground = WhitePixel (display, screen);
		break;
	case FIXPLANE:
		XSetFunction (display, gc, GXSTANDARD);
		foreground = WhitePixel (display, screen);
		break;
	default:
		fprintf (stderr, "\nxramwrite:unsupported planes parameter: %d\n", planes);
		exit (1);
	}


	cx = x + overall.lbearing;
	cy = y;
	y += overall.ascent;

	switch (orientation) {
	case 0:
		if (planes == FIXPLANE) {
			cwidth = overall.rbearing - overall.lbearing;
			cheight = overall.ascent + overall.descent;
			XClearArea (display, ramtek, cx, cy, cwidth, cheight, False);
		}
		XSetForeground (display, gc, foreground);
		XDrawString (display, ramtek, gc, x, y, text, length);
		break;
	case 4:
		if (planes == FIXPLANE) {
			cwidth = (overall.rbearing - overall.lbearing) / length;
			cheight = length * font_height;
			XClearArea (display, ramtek, cx, cy, cwidth, cheight, False);
		}
		XSetForeground (display, gc, foreground);
		for (i = 0; i < length; i++) {
			XDrawString (display, ramtek, gc, x, y + (font_height * i), text + i, 1);
		}
		break;
	default:
		fprintf (stderr, "xramwrite: unsupported orientation %d\n", orientation);
		exit (1);
	}
	XFlush (display);
}

/*_______________________________________________________________________________
	Called by:	RAMCLEAR in framtek.f
	Author:		Tom Yang
	Date:		09/25/1991
  _______________________________________________________________________________*/
void            xramclear_ (p_x, p_y, p_orientation, p_text, p_length, p_fcode)
	int            *p_x, *p_y;		 /* location to start string */
	int            *p_orientation;		 /* horizonatal=0 or vertical=4 */
	char            p_text[];		 /* text to write */
	int            *p_length;
	short          *p_fcode;
{
	int             x, y, orientation;
	unsigned int    width, height;
	char           *text;
	char           *real_text;
	int             length;
	short           fcode;
	XFontStruct    *font_struct;
	int             direction_hint;
	int             font_ascent;
	int             font_descent;
	XCharStruct     overall;
	short           font_height;

	x = *p_x;
	y = *p_y;
	orientation = *p_orientation;
	text = (char *) p_text;
	fcode = *p_fcode;

	length = *p_length + 1;
	if (fcode == 1) {
		font_struct = font_struct1;
		font_height = RAMTEXTHT1;
	} else {
		font_struct = font_struct2;
		font_height = RAMTEXTHT2;
	}
	XSetFont (display, gc, font_struct->fid);
	real_text = (char *) malloc (length);
	strncpy (real_text, text, length);
	XTextExtents (font_struct, real_text, length, &direction_hint, &font_ascent,
		      &font_descent, &overall);

	switch (orientation) {
	case 0:
		x += overall.lbearing;
		width = overall.rbearing - overall.lbearing;
		height = overall.ascent + overall.descent;
		break;
	case 4:
		x += overall.lbearing;
		width = (overall.rbearing - overall.lbearing) / length;
		height = length * font_height;
		break;
	default:
		fprintf (stderr, "xramwrite: unsupported orientation %d\n", orientation);
		exit (1);
	}
	XClearArea (display, ramtek, x, y, width, height, False);
	free (real_text);

	XFlush (display);
}

/*_______________________________________________________________________________
	Name:		clrect_
	Description:	Clear a rectangle area on screen. The unit is pixel.
	Author:		Tom Yang
	Date:		09/25/1991
  _______________________________________________________________________________*/
void            clrect_ (p_x, p_y, p_width, p_height)
	int            *p_x, *p_y;
	int            *p_width, *p_height;
{
	int             x, y;
	unsigned int    width, height;

	x = *p_x;
	y = *p_y;
	width = *p_width;
	height = *p_height;

	XClearArea (display, ramtek, x, y, width, height, False);
}

/*_______________________________________________________________________________
	Called by:	c2colabs.f
	Author:		Tom Yang
	Date:		09/24/1991
  _______________________________________________________________________________*/
void            mapcolor_ (tbl_number, err, table_path)
	int            *tbl_number;
	int            *err;
	char           *table_path;
{
	void            fitoa ();
	Colormap        cmap;
	Colormap        dcmap;
	FILE           *tblfile;
	Visual         *visual;
	XColor          temp;
	char            red, green, blue;
	char            tblext[5];
	char            tblname[MAXLINE];
	int             i;
	unsigned int    j;
	int             length;
	int             tblnum;

	length = strcspn (table_path, " ");
	memset (tblname, 0, sizeof (tblname));
	strncpy (tblname, table_path, length);
	strcat (tblname, "/colortbl.");

	tblnum = *tbl_number;
	*err = 0;
	if (tblnum == -1)
		strcat (tblname, "def");
	else {
		fitoa (tblnum, tblext);
		strcat (tblname, tblext);
	}

	visual = XDefaultVisual (display, screen);
	dcmap = XDefaultColormap (display, screen);

	cmap = XCreateColormap (display, ramtek, visual, AllocAll);
	temp.flags = DoRed | DoGreen | DoBlue;

	for (i = 0; i < REL_COLOR_START; i++) {
		temp.pixel = i;
		XQueryColor (display, dcmap, &temp);
		XStoreColor (display, cmap, &temp);
	}

	tblfile = fopen (tblname, "r");
	if (tblfile == NULL) {
		*err = -1;
		perror ("fopen");
		return;
	}
	for (i = 0; i < NUM_COLORS; i++) {
		fscanf (tblfile, "%x", &j);
		blue = j & 0x00F;
		green = (j & 0x0F0) >> 4;
		red = (j & 0xF00) >> 8;

		temp.blue = (int) (((float) blue / 0xF) * 0xFFFF);
		temp.green = (int) (((float) green / 0xF) * 0xFFFF);
		temp.red = (int) (((float) red / 0xF) * 0xFFFF);
		temp.pixel = REL_COLOR_START + i;

		XStoreColor (display, cmap, &temp);
	}
	fclose (tblfile);

	XSetWindowColormap (display, ramtek, cmap);
	AppColormap = cmap;
}

/*_______________________________________________________________________________
	Called by:	c2colabs.f
	Author:		Tom Yang
	Date:		09/24/1991
  _______________________________________________________________________________*/
void            assign_colors_ (tbl_number, err, table_path)
	int            *tbl_number;
	int            *err;
	char           *table_path;
{
	void            fitoa ();
	Colormap        dcmap;
	FILE           *tblfile;
	XColor          temp;
	char            red, green, blue;
	char            tblext[5];
	char            tblname[MAXLINE];
	int             i;
	unsigned int    j;
	int             length;
	int             tblnum;

	length = strcspn (table_path, " ");
	memset (tblname, 0, sizeof (tblname));
	strncpy (tblname, table_path, length);
	strcat (tblname, "/colortbl.");

	tblnum = *tbl_number;
	*err = 0;
	if (tblnum == -1)
		strcat (tblname, "def");
	else {
		fitoa (tblnum, tblext);
		strcat (tblname, tblext);
	}

	dcmap = XDefaultColormap (display, screen);
	tblfile = fopen (tblname, "r");
	if (tblfile == NULL) {
		*err = -1;
		perror ("fopen");
		return;
	}
	for (i = 0; i < NUM_COLORS; i++) {
		fscanf (tblfile, "%x", &j);
		blue = j & 0x00F;
		green = (j & 0x0F0) >> 4;
		red = (j & 0xF00) >> 8;

		temp.blue = (int) (((float) blue / 0xF) * 0xFFFF);
		temp.green = (int) (((float) green / 0xF) * 0xFFFF);
		temp.red = (int) (((float) red / 0xF) * 0xFFFF);

		if (XAllocColor (display, dcmap, &temp) == 0) {
			fprintf (stderr, "Error in allocating color (%x, %x, %x).\n",
				 blue, green, red);
		}
		pc_colors[i] = temp.pixel;
	}
	fclose (tblfile);

	AppColormap = dcmap;
}

/*_______________________________________________________________________________
	Called by:	RAMIMG in framtek.f
	Author:		Tom Yang
	Date:		09/24/1991
  _______________________________________________________________________________*/
xramimg_ (image, p_ydim, p_xdim, p_yst, p_xst, p_scan, type, pcflag, absscale_flag)
	short          *image;
	int            *p_xdim, *p_ydim;
	int            *p_xst, *p_yst;
	int            *p_scan, *type;
	int            *pcflag;			 /* 1: Displayed on PC */
	char           *absscale_flag;
{
	int             ydim, xdim, yst, xst;
	int             i, j, depth, format, bitmap_pad;
	XImage         *imageptr;
	u_char         *imagebuf;
	char            color_index;
	short           raw_pixel_value;

	ydim = *p_ydim;
	xdim = *p_xdim;
	yst = *p_yst;
	xst = *p_xst;

	imagebuf = (u_char *) malloc (xdim * ydim);

	for (i = 0; i < xdim; i++) {
		for (j = 0; j < ydim; j++) {
			raw_pixel_value = *(image + (ydim * i) + j);
			if (*absscale_flag) {
				color_index = raw_pixel_value / PET_COLOR_PLANES;
				if (color_index >= NUM_PET_COLORS)
					color_index = NUM_PET_COLORS - 1;
				else if (color_index < 0)
					color_index = 0;
				if (*pcflag) {
					color_index = pc_colors[color_index
								+ PCPET_COLOR_START];
				} else {
					color_index += PET_COLOR_START;
				}
			} else {
				color_index = (raw_pixel_value - REL_MINIMUM)
					/ REL_COLOR_PLANES;
				if (color_index >= NUM_REL_COLORS)
					color_index = NUM_REL_COLORS - 1;
				else if (color_index < 0)
					color_index = REL_ZERO;
				if (*pcflag) {
					color_index = pc_colors[color_index];
				} else {
					color_index += REL_COLOR_START;
				}
			}
			*(imagebuf + (xdim * j) + i) = color_index;
		}
	}

	depth = DefaultDepth (display, screen);
	format = ZPixmap;
	bitmap_pad = 8;

	imageptr = XCreateImage (display, DefaultVisual (display, screen),
				 depth, format, 0, imagebuf, ydim, xdim, bitmap_pad, ydim);
	XSetFunction (display, gc, GXSTANDARD);
	XPutImage (display, ramtek, gc, imageptr, 0, 0, yst, xst, ydim, xdim);
	XDestroyImage (imageptr);
	return 0;
}

void            xramcir_ (p_cx, p_cy, p_radius, p_planes)
	long           *p_cx, *p_cy;		 /* center of circle */
	long           *p_radius;		 /* radius of circle */
	long           *p_planes;		 /* color */
{
	int             cx, cy, radius, planes;
	unsigned long   foreground;

	cx = *p_cx;
	cy = *p_cy;
	radius = *p_radius;
	planes = *p_planes;

	switch (planes) {
	case REGPLANE:
	case TEMPPLANE:
		XSetFunction (display, gc, GXOVERLAY);
		foreground = OVERLAY_MASK;
		break;
	case RAPTUREPLANE:
		XSetFunction (display, gc, GXOVERLAY);
		foreground = WhitePixel (display, screen);
		break;
	case FIXPLANE:
		XSetFunction (display, gc, GXSTANDARD);
		foreground = WhitePixel (display, screen);
		break;
	default:
		fprintf (stderr, "\nxramlin: unsupported planes parameter: %d\n", planes);
		exit (1);
	}

	XSetForeground (display, gc, foreground);
	XSetLineAttributes (display, gc, 1, LineSolid, CapButt, JoinMiter);
	XDrawArc (display, ramtek, gc, cx - radius, cy - radius, cx + radius, cy + radius, 0, 0);
	XFlush (display);
}


void            xramlin_ (p_x1, p_y1, p_x2, p_y2, p_planes)
	long           *p_x1, *p_y1;		 /* first point on line */
	long           *p_x2, *p_y2;		 /* last point on line */
	long           *p_planes;		 /* color */
{
	int             x1, y1, x2, y2, planes;
	unsigned long   foreground;

	x1 = *p_x1;
	y1 = *p_y1;
	x2 = *p_x2;
	y2 = *p_y2;
	planes = *p_planes;

	switch (planes) {
	case REGPLANE:
	case TEMPPLANE:
		XSetFunction (display, gc, GXOVERLAY);
		foreground = OVERLAY_MASK;
		break;
	case RAPTUREPLANE:
		XSetFunction (display, gc, GXOVERLAY);
		foreground = WhitePixel (display, screen);
		break;
	case FIXPLANE:
		XSetFunction (display, gc, GXSTANDARD);
		foreground = WhitePixel (display, screen);
		break;
	default:
		fprintf (stderr, "\nxramlin: unsupported planes parameter: %d\n", planes);
		exit (1);
	}

	XSetForeground (display, gc, foreground);
	XSetLineAttributes (display, gc, 1, LineSolid, CapButt, JoinMiter);
	XDrawLine (display, ramtek, gc, x1, y1, x2, y2);
	XFlush (display);
}

void            xrampoint_ (p_x, p_y, p_planes)
	long           *p_x, *p_y;		 /* point to draw */
	long           *p_planes;		 /* color */
{
	int             x, y, planes;
	unsigned long   foreground;

	x = *p_x;
	y = *p_y;
	planes = *p_planes;

	switch (planes) {
	case REGPLANE:
	case TEMPPLANE:
		XSetFunction (display, gc, GXOVERLAY);
		foreground = OVERLAY_MASK;
		break;
	case RAPTUREPLANE:
		XSetFunction (display, gc, GXOVERLAY);
		foreground = WhitePixel (display, screen);
		break;
	case FIXPLANE:
		XSetFunction (display, gc, GXSTANDARD);
		foreground = WhitePixel (display, screen);
		break;
	default:
		fprintf (stderr, "\nxrampoint: unsupported planes parameter: %d\n", planes);
		exit (1);
	}

	XSetForeground (display, gc, foreground);
	XDrawPoint (display, ramtek, gc, x, y);
	XFlush (display);
}

void            xramerase_ (p_x1, p_y1, p_x2, p_y2, p_planes)
	long           *p_x1, *p_y1;		 /* first point on line */
	long           *p_x2, *p_y2;		 /* last point on line */
	long           *p_planes;		 /* color */
{
	int             x1, y1, x2, y2, planes;
	unsigned long   foreground;

	x1 = *p_x1;
	y1 = *p_y1;
	x2 = *p_x2;
	y2 = *p_y2;
	planes = *p_planes;

	switch (planes) {
	case REGPLANE:
	case TEMPPLANE:
		XSetFunction (display, gc, GXOVERLAY);
		foreground = OVERLAY_MASK;
		break;
	case RAPTUREPLANE:
		XSetFunction (display, gc, GXOVERLAY);
		foreground = WhitePixel (display, screen);
		break;
	case FIXPLANE:
		XSetFunction (display, gc, GXSTANDARD);
		foreground = BlackPixel (display, screen);
		break;
	default:
		XSetFunction (display, gc, GXSTANDARD);
		foreground = BlackPixel (display, screen);
		break;
	}

	XSetForeground (display, gc, foreground);
	XFillRectangle (display, ramtek, gc, x1, y1, x2 - x1 + 1, y2 - y1 + 1);
	XFlush (display);
}

void            xrambers_ (xstart, ystart, width, height, p_planes)
	int            *xstart;
	int            *ystart;
	int            *width;
	int            *height;
	long           *p_planes;		 /* color */
{
	int             planes;
	unsigned long   foreground;

	planes = *p_planes;

	switch (planes) {
	case REGPLANE:
	case TEMPPLANE:
		XSetFunction (display, gc, GXOVERLAY);
		foreground = OVERLAY_MASK;
		break;
	case RAPTUREPLANE:
		XSetFunction (display, gc, GXOVERLAY);
		foreground = WhitePixel (display, screen);
		break;
	case FIXPLANE:
		XSetFunction (display, gc, GXSTANDARD);
		foreground = BlackPixel (display, screen);
		break;
	default:
		XSetFunction (display, gc, GXSTANDARD);
		foreground = BlackPixel (display, screen);
		break;
	}

	XSetForeground (display, gc, foreground);
	XFillRectangle (display, ramtek, gc, *xstart, *ystart, *width, *height);
	XFlush (display);
}

xgetpad_ (x, y, flag)
	int            *x;
	int            *y;
	int             flag[4];
{
	Window          child;
	Window          root;
	int             i;
	int             root_x;
	int             root_y;
	int             win_x;
	int             win_y;
	u_int           keys_buttons;
	u_int           test;

	for (i = 0; i < 4; i++)
		flag[i] = 0;

	/*
	 * Read the next event
	 */
	XNextEvent (display, &event);

	switch (event.type) {
	case ButtonPress:
		*x = event.xbutton.x;
		*y = event.xbutton.y;
		flag[0] = 1;
		flag[3] = 1;
		break;
	case MotionNotify:
		XQueryPointer (display, ramtek, &root, &child, &root_x, &root_y,
			       &win_x, &win_y, &keys_buttons);
		*x = win_x;
		*y = win_y;
		test = keys_buttons & Button1Mask;
		if ((keys_buttons == test) && keys_buttons != 0) {
			flag[1] = 1;
			flag[3] = 1;
		}
		break;
	case ButtonRelease:
		*x = event.xbutton.x;
		*y = event.xbutton.y;
		flag[2] = 1;
		break;
	}
	return 0;
}

void            xwdchck_ (flag)
	char           *flag;
{
	int             i;
	char            c;

	/* Read the next event */
	XNextEvent (display, &event);

	switch (event.type) {
	case KeyPress:
		i = XLookupString (&event.xkey, &c, 1, NULL, NULL);
		if ((i == 1) && ((c == 's') || (c == 'S'))) {
			*flag = True;
		} else {
			*flag = False;
		}
	}
}

/*________________________________________________________________________
 * windump_: dump a window to a file which must already be open for
 *              writting.
 ________________________________________________________________________*/

void            windump_ (region_flag, rx, ry, rwidth, rheight, dump_file_name, length)
	Bool           *region_flag;
	int            *rx, *ry;
	unsigned int   *rwidth, *rheight;
	char           *dump_file_name;
	int            *length;
{
	void            Beep ();
	void            Error ();
	void            outl ();
	void            _swaplong ();
	void            _swapshort ();
	int             getcolors_ ();
	FILE           *out;
	int             format = ZPixmap;
	Bool            nobdrs = True;
	Bool            debug = False;
	long            add_pixel_value = 0;
	unsigned long   swaptest = 1;
	XColor         *colors;
	unsigned        buffer_size;
	int             win_name_size;
	int             header_size;
	int             ncolors, i;
	char           *win_name;
	Bool            got_win_name;
	XWindowAttributes win_info;
	XImage         *image;
	int             absx = 0, absy = 0;
	int             x, y;
	unsigned        width, height;
	int             dwidth, dheight;
	int             bw;
	Window          dummywin;
	XWDFileHeader   header;
	char            dump_name[40];

	strncpy (dump_name, dump_file_name, *length);
	dump_name[*length] = '\0';

	/*
	 * Inform the user not to alter the screen.
	 */
	Beep (display);

	if ((out = fopen (dump_name, "w")) == NULL) {
		printf ("Cannot open file %s\n", dump_name);
		return;
	}

	/*
	 * Get the parameters of the window being dumped.
	 */
	if (debug)
		outl ("xwd: Getting target window information.\n");
	if (!XGetWindowAttributes (display, ramtek, &win_info))
		Error ("Can't get target window attributes.");

	/*
	 * Handle any frame window.
	 */
	if (!XTranslateCoordinates (display, ramtek, RootWindow (display, screen), 0, 0,
				    &absx, &absy, &dummywin)) {
		fprintf (stderr,
			 "unable to translate window coordinates (%d,%d)\n",
			 absx, absy);
		exit (1);
	}
	win_info.x = absx;
	win_info.y = absy;
	width = win_info.width;
	height = win_info.height;
	bw = 0;

	if (!nobdrs) {
		bw = win_info.border_width;
		absx -= bw;
		absy -= bw;
		width += (2 * bw);
		height += (2 * bw);
	}
	dwidth = DisplayWidth (display, screen);
	dheight = DisplayHeight (display, screen);

	/*
	 * Clip to window.
	 */
	if (absx < 0) {
		width += absx;
		absx = 0;
	}
	if (absy < 0) {
		height += absy;
		absy = 0;
	}
	if (absx + width > dwidth)
		width = dwidth - absx;
	if (absy + height > dheight)
		height = dheight - absy;

	XFetchName (display, ramtek, &win_name);
	if (!win_name || !win_name[0]) {
		win_name = "xwdump";
		got_win_name = False;
	} else {
		got_win_name = True;
	}

	/*
	 * sizeof(char) is included for the null string terminator.
	 */
	win_name_size = strlen (win_name) + sizeof (char);

	/*
	 * Snarf the pixmap with XGetImage.
	 */

	if (!(*region_flag)) {
		x = absx - win_info.x;
		y = absy - win_info.y;
	} else {
		x = *rx;
		y = *ry;
		width = *rwidth;
		height = *rheight;
	}

	image = XGetImage (display, ramtek, x, y, width, height, AllPlanes, format);
	if (!image) {
		fprintf (stderr, "unable to get image at %dx%d+%d+%d\n",
			 width, height, x, y);
		exit (1);
	}
	if (add_pixel_value != 0)
		XAddPixel (image, add_pixel_value);

	/*
	 * Determine the pixmap size.
	 */
	buffer_size = Image_Size (image);

	if (debug)
		outl ("xwd: Getting Colors.\n");

	ncolors = getcolors_ (display, &win_info, &colors);

	/*
	 * Inform the user that the image has been retrieved.
	 */
	XBell (display, BEEP_VOLUME);
	XBell (display, BEEP_VOLUME);
	XFlush (display);

	/*
	 * Calculate header size.
	 */
	if (debug)
		outl ("xwd: Calculating header size.\n");
	header_size = sizeof (header) + win_name_size;

	/*
	 * Write out header information.
	 */
	if (debug)
		outl ("xwd: Constructing and dumping file header.\n");
	header.header_size = (CARD32) header_size;
	header.file_version = (CARD32) XWD_FILE_VERSION;
	header.pixmap_format = (CARD32) format;
	header.pixmap_depth = (CARD32) image->depth;
	header.pixmap_width = (CARD32) image->width;
	header.pixmap_height = (CARD32) image->height;
	header.xoffset = (CARD32) image->xoffset;
	header.byte_order = (CARD32) image->byte_order;
	header.bitmap_unit = (CARD32) image->bitmap_unit;
	header.bitmap_bit_order = (CARD32) image->bitmap_bit_order;
	header.bitmap_pad = (CARD32) image->bitmap_pad;
	header.bits_per_pixel = (CARD32) image->bits_per_pixel;
	header.bytes_per_line = (CARD32) image->bytes_per_line;
	header.visual_class = (CARD32) win_info.visual->class;
	header.red_mask = (CARD32) win_info.visual->red_mask;
	header.green_mask = (CARD32) win_info.visual->green_mask;
	header.blue_mask = (CARD32) win_info.visual->blue_mask;
	header.bits_per_rgb = (CARD32) win_info.visual->bits_per_rgb;
	header.colormap_entries = (CARD32) win_info.visual->map_entries;
	header.ncolors = ncolors;
	header.window_width = (CARD32) win_info.width;
	header.window_height = (CARD32) win_info.height;
	header.window_x = absx;
	header.window_y = absy;
	header.window_bdrwidth = (CARD32) win_info.border_width;

	if (*(char *) &swaptest) {
		_swaplong ((char *) &header, sizeof (header));
		for (i = 0; i < ncolors; i++) {
			_swaplong ((char *) &colors[i].pixel, sizeof (long));
			_swapshort ((char *) &colors[i].red, 3 * sizeof (short));
		}
	}
	(void) fwrite ((char *) &header, sizeof (header), 1, out);
	(void) fwrite (win_name, win_name_size, 1, out);

	/*
	 * Write out the color maps, if any
	 */

	if (debug)
		outl ("xwd: Dumping %d colors.\n", ncolors);
	(void) fwrite ((char *) colors, sizeof (XColor), ncolors, out);

	/*
	 * Write out the buffer.
	 */
	if (debug)
		outl ("xwd: Dumping pixmap.  bufsize=%d\n", buffer_size);

	/*
	 * This copying of the bit stream (data) to a file is to be replaced by an Xlib call which
	 * hasn't been written yet.  It is not clear what other functions of xwd will be taken over
	 * by this (as yet) non-existant X function.
	 */
	(void) fwrite (image->data, (int) buffer_size, 1, out);

	fclose (out);

	/*
	 * free the color buffer.
	 */

	if (debug && ncolors > 0)
		outl ("xwd: Freeing colors.\n");
	if (ncolors > 0)
		free (colors);

	/*
	 * Free window name string.
	 */
	if (debug)
		outl ("xwd: Freeing window name string.\n");
	if (got_win_name)
		XFree (win_name);

	/*
	 * Free image
	 */
	XDestroyImage (image);
}


/*
 * Get the XColors of all pixels in image - returns # of colors
 */
int             getcolors_ (display, win_info, colors)
	Display        *display;
	XWindowAttributes *win_info;
	XColor        **colors;
{
	void            Error ();
	int             i, ncolors;
	unsigned long   red, green, blue, red1, green1, blue1;

	if (!win_info->colormap)
		return (0);

	if (win_info->visual->class == TrueColor)
		return (0);			 /* colormap is not needed */

	ncolors = win_info->visual->map_entries;
	if (!(*colors = (XColor *) malloc (sizeof (XColor) * ncolors)))
		Error ("Out of memory!");

	if (win_info->visual->class == DirectColor) {

		/*
		 * Pixel red, green, blue, red1, green1, blue1;
		 */

		red = green = blue = 0;
		red1 = lowbit (win_info->visual->red_mask);
		green1 = lowbit (win_info->visual->green_mask);
		blue1 = lowbit (win_info->visual->blue_mask);
		for (i = 0; i < ncolors; i++) {
			(*colors)[i].pixel = red | green | blue;
			(*colors)[i].pad = 0;

			red += red1;
			if (red > win_info->visual->red_mask)
				red = 0;

			green += green1;
			if (green > win_info->visual->green_mask)
				green = 0;

			blue += blue1;
			if (blue > win_info->visual->blue_mask)
				blue = 0;
		}
	} else {
		for (i = 0; i < ncolors; i++) {
			(*colors)[i].pixel = i;
			(*colors)[i].pad = 0;
		}
	}

	XQueryColors (display, AppColormap, *colors, ncolors);

	return (ncolors);
}

/*__________________________________________________________________________
 * outl: a debugging routine.  Flushes stdout then prints a message on stderr
 *       and flushes stderr.  Used to print messages when past certain points
 *       in code so we can tell where we are.  Outl may be invoked like
 *       printf with up to 7 arguments.
  ___________________________________________________________________________*/
void            outl (msg, arg0, arg1, arg2, arg3, arg4, arg5, arg6)
	char           *msg;
	char           *arg0, *arg1, *arg2, *arg3, *arg4, *arg5, *arg6;
{
	fflush (stdout);
	fprintf (stderr, msg, arg0, arg1, arg2, arg3, arg4, arg5, arg6);
	fprintf (stderr, "\n");
	fflush (stderr);
	return;
}

/*
 * Beep: Routine to beep the display.
 */
void            Beep (display)
	Display        *display;
{
	XBell (display, -50);
	return;
}

unsigned        Image_Size (image)
	XImage         *image;
{
	if (image->format != ZPixmap)
		return (image->bytes_per_line * image->height * image->depth);
	return ((unsigned) image->bytes_per_line * image->height);
}

void            Error (string)
	char           *string;
{
	fprintf (stderr, "xwud: Error => %s\n", string);
	exit (1);
	return;
}

void            _swapshort (bp, n)
	register char  *bp;
	register unsigned n;
{
	register char   c;
	register char  *ep = bp + n;

	while (bp < ep) {
		c = *bp;
		*bp = *(bp + 1);
		bp++;
		*bp++ = c;
	}
	return;
}

void            _swaplong (bp, n)
	register char  *bp;
	register unsigned n;
{
	register char   c;
	register char  *ep = bp + n;
	register char  *sp;

	while (bp < ep) {
		sp = bp + 3;
		c = *sp;
		*sp = *bp;
		*bp++ = c;
		sp = bp + 1;
		c = *sp;
		*sp = *bp;
		*bp++ = c;
		bp += 2;
	}
	return;
}
@


1.23
log
@correct number of parameters in calls to XCreateSimpleWindow, XDrawArc
@
text
@d1 1
a1 1
/*$Id: cramtek.c,v 1.22 1999/12/14 15:56:50 tom Exp tom $*/
d3 3
d57 1
a57 1
static char     rcsid[] = "$Header: /home/npggw/tom/src/libpe/RCS/cramtek.c,v 1.22 1999/12/14 15:56:50 tom Exp tom $";
@


1.22
log
@lint cleaning
@
text
@d1 1
a1 1
/*$Id: cramtek.c,v 1.21 1994/06/16 21:02:44 ty7777 Exp tom $*/
d3 3
d54 1
a54 1
static char     rcsid[] = "$Header: /home/npggw/tom/src/libpe/RCS/cramtek.c,v 1.21 1994/06/16 21:02:44 ty7777 Exp tom $";
d99 1
d141 1
a141 1
				      *xstart, *ystart, *width, *height, border, background);
d630 1
a630 1
	XDrawArc (display, ramtek, gc, cx - radius, cy - radius, cx + radius, cy + radius);
@


1.21
log
@Added libpath for assign_colors () and mapcolor ().
@
text
@d1 1
a1 1
/*$Id: cramtek.c,v 1.20 1994/06/14 19:54:22 ty7777 Exp ty7777 $*/
d3 3
a43 1
 *
d46 1
a46 3
 *
 *	Authors:	Tom Yang and Todd Gamble. 
 *
d48 1
a48 2
 *
____________________________________________________________________________*/
d50 7
a59 1
#include <stdio.h>
a61 3
#include <X11/keysymdef.h>
#include <sys/types.h>
#include <values.h>
d66 1
a66 2
extern char	*malloc();
unsigned	Image_Size ();
d68 5
a72 7
static char rcsid [] = "$Header: /home/petsun4/ty7777/src/libpe/RCS/cramtek.c,v 1.20 1994/06/14 19:54:22 ty7777 Exp ty7777 $";

#define RAMFONT1		"12x24romankana"
#define RAMFONT2		"-adobe-times-bold-r-normal--14-140-75-75-p-77-iso8859-1"
#define RAMTEXTHT1		24
#define RAMTEXTHT2		14
#define OVERLAY_MASK		0xFFFF   
d74 7
a80 7
#define REGPLANE		2048
#define FIXPLANE		4095
#define TEMPPLANE		4096
#define GXOVERLAY		GXxor
#define GXSTANDARD		GXcopy
#define MAXLINE			256
#define TOTAL_COLOR_CELLS       256  
d83 1
a83 1
#define NUM_COLORS		NUM_REL_COLORS + NUM_PET_COLORS
d86 2
a87 2
#define REL_MINIMUM		320
#define REL_ZERO		10
d92 12
a103 12
static	Display			*display;
static	int			screen;
static	GC			gc;
static	Window 			ramtek;
static	u_long 			border;
static	u_long 			background;
static	XSetWindowAttributes 	ramtekA;
static	XFontStruct		*font_struct1;
static	XFontStruct		*font_struct2;
static	XEvent			event;
static	Colormap		AppColormap;
static	u_long 			pc_colors [NUM_COLORS];
d105 2
a106 2
void	assign_colors_();
void	mapcolor_();
d108 8
a115 8
void xramini_(xstart, ystart, width, height, tbl_number, pcflag, libpath)
int	*xstart;
int	*ystart;
int	*width;
int	*height;
int	*tbl_number;
int	*pcflag;			/* 1: Displayed on PC */
char	*libpath;		
d117 2
a118 2
	XSizeHints	myhint;
	int		err;
d120 2
a121 3
	display	= XOpenDisplay (0);
	if (display == NULL) 
	{
d125 3
a128 4
	screen		= DefaultScreen (display);
	border		= BlackPixel (display, screen);
	background	= BlackPixel (display, screen);

d130 5
a134 5
	myhint.x	= *xstart;
	myhint.y	= *ystart;
	myhint.width	= *width;
	myhint.height	= *height;
	myhint.flags	= PPosition | PSize;
d136 2
a137 2
	ramtek		= XCreateSimpleWindow (display, RootWindow (display, screen),
			*xstart, *ystart, *width, *height, border, background);
d140 1
a140 1
                            "Ramtek", None, None, 0, &myhint);
d142 2
a143 2
	ramtekA.backing_store		= WhenMapped;
	ramtekA.background_pixel	= background;
d146 2
a147 2
	/* 
	 * Input event selection 
d149 2
a150 2
	XSelectInput (display, ramtek, ButtonPressMask | PointerMotionHintMask 
			| KeyPressMask | ButtonMotionMask | ButtonReleaseMask);
d156 2
a157 2
	font_struct1	= XLoadQueryFont (display, RAMFONT1);
	font_struct2	= XLoadQueryFont (display, RAMFONT2);
d159 3
a161 3
	if (*tbl_number != -1 && *tbl_number != 40 && *tbl_number != 41 
	&& *tbl_number != 42 && *tbl_number != 46)
		*tbl_number	= -1;
d163 1
a163 1
		assign_colors_(tbl_number, &err, libpath);
d165 1
a165 1
		mapcolor_(tbl_number, &err, libpath);
d168 1
a168 1
void	xramrst_()
d170 1
a170 1
	XWindowAttributes	attribs;	/* window attributes */
d179 3
a181 3
void	xramexit_(sys_command, exec_command)
char	*sys_command;
int	*exec_command;
a182 2
	int	stat;

d190 1
a190 4
	{
		stat	= system (sys_command);
	}

d198 7
a204 7
_______________________________________________________________________________*/
void	xramwrite_(p_x, p_y, p_orientation, p_planes, p_text, p_fcode)
int 	*p_x, *p_y;		/* location to start string */
int	*p_orientation;		/* horizonatal=0 or vertical=4 */
int	*p_planes;		/* color to write */
char	*p_text;		/* text to write, terminated by "~" */
short	*p_fcode;		/* 1: font1; 2: font2 */
d206 13
a218 14
	int		x, y, cx, cy, orientation, planes;
	unsigned int	cwidth, cheight;
	char		*text;
	short		fcode;
	int		i;
	int		length;
	char		*c;
	int		foreground;
	XFontStruct	*font_struct;
	int		direction_hint;
	int		font_ascent;
	int		font_descent;
	XCharStruct	overall;
	short		font_height;
d220 6
a225 6
	x		= *p_x;
	y		= *p_y;
	orientation	= *p_orientation;
	planes		= *p_planes;
	text		= (char *) p_text;
	fcode		= *p_fcode;
d227 1
a227 1
	length		= strcspn (text, "~");
d231 6
a236 4
	if (fcode == 1)
	{
		font_struct	= font_struct1;
		font_height	= RAMTEXTHT1;
a237 5
	else 
	{
		font_struct	= font_struct2;
		font_height	= RAMTEXTHT2;
	}
d241 1
a241 1
			&font_descent, &overall);
d243 18
a260 20
	switch (planes) 
	{
		case REGPLANE:
		case TEMPPLANE:
			XSetFunction (display, gc, GXOVERLAY);
			foreground = OVERLAY_MASK;
			break;
		case RAPTUREPLANE:
			XSetFunction (display, gc, GXOVERLAY);
			foreground = WhitePixel (display, screen); 
			break;
		case FIXPLANE:
			XSetFunction (display, gc, GXSTANDARD);
			foreground = WhitePixel (display, screen); 
			break;
		default:
			fprintf (stderr, "\nxramwrite:unsupported planes parameter: %d\n", planes);
			exit (1);
	}		
		
a261 3
	cx	= x + overall.lbearing;
	cy	= y;
	y	+= overall.ascent;
d263 3
a265 9
	switch (orientation) 
	{
		case 0 : 	
			if (planes	== FIXPLANE)
			{
				cwidth	=  overall.rbearing - overall.lbearing; 
				cheight	=  overall.ascent + overall.descent;
				XClearArea (display, ramtek, cx, cy, cwidth, cheight, False);
			}
d267 24
a290 20
			XSetForeground (display, gc, foreground);
			XDrawString (display, ramtek, gc, x, y, text, length);
			break;
		case 4 :
			if (planes	== FIXPLANE)
			{
				cwidth	=  (overall.rbearing - overall.lbearing) / length; 
				cheight	=  length * font_height;
				XClearArea (display, ramtek, cx, cy, cwidth, cheight, False);
			}

			XSetForeground (display, gc, foreground);
			for (i = 0; i < length; i++) 
			{
				XDrawString (display, ramtek, gc, x, y + (font_height * i), text + i, 1);
			}
			break;
		default:
			fprintf (stderr, "xramwrite: unsupported orientation %d\n", orientation);
			exit (1);
d299 7
a305 7
_______________________________________________________________________________*/
void	xramclear_(p_x, p_y, p_orientation, p_text, p_length, p_fcode)
int 	*p_x, *p_y;		/* location to start string */
int	*p_orientation;		/* horizonatal=0 or vertical=4 */
char	p_text [];		/* text to write */
int	*p_length;
short	*p_fcode;
d307 12
a318 12
	int		x, y, orientation;
	unsigned int	width, height;
	char		*text;
	char		*real_text;
	int		length;
	short		fcode;
	XFontStruct	*font_struct;
	int		direction_hint;
	int		font_ascent;
	int		font_descent;
	XCharStruct	overall;
	short		font_height;
d320 5
a324 5
	x		= *p_x;
	y		= *p_y;
	orientation	= *p_orientation;
	text		= (char *) p_text;
	fcode		= *p_fcode;
d326 7
a332 5
	length		= *p_length + 1;
	if (fcode == 1)
	{
		font_struct	= font_struct1;
		font_height	= RAMTEXTHT1;
a333 5
	else 
	{
		font_struct	= font_struct2;
		font_height	= RAMTEXTHT2;
	}
d335 1
a335 1
	real_text	= (char *) malloc (length);
d338 1
a338 1
			&font_descent, &overall);
d340 14
a353 15
	switch (orientation) 
	{
		case 0 : 	
			x	+= overall.lbearing;
			width	=  overall.rbearing - overall.lbearing; 
			height	=  overall.ascent + overall.descent;
			break;
		case 4 :
			x	+= overall.lbearing;
			width	=  (overall.rbearing - overall.lbearing) / length; 
			height	=  length * font_height;
			break;
		default:
			fprintf (stderr, "xramwrite: unsupported orientation %d\n", orientation);
			exit (1);
d356 1
a356 1
	free  (real_text);
d366 4
a369 4
_______________________________________________________________________________*/
void	clrect_ (p_x, p_y, p_width, p_height)
int 	*p_x, *p_y;		
int 	*p_width, *p_height;	
d371 2
a372 2
	int		x, y;
	int		width, height;
d374 4
a377 4
	x		= *p_x;
	y		= *p_y;
	width		= *p_width;
	height		= *p_height;
d386 5
a390 5
_______________________________________________________________________________*/
void mapcolor_(tbl_number, err, table_path)
int  	*tbl_number;
int	*err;
char	*table_path;
d392 13
a404 11
	Colormap	cmap;
	Colormap	dcmap;
	FILE		*tblfile;
	Visual		*visual;
	XColor		temp;
	char		red, green, blue;
	char		tblext [5];
	char		tblname [MAXLINE];
	int 		i, j;
	int		length;
	int 		tblnum;
d406 1
a406 1
	length	= strcspn (table_path, " ");
d411 3
a413 3
	tblnum	= *tbl_number;
	*err	= 0;
	if (tblnum == -1) 
d415 1
a415 2
	else 
	{
d420 2
a421 2
	visual		= XDefaultVisual (display, screen);
	dcmap		= XDefaultColormap (display, screen);
d423 2
a424 2
	cmap		= XCreateColormap (display, ramtek, visual, AllocAll); 
	temp.flags	= DoRed | DoGreen | DoBlue;
d426 2
a427 3
	for (i = 0; i < REL_COLOR_START; i++)
	{
		temp.pixel	= i;
d433 1
a433 2
	if (tblfile == NULL) 
	{
d438 1
a438 3

	for (i = 0; i < NUM_COLORS; i++) 
	{
d440 3
a442 3
		blue	= j & 0x00F;
		green	= (j & 0x0F0) >> 4;
		red	= (j & 0xF00) >> 8;
d444 4
a447 4
		temp.blue	= (int) (((float) blue / 0xF) * 0xFFFF);
		temp.green	= (int) (((float) green / 0xF) * 0xFFFF);
		temp.red	= (int) (((float) red / 0xF) * 0xFFFF);
		temp.pixel	= REL_COLOR_START + i;
d450 1
a450 1
	}		
d454 1
a454 1
	AppColormap	= cmap;
d461 5
a465 5
_______________________________________________________________________________*/
void assign_colors_(tbl_number, err, table_path)
int  	*tbl_number;
int	*err;
char	*table_path;
d467 11
a477 11
	Colormap	cmap;
	Colormap	dcmap;
	FILE		*tblfile;
	XColor		temp;
	char		*lpath;
	char		red, green, blue;
	char		tblext [5];
	char		tblname [MAXLINE];
	int 		i, j;
	int		length;
	int 		tblnum;
d479 1
a479 1
	length	= strcspn (table_path, " ");
d484 3
a486 3
	tblnum	= *tbl_number;
	*err	= 0;
	if (tblnum == -1) 
d488 1
a488 2
	else 
	{
d493 3
a495 4
	dcmap	= XDefaultColormap (display, screen);
	tblfile	= fopen (tblname, "r");
	if (tblfile == NULL) 
	{
d500 1
a500 3

	for (i = 0; i < NUM_COLORS; i++) 
	{
d502 3
a504 3
		blue	= j & 0x00F;
		green	= (j & 0x0F0) >> 4;
		red	= (j & 0xF00) >> 8;
d506 3
a508 3
		temp.blue	= (int) (((float) blue / 0xF) * 0xFFFF);
		temp.green	= (int) (((float) green / 0xF) * 0xFFFF);
		temp.red	= (int) (((float) red / 0xF) * 0xFFFF);
d510 1
a510 2
		if (XAllocColor (display, dcmap, &temp) == 0)
		{
d512 1
a512 1
			blue, green, red);
d514 2
a515 3

		pc_colors [i]	= temp.pixel;
	}		
d518 1
a518 1
	AppColormap	= dcmap;
d525 8
a532 8
_______________________________________________________________________________*/
xramimg_(image, p_ydim, p_xdim, p_yst, p_xst, p_scan, type, pcflag, absscale_flag)
short	*image;
int	*p_xdim, *p_ydim;
int	*p_xst, *p_yst;
int	*p_scan, *type;
int	*pcflag;			/* 1: Displayed on PC */
char	*absscale_flag;
d534 6
a539 7
	int	ydim, xdim, yst, xst, scan;
	int 	i, j, err, depth, format, bitmap_pad;
	int	ctbl;
	XImage 	*imageptr;
	u_char 	*imagebuf;
	char	color_index;
	short	raw_pixel_value;
d541 4
a544 5
	ydim	= *p_ydim;
	xdim	= *p_xdim;
	yst	= *p_yst;
	xst	= *p_xst;
	scan	= *p_scan;
d546 1
a546 1
	imagebuf	= (u_char *) malloc (xdim * ydim); 
d548 5
a552 8
	for (i = 0; i < xdim; i++)
	{
		for (j = 0; j < ydim; j++)
		{
			raw_pixel_value	= *(image + (ydim * i) + j);
			if (*absscale_flag)
			{
				color_index	= raw_pixel_value / PET_COLOR_PLANES;
d554 1
a554 1
					color_index	= NUM_PET_COLORS - 1;
d556 6
a561 5
					color_index	= 0;
				if (*pcflag)
				{
					color_index	= pc_colors [color_index 
							+ PCPET_COLOR_START];
d563 3
a565 9
				else
				{
					color_index	+= PET_COLOR_START;
				}
			}
			else
			{
				color_index	= (raw_pixel_value - REL_MINIMUM) 
								/ REL_COLOR_PLANES;
d567 1
a567 1
					color_index	= NUM_REL_COLORS - 1;
d569 5
a573 4
					color_index	= REL_ZERO;
				if (*pcflag)
				{
					color_index	= pc_colors [color_index];
a574 4
				else
				{
					color_index	+= REL_COLOR_START;
				}
d576 1
a576 1
			*(imagebuf + (xdim * j) + i)	= color_index;
d580 3
a582 3
	depth		= DefaultDepth (display, screen); 
	format		= ZPixmap;
	bitmap_pad	= 8;
d584 2
a585 2
	imageptr	= XCreateImage (display, DefaultVisual (display, screen),
				depth, format, 0, imagebuf, ydim, xdim, bitmap_pad, ydim);
a587 1

d589 1
d592 4
a595 4
void xramcir_(p_cx, p_cy, p_radius, p_planes)
long	*p_cx, *p_cy;			/* center of circle */
long	*p_radius;			/* radius of circle */
long	*p_planes;			/* color */
d597 2
a598 2
	int cx, cy, radius, planes;
	int foreground;
d600 4
a603 4
	cx	= *p_cx;
	cy	= *p_cy;
	radius	= *p_radius;
	planes	= *p_planes;
d605 19
a623 20
	switch (planes) 
	{
		case REGPLANE:
		case TEMPPLANE:
			XSetFunction (display, gc, GXOVERLAY);
			foreground = OVERLAY_MASK;
			break;
		case RAPTUREPLANE:
			XSetFunction (display, gc, GXOVERLAY);
			foreground = WhitePixel (display, screen); 
			break;
		case FIXPLANE:
			XSetFunction (display, gc, GXSTANDARD);
			foreground = WhitePixel (display, screen); 
			break;
		default:
			fprintf (stderr, "\nxramlin: unsupported planes parameter: %d\n", planes);
			exit (1);
	}		
		
d631 4
a634 4
void xramlin_(p_x1, p_y1, p_x2, p_y2, p_planes)
long	*p_x1, *p_y1;			/* first point on line */
long	*p_x2, *p_y2;			/* last point on line */
long	*p_planes;			/* color */
d636 2
a637 2
	int x1, y1, x2, y2, planes;
	int foreground;
d639 5
a643 5
	x1	= *p_x1;
	y1	= *p_y1;
	x2	= *p_x2;
	y2	= *p_y2;
	planes	= *p_planes;
d645 19
a663 20
	switch (planes) 
	{
		case REGPLANE:
		case TEMPPLANE:
			XSetFunction (display, gc, GXOVERLAY);
			foreground = OVERLAY_MASK;
			break;
		case RAPTUREPLANE:
			XSetFunction (display, gc, GXOVERLAY);
			foreground = WhitePixel (display, screen); 
			break;
		case FIXPLANE:
			XSetFunction (display, gc, GXSTANDARD);
			foreground = WhitePixel (display, screen); 
			break;
		default:
			fprintf (stderr, "\nxramlin: unsupported planes parameter: %d\n", planes);
			exit (1);
	}		
		
d670 3
a672 3
void xrampoint_(p_x, p_y, p_planes)
long	*p_x, *p_y;			/* point to draw */
long	*p_planes;			/* color */
d674 2
a675 2
	int x, y, planes;
	int foreground;
d677 3
a679 3
	x	= *p_x;
	y	= *p_y;
	planes	= *p_planes;
d681 19
a699 20
	switch (planes) 
	{
		case REGPLANE:
		case TEMPPLANE:
			XSetFunction (display, gc, GXOVERLAY);
			foreground = OVERLAY_MASK;
			break;
		case RAPTUREPLANE:
			XSetFunction (display, gc, GXOVERLAY);
			foreground = WhitePixel (display, screen); 
			break;
		case FIXPLANE:
			XSetFunction (display, gc, GXSTANDARD);
			foreground = WhitePixel (display, screen); 
			break;
		default:
			fprintf (stderr, "\nxrampoint: unsupported planes parameter: %d\n", planes);
			exit (1);
	}		
		
d705 4
a708 4
void xramerase_(p_x1, p_y1, p_x2, p_y2, p_planes)
long	*p_x1, *p_y1;			/* first point on line */
long	*p_x2, *p_y2;			/* last point on line */
long	*p_planes;			/* color */
d710 2
a711 2
	int	x1, y1, x2, y2, planes;
	int	foreground;
d713 5
a717 5
	x1	= *p_x1;
	y1	= *p_y1;
	x2	= *p_x2;
	y2	= *p_y2;
	planes	= *p_planes;
d719 20
a738 21
	switch (planes) 
	{
		case REGPLANE:
		case TEMPPLANE:
			XSetFunction (display, gc, GXOVERLAY);
			foreground = OVERLAY_MASK;
			break;
		case RAPTUREPLANE:
			XSetFunction (display, gc, GXOVERLAY);
			foreground = WhitePixel (display, screen); 
			break;
		case FIXPLANE:
			XSetFunction (display, gc, GXSTANDARD);
			foreground = BlackPixel (display, screen); 
			break;
		default:
			XSetFunction (display, gc, GXSTANDARD); 
			foreground = BlackPixel (display, screen); 
			break;
	}		
		
d744 6
a749 6
void xrambers_ (xstart, ystart, width, height, p_planes)
	int	*xstart;
	int	*ystart;
	int	*width;
	int	*height;
	long	*p_planes;		/* color */
d751 2
a752 2
	int	planes;
	int	foreground;
d754 1
a754 1
	planes	= *p_planes;
d756 20
a775 21
	switch (planes) 
	{
		case REGPLANE:
		case TEMPPLANE:
			XSetFunction (display, gc, GXOVERLAY);
			foreground = OVERLAY_MASK;
			break;
		case RAPTUREPLANE:
			XSetFunction (display, gc, GXOVERLAY);
			foreground = WhitePixel (display, screen); 
			break;
		case FIXPLANE:
			XSetFunction (display, gc, GXSTANDARD);
			foreground = BlackPixel (display, screen); 
			break;
		default:
			XSetFunction (display, gc, GXSTANDARD); 
			foreground = BlackPixel (display, screen); 
			break;
	}		
		
d780 5
a784 5
   
xgetpad_(x, y, flag)
	int	*x; 
	int	*y; 
	int	flag [4];
d786 9
a794 9
	Window	child;
	Window	root;
	int	i;
	int	root_x; 
	int	root_y;
	int	win_x; 
	int	win_y;
	u_int	keys_buttons;
	u_int	test;
d797 1
a797 1
		flag [i]	= 0;
d799 2
a800 2
	/* 
	 * Read the next event 
d804 23
a826 25
	switch (event.type)
	{
		case ButtonPress:
			*x = event.xbutton.x; 
			*y = event.xbutton.y; 
			flag [0]	= 1;
			flag [3]	= 1;
			break;
		case MotionNotify:
			XQueryPointer (display, ramtek, &root, &child, &root_x, &root_y, 
				&win_x, &win_y, &keys_buttons);
			*x	= win_x;
			*y	= win_y;
			test	= keys_buttons & Button1Mask;
			if ((keys_buttons == test) && keys_buttons != 0)
			{
				flag [1]	= 1;
				flag [3]	= 1;
			}
			break;
		case ButtonRelease:
			*x = event.xbutton.x; 
			*y = event.xbutton.y; 
			flag [2]	= 1;
			break;
d828 1
d831 2
a832 2
void xwdchck_ (flag)
char	*flag;
d834 2
a835 2
	int	i;
	char	c;
d840 8
a847 12
	switch (event.type)
	{
		case KeyPress:
	    		i = XLookupString(&event.xkey, &c, 1, NULL, NULL);
	    		if ((i == 1) && ((c == 's') || (c == 'S'))) 
			{
				*flag	= True;
	    		}
			else
			{
				*flag	= False;
			}
d856 6
a861 6
void windump_ (region_flag, rx, ry, rwidth, rheight, dump_file_name, length)
	Bool		*region_flag;
	int		*rx, *ry;
	unsigned int	*rwidth, *rheight;
	char		*dump_file_name;
	int		*length;
d863 29
a891 23
	FILE			*out;
	int			format = ZPixmap;
	Bool			nobdrs = True;
	Bool			standard_out = True;
	Bool			debug = False;
	long			add_pixel_value = 0;
	unsigned long		swaptest = 1;
	XColor			*colors;
	unsigned		buffer_size;
	int			win_name_size;
	int			header_size;
	int			ncolors, i;
	char			*win_name;
	Bool			got_win_name;
	XWindowAttributes	win_info;
	XImage			*image;
	int			absx, absy, x, y;
	unsigned		width, height;
	int			dwidth, dheight;
	int			bw;
	Window			dummywin;
	XWDFileHeader		header;
	char			dump_name[40];
d901 1
a901 2
	if ((out	= fopen (dump_name, "w")) == NULL)
	{
d909 4
a912 4
	if (debug) 
		outl("xwd: Getting target window information.\n");
	if(!XGetWindowAttributes (display, ramtek, &win_info)) 
		Error("Can't get target window attributes.");
d914 2
a915 2
	/* 
	 * Handle any frame window. 
d918 4
a921 5
				&absx, &absy, &dummywin)) 
	{
		fprintf (stderr, 
			"unable to translate window coordinates (%d,%d)\n",
			absx, absy);
d924 5
d930 6
a935 13
	win_info.x	= absx;
	win_info.y	= absy;
	width		= win_info.width;
	height		= win_info.height;
	bw		= 0;

	if (!nobdrs) 
	{
		bw	= win_info.border_width;
		absx	-= bw;
		absy	-= bw;
		width	+= (2 * bw);
		height	+= (2 * bw);
d937 2
d940 2
a941 5
	dwidth	= DisplayWidth (display, screen);
	dheight	= DisplayHeight (display, screen);

	/* 
	 * Clip to window. 
d943 3
a945 4
	if (absx < 0) 
	{
		width	+= absx; 
		absx	= 0;
d947 3
a949 5

	if (absy < 0) 
	{
		height	+= absy; 
		absy	= 0;
d951 4
a955 5
	if (absx + width > dwidth) 
		width	= dwidth - absx;
	if (absy + height > dheight) 
		height	= dheight - absy;

d957 5
a961 8
	if (!win_name || !win_name[0]) 
	{
		win_name	= "xwdump";
		got_win_name	= False;
	} 
	else 
	{
		got_win_name	= True;
d964 2
a965 2
	/* 
	 * sizeof(char) is included for the null string terminator. 
d967 1
a967 1
	win_name_size	= strlen(win_name) + sizeof(char);
d973 8
a980 4
	if (!(*region_flag))
	{
		x	= absx - win_info.x;
		y	= absy - win_info.y;
a981 7
	else
	{
		x	= *rx;
		y	= *ry;
		width	= *rwidth;
		height	= *rheight;
	}
d983 2
a984 3
	image	= XGetImage (display, ramtek, x, y, width, height, AllPlanes, format);
	if (!image) 
	{
d986 1
a986 1
			width, height, x, y);
d989 1
a989 2

	if (add_pixel_value != 0) 
d995 1
a995 1
	buffer_size	= Image_Size(image);
d997 2
a998 2
	if (debug) 
		outl("xwd: Getting Colors.\n");
d1000 1
a1000 1
	ncolors	= getcolors_ (display, &win_info, &colors);
d1012 3
a1014 3
	if (debug) 
		outl("xwd: Calculating header size.\n");
	header_size	= sizeof(header) + win_name_size;
d1019 27
a1045 27
	if (debug) 
		outl("xwd: Constructing and dumping file header.\n");
	header.header_size	= (CARD32) header_size;
	header.file_version	= (CARD32) XWD_FILE_VERSION;
	header.pixmap_format	= (CARD32) format;
	header.pixmap_depth	= (CARD32) image->depth;
	header.pixmap_width	= (CARD32) image->width;
	header.pixmap_height	= (CARD32) image->height;
	header.xoffset		= (CARD32) image->xoffset;
	header.byte_order	= (CARD32) image->byte_order;
	header.bitmap_unit	= (CARD32) image->bitmap_unit;
	header.bitmap_bit_order	= (CARD32) image->bitmap_bit_order;
	header.bitmap_pad	= (CARD32) image->bitmap_pad;
	header.bits_per_pixel	= (CARD32) image->bits_per_pixel;
	header.bytes_per_line	= (CARD32) image->bytes_per_line;
	header.visual_class	= (CARD32) win_info.visual->class;
	header.red_mask		= (CARD32) win_info.visual->red_mask;
	header.green_mask	= (CARD32) win_info.visual->green_mask;
	header.blue_mask	= (CARD32) win_info.visual->blue_mask;
	header.bits_per_rgb	= (CARD32) win_info.visual->bits_per_rgb;
	header.colormap_entries	= (CARD32) win_info.visual->map_entries;
	header.ncolors		= ncolors;
	header.window_width	= (CARD32) win_info.width;
	header.window_height	= (CARD32) win_info.height;
	header.window_x		= absx;
	header.window_y		= absy;
	header.window_bdrwidth	= (CARD32) win_info.border_width;
d1047 5
a1051 7
	if (*(char *) &swaptest) 
	{
		_swaplong((char *) &header, sizeof(header));
		for (i = 0; i < ncolors; i++) 
		{
			_swaplong((char *) &colors[i].pixel, sizeof(long));
			_swapshort((char *) &colors[i].red, 3 * sizeof(short));
d1054 2
a1056 3
	(void) fwrite((char *)&header, sizeof(header), 1, out);
	(void) fwrite(win_name, win_name_size, 1, out);

d1061 3
a1063 3
	if (debug) 
		outl("xwd: Dumping %d colors.\n", ncolors);
	(void) fwrite((char *) colors, sizeof(XColor), ncolors, out);
d1068 2
a1069 2
	if (debug) 
		outl("xwd: Dumping pixmap.  bufsize=%d\n",buffer_size);
d1072 3
a1074 4
	 *    This copying of the bit stream (data) to a file is to be replaced
	 *  by an Xlib call which hasn't been written yet.  It is not clear
	 *  what other functions of xwd will be taken over by this (as yet)
	 *  non-existant X function.
d1076 1
a1076 1
	(void) fwrite(image->data, (int) buffer_size, 1, out);
d1084 3
a1086 3
	if (debug && ncolors > 0) 
		outl("xwd: Freeing colors.\n");
	if (ncolors > 0) 
d1092 4
a1095 4
	if (debug) 
		outl("xwd: Freeing window name string.\n");
	if (got_win_name) 
		XFree(win_name);
d1100 1
a1100 1
	XDestroyImage(image);
d1107 4
a1110 4
int getcolors_ (display, win_info, colors)
	Display			*display;
	XWindowAttributes	*win_info;
	XColor			**colors;
d1112 3
a1114 2
	int		i, ncolors;
	unsigned long	red, green, blue, red1, green1, blue1;
d1117 1
a1117 1
		return(0);
d1120 1
a1120 1
		return(0);    /* colormap is not needed */
d1122 1
a1122 1
	ncolors	= win_info->visual->map_entries;
d1124 1
a1124 1
		Error("Out of memory!");
d1126 2
a1127 2
	if (win_info->visual->class == DirectColor) 
	{
d1129 2
a1130 2
		Pixel red, green, blue, red1, green1, blue1;
		*/
d1133 6
a1138 7
		red1 = lowbit(win_info->visual->red_mask);
		green1 = lowbit(win_info->visual->green_mask);
		blue1 = lowbit(win_info->visual->blue_mask);
		for (i = 0; i < ncolors; i++) 
		{
			(*colors)[i].pixel	= red|green|blue;
			(*colors)[i].pad	= 0;
d1140 1
a1140 1
			red			+= red1;
d1142 1
a1142 1
				red	= 0;
d1144 1
a1144 1
			green	+= green1;
d1146 1
a1146 1
				green	= 0;
d1148 1
a1148 1
			blue	+= blue1;
d1152 4
a1155 7
	} 
	else 
	{
		for (i=0; i<ncolors; i++) 
		{
			(*colors)[i].pixel	= i;
			(*colors)[i].pad	= 0;
d1160 1
a1160 1
    
d1169 4
a1172 4
___________________________________________________________________________*/
outl (msg, arg0, arg1, arg2, arg3, arg4, arg5, arg6)
	char	*msg;
	char	*arg0, *arg1, *arg2, *arg3, *arg4, *arg5, *arg6;
d1174 5
a1178 4
	fflush(stdout);
	fprintf(stderr, msg, arg0, arg1, arg2, arg3, arg4, arg5, arg6);
	fprintf(stderr, "\n");
	fflush(stderr);
d1184 2
a1185 2
Beep (display)
	Display	*display;
d1187 2
a1188 1
	XBell(display, -50);
d1191 2
a1192 2
unsigned Image_Size(image)
	XImage	*image;
d1195 2
a1196 3
		return(image->bytes_per_line * image->height * image->depth);

	return((unsigned)image->bytes_per_line * image->height);
d1199 2
a1200 2
Error(string)
	char *string;
d1202 3
a1204 2
	fprintf(stderr, "xwud: Error => %s\n", string);
	exit(1);
d1207 3
a1209 3
_swapshort (bp, n)
	register char		*bp;
	register unsigned	n;
d1211 2
a1212 2
	register char	c;
	register char	*ep = bp + n;
d1214 3
a1216 4
	while (bp < ep) 
	{
		c	= *bp;
		*bp	= *(bp + 1);
d1218 1
a1218 1
		*bp++	= c;
d1220 1
d1223 3
a1225 3
_swaplong (bp, n)
	register char		*bp;
	register unsigned	n;
d1227 3
a1229 3
	register char	c;
	register char	*ep = bp + n;
	register char	*sp;
d1231 10
a1240 11
	while (bp < ep) 
	{
		sp	= bp + 3;
		c	= *sp;
		*sp	= *bp;
		*bp++	= c;
		sp	= bp + 1;
		c	= *sp;
		*sp	= *bp;
		*bp++	= c;
		bp	+= 2;
d1242 1
@


1.20
log
@Added the default colormap for PC display.
@
text
@d1 1
a1 1
/*$Id: cramtek.c,v 1.19 1994/06/09 20:15:59 ty7777 Exp $*/
d3 3
d67 1
a67 1
static char rcsid [] = "$Header: /usr/local/src/libpe/RCS/cramtek.c,v 1.19 1994/06/09 20:15:59 ty7777 Exp $";
d80 1
a80 1
#define MAX_COLORNAME_LENGTH	50
d109 1
a109 1
void xramini_(xstart, ystart, width, height, tbl_number, pcflag)
d116 1
a121 1

a159 1

d166 1
a166 1
		assign_colors_(tbl_number, &err);
d168 1
a168 1
		mapcolor_(tbl_number, &err);
d410 1
a410 1
void mapcolor_(tbl_number, err)
d413 1
a414 7
	int 		tblnum;
	char		tblname [MAX_COLORNAME_LENGTH];
	char		*tblprefix	= "/usr/local/lib/spideram/colortbl.";
	char		tblext[5];
	int 		i, j;
	FILE* 		tblfile;
	Visual		*visual;
d417 3
d421 5
a425 1
	XColor		temp;
d427 5
a433 2
	memset (tblname, 0, sizeof (tblname));
	strcpy (tblname, tblprefix);
d488 1
a488 1
void assign_colors_(tbl_number, err)
d491 1
a492 6
	int 		tblnum;
	char		tblname [MAX_COLORNAME_LENGTH];
	char		*tblprefix	= "/usr/local/lib/spideram/colortbl.";
	char		tblext[5];
	int 		i, j;
	FILE* 		tblfile;
d495 3
d499 5
a503 1
	XColor		temp;
d505 5
a511 2
	memset (tblname, 0, sizeof (tblname));
	strcpy (tblname, tblprefix);
@


1.19
log
@Deleted debugging messages.
@
text
@d1 1
a1 1
/*$Id: cramtek.c,v 1.18 1994/06/09 19:07:32 ty7777 Exp ty7777 $*/
d3 3
d64 1
a64 1
static char rcsid [] = "$Header: /home/petsun4/ty7777/src/libpe/RCS/cramtek.c,v 1.18 1994/06/09 19:07:32 ty7777 Exp ty7777 $";
d112 1
a112 1
char	*pcflag;			/* 1: Displayed on PC */
d164 2
a166 2
	else
		assign_colors_(tbl_number, &err);
d538 2
@


1.18
log
@Added processing for display image in the PC environment.
@
text
@d1 1
a1 1
/*$Id: cramtek.c,v 1.17 1994/06/06 19:03:13 ty7777 Exp ty7777 $*/
d3 3
d61 1
a61 1
static char rcsid [] = "$Header: /home/petsun4/ty7777/src/libpe/RCS/cramtek.c,v 1.17 1994/06/06 19:03:13 ty7777 Exp ty7777 $";
a530 1
printf ("i = %d (%x, %x, %x)\n", i + 1, temp.red, temp.green, temp.blue);
@


1.17
log
@Use pointers to pass integer values.
@
text
@d1 1
a1 1
/*$Id: cramtek.c,v 1.16 1994/06/06 16:49:34 ty7777 Exp ty7777 $*/
d3 3
d58 1
a58 1
static char rcsid [] = "$Header: /home/petsun4/ty7777/src/libpe/RCS/cramtek.c,v 1.16 1994/06/06 16:49:34 ty7777 Exp ty7777 $";
d80 1
d95 1
d97 1
d100 1
a100 1
void xramini_(xstart, ystart, width, height, tbl_number)
d106 1
d140 3
a142 1
	/* Input event selection */
d157 4
a160 1
	mapcolor_(tbl_number, &err);
d472 64
d540 1
a540 1
xramimg_(image, p_ydim, p_xdim, p_yst, p_xst, p_scan, type, absscale_flag)
d545 1
d565 1
d574 11
a584 1
				color_index	+= PET_COLOR_START;
d594 8
a601 1
				color_index	+= REL_COLOR_START;
d605 1
@


1.16
log
@Introduces x, y, width, and height for ramini ().
@
text
@d1 1
a1 1
/*$Id: cramtek.c,v 1.15 1994/01/21 18:09:41 ty7777 Exp ty7777 $*/
d3 3
d55 1
a55 1
static char rcsid [] = "$Header$";
d94 5
a98 5
void xramini_(xstart, ystart, dwidth, dheight, tbl_number)
int	xstart;
int	ystart;
int	dwidth;
int	dheight;
d117 4
a120 4
	myhint.x	= xstart;
	myhint.y	= ystart;
	myhint.width	= dwidth;
	myhint.height	= dheight;
d124 1
a124 1
			xstart, ystart, dwidth, dheight, border, background);
d679 5
a683 5
void xrambers_ (xstart, ystart, dwidth, dheight, p_planes)
	int	xstart;
	int	ystart;
	int	dwidth;
	int	dheight;
d713 1
a713 1
	XFillRectangle (display, ramtek, gc, xstart, ystart, dwidth, dheight);
@


1.15
log
@Changed the window name for the display window.
./
@
text
@d1 1
a1 1
/*$Id: cramtek.c,v 1.14 1994/01/06 21:19:08 ty7777 Exp ty7777 $*/
d3 4
d52 1
a52 1
static char rcsid [] = "$Id: cramtek.c,v 1.14 1994/01/06 21:19:08 ty7777 Exp ty7777 $";
a53 4
#define RAMWIDTH		1200
#define RAMHEIGHT		1000
#define STARTX			0
#define STARTY			20
d91 5
a95 1
void	xramini_(tbl_number)
d114 4
a117 4
	myhint.x	= STARTX;
	myhint.y	= STARTY;
	myhint.width	= RAMWIDTH;
	myhint.height	= RAMHEIGHT;
d121 1
a121 1
			STARTX, STARTY, RAMWIDTH, RAMHEIGHT, border, background);
d676 5
a680 1
void xrambers_ (p_planes)
d710 1
a710 1
	XFillRectangle (display, ramtek, gc, STARTX, STARTY, RAMWIDTH, RAMHEIGHT);
@


1.14
log
@Added ButtonReleaseMask for capturing events.
@
text
@d1 1
a1 1
/*$Id: cramtek.c,v 1.13 1993/11/24 20:26:52 ty7777 Exp ty7777 $*/
d3 3
d48 1
a48 1
static char rcsid [] = "$Id: cramtek.c,v 1.13 1993/11/24 20:26:52 ty7777 Exp ty7777 $";
d119 1
a119 1
	XSetStandardProperties (display, ramtek, "RAMTEK Display Window",
@


1.13
log
@Changed xramini ().
@
text
@d1 1
a1 1
/*$Id: cramtek.c,v 1.12 1993/11/24 18:46:52 ty7777 Exp ty7777 $*/
d3 3
d16 13
d45 1
a45 1
static char rcsid [] = "$Id: cramtek.c,v 1.12 1993/11/24 18:46:52 ty7777 Exp ty7777 $";
d125 1
a125 1
			| KeyPressMask | ButtonMotionMask);
@


1.12
log
@Fixed error in ramexit.
@
text
@d1 1
a1 1
/*$Id: cramtek.c,v 1.11 1993/11/24 18:08:57 ty7777 Exp ty7777 $*/
d3 3
d29 1
a29 1
static char rcsid [] = "$Id: cramtek.c,v 1.11 1993/11/24 18:08:57 ty7777 Exp ty7777 $";
d72 2
a73 1
void	xramini_()
a75 1
	int  		tbl_number;
d119 4
a122 2
	tbl_number	= -1;
	mapcolor_(&tbl_number, &err);
a149 1
		printf ("sys_command = %s *exec_command = %d\n", sys_command, *exec_command);
@


1.11
log
@Changed ramexit.
@
text
@d1 1
a1 1
/*$Id: cramtek.c,v 1.10 1993/11/24 17:15:52 ty7777 Exp ty7777 $*/
d3 3
d26 1
a26 1
static char rcsid [] = "$Id: cramtek.c,v 1.10 1993/11/24 17:15:52 ty7777 Exp ty7777 $";
d144 2
d147 1
@


1.10
log
@Added exec_command to xramexit.
@
text
@d1 5
a5 2
/*$Id$*/
/*$Log$*/
d23 1
a23 1
static char rcsid [] = "$Id$";
d140 1
a140 1
	if (*exec_command)
@


1.9
log
@Added ButtonRelease for getpad.
@
text
@d1 3
d20 2
d125 1
a125 1
void	xramexit_(sys_command)
d127 1
d132 1
d136 4
a139 1
	stat	= system (sys_command);
@


1.8
log
@Before changing getpad.
@
text
@d665 3
a667 1
long *x, *y, *flag;
d669 1
d671 5
a675 3
	Window	child;
	int	root_x, root_y;
	int	win_x, win_y;
d679 6
a684 1
	/* Read the next event */
d692 2
d700 6
d710 1
a712 7

	test	= keys_buttons & Button1Mask;

	if ((keys_buttons == test) && keys_buttons != 0)
		*flag	= 1;
	else
		*flag	= 0;
@


1.7
log
@Before building on Sun 1.3.1
@
text
@d26 1
d193 4
d494 4
d535 4
d572 4
d611 4
d645 4
d688 4
@


1.6
log
@Before any changes.
@
text
@d392 3
a394 3
		temp.blue	= (int) (((float)blue / 0xF) * 0xFFFF);
		temp.green	= (int) (((float)green / 0xF) * 0xFFFF);
		temp.red	= (int) (((float)red / 0xF) * 0xFFFF);
a466 3
	/*
	free (imagebuf);
	*/
@


1.5
log
@After adding free memory to image display.
@
text
@d466 2
d469 1
@


1.4
log
@Same as v1.3.
@
text
@d14 2
a15 2
extern char *malloc();
unsigned Image_Size();
d465 2
d949 1
a949 1
		free(colors);
d984 1
a984 1
	if (!(*colors = (XColor *) malloc (sizeof(XColor) * ncolors)))
@


1.3
log
@*** empty log message ***
@
text
@d360 1
a360 1
		itoa (tblnum, tblext);
d467 7
d475 28
d539 32
d604 30
@


1.2
log
@Add window dump utility functions
@
text
@@


1.1
log
@Initial revision
@
text
@d1 1
d4 4
a9 1
#include <stdio.h>
d11 6
d53 1
d93 2
a94 1
	XSelectInput (display, ramtek, ButtonPressMask | PointerMotionHintMask | ButtonMotionMask);
d402 1
d573 434
@
