<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>flirt: bspline.c Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.1 -->
<div class="qindex">  <form class="search" action="search.php" method="get">
<a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="dirs.html">Directories</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindex" href="globals.html">Globals</a>  | <span class="search"><u>S</u>earch&nbsp;for&nbsp;<input class="search" type="text" name="query" value="" size="20" accesskey="s"/></span></form></div>
<div class="nav">
<a class="el" href="dir_000000.html">home</a>&nbsp;/&nbsp;<a class="el" href="dir_000001.html">ens</a>&nbsp;/&nbsp;<a class="el" href="dir_000002.html">flirtproj</a>&nbsp;/&nbsp;<a class="el" href="dir_000004.html">flirt</a></div>
<h1>bspline.c</h1><div class="fragment"><pre class="fragment">00001 <span class="preprocessor">#include "<a class="code" href="bspline_8h.html">bspline.h</a>"</span>
00002 <span class="preprocessor">#include "<a class="code" href="defs_8h.html">defs.h</a>"</span>
00003 <span class="preprocessor">#include "fftw3.h"</span>
00004 <span class="preprocessor">#include &lt;stdlib.h&gt;</span>
00005 <span class="preprocessor">#include &lt;math.h&gt;</span>
00006 
00007 
00008 
00009 <span class="keywordtype">void</span> computeBSplineCoeff1D(<span class="keywordtype">double</span> I[],<span class="keywordtype">int</span> N,<span class="keywordtype">double</span> C[]) {
00010   <span class="keywordtype">double</span> inv_l[N];
00011   <span class="keywordtype">double</span> u[N-1];
00012   <span class="keywordtype">int</span> i;
00013   
00014   <span class="comment">/* compute LU factorization */</span>
00015   inv_l[0] = 6.0 / 4.0;
00016   u[0]     = 1.0 / 4.0;
00017   <span class="keywordflow">for</span> (i=1; i&lt;N-1; ++i) {
00018     inv_l[i] = 1.0 / ((1.0/6.0) * (4.0 - u[i-1]));
00019     u[i]     = (1.0/6.0) * inv_l[i];
00020   }; 
00021   inv_l[N-1] = 1.0 / ((1.0/6.0) * (4.0 - u[N-2]));
00022 
00023 
00024   C[0] = I[0] * inv_l[0];
00025   <span class="keywordflow">for</span> (i=1; i&lt;N; ++i) {
00026     <span class="comment">/* forward substitution */</span>
00027     C[i] = (I[i] - (1.0/6.0)*C[i-1]) * inv_l[i];
00028   };
00029 
00030   <span class="comment">/* backward substitution */</span>
00031   <span class="keywordflow">for</span> (i=N-2; i &gt;= 0; --i) {
00032     C[i] -= u[i]*C[i+1];
00033   };
00034 };
00035 
00036 <span class="keywordtype">void</span> computeBSplineCoeff2D(<span class="keywordtype">double</span> I[],<span class="keywordtype">int</span> m ,<span class="keywordtype">int</span> n,<span class="keywordtype">double</span> C[]) {
00037   <span class="keywordtype">int</span> N = (m&gt;n) ? m : n;
00038   <span class="keywordtype">double</span> inv_l[N];
00039   <span class="keywordtype">double</span> u[N-1];
00040   <span class="keywordtype">int</span> i,j,ij;
00041   
00042   <span class="comment">/* compute LU factorization */</span>
00043   inv_l[0] = 6.0 / 4.0;
00044   u[0]     = 1.0 / 4.0;
00045   <span class="keywordflow">for</span> (i=1; i&lt;N-1; ++i) {
00046     inv_l[i] = 1.0 / ((1.0/6.0) * (4.0 - u[i-1]));
00047     u[i]     = (1.0/6.0) * inv_l[i];
00048   }; 
00049   inv_l[N-1] = 1.0 / ((1.0/6.0) * (4.0 - u[N-2]));
00050 
00051 
00052   <span class="comment">/* for all rows do */</span>
00053   <span class="keywordflow">for</span> (i=0; i&lt;m; ++i) {
00054     <span class="comment">/* forward substitution */</span>
00055     ij = i;
00056     C[ij] = I[ij] * inv_l[0];
00057     <span class="keywordflow">for</span> (j=1; j&lt;n; ++j) {
00058       ij += m; 
00059       C[ij] = (I[ij] - (1.0/6.0)*C[ij-m]) * inv_l[j];
00060     };
00061 
00062     <span class="comment">/* backward substitution */</span>
00063     ij = i+m*(n-1); 
00064     <span class="keywordflow">for</span> (j=n-2; j &gt;= 0; --j) {
00065       ij -= m;
00066       C[ij] -= u[j]*C[ij+m];
00067     };
00068   };
00069 
00070   
00071   <span class="comment">/* for all cols do */</span>
00072   <span class="keywordflow">for</span> (j=0; j&lt;n; ++j) {
00073 
00074     <span class="comment">/* forward substitution */</span>
00075     ij = m*j;
00076     C[ij] *= inv_l[0];
00077 
00078     <span class="keywordflow">for</span> (i=1; i&lt;m; ++i) {
00079       ij ++; 
00080       C[ij] = (C[ij] - (1.0/6.0)*C[ij-1]) * inv_l[i];
00081     };
00082 
00083     <span class="comment">/* backward substitution */</span>
00084     ij = (m-1)+m*j; 
00085     <span class="keywordflow">for</span> (i=m-2; i &gt;= 0; --i) {
00086       ij--;
00087       C[ij] -= u[i]*C[ij+1];
00088     };
00089   }; 
00090 
00091 };
00092 
00093 
00094 <span class="keywordtype">void</span> computeBSplineCoeff3D(<span class="keywordtype">double</span> I[], <span class="keywordtype">int</span> m, <span class="keywordtype">int</span> n, <span class="keywordtype">int</span> p, <span class="keywordtype">double</span> C[]) {
00095   <span class="keywordtype">int</span> N = (((m&gt;n) ? m : n) &gt; p) ? ((m&gt;n) ? m : n) : p; <span class="comment">/* N = max{m,n,p} */</span>
00096   <span class="keywordtype">double</span> inv_l[N];
00097   <span class="keywordtype">double</span> u[N-1];
00098   <span class="keywordtype">int</span> i,j,k,ijk,mn;
00099 
00100 
00101   
00102   <span class="comment">/* compute LU factorization */</span>
00103   inv_l[0] = 6.0 / 4.0;
00104   u[0]     = 1.0 / 4.0;
00105   <span class="keywordflow">for</span> (i=1; i&lt;N-1; ++i) {
00106     inv_l[i] = 1.0 / ((1.0/6.0) * (4.0 - u[i-1]));
00107     u[i]     = (1.0/6.0) * inv_l[i];
00108   }; 
00109   inv_l[N-1] = 1.0 / ((1.0/6.0) * (4.0 - u[N-2]));
00110 
00111 
00112   mn = m*n;
00113 
00114 
00115 
00116   <span class="comment">/* for the 3rd dimensions do */</span>
00117   <span class="keywordflow">for</span> (i=0; i&lt;m; ++i) {
00118     <span class="keywordflow">for</span> (j=0; j&lt;n; ++j) {
00119 
00120       <span class="comment">/* forward substitution */</span>
00121       ijk = i + m*j;
00122       C[ijk] = I[ijk] * inv_l[0];
00123       <span class="keywordflow">for</span> (k=1; k&lt;p; ++k) {
00124         ijk += mn; 
00125         C[ijk] = (I[ijk] - (1.0/6.0)*C[ijk-mn]) * inv_l[k];
00126       };
00127       <span class="comment">/* backward substitution */</span>
00128       ijk = i + m*j + mn*(p-1); 
00129       <span class="keywordflow">for</span> (k=p-2; k &gt;= 0; --k) {
00130         ijk -= mn;
00131         C[ijk] -= u[k]*C[ijk+mn];
00132       };
00133 
00134     };
00135   };
00136 
00137 
00138   <span class="comment">/* for the 2nd dimensions do */</span>
00139   <span class="keywordflow">for</span> (i=0; i&lt;m; ++i) {
00140     <span class="keywordflow">for</span> (k=0; k&lt;p; ++k) {
00141       
00142       <span class="comment">/* forward substitution */</span>
00143       ijk = i + mn*k;
00144       C[ijk] = C[ijk] * inv_l[0];
00145       <span class="keywordflow">for</span> (j=1; j&lt;n; ++j) {
00146         ijk +=m; 
00147         C[ijk] = (C[ijk] - (1.0/6.0)*C[ijk-m]) * inv_l[j];
00148       };
00149       
00150       <span class="comment">/* backward substitution */</span>
00151       ijk = i + m*(n-1) + mn*k; 
00152       <span class="keywordflow">for</span> (j=n-2; j &gt;= 0; --j) {
00153         ijk -= m;
00154         C[ijk] -= u[j]*C[ijk+m];
00155       };
00156 
00157     };
00158   };
00159 
00160 
00161   <span class="comment">/* for the 1st dimensions do */</span>
00162   <span class="keywordflow">for</span> (j=0; j&lt;n; ++j) {
00163     <span class="keywordflow">for</span> (k=0; k&lt;p; ++k) {
00164       
00165       <span class="comment">/* forward substitution */</span>
00166       ijk = m*j + mn*k;
00167       C[ijk] = C[ijk] * inv_l[0];
00168       <span class="keywordflow">for</span> (i=1; i&lt;m; ++i) {
00169         ijk++; 
00170         C[ijk] = (C[ijk] - (1.0/6.0)*C[ijk-1]) * inv_l[i];
00171       };
00172       
00173       <span class="comment">/* backward substitution */</span>
00174       ijk = (m-1) + m*j + mn*k; 
00175       <span class="keywordflow">for</span> (i=m-2; i &gt;= 0; --i) {
00176         ijk--;
00177         C[ijk] -= u[i]*C[ijk+1];
00178       };
00179 
00180     };
00181   };
00182   
00183 
00184 };
00185 
00186 
00187 <span class="keywordtype">void</span> evalBSpline1D(<span class="keywordtype">double</span> C[], 
00188                    <span class="keywordtype">int</span> m ,
00189                    <span class="keywordtype">double</span> x[], 
00190                    <span class="keywordtype">int</span> N, 
00191                    <span class="keywordtype">double</span> S[]) {
00192   
00193   <span class="keywordtype">int</span> i,cnt,index;
00194   <span class="keywordtype">int</span> I[4];
00195   <span class="keywordtype">double</span> w[4];
00196   
00197   <span class="keywordtype">double</span> tau;
00198   
00199   <span class="keywordflow">for</span> (cnt=0; cnt&lt;N; ++cnt) {
00200     <span class="comment">/* compute interpolation weights for the 1st dimension */</span>
00201     tau = x[cnt] - floor(x[cnt]);
00202     w[0] = 1.0/6.0 * tau*tau*tau;
00203     w[3] = 1.0/6.0 + 0.5*tau*(tau-1.0) - w[0];
00204     w[1] = tau - 2.0*w[0] + w[3];
00205     w[2] = 1.0 - w[0] - w[1] - w[3];
00206 
00207 
00208     <span class="comment">/* check range for the 1st dimension */</span>
00209     index = ((int) floor(x[cnt])) + 2;
00210     <span class="keywordflow">for</span> (i=0; i&lt;4; ++i) {
00211       <span class="keywordflow">if</span> ((index &lt; 0) || (index &gt;= m)) { 
00212         I[i] = 0;
00213         w[i] = 0.0;
00214       } <span class="keywordflow">else</span> {
00215         I[i] = index;
00216       };
00217       index--;
00218     };
00219 
00220 
00221     <span class="comment">/* perform interpolation */</span>
00222     S[cnt] = C[I[0]]*w[0] + C[I[1]]*w[1] + C[I[2]]*w[2] + C[I[3]]*w[3];
00223     
00224   };
00225   
00226 }
00227 
00228 
00229 <span class="keywordtype">void</span> evalBSplineAndGrad1D(<span class="keywordtype">double</span> C[], 
00230                           <span class="keywordtype">int</span> m ,
00231                           <span class="keywordtype">double</span> x[], 
00232                           <span class="keywordtype">int</span> N, 
00233                           <span class="keywordtype">double</span> S[],
00234                           <span class="keywordtype">double</span> d_S[] ) {
00235   
00236   <span class="keywordtype">int</span> i,cnt,index;
00237   <span class="keywordtype">int</span> I[4];
00238   <span class="keywordtype">double</span> w[4];
00239   <span class="keywordtype">double</span> d_w[4];
00240   <span class="keywordtype">double</span> tau;
00241   
00242   <span class="keywordflow">for</span> (cnt=0; cnt&lt;N; ++cnt) {
00243     <span class="comment">/* compute interpolation weights for the 1st dimension */</span>
00244     tau = x[cnt] - floor(x[cnt]);
00245     w[0] = 1.0/6.0 * tau*tau*tau;
00246     w[3] = 1.0/6.0 + 0.5*tau*(tau-1.0) - w[0];
00247     w[1] = tau - 2.0*w[0] + w[3];
00248     w[2] = 1.0 - w[0] - w[1] - w[3];
00249 
00250     d_w[0] = 0.5*tau*tau;
00251     d_w[3] = -0.5 + tau - d_w[0];
00252     d_w[1] = 1 - 2*d_w[0] + d_w[3];
00253     d_w[2] = -d_w[0] - d_w[1] - d_w[3];
00254 
00255 
00256 
00257     <span class="comment">/* check range for the 1st dimension */</span>
00258     index = ((int) floor(x[cnt])) + 2;
00259     <span class="keywordflow">for</span> (i=0; i&lt;4; ++i) {
00260       <span class="keywordflow">if</span> ((index &lt; 0) || (index &gt;= m)) { 
00261         I[i]    = 0;
00262         w[i]   = 0.0;
00263         d_w[i] = 0.0;
00264       } <span class="keywordflow">else</span> {
00265         I[i] = index;
00266       };
00267       index--;
00268     };
00269     
00270 
00271     <span class="comment">/* perform interpolation */</span>
00272     
00273     S[cnt]   = C[I[0]]*w[0] + C[I[1]]*w[1] + C[I[2]]*w[2] + C[I[3]]*w[3];
00274     d_S[cnt] = 
00275       C[I[0]]*d_w[0] + 
00276       C[I[1]]*d_w[1] + 
00277       C[I[2]]*d_w[2] + 
00278       C[I[3]]*d_w[3];
00279   }
00280   
00281 }
00282 
00283 
00284 <span class="keywordtype">void</span> evalBSpline2D(<span class="keywordtype">double</span> C[], 
00285                    <span class="keywordtype">int</span> m ,
00286                    <span class="keywordtype">int</span> n, 
00287                    <span class="keywordtype">double</span> x[], 
00288                    <span class="keywordtype">double</span> y[], 
00289                    <span class="keywordtype">int</span> N, 
00290                    <span class="keywordtype">double</span> S[]) {
00291   
00292   <span class="keywordtype">int</span> i,j,cnt,index;
00293   <span class="keywordtype">int</span> I[4];
00294   <span class="keywordtype">int</span> J[4];
00295   <span class="keywordtype">double</span> w1[4];
00296   <span class="keywordtype">double</span> w2[4];
00297   
00298   <span class="keywordtype">double</span> tau;
00299   
00300   <span class="keywordflow">for</span> (cnt=0; cnt&lt;N; ++cnt) {
00301     <span class="comment">/* compute interpolation weights for the 1st dimension */</span>
00302     tau = x[cnt] - floor(x[cnt]);
00303     w1[0] = 1.0/6.0 * tau*tau*tau;
00304     w1[3] = 1.0/6.0 + 0.5*tau*(tau-1.0) - w1[0];
00305     w1[1] = tau - 2.0*w1[0] + w1[3];
00306     w1[2] = 1.0 - w1[0] - w1[1] - w1[3];
00307 
00308     <span class="comment">/* compute interpolation weights for the 2nd dimension */</span>
00309     tau = y[cnt] - floor(y[cnt]);
00310     w2[0] = 1.0/6.0 * tau*tau*tau;
00311     w2[3] = 1.0/6.0 + 0.5*tau*(tau-1.0) - w2[0];
00312     w2[1] = tau - 2.0*w2[0] + w2[3];
00313     w2[2] = 1.0 - w2[0] - w2[1] - w2[3];
00314 
00315     <span class="comment">/* check range for the 1st dimension */</span>
00316     index = ((int) floor(x[cnt])) + 2;
00317     <span class="keywordflow">for</span> (i=0; i&lt;4; ++i) {
00318       <span class="keywordflow">if</span> ((index &lt; 0) || (index &gt;= m)) { 
00319         I[i] = 0;
00320         w1[i] = 0.0;
00321       } <span class="keywordflow">else</span> {
00322         I[i] = index;
00323       };
00324       index--;
00325     };
00326 
00327     <span class="comment">/* check range for the 2nd dimension */</span>
00328     index = ((int) floor(y[cnt])) + 2;
00329     <span class="keywordflow">for</span> (j=0; j&lt;4; ++j) {
00330       <span class="keywordflow">if</span> ((index &lt; 0) || (index &gt;= n)) { 
00331         J[j] = 0;
00332         w2[j] = 0.0;
00333       } <span class="keywordflow">else</span> {
00334         J[j] = m*index;
00335       };
00336       index--;
00337     };
00338 
00339     <span class="comment">/* perform interpolation */</span>
00340     S[cnt] = 0.0;
00341     <span class="keywordflow">for</span> (i=0; i&lt;4; ++i) {
00342       S[cnt] += w1[i]* ( C[ I[i]+J[0] ] * w2[0] +
00343                          C[ I[i]+J[1] ] * w2[1] + 
00344                          C[ I[i]+J[2] ] * w2[2] +
00345                          C[ I[i]+J[3] ] * w2[3]   );
00346     };
00347     
00348   };
00349   
00350 };
00351 
00352 
00353 <span class="keywordtype">void</span> evalBSplineAndGrad2D(<span class="keywordtype">double</span> C[], 
00354                           <span class="keywordtype">int</span> m ,
00355                           <span class="keywordtype">int</span> n, 
00356                           <span class="keywordtype">double</span> x[], 
00357                           <span class="keywordtype">double</span> y[], 
00358                           <span class="keywordtype">int</span> N, 
00359                           <span class="keywordtype">double</span> S[],
00360                           <span class="keywordtype">double</span> d1_S[],
00361                           <span class="keywordtype">double</span> d2_S[] ) {
00362   
00363   <span class="keywordtype">int</span> i,j,cnt,index;
00364   <span class="keywordtype">int</span> I[4];
00365   <span class="keywordtype">int</span> J[4];
00366   <span class="keywordtype">double</span> w1[4];
00367   <span class="keywordtype">double</span> d_w1[4];
00368   <span class="keywordtype">double</span> w2[4];
00369   <span class="keywordtype">double</span> d_w2[4];
00370   <span class="keywordtype">double</span> sum_j;
00371   <span class="keywordtype">double</span> tau;
00372   
00373   <span class="keywordflow">for</span> (cnt=0; cnt&lt;N; ++cnt) {
00374     <span class="comment">/* compute interpolation weights for the 1st dimension */</span>
00375     tau = x[cnt] - floor(x[cnt]);
00376     w1[0] = 1.0/6.0 * tau*tau*tau;
00377     w1[3] = 1.0/6.0 + 0.5*tau*(tau-1.0) - w1[0];
00378     w1[1] = tau - 2.0*w1[0] + w1[3];
00379     w1[2] = 1.0 - w1[0] - w1[1] - w1[3];
00380 
00381     d_w1[0] = 0.5*tau*tau;
00382     d_w1[3] = -0.5 + tau - d_w1[0];
00383     d_w1[1] = 1 - 2*d_w1[0] + d_w1[3];
00384     d_w1[2] = -d_w1[0] - d_w1[1] - d_w1[3];
00385 
00386     <span class="comment">/* compute interpolation weights for the 2nd dimension */</span>
00387     tau = y[cnt] - floor(y[cnt]);
00388     w2[0] = 1.0/6.0 * tau*tau*tau;
00389     w2[3] = 1.0/6.0 + 0.5*tau*(tau-1.0) - w2[0];
00390     w2[1] = tau - 2.0*w2[0] + w2[3];
00391     w2[2] = 1.0 - w2[0] - w2[1] - w2[3];
00392 
00393     d_w2[0] = 0.5*tau*tau;
00394     d_w2[3] = -0.5 + tau - d_w2[0];
00395     d_w2[1] = 1 - 2*d_w2[0] + d_w2[3];
00396     d_w2[2] = -d_w2[0] - d_w2[1] - d_w2[3];
00397 
00398 
00399     <span class="comment">/* check range for the 1st dimension */</span>
00400     index = ((int) floor(x[cnt])) + 2;
00401     <span class="keywordflow">for</span> (i=0; i&lt;4; ++i) {
00402       <span class="keywordflow">if</span> ((index &lt; 0) || (index &gt;= m)) { 
00403         I[i]    = 0;
00404         w1[i]   = 0.0;
00405         d_w1[i] = 0.0;
00406       } <span class="keywordflow">else</span> {
00407         I[i] = index;
00408       };
00409       index--;
00410     };
00411 
00412     <span class="comment">/* check range for the 2nd dimension */</span>
00413     index = ((int) floor(y[cnt])) + 2;
00414     <span class="keywordflow">for</span> (j=0; j&lt;4; ++j) {
00415       <span class="keywordflow">if</span> ((index &lt; 0) || (index &gt;= n)) { 
00416         J[j]    = 0;
00417         w2[j]   = 0.0;
00418         d_w2[j] = 0.0;
00419       } <span class="keywordflow">else</span> {
00420         J[j] = m*index;
00421       };
00422       index--;
00423     };
00424 
00425     <span class="comment">/* perform interpolation */</span>
00426     S[cnt]    = 0.0;
00427     d1_S[cnt] = 0.0;
00428     d2_S[cnt] = 0.0;
00429     <span class="keywordflow">for</span> (i=0; i&lt;4; ++i) {
00430       sum_j = ( C[ I[i]+J[0] ] * w2[0] +
00431                 C[ I[i]+J[1] ] * w2[1] + 
00432                 C[ I[i]+J[2] ] * w2[2] +
00433                 C[ I[i]+J[3] ] * w2[3]   );
00434 
00435       S[cnt]    +=   w1[i] * sum_j;
00436       d1_S[cnt] += d_w1[i] * sum_j;
00437       d2_S[cnt] +=   w1[i] * ( C[ I[i]+J[0] ] * d_w2[0] +
00438                                C[ I[i]+J[1] ] * d_w2[1] + 
00439                                C[ I[i]+J[2] ] * d_w2[2] +
00440                                C[ I[i]+J[3] ] * d_w2[3]   );
00441     };
00442 
00443     
00444   };
00445   
00446 };
00447 
00448 
00449 <span class="keywordtype">void</span> evalBSpline3D(<span class="keywordtype">double</span> C[], 
00450                    <span class="keywordtype">int</span> m ,
00451                    <span class="keywordtype">int</span> n, 
00452                    <span class="keywordtype">int</span> p, 
00453                    <span class="keywordtype">double</span> x[], 
00454                    <span class="keywordtype">double</span> y[], 
00455                    <span class="keywordtype">double</span> z[], 
00456                    <span class="keywordtype">int</span> N, 
00457                    <span class="keywordtype">double</span> S[]) {
00458   
00459   <span class="keywordtype">int</span> i,j,k,ij,cnt,index,mn;
00460   <span class="keywordtype">int</span> I[4];
00461   <span class="keywordtype">int</span> J[4];
00462   <span class="keywordtype">int</span> K[4];
00463   <span class="keywordtype">double</span> w1[4];
00464   <span class="keywordtype">double</span> w2[4];
00465   <span class="keywordtype">double</span> w3[4];
00466   
00467   <span class="keywordtype">double</span> tau,sum_jk,sum_k;
00468   
00469   mn = m*n;
00470 
00471   <span class="keywordflow">for</span> (cnt=0; cnt&lt;N; ++cnt) {
00472     <span class="comment">/* compute interpolation weights for the 1st dimension */</span>
00473     tau = x[cnt] - floor(x[cnt]);
00474     w1[0] = 1.0/6.0 * tau*tau*tau;
00475     w1[3] = 1.0/6.0 + 0.5*tau*(tau-1.0) - w1[0];
00476     w1[1] = tau - 2.0*w1[0] + w1[3];
00477     w1[2] = 1.0 - w1[0] - w1[1] - w1[3];
00478 
00479     <span class="comment">/* compute interpolation weights for the 2nd dimension */</span>
00480     tau = y[cnt] - floor(y[cnt]);
00481     w2[0] = 1.0/6.0 * tau*tau*tau;
00482     w2[3] = 1.0/6.0 + 0.5*tau*(tau-1.0) - w2[0];
00483     w2[1] = tau - 2.0*w2[0] + w2[3];
00484     w2[2] = 1.0 - w2[0] - w2[1] - w2[3];
00485 
00486     <span class="comment">/* compute interpolation weights for the 3rd dimension */</span>
00487     tau = z[cnt] - floor(z[cnt]);
00488     w3[0] = 1.0/6.0 * tau*tau*tau;
00489     w3[3] = 1.0/6.0 + 0.5*tau*(tau-1.0) - w3[0];
00490     w3[1] = tau - 2.0*w3[0] + w3[3];
00491     w3[2] = 1.0 - w3[0] - w3[1] - w3[3];
00492 
00493 
00494     <span class="comment">/* check range for the 1st dimension */</span>
00495     index = ((int) floor(x[cnt])) + 2;
00496     <span class="keywordflow">for</span> (i=0; i&lt;4; ++i) {
00497       <span class="keywordflow">if</span> ((index &lt; 0) || (index &gt;= m)) { 
00498         I[i] = 0;
00499         w1[i] = 0.0;
00500       } <span class="keywordflow">else</span> {
00501         I[i] = index;
00502       };
00503       index--;
00504     };
00505 
00506     <span class="comment">/* check range for the 2nd dimension */</span>
00507     index = ((int) floor(y[cnt])) + 2;
00508     <span class="keywordflow">for</span> (j=0; j&lt;4; ++j) {
00509       <span class="keywordflow">if</span> ((index &lt; 0) || (index &gt;= n)) { 
00510         J[j] = 0;
00511         w2[j] = 0.0;
00512       } <span class="keywordflow">else</span> {
00513         J[j] = m*index;
00514       };
00515       index--;
00516     };
00517 
00518     <span class="comment">/* check range for the 3rd dimension */</span>
00519     index = ((int) floor(z[cnt])) + 2;
00520     <span class="keywordflow">for</span> (k=0; k&lt;4; ++k) {
00521       <span class="keywordflow">if</span> ((index &lt; 0) || (index &gt;= p)) { 
00522         K[k] = 0;
00523         w3[k] = 0.0;
00524       } <span class="keywordflow">else</span> {
00525         K[k] = mn*index;
00526       };
00527       index--;
00528     };
00529     
00530     <span class="comment">/* perform interpolation */</span>
00531     S[cnt] = 0.0;
00532     <span class="keywordflow">for</span> (i=0; i&lt;4; ++i) {
00533       sum_jk = 0.0;
00534       <span class="keywordflow">for</span> (j=0; j&lt;4; ++j) {
00535         sum_k = 0.0;
00536         ij = I[i]+J[j];
00537         <span class="keywordflow">for</span> (k=0; k&lt;4; ++k) { 
00538           sum_k += w3[k] * C[ ij+K[k] ]; 
00539         };
00540         sum_jk += w2[j]*sum_k;
00541       };
00542       S[cnt] += w1[i]*sum_jk;
00543     };
00544   };
00545   
00546 };
00547 
00548 <span class="keywordtype">void</span> evalBSplineAndGrad3D(<span class="keywordtype">double</span> C[], 
00549                           <span class="keywordtype">int</span> m ,
00550                           <span class="keywordtype">int</span> n, 
00551                           <span class="keywordtype">int</span> p, 
00552                           <span class="keywordtype">double</span> x[], 
00553                           <span class="keywordtype">double</span> y[], 
00554                           <span class="keywordtype">double</span> z[], 
00555                           <span class="keywordtype">int</span> N, 
00556                           <span class="keywordtype">double</span> S[],
00557                           <span class="keywordtype">double</span> d1_S[],
00558                           <span class="keywordtype">double</span> d2_S[],
00559                           <span class="keywordtype">double</span> d3_S[] ) {
00560   <span class="keywordtype">int</span> i,j,k,ij,cnt,index,mn;
00561   <span class="keywordtype">int</span> I[4];
00562   <span class="keywordtype">int</span> J[4];
00563   <span class="keywordtype">int</span> K[4];
00564   <span class="keywordtype">double</span> w1[4];
00565   <span class="keywordtype">double</span> w2[4];
00566   <span class="keywordtype">double</span> w3[4];
00567   <span class="keywordtype">double</span> d_w1[4];
00568   <span class="keywordtype">double</span> d_w2[4];
00569   <span class="keywordtype">double</span> d_w3[4];
00570   
00571   <span class="keywordtype">double</span> tau,sum_jk,sum_k, d3_sum_k, d2_sum_jk, d3_sum_jk;
00572   
00573   mn = m*n;
00574 
00575   <span class="keywordflow">for</span> (cnt=0; cnt&lt;N; ++cnt) {
00576     <span class="comment">/* compute interpolation weights for the 1st dimension */</span>
00577     tau = x[cnt] - floor(x[cnt]);
00578     w1[0] = 1.0/6.0 * tau*tau*tau;
00579     w1[3] = 1.0/6.0 + 0.5*tau*(tau-1.0) - w1[0];
00580     w1[1] = tau - 2.0*w1[0] + w1[3];
00581     w1[2] = 1.0 - w1[0] - w1[1] - w1[3];
00582 
00583     d_w1[0] = 0.5*tau*tau;
00584     d_w1[3] = -0.5 + tau - d_w1[0];
00585     d_w1[1] = 1 - 2*d_w1[0] + d_w1[3];
00586     d_w1[2] = -d_w1[0] - d_w1[1] - d_w1[3];
00587 
00588     <span class="comment">/* compute interpolation weights for the 2nd dimension */</span>
00589     tau = y[cnt] - floor(y[cnt]);
00590     w2[0] = 1.0/6.0 * tau*tau*tau;
00591     w2[3] = 1.0/6.0 + 0.5*tau*(tau-1.0) - w2[0];
00592     w2[1] = tau - 2.0*w2[0] + w2[3];
00593     w2[2] = 1.0 - w2[0] - w2[1] - w2[3];
00594 
00595     d_w2[0] = 0.5*tau*tau;
00596     d_w2[3] = -0.5 + tau - d_w2[0];
00597     d_w2[1] = 1 - 2*d_w2[0] + d_w2[3];
00598     d_w2[2] = -d_w2[0] - d_w2[1] - d_w2[3];
00599 
00600     <span class="comment">/* compute interpolation weights for the 3rd dimension */</span>
00601     tau = z[cnt] - floor(z[cnt]);
00602     w3[0] = 1.0/6.0 * tau*tau*tau;
00603     w3[3] = 1.0/6.0 + 0.5*tau*(tau-1.0) - w3[0];
00604     w3[1] = tau - 2.0*w3[0] + w3[3];
00605     w3[2] = 1.0 - w3[0] - w3[1] - w3[3];
00606 
00607     d_w3[0] = 0.5*tau*tau;
00608     d_w3[3] = -0.5 + tau - d_w3[0];
00609     d_w3[1] = 1 - 2*d_w3[0] + d_w3[3];
00610     d_w3[2] = -d_w3[0] - d_w3[1] - d_w3[3];
00611 
00612 
00613     <span class="comment">/* check range for the 1st dimension */</span>
00614     index = ((int) floor(x[cnt])) + 2;
00615     <span class="keywordflow">for</span> (i=0; i&lt;4; ++i) {
00616       <span class="keywordflow">if</span> ((index &lt; 0) || (index &gt;= m)) { 
00617         I[i]   = 0;
00618         w1[i]  = 0.0;
00619         d_w1[i] = 0.0;
00620       } <span class="keywordflow">else</span> {
00621         I[i] = index;
00622       };
00623       index--;
00624     };
00625 
00626     <span class="comment">/* check range for the 2nd dimension */</span>
00627     index = ((int) floor(y[cnt])) + 2;
00628     <span class="keywordflow">for</span> (j=0; j&lt;4; ++j) {
00629       <span class="keywordflow">if</span> ((index &lt; 0) || (index &gt;= n)) { 
00630         J[j]   = 0;
00631         w2[j]  = 0.0;
00632         d_w2[j] = 0.0;
00633       } <span class="keywordflow">else</span> {
00634         J[j] = m*index;
00635       };
00636       index--;
00637     };
00638 
00639     <span class="comment">/* check range for the 3rd dimension */</span>
00640     index = ((int) floor(z[cnt])) + 2;
00641     <span class="keywordflow">for</span> (k=0; k&lt;4; ++k) {
00642       <span class="keywordflow">if</span> ((index &lt; 0) || (index &gt;= p)) { 
00643         K[k]   = 0;
00644         w3[k]  = 0.0;
00645         d_w3[k] = 0.0;
00646       } <span class="keywordflow">else</span> {
00647         K[k] = mn*index;
00648       };
00649       index--;
00650     };
00651     
00652     <span class="comment">/* perform interpolation */</span>
00653     S[cnt] = 0.0;
00654     d1_S[cnt] = 0.0;
00655     d2_S[cnt] = 0.0;
00656     d3_S[cnt] = 0.0;
00657     <span class="keywordflow">for</span> (i=0; i&lt;4; ++i) {
00658       sum_jk = 0.0;
00659       d2_sum_jk = 0.0;
00660       d3_sum_jk = 0.0;
00661       <span class="keywordflow">for</span> (j=0; j&lt;4; ++j) {
00662         sum_k = 0.0;
00663         d3_sum_k = 0.0;
00664         ij = I[i]+J[j];
00665         <span class="keywordflow">for</span> (k=0; k&lt;4; ++k) { 
00666           sum_k    +=   w3[k] * C[ ij+K[k] ]; 
00667           d3_sum_k += d_w3[k] * C[ ij+K[k] ]; 
00668         };
00669         sum_jk    +=   w2[j] *    sum_k;
00670         d2_sum_jk += d_w2[j] *    sum_k;
00671         d3_sum_jk +=   w2[j] * d3_sum_k;
00672       };
00673       S[cnt]    +=   w1[i] *    sum_jk;
00674       d1_S[cnt] += d_w1[i] *    sum_jk;
00675       d2_S[cnt] +=   w1[i] * d2_sum_jk;
00676       d3_S[cnt] +=   w1[i] * d3_sum_jk;
00677     };
00678   };
00679   
00680 };
00681 
00682 
00683 
00684 
00685 
00686 <span class="comment">/* ++++++++++++++++ */</span>
00687 <span class="keywordtype">void</span> convertToBSplineCoeff2D(<span class="keywordtype">double</span>* C, <span class="keywordtype">int</span> m1, <span class="keywordtype">int</span> m2) {
00688   computeBSplineCoeff2D(C,m1,m2,C);
00689 };
00690 
00691 
00692 
00693 <span class="keywordtype">void</span> computeApproxBSplineCoeff2D(<span class="keywordtype">double</span>* I, 
00694                                  <span class="keywordtype">int</span> m1, 
00695                                  <span class="keywordtype">int</span> m2, 
00696                                  <span class="keywordtype">double</span> tau, 
00697                                  boundary_t bc, 
00698                                  <span class="keywordtype">double</span>* C) {
00699   <span class="keywordtype">int</span> j1,j2,k; 
00700   <span class="keywordtype">double</span>* lambda1 = (<span class="keywordtype">double</span>*) fftw_malloc(<span class="keyword">sizeof</span>(<span class="keywordtype">double</span>) * m1);
00701   <span class="keywordtype">double</span>* lambda2 = (<span class="keywordtype">double</span>*) fftw_malloc(<span class="keyword">sizeof</span>(<span class="keywordtype">double</span>) * m2);
00702   <span class="keywordtype">double</span>* tmp     = (<span class="keywordtype">double</span>*) fftw_malloc(<span class="keyword">sizeof</span>(<span class="keywordtype">double</span>) * m1*m2);
00703   
00704   <span class="keywordtype">double</span> fftw_normfac = 1.0 / ((double) (2 *m1 * 2*m2));
00705   
00706   fftw_plan forward;
00707   fftw_plan backward;
00708   
00709   <span class="keywordflow">switch</span> (bc) {
00710   <span class="keywordflow">case</span> <a class="code" href="defs_8h.html#a8a3">DIRICHLET</a>:
00711     forward  = fftw_plan_r2r_2d(m2,m1, I  , tmp, FFTW_RODFT10, FFTW_RODFT10, FFTW_ESTIMATE | FFTW_PRESERVE_INPUT);
00712     backward = fftw_plan_r2r_2d(m2,m1, tmp, C  , FFTW_RODFT01, FFTW_RODFT01, FFTW_ESTIMATE);
00713     <span class="comment">/* precompute eigenvalues */</span>
00714     <span class="keywordflow">for</span> (k=0; k&lt;m1 ; ++k) 
00715       lambda1[k] = (2.0 - 2.0*cos( ((<span class="keywordtype">double</span>)(k+1))*PI / ((<span class="keywordtype">double</span>)m1) ));
00716     for (k=0; k&lt;m2 ; ++k) 
00717       lambda2[k] = (2.0 - 2.0*cos( ((<span class="keywordtype">double</span>)(k+1))*PI / ((<span class="keywordtype">double</span>)m2) ));
00718     break;
00719      
00720   case NEUMANN:
00721     forward  = fftw_plan_r2r_2d(m2,m1, I  , tmp, FFTW_REDFT10, FFTW_REDFT10, FFTW_ESTIMATE | FFTW_PRESERVE_INPUT);
00722     backward = fftw_plan_r2r_2d(m2,m1, tmp, C  , FFTW_REDFT01, FFTW_REDFT01, FFTW_ESTIMATE);
00723     <span class="comment">/* precompute eigenvalues */</span>
00724     for (k=0; k&lt;m1 ; ++k) 
00725       lambda1[k] = (2.0 - 2.0*cos( ((<span class="keywordtype">double</span>)k)*PI / ((<span class="keywordtype">double</span>)m1) ));
00726     for (k=0; k&lt;m2 ; ++k) 
00727       lambda2[k] = (2.0 - 2.0*cos( ((<span class="keywordtype">double</span>)k)*PI / ((<span class="keywordtype">double</span>)m2) ));
00728 
00729   };
00730 
00731 
00732      
00733   fftw_execute(forward);
00734 
00735   for (j2=0; j2&lt;m2; ++j2)
00736     for (j1=0; j1&lt;m1; ++j1)
00737       tmp[j1+m1*j2] *= 1.0/(1.0+tau*(lambda1[j1]+lambda2[j2])*(lambda1[j1]+lambda2[j2]) );
00738      
00739   fftw_execute(backward);
00740 
00741   convertToBSplineCoeff2D(C,m1,m2);
00742 
00743   fftw_destroy_plan(forward);
00744   fftw_destroy_plan(backward);
00745   fftw_free(lambda1);
00746   fftw_free(lambda2);
00747   fftw_free(tmp);
00748 };
00749 
00750 
00751 
00752 <span class="comment">/* ++++++++++++++++ */</span>
00753 <span class="keywordtype">void</span> convertToBSplineCoeff3D(<span class="keywordtype">double</span>* C, <span class="keywordtype">int</span> m1, <span class="keywordtype">int</span> m2,<span class="keywordtype">int</span> m3) {
00754   computeBSplineCoeff3D(C,m1,m2,m3,C);
00755 };
00756 
00757 
00758 
00759 <span class="keywordtype">void</span> computeApproxBSplineCoeff3D(<span class="keywordtype">double</span>* I, 
00760                                  <span class="keywordtype">int</span> m1, 
00761                                  <span class="keywordtype">int</span> m2, 
00762                                  <span class="keywordtype">int</span> m3, 
00763                                  <span class="keywordtype">double</span> tau, 
00764                                  boundary_t bc, 
00765                                  <span class="keywordtype">double</span>* C) {
00766   <span class="keywordtype">int</span> j1,j2,j3,k; 
00767   <span class="keywordtype">double</span>* lambda1 = (<span class="keywordtype">double</span>*) fftw_malloc(<span class="keyword">sizeof</span>(<span class="keywordtype">double</span>) * m1);
00768   <span class="keywordtype">double</span>* lambda2 = (<span class="keywordtype">double</span>*) fftw_malloc(<span class="keyword">sizeof</span>(<span class="keywordtype">double</span>) * m2);
00769   <span class="keywordtype">double</span>* lambda3 = (<span class="keywordtype">double</span>*) fftw_malloc(<span class="keyword">sizeof</span>(<span class="keywordtype">double</span>) * m3);
00770   <span class="keywordtype">double</span>* tmp     = (<span class="keywordtype">double</span>*) fftw_malloc(<span class="keyword">sizeof</span>(<span class="keywordtype">double</span>) * m1*m2*m3);
00771   
00772   <span class="keywordtype">double</span> fftw_normfac = 1.0 / ((double) (2 *m1 * 2*m2 * 2*m3));
00773   
00774   fftw_plan forward;
00775   fftw_plan backward;
00776   
00777   <span class="keywordflow">switch</span> (bc) {
00778   <span class="keywordflow">case</span> <a class="code" href="defs_8h.html#a8a3">DIRICHLET</a>:
00779     forward  = fftw_plan_r2r_3d(m3,m2,m1, I  , tmp, 
00780                                 FFTW_RODFT10, FFTW_RODFT10, FFTW_RODFT10, 
00781                                 FFTW_ESTIMATE | FFTW_PRESERVE_INPUT);
00782     backward = fftw_plan_r2r_3d(m3,m2,m1, tmp, C  , 
00783                                 FFTW_RODFT01, FFTW_RODFT01, FFTW_RODFT01, 
00784                                 FFTW_ESTIMATE);
00785     <span class="comment">/* precompute eigenvalues */</span>
00786     <span class="keywordflow">for</span> (k=0; k&lt;m1 ; ++k) 
00787       lambda1[k] = (2.0 - 2.0*cos( ((<span class="keywordtype">double</span>)(k+1))*PI / ((<span class="keywordtype">double</span>)m1) ));
00788     for (k=0; k&lt;m2 ; ++k) 
00789       lambda2[k] = (2.0 - 2.0*cos( ((<span class="keywordtype">double</span>)(k+1))*PI / ((<span class="keywordtype">double</span>)m2) ));
00790     for (k=0; k&lt;m3 ; ++k) 
00791       lambda3[k] = (2.0 - 2.0*cos( ((<span class="keywordtype">double</span>)(k+1))*PI / ((<span class="keywordtype">double</span>)m3) ));
00792     break;
00793     
00794   case NEUMANN:
00795     forward  = fftw_plan_r2r_3d(m3,m2,m1, I  , tmp, 
00796                                 FFTW_REDFT10, FFTW_REDFT10, FFTW_REDFT10, 
00797                                 FFTW_ESTIMATE | FFTW_PRESERVE_INPUT);
00798     backward = fftw_plan_r2r_3d(m3,m2,m1, tmp, C  , 
00799                                 FFTW_REDFT01, FFTW_REDFT01, FFTW_REDFT01, 
00800                                 FFTW_ESTIMATE);
00801     <span class="comment">/* precompute eigenvalues */</span>
00802     for (k=0; k&lt;m1 ; ++k) 
00803       lambda1[k] = (2.0 - 2.0*cos( ((<span class="keywordtype">double</span>)k)*PI / ((<span class="keywordtype">double</span>)m1) ));
00804     for (k=0; k&lt;m2 ; ++k) 
00805       lambda2[k] = (2.0 - 2.0*cos( ((<span class="keywordtype">double</span>)k)*PI / ((<span class="keywordtype">double</span>)m2) ));
00806     for (k=0; k&lt;m3 ; ++k) 
00807       lambda3[k] = (2.0 - 2.0*cos( ((<span class="keywordtype">double</span>)k)*PI / ((<span class="keywordtype">double</span>)m3) ));
00808     
00809   };
00810   
00811   
00812   
00813   fftw_execute(forward);
00814   
00815   for (j3=0; j3&lt;m3; ++j3)
00816     for (j2=0; j2&lt;m2; ++j2)
00817       for (j1=0; j1&lt;m1; ++j1)
00818         tmp[j1+m1*(j2+m2*j3)] *= 
00819           1.0/(1.0+tau*(lambda1[j1]+lambda2[j2]+lambda3[j3])*(lambda1[j1]+lambda2[j2]+lambda3[j3]) );
00820   
00821   fftw_execute(backward);
00822   
00823   convertToBSplineCoeff3D(C,m1,m2,m3);
00824   
00825   fftw_destroy_plan(forward);
00826   fftw_destroy_plan(backward);
00827   fftw_free(lambda1);
00828   fftw_free(lambda2);
00829   fftw_free(lambda3);
00830   fftw_free(tmp);
00831 };
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Tue Jan 10 08:16:41 2006 for flirt by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.1 </small></address>
</body>
</html>
