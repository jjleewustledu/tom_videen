head	3.1;
access;
symbols;
locks; strict;
comment	@ * @;


3.1
date	2008.01.07.16.50.10;	author tom;	state Exp;
branches;
next	3.0;

3.0
date	2004.02.20.16.18.40;	author tom;	state Exp;
branches;
next	2.22;

2.22
date	2003.02.18.16.57.32;	author tom;	state Exp;
branches;
next	2.21;

2.21
date	2000.09.06.19.16.56;	author tom;	state Exp;
branches;
next	2.20;

2.20
date	99.12.17.16.58.46;	author tom;	state Exp;
branches;
next	2.19;

2.19
date	99.10.12.13.27.44;	author tom;	state Exp;
branches;
next	2.18;

2.18
date	99.03.10.20.24.46;	author tom;	state Exp;
branches;
next	2.17;

2.17
date	97.05.30.15.58.03;	author tom;	state Exp;
branches;
next	2.16;

2.16
date	97.01.03.20.19.48;	author tom;	state Exp;
branches;
next	2.15;

2.15
date	96.11.21.18.30.13;	author tom;	state Exp;
branches;
next	2.14;

2.14
date	96.11.06.17.45.10;	author tom;	state Exp;
branches;
next	2.13;

2.13
date	96.10.16.17.27.55;	author tom;	state Exp;
branches;
next	2.6;

2.6
date	96.10.01.16.21.09;	author tom;	state Exp;
branches;
next	2.5;

2.5
date	96.09.11.20.54.53;	author tom;	state Exp;
branches;
next	2.4;

2.4
date	96.09.10.20.00.59;	author tom;	state Exp;
branches;
next	2.3;

2.3
date	96.08.26.17.52.23;	author tom;	state Exp;
branches;
next	2.2;

2.2
date	96.08.23.17.39.28;	author tom;	state Exp;
branches;
next	2.1;

2.1
date	96.08.16.20.42.50;	author tom;	state Exp;
branches;
next	2.0;

2.0
date	96.08.14.20.11.24;	author tom;	state Exp;
branches;
next	1.3;

1.3
date	96.04.24.16.03.47;	author tom;	state Exp;
branches;
next	1.2;

1.2
date	95.10.24.20.15.21;	author tom;	state Exp;
branches;
next	1.1;

1.1
date	95.10.12.21.19.02;	author tom;	state Exp;
branches;
next	;


desc
@@


3.1
log
@attempt to get t88trans to redo meanmr.t88 (did not replicate)
@
text
@/*	$Id: t88trans.c,v 3.0 2004/02/20 16:18:40 tom Exp tom $
	$Log: t88trans.c,v $
 * Revision 3.0  2004/02/20  16:18:40  tom
 * Feb 2004
 *
 * Revision 2.22  2003/02/18  16:57:32  tom
 * replace libmatrix.h with matrixlib.h
 *
 * Revision 2.21  2000/09/06  19:16:56  tom
 * strcpy filename
 *
 * Revision 2.20  1999/12/17  16:58:46  tom
 * lint cleaning
 *
 * Revision 2.19  1999/10/12  13:27:44  tom
 * new libimgutil with updated arc path
 *
 * Revision 2.18  1999/03/10  20:24:46  tom
 * get initial frame from file
 *
 * Revision 2.17  1997/05/30  15:58:03  tom
 * set mh->nframe = 1
 *
 * Revision 2.16  1997/01/03  20:19:48  tom
 * fix bug in array indexing in atlas_transform.c
 *
 * Revision 2.15  1996/11/21  18:30:13  tom
 * change libimgutil (processOxygen.c) to restrict OEF to <=1.1 and CMRO2 to <= 100
 *
 * Revision 2.14  1996/11/06  17:45:10  tom
 * correct scaling of cbf and cbv images
 *
 * Revision 2.13  1996/10/16  17:27:55  tom
 * sync with Version
 * new libimage
 *
 * Revision 2.6  1996/10/01  16:21:09  tom
 * new libraries
 *
 * Revision 2.5  1996/09/11  20:54:53  tom
 * set orientation of output image
 *
 * Revision 2.4  1996/09/10  20:00:59  tom
 * *** empty log message ***
 *
 * Revision 2.3  1996/08/26  17:52:23  tom
 * new libimage
 *
 * Revision 2.2  1996/08/23  17:39:28  tom
 * new libimage
 *
 * Revision 2.1  1996/08/16  20:42:50  tom
 * modify get_input_lists.c to eliminate ".map" string in lst
 *
 * Revision 2.0  1996/08/14  20:11:24  tom
 * new libraries (libimage)
 *
 * Revision 1.3  1996/04/24  16:03:47  tom
 * changed pixel dimension units to cm
 *
 * Revision 1.2  1995/10/24  20:15:21  tom
 * changed z-scaling to use ACPC plane to top of brain
 *
 * Revision 1.1  1995/10/12  21:19:02  tom
 * Initial revision
 * */
/*	===============================================================================
 *	Module:			t88trans.c
 *	Date:			Oct 1995
 *	Author:			Tom Videen
 *	Description:
 *		Transform PET images into atlas space (Talairach 1988) using matrix.
 *		Optionally process images as cvf, cbv, oef, cmro2.
 *
 *	Command line parameters:
 *		parameter file
 *		image list
 *		output filename
 *
 *	Input Files:
 *		parameter file  (prm (5))
 *		image list	  (imagelist (5))
 *		PET image files (PETT VI, ECAT image format; any readable by getrealimg)
 *		hdr files	   (hdr (5))
 *		image mask	  (PETT VI, ECAT image format; any readable by getrealimg)
 *		map files
 *
 *	Output Files:
 *		atlas image	 (ECAT image format)
 *		rec file		(rec (5))
 *		hdr file		(hdr (5))
 *		sd image		(ECAT image format)
 *		n image		 (ECAT image format)
 *	===============================================================================
 */
static char     rcsid[] = "$Header: /home/npggw/tom/src/t88trans/RCS/t88trans.c,v 3.0 2004/02/20 16:18:40 tom Exp tom $";

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <image.h>
#include <libimage.h>
#include <matrixlib.h>
#include <nrutil.h>
#include <libnrimg.h>				 /* writetensor */
#include <imgutil.h>				 /* IMAGE_LIST_DATA, MAXPATH, HEADER_DATA */
#include <atlas.h>				 /* BRAIN_ATLAS */

#define  IMGLIST_SIZE 2000			 /* max size of imglist */

/*	----------------------------
 *	Function:	t88trans
 *	----------------------------
 */
main (argc, argv)
	int             argc;
	char           *argv[];
{
	void            atlas_transform ();
	void            getatlas_dh68 ();
	void            image_scale ();
	int             get_input_lists ();
	int             getprms_t88 ();
	ImageFile      *file1;
	Index           indx;
	FILE           *recfp;			 /* rec file */
	BRAIN_ATLAS     atlas;			 /* brain atlas definition */
	PARAMETER_DATA  prm;			 /* processing parameters */
	IMAGE_LIST_DATA *imglist;		 /* list of images to process */
	HEADER_DATA    *hdr;			 /* hdr structure */
	float         **map;			 /* conversion matrix Atlas -> PET   */
	float         **map1;			 /* conversion matrix Atlas -> PET   */
	float         **shift;			 /* shift map matrix to new zorigin */
	int             use_mask = 0;
	int             compute_sd = 0;
	int             paired_images = 0;
	int             oxygen_mode = 0;
	char           *lstfile;
	char           *prmfile;
	char           *outfile;
	char           *recfile;
	char          **mapfile;		 /* map filenames */
	char            maskfile[MAXPATH];
	char            sdfile[MAXPATH];
	char            wtfile[MAXPATH];
	char           *ext;
	char            runstamp[40];		 /* version, date and userid info */
	char           *today;
	char           *userid;
	char           *activation_scan;
	char           *control_scan;
	char           *flow_scan1;
	char           *vol_scan1;
	char           *flow_scan2;
	char           *vol_scan2;
	int             lstsize = 0;
	int             imgmode;
	int             filtmode;
	int             i, j, k, m, n;		 /* array indices */
	float           scaler;			 /* scale individual PET images */
	float           default_pixel_size;
	float           default_plane_separation;
	float           plane_separation = 0;
	double          weight;
	double          maxwt;
	int             scanner;		 /* 6, 953, 961 */
	long            odim[3];		 /* dimensions of output atlas images */
	long            idim[3];		 /* dimensions of input images */
	float        ***image1;			 /* first (activation) PET image */
	float        ***image2;			 /* second (control) PET image */
	float        ***image3;			 /* flow PET image for oxygen processing */
	float        ***image4;			 /* volume PET image for oxygen processing */
	float        ***atlas_image;		 /* atlas-transformed image */
	float        ***totwt;			 /* total of weighted images contributing to each
						  * element of atlas_image */
	float        ***sdimage;		 /* SD image */
	float        ***mask;			 /* mask for PET images */
	char         ***scan;			 /* scan filenames */

/*
 *	parameters read from prm file
 */

	float           smg_norm;
	float           smg_mskpct;
	int             first_slice;
	int             last_slice;
	int             default_z0;		 /* default atlas.z0 (read in getatlas_* ) */
	int             zorigin;		 /* atlas.z0 from prm file */
	int             zmax;			 /* atlas.nz from prm file */
	int             processing;
	char            smg_mode[10] = "";
	char            smg_divisor[10] = "";
	char            smg_included[10] = "";
	char            smg_mask[10] = "";
	char            smg_compute[10] = "";
	char            smg_sdimage[10] = "";
	char            smg_nimage[10] = "";
	char            smg_symmetry[10] = "";
	char            atlas_name[10] = "";

	filtmode = IMGFILTER_MODE;
	maxwt = 0;
	map = matrix (1, 4, 1, 4);

/*
 *	Read command line arguments and initialize filenames.
 *	---------------------------------------------------
 */

	if (argc != 13) {
		fprintf (stderr, "Usage: t88trans prmlist imglist outfile recfile date\n");
		return (ERROR);
	}
	prmfile = argv[1];
	lstfile = argv[2];
	outfile = argv[3];
	recfile = argv[4];
	(void) sprintf (runstamp, "%s %s %s %s %s %s", argv[5], argv[6], argv[7], argv[8], argv[9], argv[10]);
	today = argv[11];
	userid = argv[12];

	(void) strcpy (sdfile, outfile);
	ext = strrchr (sdfile, '.');
	if (ext != NULL)
		(void) strcpy (ext, ".sd");
	else
		(void) strcat (sdfile, ".sd");

	(void) strcpy (wtfile, outfile);
	ext = strrchr (wtfile, '.');
	if (ext != NULL)
		(void) strcpy (ext, ".n");
	else
		(void) strcat (wtfile, ".n");

	recfp = fopen (recfile, "a");
	if (recfp == (FILE *) NULL) {
		fprintf (stderr, "Error: cannot open %s\n", recfile);
		return (ERROR);
	}
	indx.frm = 1;
	indx.pln = 1;
	indx.gate = 1;
	indx.data = 0;
	indx.bed = 0;
	prm.processing = 0;

/*
 *	Read imagelist into structure imglist
 *	----------------------------------------
 */

	imglist = (IMAGE_LIST_DATA *) malloc (IMGLIST_SIZE * sizeof (IMAGE_LIST_DATA));

	if (readmaplist (lstfile, imglist, &lstsize) == ERROR) {
		fprintf (stderr, "ERROR [t88trans]: reading list %s\n", lstfile);
		return (ERROR);
	}
	if (lstsize > IMGLIST_SIZE) {
		fprintf (stderr, "ERROR [t88trans]: imglist size %d > %d\n", lstsize, IMGLIST_SIZE);
		return (ERROR);
	}
/*
 *	Read parameters into structure prm
 *	---------------------------------------------
 */
	scan = (char ***) malloc (lstsize * sizeof (char **));
	for (i = 0; i < lstsize; i++) {
		scan[i] = (char **) malloc (6 * sizeof (char *));
		for (j = 0; j < 6; j++)
			scan[i][j] = (char *) malloc (sizeof (MAXPATH));
	}
	mapfile = (char **) malloc (lstsize * sizeof (char *));
	if (mapfile == NULL)
		return (ERROR);
	for (i = 0; i < lstsize; i++)
		mapfile[i] = (char *) malloc (sizeof (MAXPATH));

	if (getprms_t88 (prmfile, &smg_norm, smg_divisor, smg_included, &processing, smg_mode, smg_mask,
	     smg_sdimage, smg_nimage, smg_symmetry, &smg_mskpct, smg_compute, &default_pixel_size,
			 &default_plane_separation, &first_slice, &last_slice, &zorigin, &zmax,
			 atlas_name) == ERROR) {
		fprintf (stderr, "ERROR [t88trans]: reading parameter file %s\n", prmfile);
		return (ERROR);
	}
	if (strcmp (smg_mode, "paired") == 0)
		paired_images = 1;

	if (processing == PROC_OEF || processing == PROC_CMRO2) {
		oxygen_mode = 1;
		imgmode = MULTITRACER_IMAGE_MODE;
	} else if (strcmp (smg_mode, "diff") == 0)
		imgmode = DIFIMAGE_MODE;
	else
		imgmode = STDIMAGE_MODE;

/*
 *	Construct full path names in scan
 */
	if (get_input_lists (prmfile, lstsize, imgmode, filtmode, scan, mapfile, &prm, imglist) == ERROR) {
		fprintf (stderr, "ERROR [t88trans]: building image names\n");
		return (ERROR);
	}
/*
 *	Get atlas values and allocate memory
 */

	if (strcmp (atlas_name, "t88") != 0) {
		getatlas_t88br (&atlas);
	} else if (strcmp (atlas_name, "dh68") != 0) {
		getatlas_dh68 (&atlas);
	} else {
		fprintf (stderr, "ERROR [t88trans]: illegal atlas name: %s\n", atlas_name);
		return (ERROR);
	}
	default_z0 = atlas.z0;
	if (zorigin > 0)
		atlas.z0 = zorigin;
	if (zmax > 0)
		atlas.nz = zmax;

	odim[0] = (long) atlas.nx;
	odim[1] = (long) atlas.ny;
	odim[2] = (long) atlas.nz;
	if ((atlas_image = f3tensor (1, odim[2], 1, odim[1], 1, odim[0])) == NULL) {
		fprintf (stderr, "ERROR [t88trans]: Cannot malloc image for atlas_image\n");
		return (ERROR);
	}
	if ((totwt = f3tensor (1, odim[2], 1, odim[1], 1, odim[0])) == NULL) {
		fprintf (stderr, "ERROR [t88trans]: Cannot malloc image for totwt\n");
		return (ERROR);
	}
	hdr = (HEADER_DATA *) malloc (sizeof (HEADER_DATA));
	map = matrix (1, 4, 1, 4);

/*
 *	LOOP for each image or image-pair in the list:
 *	---------------------------------------------
 */

	for (i = 0; i < lstsize; ++i) {
		activation_scan = scan[i][0];
		if (oxygen_mode) {
			flow_scan1 = scan[i][1];
			vol_scan1 = scan[i][2];
			if (paired_images) {
				control_scan = scan[i][3];
				flow_scan2 = scan[i][4];
				vol_scan2 = scan[i][5];
			}
		} else if (paired_images) {
			control_scan = scan[i][1];
		}
/*
 *	First image, first time -- get scanner and dimensions; zero arrays (atlas_image, totwt, sdimage)
 *	------------------------------------------------------------------
 */
		if (i == 0) {
			file1 = make_imgfile (activation_scan);
			if (file1 == NULL) {
				fprintf (stderr, "ERROR [t88trans]: making file\n");
				return (ERROR);
			}
			if (get_imgh (file1, &indx) == ERROR) {
				fprintf (stderr, "ERROR [t88trans]: opening %s\n", activation_scan);
				return (ERROR);
			}
			scanner = file1->mh->scanner_type;
			if (scanner != 6 && scanner != 953 && scanner != 961 && scanner != 0) {
				fprintf (stderr, "ERROR [t88trans]: file is not a recognized PET image\n");
				return (ERROR);
			}
			idim[0] = odim[0];
			idim[1] = odim[1];
			idim[2] = (long) file1->sh->dim3;
			plane_separation = file1->sh->sample_size_3;

			if (default_plane_separation > 0)
				plane_separation = default_plane_separation;

			if (strcmp (smg_mask, "yes") == 0)
				use_mask = 1;
			if (strcmp (smg_sdimage, "yes") == 0) {
				compute_sd = 1;
				if ((sdimage = f3tensor (1, odim[2], 1, odim[1], 1, odim[0])) == NULL) {
					fprintf (stderr, "ERROR [t88trans]: Cannot malloc image for sdimage\n");
					return (ERROR);
				}
			} 
			for (m = 1; m <= odim[2]; ++m) {
				for (j = 1; j <= odim[1]; ++j) {
					for (k = 1; k <= odim[0]; ++k) {
						atlas_image[m][j][k] = 0.;
						totwt[m][j][k] = 0.;
						if (compute_sd)
							sdimage[m][j][k] = 0.;
					}
				}
			}
		} else {
			if (get_imgh (file1, &indx) == ERROR) {
				fprintf (stderr, "ERROR [t88trans]: opening %s\n", activation_scan);
				return (ERROR);
			}
		}
/*
 *	Read and process First (activation) image
 *	-----------------------------------------
 */
		if (oxygen_mode) {
			if ((image3 = rdtensor1 (flow_scan1, odim)) == NULL) {
				fprintf (stderr, "ERROR [t88trans] reading cbf %s\n", flow_scan1);
				return (ERROR);
			}
			recout (recfp, flow_scan1);
			fprintf (stdout, "Flow = %s\n", flow_scan1);

			if ((image4 = rdtensor1 (vol_scan1, odim)) == NULL) {
				fprintf (stderr, "ERROR [t88trans]: opening cbv %s\n", vol_scan1);
				return (ERROR);
			}
			recout (recfp, vol_scan1);
			fprintf (stdout, "Vol  = %s\n", vol_scan1);
		}
		if ((image1 = rdtensor (file1, indx, odim)) == NULL) {
			fprintf (stderr, "ERROR [t88trans] reading scan %s\n", activation_scan);
			return (ERROR);
		}
		close_imgfile (file1);
		recout (recfp, activation_scan);
		fprintf (stdout, "Activation  = %s\n", activation_scan);

		if (strcmp (smg_compute, "no") != 0) {
			if (imgmode == DIFIMAGE_MODE)
				scaler = 1.0;
			else if (smg_norm == 0) {
				fprintf (stderr, "ERROR [t88trans]: Parameter smg_norm in parameter list is 0\n");
				return (ERROR);
			} else if (imglist[i].mean1 == 0) {
				fprintf (stderr, "ERROR [t88trans]: Normalization factor in image list is 0\n");
				return (ERROR);
			} else
				scaler = smg_norm / imglist[i].mean1;
			fprintf (stdout, "%f  %f\n", smg_norm, imglist[i].mean1);
			fprintf (stdout, "Scale %s by %f\n", activation_scan, scaler);
			fprintf (recfp, "Scale %s by %f\n", activation_scan, scaler);
		} else
			scaler = 1.0;

		if (oxygen_mode) {
			if (processOxygen (image1, image3, image4, idim, scaler,
			    processing, activation_scan, flow_scan1, vol_scan1, recfp, hdr) > 0) {
				fprintf (stderr, "ERROR [t88trans] processing %s %s %s\n", activation_scan,
					 flow_scan1, vol_scan1);
				return (ERROR);
			}
			free_f3tensor (image3, 1, idim[2], 1, idim[1], 1, idim[0]);
			free_f3tensor (image4, 1, idim[2], 1, idim[1], 1, idim[0]);
		} else if (processPET (image1, idim, scaler, processing,
				       activation_scan, recfp, hdr) > 0) {
			fprintf (stderr, "ERROR [t88trans] processing %s\n", activation_scan);
			return (ERROR);
		}
/*
 *	Read and process second (control) image (for paired lists)
 *	----------------------------------------------------------
 */
		if (paired_images) {
			if (oxygen_mode) {
				if ((image3 = rdtensor1 (flow_scan2, odim)) == NULL) {
					fprintf (stderr, "ERROR [t88trans] reading cbf2 %s\n", flow_scan2);
					return (ERROR);
				}
				recout (recfp, flow_scan2);
				fprintf (stdout, "Flow = %s\n", flow_scan2);

				if ((image4 = rdtensor1 (vol_scan2, odim)) == NULL) {
					fprintf (stderr, "ERROR [t88trans] reading cbv2 %s\n", vol_scan2);
					return (ERROR);
				}
				recout (recfp, vol_scan2);
				fprintf (stdout, "Vol  = %s\n", vol_scan2);
			}
			if ((image2 = rdtensor1 (control_scan, odim)) == NULL) {
				fprintf (stderr, "ERROR [t88trans] reading control %s\n", control_scan);
				return (ERROR);
			}
			recout (recfp, control_scan);
			fprintf (stdout, "Control  = %s\n", control_scan);

			if (imgmode == DIFIMAGE_MODE)
				scaler = 1.0;
			else if (imglist[i].mean2 == 0) {
				fprintf (stderr, "ERROR [t88trans]: Normalization factor in image list is 0\n");
				return (ERROR);
			} else
				scaler = smg_norm / imglist[i].mean2;
			fprintf (recfp, "Scale %s by %f\n", control_scan, scaler);

			if (oxygen_mode) {
				if (processOxygen (image2, image3, image4, idim, scaler,
				processing, control_scan, flow_scan2, vol_scan2, recfp, hdr) > 0) {
					fprintf (stderr, "ERROR [t88trans] processing %s %s %s\n", control_scan,
						 flow_scan2, vol_scan2);
					return (ERROR);
				}
				free_f3tensor (image3, 1, idim[2], 1, idim[1], 1, idim[0]);
				free_f3tensor (image4, 1, idim[2], 1, idim[1], 1, idim[0]);
			} else if (processPET (image2, idim, scaler, processing,
					       control_scan, recfp, hdr) > 0) {
				fprintf (stderr, "ERROR [t88trans] processing %s\n", control_scan);
				return (ERROR);
			}
		}
/*
 *	Read the mask file (optional)
 *	-----------------------------
 */
		if (use_mask) {
			strcpy (maskfile, activation_scan);
			ext = strrchr (maskfile, '.');
			if (ext != NULL)
				(void) strcpy (ext, ".msk");
			else
				(void) strcat (maskfile, ".msk");
			if ((mask = rdtensor1 (maskfile, odim)) == NULL) {
				fprintf (stderr, "ERROR [t88trans] reading mask %s\n", maskfile);
				return (ERROR);
			}
			recout (recfp, maskfile);
		}
/*
 *	Read Matrix file information
 *	-------------------------
 */

		if (atlas.z0 == default_z0) {
			if (getmap (mapfile[i], map) == ERROR) {
				fprintf (stderr, "Error reading map %s\n", mapfile[i]);
				return (ERROR);
			}
/*	If atlas.z0 differs from the atlas definition, compute the shift */

		} else {			 /* if z0 differs from the atlas definition,
						  * compute the shift */
			shift = matrix (1, 4, 1, 4);
			map1 = matrix (1, 4, 1, 4);
			if (getmap (mapfile[i], map1) == ERROR) {
				fprintf (stderr, "Error reading map %s\n", mapfile[i]);
				return (ERROR);
			}
			for (m = 1; m <= 4; m++) {
				for (n = 1; n <= 4; n++)
					shift[m][n] = 0.0;
				shift[m][m] = 1.0;
			}
			shift[3][4] = (default_z0 - atlas.z0) * (atlas.slice_separation / plane_separation);
			matrix_mult (shift, map1, map, 4, 4, 4);
			free_matrix (shift, 1, 4, 1, 4);
			free_matrix (map1, 1, 4, 1, 4);
		}
		fprintf (recfp, "%s\n", mapfile[i]);
		for (m = 1; m <= 4; m++) {
			for (n = 1; n <= 4; n++)
				fprintf (recfp, "%10.4f  ", map[m][n]);
			fprintf (recfp, "\n");
		}
		fprintf (recfp, "Matrix Transform:  Matrix*Atlas -> PET\n");
		matrix_print (map, 4, 4);

/*
 *	Subtract, transform to atlas space, and sum
 */
		if (paired_images)
			subtensors (image1, image2, idim);
		weight = imglist[i].weight;
		maxwt += weight;
		atlas_transform (image1, idim, atlas_image, odim, sdimage, weight, totwt,
				 mask, map, use_mask, compute_sd, first_slice, last_slice);
		if (paired_images)
			free_f3tensor (image2, 1, idim[2], 1, idim[1], 1, idim[0]);
		free_f3tensor (image1, 1, idim[2], 1, idim[1], 1, idim[0]);
		if (use_mask)
			free_f3tensor (mask, 1, idim[2], 1, idim[1], 1, idim[0]);
	}

/*	End LOOP
 *	--------
 *
 *	Scale final atlas image and mask pixels
 *	---------------------------------------
 */

	image_scale (atlas_image, totwt, odim, maxwt, smg_divisor, smg_included,
		     compute_sd, sdimage);

	scaler = 1.0;
	if (prm.processing == PROC_CBF)
		scaler = SCALE_CBF;
	else if (prm.processing == PROC_CBV)
		scaler = SCALE_CBV;
	else if (prm.processing == PROC_OEF)
		scaler = SCALE_OEF;
	else if (prm.processing == PROC_CMRO2)
		scaler = SCALE_CMRO2;
	if (scaler != 1.0) {
		for (i = 1; i <= odim[2]; ++i) {
			for (j = 1; j <= odim[1]; ++j) {
				for (k = 1; k <= odim[0]; ++k) {
					atlas_image[i][j][k] *= scaler;
				}
			}
		}
	}
/*
 *	Write Summed Image to outfile
 *	-----------------------------
 *	pixel_size and slice_separation must be set in all subheaders
 */

	(void) strcpy (file1->name, outfile);
	(void) strcpy (file1->mode, "w");
	file1->mh->nplane = odim[2];
	file1->mh->nframe = 1;
	file1->mh->slicesep = atlas.slice_separation;
	file1->mh->zorigin = atlas.z0;
	file1->mh->orientation = 0;
	file1->sh->sample_size_1 = atlas.pixel_size;
	file1->sh->sample_size_2 = atlas.pixel_size;
	file1->sh->sample_size_3 = atlas.slice_separation;
	file1->sh->dim1 = (short) odim[0];
	file1->sh->dim2 = (short) odim[1];
	file1->sh->dim3 = (short) odim[2];
	(void) save_rcs (file1, rcsid, runstamp);
	indx.frm = 1;
	if (wrtensor (file1, indx, atlas_image) == ERROR) {
		fprintf (stderr, "ERROR [t88trans] writing %s\n", outfile);
		return (ERROR);
	}

/*	Write HDR file	*/

	if (processing != PROC_NONE) {
		if (writehdr (hdr, outfile, userid, today, processing, (short) atlas.nz) == ERROR) {
			fprintf (stderr, "ERROR [t88trans] writing hdr file\n");
		}
	}

/*	Write SD Image to sdfile	*/

	if (compute_sd) {
		(void) strcpy (file1->name, sdfile);
		(void) strcpy (file1->mode, "w");
		if (wrtensor (file1, indx, sdimage) == ERROR) {
			fprintf (stderr, "ERROR [t88trans] writing %s\n", sdfile);
			return (ERROR);
		}
	}

/*	Write Total Weight Image to wtfile	*/

	if (strcmp (smg_nimage, "yes") == 0) {
		(void) strcpy (file1->name, wtfile);
		(void) strcpy (file1->mode, "w");
		if (wrtensor (file1, indx, totwt) == ERROR) {
			fprintf (stderr, "ERROR [t88trans] writing %s\n", wtfile);
			return (ERROR);
		}
	}

/*  Free memory	*/

	(void) fclose (recfp);
	if (sdimage != NULL)
		free_f3tensor (sdimage, 1, odim[2], 1, odim[1], 1, odim[0]);
	free_f3tensor (totwt, 1, odim[2], 1, odim[1], 1, odim[0]);
	free_f3tensor (atlas_image, 1, odim[2], 1, odim[1], 1, odim[0]);
	free (atlas.xdim);
	free (atlas.ydim);
	free (imglist);
	for (i = 0; i < lstsize; i++) {
		for (j = 0; j < 6; j++)
			free (scan[i][j]);
		free (scan[i]);
	}
	free (scan);
	for (i = 0; i < lstsize; i++)
		free (mapfile[i]);
	if (mapfile != NULL)
		free (mapfile);
	free (hdr);
	free_imgfile (file1);
	free_matrix (map, 1, 4, 1, 4);
	return (0);
}
@


3.0
log
@Feb 2004
@
text
@d1 1
a1 1
/*	$Id: t88trans.c,v 2.22 2003/02/18 16:57:32 tom Exp tom $
d3 3
d96 1
a96 1
static char     rcsid[] = "$Header: /home/npggw/tom/src/t88trans/RCS/t88trans.c,v 2.22 2003/02/18 16:57:32 tom Exp tom $";
d258 1
a258 1
		fprintf (stderr, "ERROR [t88trans]: reading %s\n", lstfile);
d367 1
a367 1
				fprintf (stderr, "ERROR [t88trans]: Cannot open %s\n", activation_scan);
d402 5
d414 1
a414 1
				fprintf (stderr, "ERROR [t88trans] reading %s\n", flow_scan1);
d421 1
a421 1
				fprintf (stderr, "ERROR [t88trans]: Cannot open %s\n", vol_scan1);
d428 1
a428 1
			fprintf (stderr, "ERROR [t88trans] reading %s\n", activation_scan);
d473 1
a473 1
					fprintf (stderr, "ERROR [t88trans] reading %s\n", flow_scan2);
d480 1
a480 1
					fprintf (stderr, "ERROR [t88trans] reading %s\n", vol_scan2);
d487 1
a487 1
				fprintf (stderr, "ERROR [t88trans] reading %s\n", control_scan);
d529 1
a529 1
				fprintf (stderr, "ERROR [t88trans] reading %s\n", maskfile);
d541 1
a541 1
				fprintf (stderr, "Error reading %s\n", mapfile[i]);
d551 1
a551 1
				fprintf (stderr, "Error reading %s\n", mapfile[i]);
@


2.22
log
@replace libmatrix.h with matrixlib.h
@
text
@d1 1
a1 1
/*	$Id: t88trans.c,v 2.21 2000/09/06 19:16:56 tom Exp tom $
d3 3
d66 1
a66 1
 *	Date:			12-Oct-95
d93 1
a93 1
static char     rcsid[] = "$Header: /home/npggw/tom/src/t88trans/RCS/t88trans.c,v 2.21 2000/09/06 19:16:56 tom Exp tom $";
d103 2
a104 2
#include <libnrimg.h>			 /* writetensor */
#include <imgutil.h>			 /* IMAGE_LIST_DATA, MAXPATH, HEADER_DATA */
d107 1
a107 1
#define  IMGLIST_SIZE 2000		 /* max size of imglist */
a120 1
	int             getmap ();
d122 1
a122 1
	ImageFile      *file;
d132 4
a135 4
	BOOLEAN         use_mask = 0;
	BOOLEAN         compute_sd = 0;
	BOOLEAN         paired_images = 0;
	BOOLEAN         oxygen_mode = 0;
d145 1
a145 1
	char            runstamp[40];	 /* version, date and userid info */
d154 1
a154 1
	int             lstsize=0;
d157 1
a157 1
	int             i, j, k, m, n;	 /* array indices */
d161 1
a161 1
	float           plane_separation=0;
d171 1
a171 1
	float        ***atlas_image;	 /* atlas-transformed image */
d173 1
a173 1
									  * element of atlas_image */
d190 9
a198 9
	char            smg_mode[10]="";
	char            smg_divisor[10]="";
	char            smg_included[10]="";
	char            smg_mask[10]="";
	char            smg_compute[10]="";
	char            smg_sdimage[10]="";
	char            smg_nimage[10]="";
	char            smg_symmetry[10]="";
	char            atlas_name[10]="";
d217 1
a217 1
	sprintf (runstamp, "%s %s %s %s %s %s", argv[5], argv[6], argv[7], argv[8], argv[9], argv[10]);
d221 1
a221 1
	strcpy (sdfile, outfile);
d224 1
a224 1
		strcpy (ext, ".sd");
d226 1
a226 1
		strcat (sdfile, ".sd");
d228 1
a228 1
	strcpy (wtfile, outfile);
d231 1
a231 1
		strcpy (ext, ".n");
d233 1
a233 1
		strcat (wtfile, ".n");
d273 2
a302 1

d307 1
a307 1
	if (!(strcmp (atlas_name, "t88"))) {
d309 1
a309 1
	} else if (!(strcmp (atlas_name, "dh68"))) {
d358 3
a360 3
			file = make_imgfile (activation_scan);
			if (open_imgfile (file) == ERROR) {
				fprintf (stderr, "ERROR [t88trans]: Cannot open %s\n", activation_scan);
d363 2
a364 2
			if (get_mh (file) == ERROR) {
				fprintf (stderr, "ERROR [t88trans]: Cannot get MainHeader from %s\n", activation_scan);
d367 1
a367 18
			if (existimgfrm (file, &indx) == ERROR) {
				if (indx.frm == 1) {
					indx.frm = 2;
					if (existimgfrm (file, &indx) == ERROR) {
						fprintf (stderr, "ERROR [t88trans]: cannot find %s frame 1 or 2\n", activation_scan);
						return (ERROR);
					}
				} else {
					fprintf (stderr, "ERROR [t88trans]: cannot find %s frame %d\n", activation_scan, indx.frm);
					return (ERROR);
				}
			}
			if (get_sh (file, &indx) == ERROR) {
				fprintf (stderr, "ERROR [t88trans]: Cannot read file subheader in %s\n",
					 activation_scan);
				return (ERROR);
			}
			scanner = file->mh->scanner_type;
d374 3
a376 3
			idim[2] = (long) file->sh->dim3;
			plane_separation = file->sh->sample_size_3;
			close_imgfile (file);
d388 1
a388 2
			} else
				sdimage = (float ***) NULL;
d405 1
a405 1
			if ((image3 = rdtensor (flow_scan1, indx, odim)) == NULL) {
d412 1
a412 1
			if ((image4 = rdtensor (vol_scan1, indx, odim)) == NULL) {
d417 1
a417 1
			fprintf (stdout,"Vol  = %s\n", vol_scan1);
d419 1
a419 1
		if ((image1 = rdtensor (activation_scan, indx, odim)) == NULL) {
d423 1
d425 1
a425 1
		fprintf (stdout,"Activation  = %s\n", activation_scan);
d438 2
a439 2
			fprintf (stdout,"%f  %f\n", smg_norm, imglist[i].mean1);
			fprintf (stdout,"Scale %s by %f\n", activation_scan, scaler);
d464 1
a464 1
				if ((image3 = rdtensor (flow_scan2, indx, odim)) == NULL) {
d469 1
a469 1
				fprintf (stdout,"Flow = %s\n", flow_scan2);
d471 1
a471 1
				if ((image4 = rdtensor (vol_scan2, indx, odim)) == NULL) {
d476 1
a476 1
				fprintf (stdout,"Vol  = %s\n", vol_scan2);
d478 1
a478 1
			if ((image2 = rdtensor (control_scan, indx, odim)) == NULL) {
d483 1
a483 1
			fprintf (stdout,"Control  = %s\n", control_scan);
d517 1
a517 1
				strcpy (ext, ".msk");
d519 2
a520 2
				strcat (maskfile, ".msk");
			if ((mask = rdtensor (maskfile, indx, odim)) == NULL) {
d615 16
a630 15
	strcpy (file->name, outfile);
	strcpy (file->mode, "w");
	file->mh->nplane = odim[2];
	file->mh->nframe = 1;
	file->mh->slicesep = atlas.slice_separation;
	file->mh->zorigin = atlas.z0;
	file->mh->orientation = 0;
	file->sh->sample_size_1 = atlas.pixel_size;
	file->sh->sample_size_2 = atlas.pixel_size;
	file->sh->sample_size_3 = atlas.slice_separation;
	file->sh->dim1 = (short) odim[0];
	file->sh->dim2 = (short) odim[1];
	file->sh->dim3 = (short) odim[2];
	save_rcs (file, rcsid, runstamp);
	if (wrtensor (file, indx, atlas_image) == ERROR) {
d634 3
a636 4
/*
 *	Write HDR file
 *	--------------
 */
a641 4
/*
 *	Write SD Image to sdfile
 *	------------------------
 */
d643 2
d646 3
a648 3
		strcpy (file->name, sdfile);
		strcpy (file->mode, "w");
		if (wrtensor (file, indx, sdimage) == ERROR) {
a652 4
/*
 *	Write Total Weight Image to wtfile
 *	----------------------------------
 */
d654 2
d657 3
a659 3
		strcpy (file->name, wtfile);
		strcpy (file->mode, "w");
		if (wrtensor (file, indx, totwt) == ERROR) {
d664 5
a668 5
/*
 *  Free memory
 *  -----------
 */
	if (compute_sd)
a679 1

d683 2
a684 1
	free (mapfile);
d686 1
a686 2
	free_imgfile (file);
	fclose (recfp);
@


2.21
log
@strcpy filename
@
text
@d1 1
a1 1
/*	$Id: t88trans.c,v 2.20 1999/12/17 16:58:46 tom Exp tom $
d3 3
d90 1
a90 1
static char     rcsid[] = "$Header: /home/npggw/tom/src/t88trans/RCS/t88trans.c,v 2.20 1999/12/17 16:58:46 tom Exp tom $";
d98 1
a98 1
#include <libmatrix.h>
@


2.20
log
@lint cleaning
@
text
@d1 1
a1 1
/*	$Id: t88trans.c,v 2.19 1999/10/12 13:27:44 tom Exp tom $
d3 3
d87 1
a87 1
static char     rcsid[] = "$Header: /home/npggw/tom/src/t88trans/RCS/t88trans.c,v 2.19 1999/10/12 13:27:44 tom Exp tom $";
d626 1
a626 1
	file->name = outfile;
d659 1
a659 1
		file->name = sdfile;
d672 1
a672 1
		file->name = wtfile;
@


2.19
log
@new libimgutil with updated arc path
@
text
@d1 1
a1 1
/*	$Id: t88trans.c,v 2.18 1999/03/10 20:24:46 tom Exp tom $
d3 3
d84 1
a84 1
static char     rcsid[] = "$Header: /home/npggw/tom/src/t88trans/RCS/t88trans.c,v 2.18 1999/03/10 20:24:46 tom Exp tom $";
d92 1
a92 1
#include <nr.h>
d94 2
a95 2
#include <libnrimg.h>				 /* writetensor */
#include <imgutil.h>				 /* IMAGE_LIST_DATA, MAXPATH, HEADER_DATA */
d98 1
a98 1
#define  IMGLIST_SIZE 2000			 /* max size of imglist */
a107 1
	int             atlas_scalers ();
d109 3
d113 1
a113 1
	void            matrix_inv ();
d146 1
a146 1
	int             lstsize;
d153 3
a155 3
	float           plane_separation;
	float           weight;
	float           maxwt;
d182 9
a190 9
	char            smg_mode[10];
	char            smg_divisor[10];
	char            smg_included[10];
	char            smg_mask[10];
	char            smg_compute[10];
	char            smg_sdimage[10];
	char            smg_nimage[10];
	char            smg_symmetry[10];
	char            atlas_name[10];
d202 1
a202 1
		printf ("Usage: t88trans prmlist imglist outfile recfile date\n");
d237 1
d289 4
a292 1
	get_input_lists (prmfile, lstsize, imgmode, filtmode, scan, mapfile, &prm, imglist);
d362 1
a362 1
						fprintf (stderr, "ERROR [t88trans]: cannot find %s frame 1 or 2\n", file);
d366 1
a366 1
					fprintf (stderr, "ERROR [t88trans]: cannot find %s frame %d\n", file, indx.frm);
d419 1
a419 1
			printf ("Flow = %s\n", flow_scan1);
d426 1
a426 1
			printf ("Vol  = %s\n", vol_scan1);
d433 1
a433 1
		printf ("Activation  = %s\n", activation_scan);
d446 2
a447 2
			printf ("%f  %f\n", smg_norm, imglist[i].mean1);
			printf ("Scale %s by %f\n", activation_scan, scaler);
d477 1
a477 1
				printf ("Flow = %s\n", flow_scan2);
d484 1
a484 1
				printf ("Vol  = %s\n", vol_scan2);
d491 1
a491 1
			printf ("Control  = %s\n", control_scan);
@


2.18
log
@get initial frame from file
@
text
@d1 1
a1 1
/*	$Id: t88trans.c,v 2.17 1997/05/30 15:58:03 tom Exp tom $
d3 3
d81 1
a81 1
static char     rcsid[] = "$Header: /home/npggw/tom/src/t88trans/RCS/t88trans.c,v 2.17 1997/05/30 15:58:03 tom Exp tom $";
@


2.17
log
@set mh->nframe = 1
@
text
@d1 1
a1 1
/*	$Id: t88trans.c,v 2.16 1997/01/03 20:19:48 tom Exp tom $
d3 3
d64 1
a64 1
 *		image list      (imagelist (5))
d66 2
a67 2
 *		hdr files       (hdr (5))
 *		image mask      (PETT VI, ECAT image format; any readable by getrealimg)
d71 5
a75 7
 *		atlas image     (ECAT image format)
 *		rec file        (rec (5))
 *		hdr file        (hdr (5))
 *		sd image        (ECAT image format)
 *		n image         (ECAT image format)
 *
 *	History:
d78 1
a78 1
static char     rcsid[] = "$Header: /home/npggw/tom/src/t88trans/RCS/t88trans.c,v 2.16 1997/01/03 20:19:48 tom Exp tom $";
d129 1
a129 1
	char            runstamp[40];		 /* version, date and userid info */
d141 1
a141 1
	int             i, j, k, m, n;		 /* array indices */
d155 1
a155 1
	float        ***atlas_image;		 /* atlas-transformed image */
d157 1
a157 1
						  * element of atlas_image */
a192 2
	printf ("Copyright 1991-1996, Washington University\n");
	printf ("All rights reserved. Unauthorized reproduction prohibited.\n");
d346 12
@


2.16
log
@fix bug in array indexing in atlas_transform.c
@
text
@d1 1
a1 1
/*	$Id: t88trans.c,v 2.15 1996/11/21 18:30:13 tom Exp tom $
d3 3
d77 1
a77 1
static char     rcsid[] = "$Header: /home/npggw/tom/src/t88trans/RCS/t88trans.c,v 2.15 1996/11/21 18:30:13 tom Exp tom $";
d603 1
@


2.15
log
@change libimgutil (processOxygen.c) to restrict OEF to <=1.1 and CMRO2 to <= 100
@
text
@d1 1
a1 1
/*	$Id: t88trans.c,v 2.14 1996/11/06 17:45:10 tom Exp tom $
d3 3
d74 1
a74 1
static char     rcsid[] = "$Header: /home/npggw/tom/src/t88trans/RCS/t88trans.c,v 2.14 1996/11/06 17:45:10 tom Exp tom $";
@


2.14
log
@correct scaling of cbf and cbv images
@
text
@d1 1
a1 1
/*	$Id: t88trans.c,v 2.13 1996/10/16 17:27:55 tom Exp tom $
d3 3
d71 1
a71 1
static char     rcsid[] = "$Header: /home/npggw/tom/src/t88trans/RCS/t88trans.c,v 2.13 1996/10/16 17:27:55 tom Exp tom $";
@


2.13
log
@sync with Version
new libimage
@
text
@d1 1
a1 1
/*	$Id: t88trans.c,v 2.6 1996/10/01 16:21:09 tom Exp tom $
d3 4
d68 1
a68 1
static char     rcsid[] = "$Header: /home/npggw/tom/src/t88trans/RCS/t88trans.c,v 2.6 1996/10/01 16:21:09 tom Exp tom $";
d78 3
a80 3
#include <libnrimg.h>		 /* writetensor */
#include <imgutil.h>		 /* IMAGE_LIST_DATA, MAXPATH, HEADER_DATA */
#include <atlas.h>			 /* BRAIN_ATLAS */
d82 1
a82 1
#define  IMGLIST_SIZE 2000	 /* max size of imglist */
d119 1
a119 1
	char            runstamp[40];	 /* version, date and userid info */
d131 1
a131 1
	int             i, j, k, m, n;	 /* array indices */
d145 1
a145 1
	float        ***atlas_image;	 /* atlas-transformed image */
d147 1
a147 1
						  			  * element of atlas_image */
d161 1
a161 1
	int             zorigin;	 	 /* atlas.z0 from prm file */
a511 1

d514 2
a515 1
		} else {	/* if z0 differs from the atlas definition, compute the shift */
d567 18
@


2.6
log
@new libraries
@
text
@d1 1
a1 1
/*	$Id: t88trans.c,v 2.5 1996/09/11 20:54:53 tom Exp tom $
d3 3
d64 1
a64 1
static char     rcsid[] = "$Header: /home/npggw/tom/src/t88trans/RCS/t88trans.c,v 2.5 1996/09/11 20:54:53 tom Exp tom $";
@


2.5
log
@set orientation of output image
@
text
@d1 1
a1 1
/*	$Id: t88trans.c,v 2.4 1996/09/10 20:00:59 tom Exp tom $
d3 3
d61 1
a61 1
static char     rcsid[] = "$Header: /home/npggw/tom/src/t88trans/RCS/t88trans.c,v 2.4 1996/09/10 20:00:59 tom Exp tom $";
@


2.4
log
@*** empty log message ***
@
text
@d1 1
a1 1
/*	$Id: t88trans.c,v 2.3 1996/08/26 17:52:23 tom Exp tom $
d3 3
d58 1
a58 1
static char     rcsid[] = "$Header: /home/npggw/tom/src/t88trans/RCS/t88trans.c,v 2.3 1996/08/26 17:52:23 tom Exp tom $";
d568 1
@


2.3
log
@new libimage
@
text
@d1 1
a1 1
/*	$Id: t88trans.c,v 2.2 1996/08/23 17:39:28 tom Exp tom $
d3 3
d55 1
a55 1
static char     rcsid[] = "$Header: /home/npggw/tom/src/t88trans/RCS/t88trans.c,v 2.2 1996/08/23 17:39:28 tom Exp tom $";
d259 1
a259 1
	get_input_lists (prmfile, lstsize, filtmode, scan, mapfile, &prm, imglist);
d266 1
a266 1
		getatlas_t88 (&atlas);
d331 1
a331 1
			if (scanner != 6 && scanner != 953 && scanner != 961) {
@


2.2
log
@new libimage
@
text
@d1 1
a1 1
/*	$Id: t88trans.c,v 2.1 1996/08/16 20:42:50 tom Exp tom $
d3 3
d52 1
a52 1
static char     rcsid[] = "$Header: /home/npggw/tom/src/t88trans/RCS/t88trans.c,v 2.1 1996/08/16 20:42:50 tom Exp tom $";
@


2.1
log
@modify get_input_lists.c to eliminate ".map" string in lst
@
text
@d1 1
a1 1
/*	$Id: t88trans.c,v 2.0 1996/08/14 20:11:24 tom Exp tom $
d3 3
d49 1
a49 1
static char     rcsid[] = "$Header: /home/npggw/tom/src/t88trans/RCS/t88trans.c,v 2.0 1996/08/14 20:11:24 tom Exp tom $";
@


2.0
log
@new libraries (libimage)
@
text
@d1 1
a1 1
/*	$Id: t88trans.c,v 1.3 1996/04/24 16:03:47 tom Exp tom $
d3 3
d46 1
a46 1
static char     rcsid[] = "$Header: /home/petsun19/tom/src/t88trans/RCS/t88trans.c,v 1.3 1996/04/24 16:03:47 tom Exp tom $";
@


1.3
log
@changed pixel dimension units to cm
@
text
@d1 1
a1 1
/*	$Id: t88trans.c,v 1.2 1995/10/24 20:15:21 tom Exp tom $
d3 3
d31 1
a31 1
 *		matrix files
d43 2
d49 7
a55 8
#include <petutil/matrix.h>
#include <petutil/package.h>	 /* BOOLEAN */
#include <petutil/petutil.h>
#include <petutil/imglist.h>	 /* IMAGE_LIST_DATA, MAXPATH */
#include <nrecipes/kr/nr.h>
#include <nrecipes/kr/nrutil.h>
#include "brain_atlas.h"		 /* BRAIN_ATLAS */
#define  LSTSIZE 2000			 /* max size of imglist */
d57 1
a57 2
static char     rcsid[] = "$Header: /home/petsun19/tom/src/t88trans/RCS/t88trans.c,v 1.2 1995/10/24 20:15:21 tom Exp tom $";
char            list[] = "*;*;*;*";		 /* any frame plane gate bed */
a58 4
REAL_SLICE     *atlas_image;	 /* atlas-transformed image */
REAL_SLICE     *totwt;			 /* total of weighted images contributing to each
						  			element of atlas_image */

a67 1
	void            getlists ();
d71 3
a73 5

	Image_subheader **subheader;
	Main_header    *main_header;
	MatrixFile     *fptr;
	FILE           *recfp;
d75 2
a76 2
	PARAMETER_DATA  parameter_data;
	IMAGE_LIST_DATA *imglist;
d79 2
a80 2

	BOOLEAN         encoded_flag;
a84 1
	COMMENT_INFO    comment_info_data;
d89 1
a92 1
	char            matrixfile[LSTSIZE][MAXPATH];
d94 1
a94 1
	char            date[40];
d104 3
a106 4
	int             image_mode;
	int             filter_mode;
	int             fd;
	int             i, j, k, m;		 /* array indices */
a107 2
	float           pixel_size;
	float           plane_separation;
d110 1
d113 13
a125 12
	int             scanner;		 /* 6 = PETT VI;  10 = 953B */
	short           nx;
	short           ny;
	short           num_slices;
	struct Matval   matval;
	REAL_SLICE     *image1;			 /* first (activation) PET image */
	REAL_SLICE     *image2;			 /* second (control) PET image */
	REAL_SLICE     *image3;			 /* flow PET image for oxygen processing */
	REAL_SLICE     *image4;			 /* volume PET image for oxygen processing */
	REAL_SLICE     *sdimage;		 /* SD image */
	REAL_SLICE     *mask;			 /* mask for PET images */
	SCANLIST_ARRAY *scan;
d135 4
a138 2
	int             zorigin;
	int             zmax;
a141 1
	char            processing[10];
d149 1
a149 7
	matval.frame = 1;			 /* default values for matval */
	matval.plane = 1;
	matval.gate = 1;
	matval.data = 0;
	matval.bed = 0;

	filter_mode = IMGFILTER_MODE;
d158 1
a158 1
	printf ("Copyright 1991-1995, Washington University\n");
d162 1
a162 1
		exit (FAIL);
d168 1
a168 1
	sprintf (date, "%s %s %s %s %s %s", argv[5], argv[6], argv[7], argv[8], argv[9], argv[10]);
d189 1
a189 1
		exit (FAIL);
d191 6
d202 1
a202 1
	imglist = (IMAGE_LIST_DATA *) malloc (sizeof (IMAGE_LIST_DATA) * LSTSIZE);
d204 3
a206 3
	if (readlist (lstfile, imglist, &lstsize) == FAIL) {
		fprintf (stderr, "Error: reading %s\n", lstfile);
		exit (FAIL);
d208 3
a210 3
	if (lstsize > LSTSIZE) {
		fprintf (stderr, "Error: imglist size %d > %d\n", lstsize, LSTSIZE);
		exit (FAIL);
d213 1
a213 1
 *	Read parameters into structure parameter_data
d216 9
d226 1
a226 3
	scan = (SCANLIST_ARRAY *) malloc (lstsize * sizeof (SCANLIST_ARRAY));

	if (getprms_t88 (prmfile, &smg_norm, smg_divisor, smg_included, processing, smg_mode, smg_mask,
d229 3
a231 3
			 atlas_name) == FAIL) {
		fprintf (stderr, "Error: reading parameter file %s\n", prmfile);
		exit (FAIL);
d236 1
a236 1
	if ((strcmp (processing, "oef") == 0) || (strcmp (processing, "cmro2") == 0)) {
d238 1
a238 1
		image_mode = MULTITRACER_IMAGE_MODE;
d240 1
a240 1
		image_mode = DIFIMAGE_MODE;
d242 1
a242 1
		image_mode = STDIMAGE_MODE;
d247 1
a247 2
	getlists (prmfile, lstsize, image_mode, filter_mode, scan, matrixfile,
		  &parameter_data, imglist);
d254 6
a259 7
		get_t88atlas (&atlas);
		if (zorigin > 0)
			atlas.z0 = zorigin - 1;
		if (zmax > 0)
			atlas.zdim = zmax;
		else
			atlas.zdim = 49;
d261 17
a277 4
	main_header = (Main_header *) calloc (1, sizeof (Main_header));
	subheader = (Image_subheader **) malloc (atlas.zdim * sizeof (caddr_t));
	atlas_image = (REAL_SLICE *) malloc (atlas.zdim * sizeof (REAL_SLICE));
	totwt = (REAL_SLICE *) malloc (atlas.zdim * sizeof (REAL_SLICE));
d279 1
d304 4
a307 4
			fd = open (activation_scan, O_RDONLY, 0);
			if (fd == -1) {
				fprintf (stderr, "Error opening %s\n", activation_scan);
				exit (FAIL);
d309 3
a311 5
			scanner = getimage_type (fd, activation_scan, &encoded_flag, &num_slices);
			close (fd);
			if (scanner == ERROR_SCANNER) {
				fprintf (stderr, "Error: file is not a recognized PET image\n");
				exit (FAIL);
d313 4
a316 11
			if (scanner == ECAT_SCANNER) {
				fptr = OpenEcat (activation_scan, &num_slices, &nx, &ny, &pixel_size,
						 &plane_separation, matval);
				if (fptr == (MatrixFile *) NULL) {
					fprintf (stderr, "Error: cannot open %s as an ECAT image file\n", activation_scan);
					exit (FAIL);
				}
				matrix_close (fptr);
			} else {
				nx = DIM;
				ny = DIM;
d318 12
d331 1
a331 8
			image1 = (REAL_SLICE *) calloc (num_slices, sizeof (REAL_SLICE));
			if (paired_images)
				image2 = (REAL_SLICE *) calloc (num_slices, sizeof (REAL_SLICE));
			if (oxygen_mode) {
				image3 = (REAL_SLICE *) calloc (num_slices, sizeof (REAL_SLICE));
				image4 = (REAL_SLICE *) calloc (num_slices, sizeof (REAL_SLICE));
			}
			if (strcmp (smg_mask, "yes") == 0) {
a332 2
				mask = (REAL_SLICE *) calloc (num_slices, sizeof (REAL_SLICE));
			}
d335 4
a338 1
				sdimage = (REAL_SLICE *) calloc (atlas.zdim, sizeof (REAL_SLICE));
d340 6
a345 7
				sdimage = (REAL_SLICE *) calloc (1, sizeof (float));

			for (m = 0; m < atlas.zdim; ++m) {
				for (j = 0; j < DIM; ++j) {
					for (k = 0; k < DIM; ++k) {
						atlas_image[m][j][k] = 0;
						totwt[m][j][k] = 0;
d347 1
a347 1
							sdimage[m][j][k] = 0;
d357 3
a359 4
			if (getrealimg (flow_scan1, scanner, matval, nx, ny, num_slices, image3,
					main_header, subheader) == FAIL) {
				fprintf (stderr, "Error reading %s\n", flow_scan1);
				exit (FAIL);
d364 3
a366 4
			if (getrealimg (vol_scan1, scanner, matval, nx, ny, num_slices, image4,
					main_header, subheader) == FAIL) {
				fprintf (stderr, "Error reading %s\n", vol_scan1);
				exit (FAIL);
d371 3
a373 4
		if (getrealimg (activation_scan, scanner, matval, nx, ny, num_slices, image1,
				main_header, subheader) == FAIL) {
			fprintf (stderr, "Error reading %s\n", activation_scan);
			exit (FAIL);
d379 1
a379 1
			if (image_mode == DIFIMAGE_MODE)
d382 2
a383 2
				fprintf (stderr, "Error: Parameter smg_norm in parameter list is 0\n");
				exit (FAIL);
d385 2
a386 2
				fprintf (stderr, "Error: Normalization factor in image list is 0\n");
				exit (FAIL);
d389 2
d396 1
a396 1
			if (process_oxygen (image1, image3, image4, nx, ny, num_slices, scaler,
d398 1
a398 1
				fprintf (stderr, "Error processing %s %s %s\n", activation_scan,
d400 1
a400 1
				exit (FAIL);
d402 6
a407 4
		} else if (process_pet (image1, nx, ny, num_slices, scaler, processing,
					activation_scan, recfp, hdr) > 0) {
			fprintf (stderr, "Error processing %s\n", activation_scan);
			exit (FAIL);
a412 1

d415 3
a417 4
				if (getrealimg (flow_scan2, scanner, matval, nx, ny, num_slices, image3,
						main_header, subheader) == FAIL) {
					fprintf (stderr, "Error reading %s\n", flow_scan2);
					exit (FAIL);
d422 3
a424 4
				if (getrealimg (vol_scan2, scanner, matval, nx, ny, num_slices, image4,
						main_header, subheader) == FAIL) {
					fprintf (stderr, "Error reading %s\n", vol_scan2);
					exit (FAIL);
d429 3
a431 4
			if (getrealimg (control_scan, scanner, matval, nx, ny, num_slices, image2,
					main_header, subheader) == FAIL) {
				fprintf (stderr, "Error reading %s\n", control_scan);
				exit (FAIL);
d436 1
a436 1
			if (image_mode == DIFIMAGE_MODE)
d439 2
a440 2
				fprintf (stderr, "Error: Normalization factor in image list is 0\n");
				exit (FAIL);
d446 1
a446 1
				if (process_oxygen (image2, image3, image4, nx, ny, num_slices, scaler,
d448 1
a448 1
					fprintf (stderr, "Error processing %s %s %s\n", control_scan,
d450 1
a450 1
					exit (FAIL);
d452 6
a457 4
			} else if (process_pet (image2, nx, ny, num_slices, scaler, processing,
						control_scan, recfp, hdr) > 0) {
				fprintf (stderr, "Error processing %s\n", control_scan);
				exit (FAIL);
a463 1

d471 3
a473 4
			if (getrealimg (maskfile, scanner, matval, nx, ny, num_slices, mask,
					main_header, subheader) == FAIL) {
				fprintf (stderr, "Error reading %s\n", maskfile);
				exit (FAIL);
d482 24
a505 3
		if (getmap (matrixfile[i], map) == FAIL) {
			fprintf (stderr, "Error reading %s\n", matrixfile[i]);
			exit (FAIL);
d507 6
a512 1
		fprintf (recfp, "%s\n", matrixfile[i]);
a518 1

d520 1
a520 1
			image_diff (image1, image2, num_slices);
d523 7
a529 2
		atlas_transform (image1, atlas_image, sdimage, weight, totwt, atlas, mask, map,
				 num_slices, use_mask, compute_sd, first_slice, last_slice);
d539 1
a539 1
	image_scale (atlas_image, totwt, atlas.zdim, maxwt, smg_divisor, smg_included,
d548 15
a562 2
	for (i = num_slices; i < atlas.zdim; i++) {
		subheader[i] = matrixx_init_image_subheader (subheader[0]);
a563 16
	for (i = 0; i < atlas.zdim; i++) {
		subheader[i]->pixel_size = 0.1 * atlas.pixel_size;
		subheader[i]->slice_width = 0.1 * atlas.slice_separation;
	}
	main_header->plane_separation = 0.1 * atlas.slice_separation;
	strncpy (main_header->physician_name, &rcsid[48], sizeof (main_header->physician_name) - 1);
	strncpy (main_header->operator_name, date, sizeof (main_header->operator_name) - 1);

	comment_info (main_header->study_description, &comment_info_data);
	comment_info_data.zorigin = atlas.z0 + 1;
	info2comment (comment_info_data, main_header->study_description);

	if (writerealimg (outfile, matval, DIM, DIM, atlas.zdim, atlas_image, main_header, subheader)
	    == FAIL) {
		fprintf (stderr, "Error writing %s\n", outfile);
	}
d568 3
a570 4

	if (strcmp (processing, "none") != 0) {
		if (writehdr (hdr, outfile, userid, today, processing, (short) atlas.zdim) == FAIL) {
			fprintf (stderr, "Error writing hdr file\n");
d579 5
a583 3
		if (writerealimg (sdfile, matval, DIM, DIM, atlas.zdim, sdimage, main_header, subheader)
		    == FAIL) {
			fprintf (stderr, "Error writing %s\n", sdfile);
d592 5
a596 3
		if (writerealimg (wtfile, matval, DIM, DIM, atlas.zdim, totwt, main_header, subheader)
		    == FAIL) {
			fprintf (stderr, "Error writing %s\n", wtfile);
d600 2
a601 2
 *	Clean up
 *	--------
d603 12
a615 15
	for (i = 0; i < atlas.zdim; i++)
		free (subheader[i]);
	free (subheader);
	free (main_header);
	free (image1);
	if (paired_images)
		free (image2);
	if (oxygen_mode) {
		free (image3);
		free (image4);
	}
	free (sdimage);
	if (use_mask)
		free (mask);
	free (imglist);
d617 3
d621 2
d624 1
a624 2
	fclose (recfp);
	exit (SUCCEED);
@


1.2
log
@changed z-scaling to use ACPC plane to top of brain
@
text
@d1 1
a1 1
/*	$Id: t88trans.c,v 1.1 1995/10/12 21:19:02 tom Exp tom $
d3 3
d53 1
a53 1
static char     rcsid[] = "$Header: /home/npggw/tom/src/t88trans/RCS/t88trans.c,v 1.1 1995/10/12 21:19:02 tom Exp tom $";
d515 2
a516 2
		subheader[i]->pixel_size = atlas.pixel_size;
		subheader[i]->slice_width = atlas.slice_separation;
d518 1
a518 1
	main_header->plane_separation = atlas.slice_separation;
@


1.1
log
@Initial revision
@
text
@d1 5
a5 2
/*	$Id$
	$Log$ */
d50 1
a50 1
static char     rcsid[] = "$Header$";
@
