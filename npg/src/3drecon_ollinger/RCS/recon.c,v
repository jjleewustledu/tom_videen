head	1.1;
access;
symbols;
locks; strict;
comment	@ * @;


1.1
date	98.04.01.14.39.42;	author tom;	state Exp;
branches;
next	;


desc
@@


1.1
log
@Initial revision
@
text
@/*$Id: recon.c,v 3.1 1998/03/24 23:43:10 jmo Exp jmo $*/
/*$Log: recon.c,v $
 * Revision 3.1  1998/03/24  23:43:10  jmo
 * ..
 *
 * Revision 3.0  1997/10/29  19:26:43  jmo
 * Support Exact HR.
 *
 * Revision 2.7  1997/08/06  18:22:04  jmo
 * Last version before adding CTI rev 7 support.
 *
 * Revision 2.6  1997/04/04  20:49:58  jmo
 * *** empty log message ***
 *
 * Revision 2.5  1996/09/05  14:22:38  jmo
 * *** empty log message ***
 *
 * Revision 2.4  1996/06/19  11:20:28  jmo
 *
 * Revision 2.3  1996/04/23  15:02:05  jmo
 * Version released April 23, 1996
 *
 * Revision 2.1  1996/03/15  21:57:19  jmo
 * Version installed in St. Louis.
 *
 * Revision 2.0  1996/01/27  13:46:08  jmo
 * Version installed at Neuro-imaging group, January 1996
 *
 * Revision 1.2  1996/01/18  16:10:06  jmo
 * Modified file formats, Interfile and Matrix Rev 7.0 support.
 *
 * Revision 1.1  1996/01/12  18:09:20  jmo
 * Initial revision
 *
 * Revision 1.12  1995/10/25  16:36:29  jmo
 * *** empty log message ***
 *
 * Revision 1.11  1995/09/19  10:44:20  jmo
 * Version for revised paper to physics in medicine and biology.
 *
 * Revision 1.10  95/08/17  14:56:26  jmo
 * *** empty log message ***
 * 
 * Revision 1.9  95/06/19  16:46:41  jmo
 * Modify method for mashed sinograms.
 * 
 * Revision 1.8  95/05/26  14:29:46  jmo
 * Version sent to Pittsburgh, 5/26/95
 * 
 * Revision 1.7  95/05/04  10:37:30  jmo
 * Modified normalization files.
 * 
 * Revision 1.6  95/04/27  17:43:24  jmo
 * Version used for 3d95
 * 
 * Revision 1.5  95/04/01  13:21:29  jmo
 * Version really sent to Pittsburgh.  Fix call to scatscl.
 * 
 * Revision 1.4  95/03/31  15:47:37  jmo
 *  Version for 951 sent to Pittsburgh.
 * 
 * Revision 1.3  95/03/03  16:25:27  jmo
 * Modified but not tested for cti951
 * 
 * Revision 1.2  95/02/11  16:55:10  jmo
 * No changes
 * 
 * Revision 1.1  1995/01/19  22:40:20  ty7777
 * Initial revision
 **/

/*-------------------------------------------------------------

Subroutine: recon

Perpetrator: John Ollinger

Date of infraction: August 5, 1989

Copyright 1991-1996, Washington University.
All rights reserved. Unauthorized reproduction prohibited.

-------------------------------------------------------------------*/

#include <stdio.h>
#include <fcntl.h>
#include <math.h>
/*#include <unistd.h>*/
#include <string.h>
#include <stdlib.h>

#include <imagio.h>
#include <scatter.h>
#include <cti_proto.h>

#define IMGDIM_MAX 1024	 /* Image dimension. */
#define	INTERP_FCT 20	/* Interpolation dsamp_factor.		*/
#define INTERP_LEN_MAX  INTERP_FCT*(IMGDIM_MAX+2) /* Length of interpolated data.*/
#define FFT_LEN 2048
#define MU_MIN .01	/* Transmission pixels with atten coef less than this
			   are assumed to correspond to air. */

float  gaus_fwhm,	/* FWHM for Gaussian filter.		*/
       xang_dsamp;	/* Ratio of acquired to processed projection angles.*/

int	ang_dsamp,numray_fft,scanner_type,numray_cti_raw;

char   filnam[MAXNAME];

/***static char rcsid [] = "$Header: /home/fafner/jmo/src/scatter/scat/RCS/recon.c,v 3.1 1998/03/24 23:43:10 jmo Exp jmo $";***/

/*********************************************************************************/
void recon (emisfile,tranfile,blankfile,nrmfil,geofil,sc, 
	emis_img, tran_img, iter, scat_sino, quiet,emis_sino_dsamp,recon_mode)
/*********************************************************************************/

char	**emisfile,
	**tranfile,
	**blankfile,
	*geofil,
	*nrmfil;

struct 	scatter_tab *sc;

float 	**emis_img,
	**tran_img,
	*scat_sino[NUM_RINGS],
	**emis_sino_dsamp;

int	iter,
	quiet,
	recon_mode;

{

float	tran_duration,emis_duration,min,scat,corrtr,corrsc,
	tran_scl,x,sum,total_sum,max,sum1,sum2,sclm1,sclp1,scl,sclsum,
	pixm1,pixm2,pixp1,pixp2,thresh,d,lshld,theta,nmax,maxsum,
	sclcnts,suma,sumb,t2,t3,t4,rings[2],blank_scl,
	*image,
	*scatpln;

static float emis_scl,emis_dsamp_sum=0,
	**mask,			/* Mask giving support of transmission images.*/
	**tran_sino_dsamp,
	**blank_sino_dsamp,
	**blank_sino,
	**emis_sino,
	**tran_sino,
	**emis_sino_corr,
	**attn_dsamp,
	**normtr,**normsc,**normtr_dsamp,**normsc_dsamp;

int	i,j,k,m,ioff,joff,koff,moff,j1,j2,plnmin,plnmax,iang,
	plane,pln,ring1,ring2,plnm1,plnp1,pln_f3d,isino,jsino,
	recon_emis = TRUE,  ring, itht, i1, i2,ifile,
	dsamp_factor = 2;	/* Sinogram downsampling dsamp_factor. */

static int 	first=TRUE,imgdimm1=-1,
		recon_tran = FALSE,
		numraym1 = -1,
		numangm1 = -1;

static FILE 	*fd_emis_out,*fd_tran_out;

char	emis_outfil[MAXNAME],
	tran_outfil[MAXNAME],
	tran_sino_outfil[MAXNAME],
	emis_corr_file[MAXNAME],
	*dot;

if(first == TRUE) {
    first = FALSE;
    if((emis_sino = (float **)
		malloc((sc->numvpln+1)*sizeof(float *))) == NULL) {
        fprintf(stderr,"Malloc failed of *emis_sino in recon.\n");
        return;
        }
    if((tran_sino = (float **)
		malloc((sc->numvpln+1)*sizeof(float *))) == NULL) {
        fprintf(stderr,"Malloc failed of *tran_sino in recon.\n");
        return;
        }
    if((blank_sino = (float **)
		malloc((sc->numvpln+1)*sizeof(float *))) == NULL) {
        fprintf(stderr,"Malloc failed of *blank_sino in recon.\n");
        return;
        }
    if((emis_sino_corr = (float **)
		malloc((sc->numvpln+1)*sizeof(float *))) == NULL) {
        fprintf(stderr,"Malloc failed of *emis_sino_corr in recon.\n");
        return;
        }
    if((blank_sino_dsamp = (float **)
		malloc((sc->numpln+1)*sizeof(float *))) == NULL) {
        fprintf(stderr,"Malloc failed of *blank_sino_dsamp in recon.\n");
        return;
        }
    if((tran_sino_dsamp = (float **)
		malloc((sc->numpln+1)*sizeof(float *))) == NULL) {
        fprintf(stderr,"Malloc failed of *tran_sino_dsamp in recon.\n");
        return;
        }
    if((attn_dsamp = (float **)
		malloc((sc->numpln+1)*sizeof(float *))) == NULL) {
        fprintf(stderr,"Malloc failed of *attn_dsamp in recon.\n");
        return;
        }
    if((normtr = (float **)
		malloc((sc->numvpln+1)*sizeof(float *))) == NULL) {
        fprintf(stderr,"Malloc failed of *normtr in recon.\n");
        return;
        }
    if((normsc = (float **)
		malloc((sc->numvpln+1)*sizeof(float *))) == NULL) {
        fprintf(stderr,"Malloc failed of *normsc in recon.\n");
        return;
        }
    if((normtr_dsamp = (float **) 
			malloc((sc->numpln+1)*sizeof(float *))) == NULL) {
        fprintf(stderr,"Malloc failed of *normtr_dsamp in recon.\n");
        return;
        }
    if((normsc_dsamp = (float **)
		malloc((sc->numpln+1)*sizeof(float *))) == NULL) {
        fprintf(stderr,"Malloc failed of *normsc_dsamp in recon.\n");
        return;
        }
    strcpy(emis_outfil,emisfile[0]);
    dot = strrchr(emis_outfil,(int)'.');
    *dot = NULL;
    sprintf(emis_outfil,"%s_%dx%d_%d_h%3.2f_s0.img",
			emis_outfil,sc->imgdim,sc->imgdim,sc->numang,sc->emis_cutoff);
    strcpy(tran_outfil,tranfile[0]);
    dot = strrchr(tran_outfil,'.');
    *dot = NULL;
    sprintf(tran_outfil,"%s_%dx%d_%d_h%3.2f.img",
			tran_outfil,sc->imgdim,sc->imgdim,sc->numang,sc->tran_cutoff);
    if((fd_emis_out=fopen(emis_outfil,"rb")) == NULL)
	recon_emis = TRUE;
    else
	fclose(fd_emis_out);
    if((fd_tran_out=fopen(tran_outfil,"rb")) == NULL)
	recon_tran = TRUE;
    else
	fclose(fd_tran_out);
    sc->mult_scl = (float **)malloc(LEN_RING_LIST*LEN_RING_LIST*sizeof(float *));
    for(i=0;i<LEN_RING_LIST*LEN_RING_LIST;i++)
        sc->mult_scl[i] = (float *)malloc(NUMANG_OUT*sizeof(float));
    }

if(sc->numang != numangm1 || sc->numray != numraym1) {
    /* Extract and combine sinograms. */
    numraym1 = sc->numray;
    numangm1 = sc->numang;
    recon_tran = TRUE;
    if(iter > 1) {
        for(plane=1;plane<=sc->numpln;plane++) {
	    free(attn_dsamp[plane]);
	    free(emis_sino_corr[plane]);
	    free(emis_img[plane]);
	    free(sc->psi_shldmin[plane]);
	    free(sc->psi_shldmax[plane]);
	    free(normtr_dsamp[plane]);
	    free(normsc_dsamp[plane]);
	    }
	free(sc->psi_shldmin);
	free(sc->psi_shldmax);
        for(plane=-sc->numpln/2+1;plane<2*sc->numpln-sc->numpln/2+1;plane++) 
	    free(tran_img[plane]);
	for(i=1;i<=sc->numpln;i++) {
	    free(sc->tran_width[i][0]);
	    free(sc->tran_width[i]);
	    }
        free(sc->tran_width);
	}

    /* Allocate memory for trans image width table for mult scat model. */
    sc->tran_width = (float ***)malloc((sc->numpln+1)*sizeof(float **));
    for(i=1;i<=sc->numpln;i++) {
	sc->tran_width[i]=(float **)malloc(NUMANG_OUT*sizeof(float *));
	sc->tran_width[i][0] = 
			(float *)malloc(NUMANG_OUT*sc->imgdim*sizeof(float));
	for(j=1;j<NUMANG_OUT;j++)
	    sc->tran_width[i][j] = sc->tran_width[i][j-1] + sc->imgdim;
	}
    /* allocate memory for normalization data. */
    for(plane=1;plane<=sc->numvpln;plane++) {
	normtr[plane] = (float *)malloc(sc->lensin*sizeof(float));
	normsc[plane] = (float *)malloc(sc->lensin*sizeof(float));
	for(i=0;i<sc->lensin;i++) {
	    normsc[plane][i] = 0.;
	    normtr[plane][i] = 0.;
	    }
	}
    for(plane=1;plane<=sc->numpln;plane++) {
	normtr_dsamp[plane] = (float *)malloc(sc->lensin*sizeof(float));
	normsc_dsamp[plane] = (float *)malloc(sc->lensin*sizeof(float));
	for(i=0;i<sc->lensin;i++) {
	    normsc_dsamp[plane][i] = 0.;
	    normtr_dsamp[plane][i] = 0.;
	    }
	}
    if(quiet == FALSE)
        fprintf(stdout,"Generating sinograms.\n");
    for(plane=1;plane<=sc->numvpln;plane++) {
        ifile = sc->filenum[plane];
        pln = sc->physvpln[plane];
	tran_sino[plane] 
		= get_2d_sino(tranfile[ifile],pln,&tran_duration,sc);
	blank_sino[plane]
		= get_2d_sino(blankfile[ifile],pln,&sc->blank_duration[ifile],sc);
	emis_sino[plane] = get_emis_sino(emisfile[ifile],nrmfil,geofil,
			normtr[plane],normsc[plane],pln,&emis_duration,sc);
        if(sc->emis_duration[ifile] > 0)  {
	    /* Correct for decay of isotope (F18) and scan duration.*/
            t2 = sc->emis_duration[0]; 
	    t3 = sc->start_time[ifile]-sc->start_time[0];
            t4 = t3 + sc->emis_duration[ifile];
            emis_scl = (1.-exp(-t2/TC_F18))/(exp(-t3/TC_F18)-exp(-t4/TC_F18));
	    }
        if(sc->tran_duration[ifile] > 0) 
    	    tran_scl = sc->tran_duration[0]/sc->tran_duration[ifile];
        if(sc->blank_duration[ifile] > 0) 
    	    blank_scl = sc->blank_duration[0]/sc->blank_duration[ifile];
        if(emis_scl != 1.) {
            for(i=0;i<sc->lensin;i++)
                emis_sino[plane][i] *= emis_scl;
            }
        if(tran_scl != 1.) {
            for(i=0;i<sc->lensin;i++)
                tran_sino[plane][i] *= tran_scl;
            }
        if(blank_scl != 1.) {
            for(i=0;i<sc->lensin;i++)
                blank_sino[plane][i] *= blank_scl;
            }
	}

    /* Downsample sinograms to final axial width. */
    sino_axl_dsamp(emis_sino,emis_sino_dsamp,sc,dsamp_factor);
    sino_axl_dsamp(tran_sino,tran_sino_dsamp,sc,dsamp_factor);
    sino_axl_dsamp(blank_sino,blank_sino_dsamp,sc,dsamp_factor);
    sino_axl_dsamp(normtr,normtr_dsamp,sc,dsamp_factor);
    sino_axl_dsamp(normsc,normsc_dsamp,sc,dsamp_factor);
    /* Correct for FOV of a single ring, fraction of each scattering 
	element that scatters into current set of detectors (assume 
	that adjacent pixels summed after rotation, so each pixel represents 
	a width RAYSPC mm wide, and divide by number of 
	angles because radiation isotropic. Model detector ring aperture
	using small angle approximation and assuming uniform detector
	efficiency.*/
    emis_scl = 2*PI*RADIUS_DET*((float)sc->numray/(float)sc->imgdim)/
					(WCA_TOT*NUMANG);
    if(sc->blank_duration[0] < 1.e-20)
        tran_scl = 1.;
    else
        tran_scl = sc->tran_duration[0]/sc->blank_duration[0];

    for(plane=1;plane<=sc->numpln;plane++) {

        /* Fix regions of sinograms not sampled by rotating rod sources. */
        i1 = sc->numray/2 - (int)(PATIENT_APERTURE/(2.*RAYSIZ));
        i2 = sc->numray/2 + (int)(PATIENT_APERTURE/(2.*RAYSIZ));
        for(iang=0,ioff=0;iang<sc->numang;iang++,ioff+=sc->numray) {
	    for(i=0;i<=i1;i++) {
	        blank_sino_dsamp[plane][i+ioff] = 1.;
	        tran_sino_dsamp[plane][i+ioff] = -1.;
	        normtr[plane][i+ioff] = 1.;
	        normsc[plane][i+ioff] = 1.;
	        }
	    for(i=i2;i<sc->numray;i++) {
	        blank_sino_dsamp[plane][i+ioff] = 1.;
	        tran_sino_dsamp[plane][i+ioff] = -1.;
	        normtr[plane][i+ioff] = 1.;
	        normsc[plane][i+ioff] = 1.;
	        }
	    }

        attn_dsamp[plane] = (float *)malloc(sc->lensin*sizeof(float));
        emis_sino_corr[plane] = (float *)malloc(sc->lensin*sizeof(float));
        for(i=0;i<sc->lensin;i++) {
            if(tran_sino_dsamp[plane][i] > 0) {
                x = blank_sino_dsamp[plane][i]/tran_sino_dsamp[plane][i];
                tran_sino_dsamp[plane][i]  = (float)log((double)(tran_scl*x));
		}
            else {
                x  = 0.;
                tran_sino_dsamp[plane][i]  = 0;
		}
            attn_dsamp[plane][i] = tran_scl*x;
	    emis_sino_corr[plane][i] = emis_scl*normtr_dsamp[plane][i]*
			    attn_dsamp[plane][i]*emis_sino_dsamp[plane][i];
	    emis_dsamp_sum += emis_sino_dsamp[plane][i];
            }
        free(blank_sino[plane]);
        free(tran_sino[plane]);
        free(emis_sino[plane]);
	free(normtr[plane]);
	free(normsc[plane]);
/***        if(quiet == FALSE)  {
            wrimg_easy("emis_dsamp.ifs",emis_sino_dsamp[plane],plane,INTERFILE,SHORT_DATA,3,
		sc->numray,sc->numang,sc->numpln,sc->pixsiz,sc->pixsiz,
	 	SLCTHK*dsamp_factor,NULL);
	    }
        if(quiet == FALSE)  {
            wrimg_easy("attn.ifs",attn_dsamp[plane],plane,INTERFILE,SHORT_DATA,3,
		sc->numray,sc->numang,sc->numpln,sc->pixsiz,sc->pixsiz,
	 	SLCTHK*dsamp_factor,NULL);
	    }
        if(quiet == FALSE)  {
            wrimg_easy("normtr.ifs",normtr_dsamp[plane],plane,INTERFILE,SHORT_DATA,3,
		sc->numray,sc->numang,sc->numpln,sc->pixsiz,sc->pixsiz,
	 	SLCTHK*dsamp_factor,NULL);
	    }***/
	}
    /* Build table defining regions that do not sample the subject. */
    sc->tran_sup = get_tran_support(tran_sino_dsamp,sc->numray,
						sc->numang,sc->numpln);
    }

/* Subtract scatter estimate from emission data.  First, downsample 
   estimated scatter in angle. */
if(iter > 1) {
    scatpln = (float *)malloc(sc->lensin*sizeof(float));
    sclsum = 0.;
    for(plane=0;plane<sc->num_dir_rings;plane++) {
        for(i=0,joff=0,koff=0;i<sc->numang;
		i++,joff+=sc->numray,koff+=ang_dsamp*sc->numray) {
            for(j=0;j<sc->numray;j++) {
	        scat_sino[plane][j+joff] = scat_sino[plane][j+koff];
	        for(k=1,moff=sc->numray;k<ang_dsamp;k++,moff+=sc->numray) 
	            scat_sino[plane][j+joff] += scat_sino[plane][j+koff+moff];
	        }
	    }
        }
    for(plane=1;plane<=sc->numpln;plane++) {
        rings[0] = plane - 1;
        rings[1] = plane - 1;
	plnm1 = NUM_RINGS;
	plnp1 = 0;
	pln_f3d = plnnum_f3d(plane,plane,scanner_type);
	if(plane <= sc->dir_ring_list[0]) {
	    plnp1 = 0;
	    plnm1 = -1;
	    }
	else if(plane >= sc->dir_ring_list[sc->num_dir_rings-1]) {
	    plnp1 = sc->num_dir_rings - 1;
	    plnm1 = -1;
	    }
	else {
	    for(i=1;i<sc->num_dir_rings;i++) {
	       if(plane>=sc->dir_ring_list[i-1] && plane<sc->dir_ring_list[i]) {
		   plnm1 = i - 1;
		   plnp1 = i;
		   }
		}
	    }
	if(plnm1 < 0) { /* Must be slice at the end. */
	/* Use multiplicative correction. */
	    if(sc->iter_type == EM) {
                for(i=0;i<sc->lensin;i++) {
		    corrtr = attn_dsamp[plane][i]*emis_scl*normtr_dsamp[plane][i];
		    corrsc = attn_dsamp[plane][i]*emis_scl*normsc_dsamp[plane][i];
	            emis_sino_corr[plane][i] = 
		    corrtr*emis_sino_dsamp[plane][i]*emis_sino_corr[plane][i]/
		    (emis_sino_corr[plane][i]+corrsc*scat_sino[plnp1][i]);
		    }
	 	 }
	    else { /* Use successive substitution. */
                for(i=0;i<sc->lensin;i++)
		    scatpln[i] = scat_sino[plnp1][i]*normsc_dsamp[plane][i];
		if(sc->line_source == TRUE)
		    scl = 1.;
		else {
		    scl = scatscl(pln_f3d,scatpln,emis_sino_dsamp[plane],
		          sc->numang,scanner_type,sc->numray,sc->numang,
		          sc->tran_sup,&sclcnts,rings);
		    }
		sclsum += scl;
                for(i=0;i<sc->lensin;i++)
	            emis_sino_corr[plane][i] = 
		        attn_dsamp[plane][i]*emis_scl*normtr_dsamp[plane][i]*
                        (emis_sino_dsamp[plane][i] - scl*scatpln[i]);
	         }
	    }
	else {
	    sclm1 = (float)(sc->dir_ring_list[plnp1] - plane)/
		(float)(sc->dir_ring_list[plnp1] - sc->dir_ring_list[plnm1]);
	    sclp1 = (float)(plane - sc->dir_ring_list[plnm1])/
		(float)(sc->dir_ring_list[plnp1] - sc->dir_ring_list[plnm1]);
	    if(sc->iter_type == EM) {
                for(i=0;i<sc->lensin;i++)  {
		    scat = sclm1*scat_sino[plnm1][i] + sclp1*scat_sino[plnp1][i];
		    corrtr = attn_dsamp[plane][i]*emis_scl*normtr_dsamp[plane][i];
		    corrsc = attn_dsamp[plane][i]*emis_scl*normsc_dsamp[plane][i];
	            emis_sino_corr[plane][i] = 
	     	      corrtr*emis_sino_dsamp[plane][i]*emis_sino_corr[plane][i]/
		        (emis_sino_corr[plane][i] + corrsc*scat);
		    }
		}
	    else { /* Use successive substitution. */
		for(i=0;i<sc->lensin;i++)
		    scatpln[i] = normsc_dsamp[plane][i]*
		        (sclm1*scat_sino[plnm1][i] + sclp1*scat_sino[plnp1][i]);
		if(sc->line_source == TRUE)
		    scl = 1.;
		else
		    scl = scatscl(pln_f3d,scatpln,emis_sino_dsamp[plane],
		    sc->numang,scanner_type,sc->numray,sc->numang,sc->tran_sup,
		    &sclcnts,rings);
		sclsum += scl;
		for(i=0;i<sc->lensin;i++)
                    emis_sino_corr[plane][i] = normtr_dsamp[plane][i]*
			attn_dsamp[plane][i]*emis_scl*
                        (emis_sino_dsamp[plane][i] - scl*scatpln[i]);
		}
	    }
	}
    printf("Average scatter scale factor: %f\n",sclsum/sc->numpln);
    free(scatpln);
    }

if(recon_tran == TRUE) {
    recon_tran = FALSE;
    if((mask=(float **)malloc((sc->numpln+1)*sizeof(float *)))==NULL) {
        fprintf(stderr,"Malloc failed for mask in recon.\n");
        return;
        }
/*    if(quiet == FALSE)
        printf("Reconstructing transmission images.\n");*/
    strcpy(tran_outfil,tranfile[0]);
    dot = strrchr(tran_outfil,'.');
    *dot = NULL;
    sprintf(tran_sino_outfil,"%s_sino_dsamp.img",tran_outfil);
    sprintf(tran_outfil,"%s_%dx%d_%d_h%3.2f.img",
			tran_outfil,sc->imgdim,sc->imgdim,sc->numang,sc->tran_cutoff);
    thresh = (float)exp((double)(-sc->pixsiz*MU_MIN/10.));
    image = (float *)malloc(sc->imgsq*sizeof(float));
    maxsum = 0.;
    nmax = 0.;
    for(plane=1;plane<=sc->numpln;plane++) {
        if((mask[plane]=(float *)malloc(sc->imgsq*sizeof(float)))==NULL) {
            fprintf(stderr,"Malloc failed for mask in recon.\n");
            return;
            }
	tran_img[plane] = fbp(sc,tran_sino_dsamp[plane],sc->tran_cutoff);
 	  for(itht=0;itht<NUMANG_OUT;itht++) {
	    theta = PI*THETA_DIR*(float)itht/(float)NUMANG_OUT + THETA_START;
	    rotate_2d(theta,tran_img[plane],image,sc);
	    max = 0.;
	    for(i=0,joff=0;i<sc->imgdim;i++,joff+=sc->imgdim) {
		sc->tran_width[plane][itht][i] =0.;
		for(j=0;j<sc->imgdim;j++) 
		    sc->tran_width[plane][itht][i] += image[j+joff];
	        sc->tran_width[plane][itht][i] /= (MU_H2O*(float)sc->numang);
	    if(sc->tran_width[plane][itht][i] > max)
		max = sc->tran_width[plane][itht][i];
		}
	    maxsum += max;
	    nmax += 1.;
	    }
	for(i=0;i<sc->imgsq;i++) {
            if(tran_img[plane][i] < 0) {
		tran_img[plane][i] = 1.;
		x = 0.;
		}
	    else {
	        x = - tran_img[plane][i]/(float)sc->numang;
	        tran_img[plane][i] = (float)exp((double)x);
	        }
            if(tran_img[plane][i] > thresh) 
		tran_img[plane][i] = 1.;
	    if(x < -.01)
		mask[plane][i] = 1.;
	    else
		mask[plane][i] = 0.;
	    }
        if(quiet == FALSE)  {
            wrimg_easy(tran_sino_outfil,tran_sino_dsamp[plane],plane,INTERFILE,SHORT_DATA,3,
		sc->numray,sc->numang,sc->numpln,sc->pixsiz,sc->pixsiz,
	 	SLCTHK*dsamp_factor,NULL);
	    }
	free(tran_sino_dsamp[plane]);

	/* Process mask to eliminate holes. */
	for(i=0,joff=0;i<sc->imgdim;i++,joff+=sc->imgdim) {
	    pixm1 = 0; pixm2 = 0; j1 = 0; j2 = 0;
	    pixp1 = 0; pixp2 = 0;
	    for(j=joff,k=joff+sc->imgdim-1;j<joff+sc->imgdim;j++,k--) {
		if(((mask[plane][j] + pixm1 + pixm2) > 2.9) && (j1 == 0)) 
		    j1 = j;
		if(((mask[plane][k] + pixp1 + pixp2) > 2.9) && (j2 == 0)) 
		    j2 = k;
		pixm2 = pixm1; pixm1 = mask[plane][j];
		pixp2 = pixp1; pixp1 = mask[plane][k];
		}
	    for(m=j1;m<j2;m++)
	        mask[plane][m] = 1.;
	    }
        if(quiet == FALSE)  {
            wrimg_easy(tran_outfil,tran_img[plane],plane,INTERFILE,SHORT_DATA,3,
		sc->imgdim,sc->imgdim,sc->numpln,sc->pixsiz,sc->pixsiz,
	 	SLCTHK*dsamp_factor,NULL);
	    }
	}
    close_if(tran_outfil);
    printf("Maximum path length through transmission image: %f cm.\n",maxsum/nmax/10.);
    }


/* Calculate scale factor for multiple scatter model. */
for(jsino=0;jsino<sc->num_scat_sinos;jsino++) {
    ring1 = sc->dir_ring[jsino];
    ring2 = sc->scat_ring[jsino];
    if(ring1 == ring2) {
        isino = sc->ring_tab[ring1][ring1];
        plane = sc->dir_ring_list[ring1];
        min = 1.e20; max = -1.e20;
        for(itht=0,joff=0,sum2=0.;itht<NUMANG_OUT;
				itht++,joff+=sc->numray*sc->ang_step) {
    	    sc->mult_scl[isino][itht] = 0.;
	    sum = 0.;
	    for(k=0,j=0;k<sc->numray/sc->ray_step;k++) {
	        for(m=0,sum1=0.;m<sc->ray_step;m++,j++)
		    /* Use attenuation-corrected emission sinogram. */
	            sum1 += emis_sino_corr[plane][j+joff];
	        sc->mult_scl[isino][itht]+=sum1*sc->tran_width[plane][itht][k];
	        sum += sum1;
	        }
	    x = sc->mult_scl[isino][itht]/sum;
	    if(x < min)
	        min = x;
	    else if(x > max)
	        max = x;
            if(min < 0.)
                min = 0.;
	    sum2 += sc->mult_scl[isino][itht]/sum;
    	    sc->mult_scl[isino][itht] *= sc->mult_A/sum;
            if(sc->mult_scl[isino][itht] < 0.)
                sc->mult_scl[isino][itht] = 0.;
            }
        if(iter == 1)
         printf("Ring #%d, Mean path: %8.4f mm, min: %8.4f, max: %8.4f.\n",plane,sum2/NUMANG_OUT,min,max);
	}
    }

/* Approximate scale factor for cross-planes as the average of the
   scale factor for the two rings that are involved. */
for(isino=0;isino<sc->num_scat_sinos;isino++) {
    ring1 = sc->dir_ring[isino];
    ring2 = sc->scat_ring[isino];
    if(ring1 != ring2) {
        i1 = sc->ring_tab[ring1][ring1];
        i2 = sc->ring_tab[ring2][ring2];
	for(itht=0;itht<NUMANG_OUT;itht++) 
	    sc->mult_scl[isino][itht] = 
		.5*(sc->mult_scl[i1][itht]+ sc->mult_scl[i2][itht]);
        }
    }


if (recon_emis == TRUE) {
    strcpy(emis_outfil,emisfile[0]);
    dot = strrchr(emis_outfil,(int)'.');
    *dot = NULL;
    sprintf(emis_outfil,"%s_%dx%d_%d_h%3.2f_s%d.img",
		emis_outfil,sc->imgdim,sc->imgdim,sc->numang,sc->emis_cutoff,iter-1);
/*    sprintf(attn_outfil,"attn_dsamp.img");*/
    sprintf(emis_corr_file,"emis_sino_corr_%dx%d_%d_s%d.img",
				sc->imgdim,sc->imgdim,sc->numang,iter-1);
    for(plane=1;plane<=sc->numpln;plane++) {
        switch(recon_mode) {
        case FOV_ONLY:
            if(plane >= sc->mainplane1 && plane <= sc->mainplane1+NUM_RINGS) 
                emis_img[plane] = fbp(sc,emis_sino_corr[plane],sc->emis_cutoff);
            else {
		emis_img[plane] = (float *)malloc(sc->imgsq*sizeof(float));
                for(i=0;i<sc->imgsq;i++) emis_img[plane][i] = 0.;
                }
            break;
        case OUT_OF_FOV_ONLY:
            if(plane < sc->mainplane1 || plane > sc->mainplane1+NUM_RINGS) 
                emis_img[plane] = fbp(sc,emis_sino_corr[plane],sc->emis_cutoff);
            else {
		emis_img[plane] = (float *)malloc(sc->imgsq*sizeof(float));
                for(i=0;i<sc->imgsq;i++) emis_img[plane][i] = 0.;
                }
            break;
        default:
            emis_img[plane] = fbp(sc,emis_sino_corr[plane],sc->emis_cutoff);
        }
	/* Set pixels outside support of transmission image to zero. */
	for(i=0;i<sc->imgsq;i++) 
	    emis_img[plane][i] *= mask[plane][i];
	if(sc->line_source == TRUE) {
	    /* For line sources set all negative pixels to zero.  Scale
	       to maintain correct number of counts.  This compensates
	       for undershoot in undersampled line sources. */
	    suma = 0.; sumb = 0.;
	    for(i=0;i<sc->imgsq;i++) {
		suma += emis_img[plane][i];
                if(emis_img[plane][i] < 0) {
		    emis_img[plane][i] = 0.;
		    }
		sumb += emis_img[plane][i];
		}
	    for(i=0;i<sc->imgsq;i++)
		emis_img[plane][i] *= suma/sumb;
	    }
        if(quiet == FALSE) {
            wrimg_easy(emis_corr_file,emis_sino_corr[plane],plane,INTERFILE,
		SHORT_DATA,3,sc->numray,sc->numang,sc->numpln,sc->raysiz,1.,
	        SLCTHK*dsamp_factor,NULL);
            wrimg_easy(emis_outfil,emis_img[plane],plane,INTERFILE,SHORT_DATA,3,
	        sc->imgdim,sc->imgdim,sc->numpln,sc->pixsiz,sc->pixsiz,
	        SLCTHK*dsamp_factor,NULL);
            }
	}
    close_if(emis_corr_file);
    close_if(emis_outfil);
    if(iter > 1) {
    	if(sc->ext_emis_up > 0.) {
            for(j=1,plane=sc->emis_plnmin;plane<1;plane++,j++) {
                for(i=0;i<sc->imgsq;i++)
        	    emis_img[plane][i] = emis_img[1][i];
	        }
	    }
	if(sc->ext_emis_dwn > 0.) {
            for(j=sc->numpln,plane=sc->numpln+1;plane<sc->emis_plnmax;plane++,j--) {
                for(i=0;i<sc->imgsq;i++)
    	            emis_img[plane][i] = emis_img[sc->numpln][i];
	  	}
            }
        }
    }

if(quiet == FALSE && iter == 1) {
    total_sum = 0.;
    for(plane=1;plane<=sc->numpln;plane++) {
        sum = 0.;
        for(i=0;i<sc->imgsq;i++)
            sum += emis_img[plane][i];
        total_sum += sum;
        printf("Emission plane %d sums to %7.4f million counts.\n",plane,sum/1.e6);
        }
	printf("Volume sums to %9.4f million counts.\n",total_sum*1.e-6);
    }

if( sc->imgdim != imgdimm1) {
    imgdimm1 = sc->imgdim;
    if((sc->psi_shldmin = (float **)malloc((NUM_RINGS+1)*sizeof(int)))==NULL) {
        fprintf(stderr,"Malloc failed of *sc->shldmin in recon.\n");
        return;
        }
    if((sc->psi_shldmax = (float **)malloc((NUM_RINGS+1)*sizeof(int)))==NULL) {
        fprintf(stderr,"Malloc failed of *sc->shldmax in recon.\n");
        return;
        }
        for(plane=1;plane<=NUM_RINGS;plane++) {
    	    if((sc->psi_shldmin[plane] = (float *)
				malloc((sc->imgdim)*sizeof(float)))==NULL) {
                fprintf(stderr,"Malloc failed of sc->shldmin in recon.\n");
                return;
                }
    	    if((sc->psi_shldmax[plane] = (float *)
				malloc((sc->imgdim)*sizeof(float)))==NULL) {
                fprintf(stderr,"Malloc failed of sc->shldmax in recon.\n");
                return;
	    }
	}
    for(i=0,d=(-sc->pixsiz*(sc->imgdim-1)/2.);i<sc->imgdim;i++,d+=sc->pixsiz) {
        lshld = sqrt(SHLD_ORSQ - d*d) - sqrt(SHLD_IRSQ - d*d);
        for(plane=1;plane<=NUM_RINGS;plane++) {
	    sc->psi_shldmin[plane][i] = -atan(((plane-1)*SLCTHK+WC2)/lshld);
	    sc->psi_shldmax[plane][i] =  atan(((NUM_RINGS-plane)*SLCTHK+WC2)/lshld);
	    }
	}
    
    /* Extend volume to account for scatter from ouside the FOV. */
    if(sc->ext_tran_up > 0.) {
        plnmin = 1 - (sc->ext_tran_up/SLCTHK + .5) - 2;
	if(plnmin < -2*sc->numpln) plnmin = -2*sc->numpln;
        for(plane=plnmin;plane<1;plane++) {
            tran_img[plane] = (float *)malloc(sc->imgsq*sizeof(float));
            for(i=0;i<sc->imgsq;i++)
                tran_img[plane][i] = tran_img[1][i];
	    }
        sc->tran_plnmin = plnmin + 2;
        }
    else
        sc->tran_plnmin = 1;
    if(sc->ext_tran_dwn > 0.) {
	plnmax = sc->numpln + (sc->ext_tran_dwn/SLCTHK + .5) + 3;
	if(plnmax > 3*sc->numpln) plnmax = 3*sc->numpln;
        for(plane=sc->numpln+1;plane<=plnmax;plane++) {
            tran_img[plane] = (float *)malloc(sc->imgsq*sizeof(float));
            for(i=0;i<sc->imgsq;i++)
    	        tran_img[plane][i] = tran_img[sc->numpln][i];
	    }
        sc->tran_plnmax = plnmax - 2;
	}
    else
        sc->tran_plnmax = sc->numpln;
/***printf("************* Patched for NSS97 *******************\n");
printf("************* REMOVE THIS PATCH *******************\n");*** NSS97*/
    if(sc->ext_emis_up > 0.) {
        plnmin = 1 - (sc->ext_emis_up/SLCTHK + .5) - 2;
        if(plnmin < -2*sc->numpln) 
	    plnmin = -2*sc->numpln;
        for(j=1,plane=plnmin;plane<1;plane++,j++) {
            emis_img[plane]=(float *)malloc(sc->imgsq*sizeof(float));
            for(i=0;i<sc->imgsq;i++)
                emis_img[plane][i] = emis_img[1][i];
                /***emis_img[plane][i] = emis_img[j][i];*** NSS97*/
            }
        for(i=0;i<sc->imgsq;i++) {
            emis_img[plnmin][i] = 0.;
            emis_img[plnmin+1][i] = 0.;
    	    }
        sc->emis_plnmin = plnmin + 2;
        }
    else
        sc->emis_plnmin = 1;
    if(sc->ext_emis_dwn > 0.) {
        plnmax = sc->numpln + (sc->ext_emis_dwn/SLCTHK + .5) + 3;
        if(plnmax > 3*sc->numpln) 
	    plnmax = 3*sc->numpln;
        for(plane=sc->numpln+1,j=sc->numpln;plane<=plnmax;plane++,j--) {
            emis_img[plane]=(float *)malloc(sc->imgsq*sizeof(float));
            for(i=0;i<sc->imgsq;i++)
    	        emis_img[plane][i] = emis_img[sc->numpln][i];
    	        /***emis_img[plane][i] = emis_img[j][i];*** NSS97*/
	    }
        for(i=0;i<sc->imgsq;i++) {
	    emis_img[plnmax][i] = 0.;
    	    emis_img[plnmax-1][i] = 0.;
	    }
        sc->emis_plnmax = plnmax - 2;
        }
    else
        sc->emis_plnmax = sc->numpln;
    }
/***for(plane=1;plane<sc->numpln;plane++) {
    for(i=0;i<sc->imgsq;i++)
         emis_img[plane][i] = 0.;
    }*** NSS97 */

}

/**************************************************/
void sino_axl_dsamp(sino,sino_dsamp,sc,dsamp_factor)
/**************************************************/

float 	**sino,
	**sino_dsamp;
ScatterTable *sc;
int	dsamp_factor;		/* Downsampling dsamp_factor. */

{

int	i,j,k,pln,pln_ds,maxpln,num_coeffs;

float	*coeffs,delta,x;

for(i=1;i<=sc->numpln;i++) {
    if((sino_dsamp[i] = (float *)malloc(sc->lensin*sizeof(float))) == NULL) {
        fprintf(stderr,"Malloc failed in sino_dsamp.\n");
        return;
        }
    }
num_coeffs = 3*sc->numpln;
coeffs = (float *)malloc(num_coeffs*sizeof(float));

/* First get the fov of interest. */
for(i=0,k=3*sc->mainplane1;i<NUM_RINGS-2;i++,k+=3) {
    coeffs[k] = .25;
    coeffs[k+1] = .5;
    coeffs[k+2] = .25;
    }
/* First plane of interest overlaps aux scan. */
delta = sc->mainvplane1 - 1 - sc->plnpos[sc->mainvplane1-1];
if(sc->mainplane1 > 1) {
    k = 3*(sc->mainplane1 - 1);
    x = 1 + delta/2.;
    coeffs[k] = (.25 + delta)/x;
    coeffs[k+1] = .5/x;
    coeffs[k+2] = .25/x;
    for(k=0,i=0;i<sc->mainplane1-1;k+=3,i++) {
        coeffs[k] = .25 - delta/2.;
        coeffs[k+1] = .5;
        coeffs[k+2] = .25 + delta/2.;
        }
    }
else {
    coeffs[0] = -1;
    coeffs[1] = .75;
    coeffs[2] = .25;
    }

maxpln = sc->mainplane1 + (MAX_PLANE+1)/2 - 1;
if(maxpln == sc->numpln) {
    k = (sc->numpln-1)*3;
    coeffs[k] = .75;
    coeffs[k+1] = .25;
    coeffs[k+2] = 0.;
    }
else {
    delta = 2*maxpln - sc->plnpos[2*maxpln];
    k = 3*(maxpln - 1);
    x = 1 + delta/2.;
    coeffs[k] = .25/x;
    coeffs[k+1] = .5/x;
    coeffs[k+2] = (.25 + delta)/x;
    for(i=maxpln;i<sc->numpln;k+=3,i++) {
        coeffs[k] = .25 - delta/2.;
        coeffs[k+1] = .5;
        coeffs[k+2] = .25 + delta/2.;
        }
    coeffs[k] = .25 - delta/2.;
    coeffs[k+1] = .75 + delta/2.;
    coeffs[k+2] = 0.;
    }

for(pln=1,pln_ds=1,k=0;pln_ds<=sc->numpln;pln+=2,pln_ds++,k+=3) {
    if(pln_ds > 1 && pln_ds <sc->numpln) {
        for(i=0;i<sc->lensin;i++)
            sino_dsamp[pln_ds][i] = coeffs[k]  *sino[pln-1][i] 
		                  + coeffs[k+1]*sino[pln][i]
		    	          + coeffs[k+2]*sino[pln+1][i];
        }
    else {
        if(pln_ds == 1) {
            for(i=0;i<sc->lensin;i++)
                sino_dsamp[pln_ds][i] = coeffs[1]*sino[pln][i]
		    	              + coeffs[2]*sino[pln+1][i];
            }
        else {
            for(i=0;i<sc->lensin;i++)
                sino_dsamp[pln_ds][i] = coeffs[num_coeffs-3]*sino[pln-1][i]
		    	              + coeffs[num_coeffs-2]*sino[pln][i];
            }
        }
    }

free(coeffs);

}

/***********************************************************************/
float *get_emis_sino(sinofile,nrmfil,geofil,normtr,normsc,plane,duration,sc)
/***********************************************************************/

char	*sinofile;
char	*geofil,
	*nrmfil;	/* Normalization files. */
float   *normtr,
	*normsc;
int	plane;
float	*duration;
struct scatter_tab *sc;

{

static int first=TRUE,septa_out=FALSE;

MainHeader    *mhdr;

int	i;

float	*sino;

if(first == TRUE) {
    first = FALSE;
    if((mhdr = getmhdr(sinofile)) == NULL) {
        printf("Error in getmhdr, %s.\n",sinofile);
        exit(ERROR);
        }
    scanner_type = mhdr->scanner_type;
    if(mhdr->nplane > MAX_PLANE)
        septa_out = TRUE;
    }

if(septa_out == TRUE) {
    if(scanner_type == 961) {
        sino = get_961_sino(sinofile,nrmfil,geofil,normtr,normsc,plane,duration,sc,sc->frame);
        for(i=0;i<sc->lensin;i++) {
            normtr[i] /= xang_dsamp;
            normsc[i] /= xang_dsamp;
            }
	}
    else {
        sino = get_3dto2d_sino(sinofile,nrmfil,geofil,normtr,normsc,plane,duration,sc);
        }
    }
else {
    sino = get_2d_sino(sinofile,plane,duration,sc);
    }

return(sino);

}
    

/*************************************************************************/
float *get_3dto2d_sino(sinofile,nrmfil,geofil,normtr,normsc,plane,duration,sc)
/*************************************************************************/

/* Get sinogram "plane" using combinations to yield 31 planes, with
   straight slices from two crosses, one straight and cross planes
   from four crosses. */

char	*sinofile;
char	*geofil,
	*nrmfil;	/* Normalization files. */
float   *normtr,*normsc;
int	plane;
float	*duration;
struct scatter_tab *sc;

{

int 	i,ring,pln_offset;

float	*sino,*sino1,*sino2,*sino3;

pln_offset = 0;
if(plane == 1 || plane == MAX_PLANE) {
    /* No planes to combine for this straight slice. */
    ring = (plane-1)/2;
    sino = get_3d_sino(sinofile,nrmfil,geofil,normtr,normsc,
					ring,ring,duration,sc);
    for(i=0;i<sc->lensin;i++) {
	normtr[i] /= xang_dsamp;
	normsc[i] /= xang_dsamp;
	}
    }
else if(plane == 2 || plane == MAX_PLANE-1) {
    /* Combine two cross slices for this cross slice. */
    ring = (plane-1)/2;
    sino = get_3d_sino(sinofile,nrmfil,geofil,normtr,normsc,
					ring,ring+1,duration,sc);

    sino1 = get_3d_sino(sinofile,nrmfil,geofil,normtr,normsc,
					ring+1,ring,duration,sc);
    for(i=0;i<sc->lensin;i++) {
	sino[i] = .5*(sino1[i] + sino[i]);
	normtr[i] /= (2*xang_dsamp);
	normsc[i] /= (2*xang_dsamp);
	}
    free(sino1);
    }
else if(2*(plane/2) != plane) {
    /* Odd planes are straight, combine three planes. */
    ring = (plane-1)/2 - 1;
    sino = get_3d_sino(sinofile,nrmfil,geofil,normtr,normsc,
					ring,ring+2,duration,sc);
    sino1 = get_3d_sino(sinofile,nrmfil,geofil,normtr,normsc,
					ring+2,ring,duration,sc);
    sino2 = get_3d_sino(sinofile,nrmfil,geofil,normtr,normsc,
					ring+1,ring+1,duration,sc);

    for(i=0;i<sc->lensin;i++) { 
	sino[i] = (sino[i] + sino1[i] + sino2[i])/3.;
	normtr[i] /= (3*xang_dsamp);
	normsc[i] /= (3*xang_dsamp);
	}

    free(sino1);
    free(sino2);
    }
else {
    /* Must be cross plane, combine four crosses. */
    ring = plane/2 - 2;
    sino = get_3d_sino(sinofile,nrmfil,geofil,normtr,normsc,
					ring,ring+3,duration,sc);
    sino1 = get_3d_sino(sinofile,nrmfil,geofil,normtr,normsc,
					ring+3,ring,duration,sc);
    sino2 = get_3d_sino(sinofile,nrmfil,geofil,normtr,normsc,
					ring+1,ring+2,duration,sc);
    sino3 = get_3d_sino(sinofile,nrmfil,geofil,normtr,normsc,
					ring+2,ring+1,duration,sc);

    for(i=0;i<sc->lensin;i++) {
	sino[i] = .25*(sino[i] + sino1[i] + sino2[i] + sino3[i]);
	normtr[i] /= (4*xang_dsamp);
	normsc[i] /= (4*xang_dsamp);
	}
    free(sino1);
    free(sino2);
    free(sino3);
    }

return(sino);

}

/*************************************************************************/
float *get_3d_sino(sinofile,nrmfil,geofil,normtr,normsc,
					ring1,ring2,duration,sc)
/*************************************************************************/

char	*sinofile;	/* Sinogram file to be read. */
char	*geofil,
	*nrmfil;	/* Normalization files. */
float   *normtr,*normsc;
int	ring1,ring2;	/* Rings defining plane to read. */
float	*duration;	/* Duration in seconds. */
struct 	scatter_tab *sc;

{

float 	*sino;

int 	pln_3d;

if(strstr(sinofile,".scn")) {
    pln_3d = plnnum_f3d(ring1+1,ring2+1,scanner_type);
    sino = get_cti_sino(sinofile,nrmfil,geofil,normtr,normsc,pln_3d,
					duration,sc,sc->frame);
    }

return(sino);

}

/************************************************/
float *get_2d_sino(sinofile,plane,duration,sc)
/************************************************/

char	*sinofile;	/* Sinogram file to be read. 	*/
int	plane;		/* Plane to read. 		*/
float	*duration;	/* Duration in seconds. 	*/
struct	scatter_tab *sc;

{

float 	*sino;

int	frame=1;

char 	*cdum=NULL;
float	*fdum=NULL;
    
if(!strstr(sinofile,".scn"))
/*    if(scanner_type == 961) */
        sino = get_961_sino(sinofile,cdum,cdum,fdum,fdum,plane,duration,sc,sc->frame);
    else
        sino = get_cti_sino(sinofile,cdum,cdum,fdum,fdum,plane,duration,sc,frame);

return(sino);

}


/************************************************************************/
float *get_cti_sino(sinofile,nrmfil,geofil,normtr,normsc,plane,duration,sc,frame)
/************************************************************************/

/* Read specified plane from cti-file, returns sinogram.  Note that
   the returned array is overwritten on the next call. */

char	*sinofile;	/* Sinogram file to be read. */
char	*geofil,
	*nrmfil;	/* Normalization files. */
float   *normtr,*normsc;
int	plane;		/* Plane number in 3D file. */
float	*duration;	/* Duration in seconds. */
struct	scatter_tab *sc;
int	frame;

{

float	*sino,*normtr1,*normsc1,
	**norm,*geo;

int	i,j,k,joff,koff,moff,gate=1,data=0,bed=0,
	ioff,length,dim1,dim2,pad;

MainHeader *mh;
SubHeader *shdr;
NormData *nrm;

if((mh = getmhdr(sinofile)) == NULL) {
    printf("Error in getmhdr, %s.\n",sinofile);
    exit(ERROR);
    }
if((shdr = getsbhdr(sinofile,plane,frame,gate,data,bed)) == NULL) {
    printf("Error in getsbhdr, %s.\n",sinofile);
    exit(ERROR);
    }
numray_cti_raw = shdr->dim1;
dim1 = shdr->dim1;
dim2 = shdr->dim2;
length = dim1*dim2;
if((sino=rdimg(sinofile,plane,frame,gate,data,bed)) == NULL) {
    printf("Error while reading %s in rdimg.\n",sinofile);
    return(NULL);
    }
if(mh->file_format == INTERFILE) {
    for(i=0;i<length;i++)
	sino[i] *= shdr->deadtime_corr;
    }

#ifdef CHOP
/* Chop out central bins sinograms. */
pad = (shdr->dim1 - NUMRAY)/2;
for(i=0,ioff=pad,joff=0;i<dim2;i++,ioff+=shdr->dim1,joff+=NUMRAY) {
    for(j=0;j<NUMRAY;j++)
        sino[j+joff] = sino[j+ioff];
    }
dim1 = NUMRAY;
#endif

if(sc->numang*(dim2/sc->numang) != dim2) {
    fprintf(stderr,"Invalid value of numang in get_cti_sino.\n");
    exit(ERROR);
    }
else
    ang_dsamp = dim2/sc->numang;
xang_dsamp = (float)dim2/(float)sc->numang;

if(nrmfil != NULL) {
    /* Must be emission sinogram. */
    if((nrm=read_norm(nrmfil,plane)) == NULL) {
        fprintf(stderr,"Error reading %s, plane %d\n",nrmfil,plane);
        exit(ERROR);
        }
    if((geo=rdimg(geofil,plane,1,gate,data,bed)) == NULL) {
        fprintf(stderr,"Error reading %s, plane %d\n",geofil,plane);
        exit(ERROR);
        }
    norm = inflate_norm(nrm,geo);
    normtr1 = norm[0];
    normsc1 = norm[1];
    for(i=0,koff=0,joff=0;i<dim2;i++,koff+=NUMRAY,joff+=sc->numray) {
        for(j=0,k=(NUMRAY-sc->numray)/2;j<sc->numray;j++,k++) {
            normtr1[j+joff] = nrm->true_plane_eff*normtr1[k+koff];
	    if(normsc1[k+koff] > 0) {
                normsc1[j+joff] = nrm->scat_plane_eff/normsc1[k+koff];
		}
	    }
	}

    if(ang_dsamp > 1) {
        /* Sum adjacent sinogram angles. */
        for(i=0,joff=0,koff=0;i<sc->numang;
    		i++,joff+=sc->numray,koff+=ang_dsamp*sc->numray) {
            for(j=0;j<sc->numray;j++) {
    	        normtr1[j+joff] = normtr1[j+koff];
    	        normsc1[j+joff] = normsc1[j+koff];
    	        for(k=1,moff=sc->numray;k<ang_dsamp;k++,moff+=sc->numray) {
    	            normsc1[j+joff] += normsc1[j+koff+moff];
    	            normtr1[j+joff] += normtr1[j+koff+moff];
    		    }
		}
    	    }
	}
    for(i=0;i<sc->lensin;i++) {
	normsc[i] += normsc1[i];
	normtr[i] += normtr1[i];
	}
    free(normtr1);
    free(normsc1);
    free(nrm);
    free(geo);
    free(norm);
    }

/* Correct overflows and reduce number of rays. */
if(shdr->min*shdr->scale_factor < -5000) {
    printf("Assuming overflow in \"get_sino\"\n");
printf("File: %s, plane: %d\n",sinofile,plane);
    for(i=0,koff=0,joff=0;i<dim2;i++,koff+=dim1,joff+=sc->numray) {
        for(j=0,k=(dim1 - sc->numray)/2;j<sc->numray;j++,k++) {
            if(sino[j+joff] < -5000)
                sino[j+joff] = sino[k+koff] + 65535.;
	    else
		sino[j+joff] = sino[k+koff];
            }
	}
    }
else {
    for(i=0,koff=0,joff=0;i<dim2;i++,koff+=dim1,joff+=sc->numray) {
        for(j=0,k=(dim1 - sc->numray)/2;j<sc->numray;j++,k++) 
            sino[j+joff] = sino[k+koff];
	}
    }

if(ang_dsamp > 1) {
    /* Sum adjacent sinogram angles. */
    for(i=0,joff=0,koff=0;i<sc->numang;
		i++,joff+=sc->numray,koff+=ang_dsamp*sc->numray) {
        for(j=0;j<sc->numray;j++) {
	    sino[j+joff] = sino[j+koff];
	    for(k=1,moff=sc->numray;k<ang_dsamp;k++,moff+=sc->numray) 
	        sino[j+joff] += sino[j+koff+moff];
	    }
        }
    }

*duration = .001*(float)shdr->duration;
free(shdr);

return(sino);

}

/************************************************************************/
float *get_961_sino(sinofile,nrmfil,geofil,normtr,normsc,plane,duration,sc,frame)
/************************************************************************/

/* Read specified plane from cti-file, returns sinogram.  Note that
   the returned array is overwritten on the next call. */

char	*sinofile;	/* Sinogram file to be read. */
char	*geofil,
	*nrmfil;	/* Normalization files. */
float   *normtr,*normsc;
int	plane;		/* Plane number in 3D file. */
float	*duration;	/* Duration in seconds. */
struct	scatter_tab *sc;
int	frame;

{

float	*sino,*normtr1,*normsc1,
	**norm,*geo;

int	i,j,k,joff,koff,moff,gate=1,data=0,bed=0,
	ioff,dim1,dim2,pad;

SubHeader *shdr;
NormData *nrm;

if((shdr = getsbhdr(sinofile,plane,frame,gate,data,bed)) == NULL) {
    printf("Error in getsbhdr, %s.\n",sinofile);
    exit(ERROR);
    }
numray_cti_raw = shdr->dim1;
dim2 = shdr->dim2;
if((sino=rdimg(sinofile,plane,frame,gate,data,bed)) == NULL) {
    printf("Error while reading %s in rdimg.\n",sinofile);
    return(NULL);
    }

#ifdef CHOP
/* Chop out central bins sinograms. */
pad = (shdr->dim1 - NUMRAY)/2;
for(i=0,ioff=pad,joff=0;i<dim2;i++,ioff+=shdr->dim1,joff+=NUMRAY) {
    for(j=0;j<NUMRAY;j++)
        sino[j+joff] = sino[j+ioff];
    }
#endif
dim1 = NUMRAY;
if(sc->numang*(dim2/sc->numang) != dim2) {
    fprintf(stderr,"Invalid value of numang in get_cti_sino.\n");
    exit(ERROR);
    }
else
    ang_dsamp = dim2/sc->numang;
xang_dsamp = (float)dim2/(float)sc->numang;

if(nrmfil != NULL) {
    /* Must be emission sinogram. */
    if((nrm=read_norm(nrmfil,plane)) == NULL) {
        fprintf(stderr,"Error reading %s, plane %d\n",nrmfil,plane);
        exit(ERROR);
        }
    if((geo=rdimg(geofil,plane,1,gate,data,bed)) == NULL) {
        fprintf(stderr,"Error reading %s, plane %d\n",geofil,plane);
        exit(ERROR);
        }
    norm = inflate_norm(nrm,geo);
    normtr1 = norm[0];
    normsc1 = norm[1];
    for(i=0,koff=0,joff=0;i<dim2;i++,koff+=NUMRAY,joff+=sc->numray) {
        for(j=0,k=(NUMRAY-sc->numray)/2;j<sc->numray;j++,k++) {
            normtr1[j+joff] = nrm->true_plane_eff*normtr1[k+koff];
	    if(normsc1[k+koff] > 0) {
                normsc1[j+joff] = nrm->scat_plane_eff/normsc1[k+koff];
		}
	    }
	}
    if(ang_dsamp > 1) {
        /* Sum adjacent sinogram angles. */
        for(i=0,joff=0,koff=0;i<sc->numang;
    		i++,joff+=sc->numray,koff+=ang_dsamp*sc->numray) {
            for(j=0;j<sc->numray;j++) {
    	        normtr1[j+joff] = normtr1[j+koff];
    	        normsc1[j+joff] = normsc1[j+koff];
    	        for(k=1,moff=sc->numray;k<ang_dsamp;k++,moff+=sc->numray) {
    	            normsc1[j+joff] += normsc1[j+koff+moff];
    	            normtr1[j+joff] += normtr1[j+koff+moff];
    		    }
		}
    	    }
	}

    for(i=0;i<sc->lensin;i++) {
	normsc[i] += normsc1[i];
	normtr[i] += normtr1[i];
	}
    free(normtr1);
    free(normsc1);
    free(nrm);
    free(geo);
    free(norm);
    }

/* Correct overflows and reduce number of rays. */
if(shdr->min*shdr->scale_factor < -5000) {
    printf("Assuming overflow in \"get_sino\"\n");
printf("File: %s, plane: %d\n",sinofile,plane);
    for(i=0,koff=0,joff=0;i<dim2;i++,koff+=dim1,joff+=sc->numray) {
        for(j=0,k=(dim1 - sc->numray)/2;j<sc->numray;j++,k++) {
            if(sino[j+joff] < -5000)
                sino[j+joff] = sino[k+koff] + 65535.;
	    else
		sino[j+joff] = sino[k+koff];
            }
	}
    }
else {
    for(i=0,koff=0,joff=0;i<dim2;i++,koff+=dim1,joff+=sc->numray) {
        for(j=0,k=(dim1 - sc->numray)/2;j<sc->numray;j++,k++) 
            sino[j+joff] = sino[k+koff];
	}
    }

if(ang_dsamp > 1) {
    /* Sum adjacent sinogram angles. */
    for(i=0,joff=0,koff=0;i<sc->numang;
		i++,joff+=sc->numray,koff+=ang_dsamp*sc->numray) {
        for(j=0;j<sc->numray;j++) {
	    sino[j+joff] = sino[j+koff];
	    for(k=1,moff=sc->numray;k<ang_dsamp;k++,moff+=sc->numray) 
	        sino[j+joff] += sino[j+koff+moff];
	    }
        }
    }

*duration = .001*(float)shdr->duration;
free(shdr);

/* Account for summing done in ACS. */
/*** Let normalization take care of this.
if(plane == 1 || plane == MAX_PLANE)
    scl = 1.;
else if(plane == 2 || plane == MAX_PLANE-1)
    scl = .5;
else {
    if((plane%2) == 0)
        scl = 1./4;
    else
        scl = 1./3;
    }
for(i=0;i<sc->lensin;i++)
    sino[i] *= scl;***/

return(sino);

}

/*----------------------*/
float *fbp(ScatterTable *sc,float *sino,float cutoff)
/*----------------------*/

{

float   filter[FFT_LEN],
	*image,
	scl;

int	i;

static float ramp[FFT_LEN];

static int first = TRUE,imgdimm1;

if(first == TRUE || imgdimm1 != sc->imgdim) { /* Calculate ramp filter.	*/
    first = FALSE;
    imgdimm1 = sc->imgdim;
    if(sc->numray > 256)
	numray_fft = 512;
    else if(sc->numray > 128)
	numray_fft = 256;
    else
	numray_fft = 128;
    ramp_fltr_c(ramp,numray_fft);
    }

/* Copy ramp to filter to be windowed.		*/
for(i=0;i<2*numray_fft;i++) {
    filter[i] = ramp[i];
    }

hanning_fltr(filter,cutoff);
/* Scale for FFT and for zooming in backprojection routine. */
/* Scale up by numray/imgdim to account for change in pixel size, and
   incorporate into usual scale dsamp_factor of PI/numray. */
scl = (PI*sc->numray)/((float)sc->imgdim*(float)numray_fft);
for(i=0;i<2*numray_fft;i++)
    filter[i] *= scl;

if(NULL==(image=(float *)malloc((unsigned)(sc->imgsq*sizeof(float))))) {
    printf("Could not malloc memory for image.\n");
    exit(NULL);
    }

recfbp(sc,sino,image,filter);

return(image);

}


/*---------------------------------------------*/
void hanning_fltr(float   *filter,float   cutoff)
/*---------------------------------------------*/

{

float 	epsilon = 1.0e-03,
	scale,
	dsamp_factor,
	smooth;

int	i,j;

/* Compute the filter window (sinc(x)-0.5*sinc(x/2)**2) */

/* Scale dsamp_factor for filter. */
scale = 1.;
if(cutoff > .001)
    smooth = PI/(cutoff*2.*(float)numray_fft);
else
    smooth = 0.;

/* Window ramp with raised cosine.	*/
filter[0] = scale*filter[0];
for(i=0,j=2;i<numray_fft-1;i++,j+=2) {
    dsamp_factor = .5*(1. + (float)cos((double)(smooth*(float)(i+1))) );
    if(dsamp_factor < epsilon) 
	scale = 0.;
    filter[j] *= scale*dsamp_factor;
    filter[j+1] = filter[j];
    }
filter[1] *= scale*.5*
	     (1. + (float)cos((double)(smooth*(float)numray_fft )));

}

/*---------------------------*/
void ramp_fltr_c(filter,numray)
/*---------------------------*/
/* Compute ramp filter using Colsher method. */

float	filter[];
int	numray;

{
/*#ifdef HP-UX
	extern		realft ();
#else
	extern		realft_ ();
#endif*/

int	i,ifwd=1;

filter[0] = .25;
for(i=1;i<numray+1;) {
    filter[i] =  1./(PI*(float)i); 
    filter[i] *= -filter[i];
    filter[i+1] = 0.;
    filter[2*numray-i] = filter[i];
    filter[2*numray-i-1] = 0.;
    i += 2;
    }

/* Forward transform filter. */
#ifdef HP-UX
	realft (filter, &numray, &ifwd);
#else
	realft_(filter, &numray, &ifwd);
#endif

}

/*-------------------------*/
void ramp_fltr(filter,numray)
/*-------------------------*/
/* 
Purpose: Compute ramp filter with no window using a
	 direct method.*/

float	filter[];
int	numray;

{

int	i,j;

/* Compute ramp in frequency domain.  Since a real FFT 
   routine is used, only half of the frequency components
   are computed. */
filter[0] = 0.; /* DC component.*/
filter[1] = (float)numray/(2.*(float)numray);/* Highest frequency.*/
for(i=2,j=1;i<2*numray;i+=2,j++) {
    filter[i] = (float)j/(2.*(float)numray);
    filter[i+1] = filter[i];
    }

/* Transform to spatial domain.*/
/*realft_(filter,&numray,&inv);*/

/* Zero out pad and rescale.*/
/*scl = 1./(float)numray;
for(i=numray/2;i<numray+numray/2;i++)
    filter[i] = 0.;
for(i=0;i<numray/2;i++)
    filter[i] *= scl;
for(i=numray+numray/2;i<2*numray;i++)
    filter[i] *= scl;*/

/* Forward transform filter.*/
/*realft_(filter,&numray,&fwd);*/

}


/*-----------------------------*/
void recfbp(sc,sino,image,filter)
/*-----------------------------*/
/*
Purpose: Implement filtered backprojection.
	 sino: Input sinogram.
	 image: Output image
	 filter: Filter computed in hann_fltr or gauss_fltr
*/

struct 	scatter_tab *sc;
float	*sino,
	*image,
	filter[];

{
/*#ifdef HP-UX
	extern		realft ();
#else
	extern		realft_ ();
#endif*/

float	prodat[FFT_LEN],theta;

int	iang,iangoff,nray,i,ifwd,irev,pad;

/* Zero out image.*/
for(i=0;i<sc->imgsq;i++)
    image[i] = 0.;
for(i=0;i<FFT_LEN;i++)
    prodat[i] = 0.;

/* Loop over projections. */
pad = (numray_fft - sc->numray)/2;
for(iang=0,iangoff=0;iang<sc->numang;iang++,iangoff+=sc->numray) {

    /* Convert data to float and store in padded vector.*/
    for(i=0;i<pad;i++)
	prodat[i] = 0;
    for(nray=0,i=pad;nray<sc->numray;nray++,i++) 
        prodat[i]  = sino[nray+iangoff];

    /* Avoid circular convolution effects by extending projection
       data by zero filling. */
    for(nray=numray_fft-pad;nray<2*numray_fft;nray++)
        prodat[nray] = 0;

    /* Forward transform projection. */
    ifwd = 1;
#ifdef HP-UX
	realft (prodat, &numray_fft, &ifwd);
#else
	realft_(prodat, &numray_fft, &ifwd);
#endif

    /* Filter in frequency domain. */
    for(nray=0;nray<2*numray_fft;nray++) 
        prodat[nray] *= filter[nray];

    /*  Inverse transform filtered projection. */
    irev = 0;
#ifdef HP-UX
	realft (prodat, &numray_fft, &irev);
#else
	realft_(prodat, &numray_fft, &irev);
#endif

    /* Remove pad from filtered data. */
    for(i=0;i<sc->numray;i++)
	prodat[i] = prodat[i+pad];

/*    if(12*(iang/12) == iang) 
	printf("Backprojecting angle #%d\n",iang);*/
/* Add offset to theta to account for downsampling of sinogram. */
    theta = -THETA_START - THETA_DIR*PI*((float)iang+.5)/(float)sc->numang;
    bakpro(theta,prodat,image,RAY_OFFSET,sc); 

    }

}
/*---------------------------------------------------------------

Subroutine: bakpro

Purpose: Backproject a single angle into an image by 
          interpolating projection array and using a nearest 
          neighbor scheme.  The algorithm is implemented using
	   primarily vector operations.

Coordinate system: This routine assumes that the pixel represented
	by image[0][0] in "C" lies at the upper left corner of 
	the image.  A back-projection at theta=0
	sums into pixels lying along a vertical path in the image,
	i.e., along the first index to the array.  The projection is
	assumed to lie above the image, with the projection
	indexed by prodat[0] lying above image[0][0].  Theta is
	defined such that increasing theta would rotate the 
	displayed projecton in the counter-clockwise direction.

Calling sequence: call bakpro(theta,prodat,image,numray,numang)
	theta: Angle of projection in radians.
	prodat: Projection data.
	image: Image
	numray: Number of rays per projection.

By: John Ollinger

Date: September 15, 1989

----------------------------------------------------------------*/

void bakpro(
	float   theta,       /* Angle of projection in radians.      */
	float   *prodat,     /* Projection data.                     */
	float   *image,      /* Reconstructed image.                 */
	float   sino_offset, /* Offset of sinogram center from image center. */
	ScatterTable *sc)

{

float	proint[INTERP_LEN_MAX];	/* Interpolated projection.	*/


static int ilow[IMGDIM_MAX],	/* Starting pixel of circle.	*/
	ihigh[IMGDIM_MAX],	/* Ending pixel of circle.	*/
	inum[IMGDIM_MAX],	/* Number of pixels in chord.	*/
	imgdimm1;		/* Image dimension. 		*/

int	i,j,joff;

static int imin,ii;

static float center,radsq;

float	xcord,cdsq,ctht,stht,cnst,kd,xioff,xooff,zoom_tot,
	xi,del;

if(sc->imgdim != imgdimm1) {
    /* Compute boundaries of circular region to be reconstructed.*/
    imgdimm1 = sc->imgdim;
    center = (float)(sc->imgdim-1)/2.;
    radsq  = center*center;
    imin = 1;
    for(j=0;j<sc->imgdim;j++) {
        cdsq = (float)j - center;
	cdsq = radsq - cdsq*cdsq;
	if(cdsq > 0) 
            xcord = (float)sqrt( (double)cdsq);
	else
	    xcord = 0;
        ilow[j]  = (int)(center - xcord) + imin; 
        ihigh[j] = (int)(center + xcord) - imin;
	inum[j] = ihigh[j] - ilow[j] + 1;
        }
    for(i=0;i<INTERP_LEN_MAX;i++)
	proint[i] = 0.;
    }

xioff = ((float)sc->numray - 1.)/2.;
xooff = (float)INTERP_FCT*(sc->imgdim - 1)/2.;
zoom_tot = (float)sc->imgdim/(float)sc->numray;
for(i=0;i<INTERP_FCT*sc->imgdim;i++) {
    xi = xioff + (((float)i - xooff)/(INTERP_FCT*zoom_tot) + sino_offset);
    ii = (int)xi;
    del = xi - (float)ii;
    proint[i] = (1. - del)*prodat[ii] + del*prodat[ii+1];
    }

/* Backproject.	*/
ctht =  INTERP_FCT*(float)cos((double)theta);
stht =  INTERP_FCT*(float)sin((double)theta);

/*cnst = center*(INTERP_FCT - ctht + stht) + ctht*(float)imin + INTERP_FCT;*/
cnst = center*(INTERP_FCT - ctht + stht) + ctht*(float)imin;
for(i=imin,joff=imin*sc->imgdim;i<sc->imgdim-imin;i++,joff+=sc->imgdim) {
    kd = -(float)ilow[i]*stht + cnst;
    for(j=ilow[i];j<ihigh[i];j++) {
        image[j+joff] += proint[(int)kd];
        kd -= stht;
	}
    cnst += ctht;
    }

}

/*******************************/
void getbed(sc,emisfile,tranfile)
/*******************************/

ScatterTable *sc;
char	**emisfile,
	**tranfile;

{

int	minpln=10000,maxpln=0,minpln1,maxpln1,ifile,pln,*plnoff,
	plane=1,gate=1,data=0,bed=0,del;

float	*bed_off,*xplnoff;

MainHeader *mh;

SubHeader *sh;

sc->bed_pos = (float *)malloc(sc->nfile*sizeof(float));
sc->emis_duration = (float *)malloc(sc->nfile*sizeof(float));
sc->tran_duration = (float *)malloc(sc->nfile*sizeof(float));
sc->blank_duration = (float *)malloc(sc->nfile*sizeof(float));
sc->start_time = (float *)malloc(sc->nfile*sizeof(float));
bed_off = (float *)malloc(sc->nfile*sizeof(float));
xplnoff = (float *)malloc(sc->nfile*sizeof(float));
plnoff = (int *)malloc(sc->nfile*sizeof(int));
for(ifile=0;ifile<sc->nfile;ifile++) {
    if((mh = getmhdr(emisfile[ifile])) == NULL) {
        printf("Error in getmhdr, %s.\n",emisfile[ifile]);
        exit(ERROR);
        }
    if((sh = getsbhdr(emisfile[ifile],plane,sc->frame,gate,data,bed)) == NULL) {
        printf("Error in getsbhdr, %s.\n",emisfile[ifile]);
        exit(ERROR);
        }
    sc->emis_duration[ifile] = sh->duration/60000.;
    free(sh);
    if((sh = getsbhdr(tranfile[ifile],plane,sc->frame,gate,data,bed)) == NULL) {
        printf("Error in getsbhdr, %s.\n",tranfile[ifile]);
        exit(ERROR);
        }
    sc->tran_duration[ifile] = .001*sh->duration;
    sc->start_time[ifile] = mh->start_time/60;
    free(sh);
    sc->bed_pos[ifile] = 10.*mh->init_bed_pos;
    bed_off[ifile] = sc->bed_pos[0] - sc->bed_pos[ifile];
    xplnoff[ifile] = bed_off[ifile]/(SLCTHK/2.);
    if(xplnoff[ifile] < 0) {
        plnoff[ifile] = (int)(xplnoff[ifile] - .5);
        maxpln1 = MAX_PLANE - plnoff[ifile];
        minpln1 = maxpln1 - MAX_PLANE + 1;
        }
    else if(xplnoff[ifile] > 0) {
        plnoff[ifile] = (int)(xplnoff[ifile] + .5);
        minpln1 = 1 - plnoff[ifile];
        maxpln1 = minpln1 + MAX_PLANE - 1;
        }
    else {
        plnoff[ifile] = 0;
        minpln1 = 1;
        maxpln1 = MAX_PLANE;
        }
    if(minpln1 < minpln)
        minpln = minpln1;
    if(maxpln1 > maxpln)
        maxpln = maxpln1;
    if(ifile < sc->nfile-1)
        free(mh);
    }

sc->numvpln = maxpln - minpln + 1;
sc->numpln = (sc->numvpln+1)/2;
sc->mainvplane1 = 2 - minpln;
sc->mainplane1 = sc->mainvplane1/2 + 1;
sc->physvpln =  (int *)malloc((sc->numvpln+1)*sizeof(int));
sc->plnpos = (float *)malloc((sc->numvpln+1)*sizeof(float));
sc->plnpos[0] = 0.;
sc->physpln =  (int *)malloc((sc->numpln+1)*sizeof(int));
sc->filenum =  (int *)malloc((sc->numvpln+1)*sizeof(float));

for(ifile=0;ifile<sc->nfile;ifile++) {
    if(bed_off[ifile] == 0) {
        for(pln=sc->mainvplane1;pln<=sc->mainvplane1+MAX_PLANE-1;pln++) {
            sc->plnpos[pln] = pln;
            sc->physvpln[pln] = pln - sc->mainvplane1 + 1;
            sc->physpln[(pln+1)/2] = (sc->physvpln[pln]+1)/2;
            sc->filenum[pln] = ifile;
            }
        }
    else if(bed_off[ifile] > 0) {
        for(pln=1;pln<sc->mainvplane1;pln++) {
            sc->physvpln[pln] = pln;
            sc->plnpos[pln] = pln - 1 - xplnoff[ifile] + sc->mainvplane1;
            sc->physpln[(pln+1)/2] = (sc->physvpln[pln]+1)/2;
            sc->filenum[pln] = ifile;
            }
        }
    else {
        for(pln=MAX_PLANE+1;pln<=sc->numvpln;pln++) {
            sc->physvpln[pln] = pln + plnoff[ifile];
            sc->plnpos[pln] =  sc->physvpln[pln] - 1 - xplnoff[ifile] + sc->mainvplane1;
            sc->physpln[(pln+1)/2] = (sc->physvpln[pln]+1)/2;
            sc->filenum[pln] = ifile;
            }
        }
    }
/*for(pln=0;pln<sc->numvpln;pln++)
     printf("pln: %d, plnpos: %f\n",pln,sc->plnpos[pln]);*/
/*for(pln=0;pln<sc->numpln;pln++)
     printf("pln: %d, plnpos: %d\n",pln,sc->physpln[pln]);*/

free(mh);
free(bed_off);
free(xplnoff);

}
@
