head	1.1;
access;
symbols;
locks; strict;
comment	@ * @;


1.1
date	98.04.01.14.39.42;	author tom;	state Exp;
branches;
next	;


desc
@@


1.1
log
@Initial revision
@
text
@/*$Id: interfile.c,v 3.1 1998/03/24 23:43:10 jmo Exp jmo $*/
/*$Log: interfile.c,v $
 * Revision 3.1  1998/03/24  23:43:10  jmo
 * ..
 *
 * Revision 3.0  1997/10/29  19:26:43  jmo
 * Support Exact HR.
 *
 * Revision 2.6  1997/08/06  18:22:04  jmo
 * Last version before adding CTI rev 7 support.
 *
 * Revision 2.5  1996/06/27  19:14:49  jmo
 * Fix bug with open mode in getfp.
 *
 * Revision 2.4  1996/06/19  11:20:10  jmo
 *
 * Revision 2.3  1996/04/23  15:02:05  jmo
 * Version released April 23, 1996
 *
 * Revision 2.2  1996/04/23  14:56:14  jmo
 * Version Released on Web site, April 23, 1996
 *
 * Revision 2.1  1996/03/15  21:57:19  jmo
 * Version installed in St. Louis.
 *
 * Revision 2.0  1996/01/27  13:44:43  jmo
 * Version installed at Neuro-imaging group, January 1996
 *
 * Revision 1.2  1996/01/18  16:09:59  jmo
 * Modified file formats, Interfile and Matrix Rev 7.0 support.
 *
 * Revision 1.1  1996/01/12  18:09:11  jmo
 * Initial revision
 *
 * Revision 1.2  1995/11/08  14:07:53  jmo
 * Initial testing.
 *
 * Revision 1.1  1995/10/25  16:36:14  jmo
 * Initial revision
 *
 * Revision 1.6  1995/10/20  16:36:47  jmo
 * *** empty log message ***
 *
 * Revision 1.5  95/10/19  17:11:37  17:11:37  jmo (John Ollinger)
 * *** empty log message ***
 * 
 * Revision 1.4  95/09/19  10:43:41  jmo
 * Version for revised paper to physics in medicine and biology.
 * 
 * Revision 1.3  95/05/05  21:27:59  jmo
 * *** empty log message ***
 * 
 * Revision 1.2  95/03/31  15:48:50  jmo
 *  Version for 951 sent to Pittsburgh.
 * 
 * Revision 1.1  95/01/19  22:40:20  ty7777
 * Initial revision
 * */

/*---------------------------------------------------------------------

Routines: Wrapper routines for CTI image I/O programs.
	getsbhdr_if
	putsbhdr_if
	putmhdr_if
	getmhdr_if
	rdimg
	wrimg

Copyright 1991-1996, Washington University.
All rights reserved. Unauthorized reproduction prohibited.

---------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <if.h>
#include <imagio.h>

#define MAX_FILES 50
#define MAXNAME 120
#define MAX_LINE 200
#define TRUE 1
#define FALSE 0
#define NUM_KEYS 31
#define NUM_MHKEYS (NUM_KEYS - 9)

static char rcsid [] = "$Header: /home/fafner/jmo/src/scatter/scat/RCS/interfile.c,v 3.1 1998/03/24 23:43:10 jmo Exp jmo $";


FILE    *fp_list[MAX_FILES] =
                {NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL};
char    file_list_if[MAX_FILES][MAXNAME];
char    hdr_list[MAX_FILES][MAXNAME];
char    mode_list_if[MAX_FILES][4]; /* Access modes of opened files. */
IFheader *ifh_list[MAX_FILES] = {NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL};

FILE *getfp(char *filnam,char *mode);
FILE *write_fp(char *filnam,char *mode);
char *header_file(char *filnam);
void  put_ifh(char *hdrfil,IFheader *ifh);
IFheader *get_ifh(char *filnam);
IFheader *gethdr_if(char *filnam);
IFheader *make_ifh(int dim3,int dim4);
char *getstr(char *line);
void 	close_if(char *filnam),free_ifmh(MainHeader_if *mh),
	free_ifh(IFheader *ifh);
SubHeader_if *getsbhdr_if(char *filnam,int plane,int frame);
MainHeader_if *getmhdr_if(char *filnam);
void write_key( FILE *fpw,char *line,IFheader *ifh,int bed);
int putmhdr_if(MainHeader_if *mh,char *filnam_in);
int putsbhdr_if(SubHeader_if *sh,char *filnam_in,int plane,int frame);

static char *key[NUM_KEYS] =     
		       {"INTERFILE",
			"originating system",
			"number of dimensions",
			"program version",
			"matrix size [1]",
			"matrix size [2]",
			"matrix size [3]",
			"matrix size [4]",
			"scaling factor (mm/pixel) [1]",
			"scaling factor (mm/pixel) [2]",
			"scaling factor (mm/pixel) [3]",
			"number of bytes per pixel",
			"name of data file",
			"patient ID",
			"study date",
			"number format",
			"volume scale factor",
			"bed elevation",
			"number of bed positions",
			"initial bed position",
                        "bed offset",
			"frame number",
			"frame starting time",
			"frame duration",
			"plane number",
			"storage scale factor",
			"number of trues",
			"number of randoms",
			"number of multiples",
			"deadtime correction factor",
			"user defined comment"};


/*************************/
IFheader *gethdr_if(filnam)
/*************************/

char	*filnam;

{

FILE 	*fp;

char	line[MAX_LINE],number[20],
	*string,*hdrfil;

int	i,bytes_pix,plane,frame,bed=0;

IFheader *ifh;

ifh    = (IFheader *)malloc(sizeof(IFheader));
ifh->mh = (MainHeader_if *)malloc(sizeof(MainHeader_if));
ifh->mh->study_date = NULL;
ifh->mh->sw_revision = NULL;
ifh->mh->patient_id = NULL;
ifh->mh->data_file = NULL;
/*ifh->sh = (SubHeader_if ***)malloc(sizeof(SubHeader_if));*/
ifh->sh = NULL;

hdrfil = header_file(filnam);
if(filnam != NULL) {
    ifh->filnam = (char *)malloc(1+strlen(hdrfil));
    strcpy(ifh->filnam,hdrfil);
    }
put_ifh(hdrfil,ifh);

if((fp = getfp(hdrfil,"r")) == NULL)
    return(NULL);

if(fgets(line,MAX_LINE,fp) == NULL)
    return(NULL);
else {
    if(strstr(line,"INTERFILE") == NULL)
	return(NULL);
    }

plane = -1;
frame = -1;
ifh->mh->dim4 = 1;
while(fgets(line,200,fp) != NULL) {
    if(strstr(line,"originating system"))
	ifh->mh->orig_system = atoi(getstr(line));
    else if(strstr(line,"number of dimensions"))
	ifh->mh->ndim = atoi(getstr(line));
    else if(strstr(line,"matrix size [1]"))
	ifh->mh->dim1 = atoi(getstr(line));
    else if(strstr(line,"matrix size [2]"))
	ifh->mh->dim2 = atoi(getstr(line));
    else if(strstr(line,"matrix size [3]"))
	ifh->mh->dim3 = atoi(getstr(line));
    else if(strstr(line,"matrix size [4]")) {
	ifh->mh->dim4 = atoi(getstr(line));
	ifh->fh = (FrameHeader_if **)
			malloc(ifh->mh->dim4*sizeof(FrameHeader_if *));
	ifh->sh = (SubHeader_if ***)
			malloc(ifh->mh->dim4*sizeof(SubHeader_if **));
	}
    else if(strstr(line,"scaling factor (mm/pixel) [1]"))
	sscanf(getstr(line),"%f",&ifh->mh->voxel_size_1);
    else if(strstr(line,"scaling factor (mm/pixel) [2]"))
	sscanf(getstr(line),"%f",&ifh->mh->voxel_size_2);
    else if(strstr(line,"scaling factor (mm/pixel) [3]"))
	sscanf(getstr(line),"%f",&ifh->mh->voxel_size_3);
    else if(strstr(line,"volume scale factor"))
	sscanf(getstr(line),"%f",&ifh->mh->scale_factor);
    else if(strstr(line,"bed elevation"))
	sscanf(getstr(line),"%f",&ifh->mh->bed_elevation);
    else if(strstr(line,"initial bed position"))
	sscanf(getstr(line),"%f",&ifh->mh->init_bed_pos);
    else if(strstr(line,"number of bed positions"))
	sscanf(getstr(line),"%d",&ifh->mh->nbed);
    else if(strstr(line,"bed offset")) {
	sscanf(getstr(line),"%f",&ifh->mh->bed_off[bed]);
	++bed;
	}
    else if(strstr(line,"name of data file")) {
	string = getstr(line);
	if(string != NULL) {
	    ifh->mh->data_file = (char *)malloc(1+strlen(string));
	    strcpy(ifh->mh->data_file,string);
	    }
	}
    else if(strstr(line,"patient ID")) {
	string = getstr(line);
	if(string != NULL) {
	    ifh->mh->patient_id = (char *)malloc(1+strlen(string));
	    strcpy(ifh->mh->patient_id,string);
	    }
	}
    else if(strstr(line,"study date")) {
	string = getstr(line);
	if(string != NULL) {
	    ifh->mh->study_date = (char *)malloc(1+strlen(string));
	    strcpy(ifh->mh->study_date,string);
	    }
	}
    else if(strstr(line,"program version")) {
	string = getstr(line);
	if(string != NULL) {
	    ifh->mh->sw_revision = (char *)malloc(1+strlen(string));
	    strcpy(ifh->mh->sw_revision,string);
	    }
	else
	    ifh->mh->sw_revision = NULL;
	}
    else if(strstr(line,"number format")) {
	string = getstr(line);
	strcpy(number,string);
	}
    else if(strstr(line,"number of bytes per pixel"))
	bytes_pix = atoi(getstr(line));
    else if(strstr(line,"frame number")) {
	frame = atoi(getstr(line));
	frame -= 1;
	ifh->sh[frame] = (SubHeader_if **)
			malloc(ifh->mh->dim3*sizeof(SubHeader_if *));
	ifh->fh[frame] = (FrameHeader_if *)malloc(sizeof(FrameHeader_if));
    	for(i=0;i<ifh->mh->dim3;i++)
	    ifh->sh[frame][i] = NULL;
	}
    else if(strstr(line,"frame starting time")) {
	if(frame < 0) return(NULL);
	ifh->fh[frame]->starting_time = atoi(getstr(line));
	}
    else if(strstr(line,"frame duration")) {
	if(frame < 0) return(NULL);
	ifh->fh[frame]->duration = atoi(getstr(line));
	}
    else if(strstr(line,"plane number")) {
	plane = atoi(getstr(line));
	plane -= 1;
	ifh->sh[frame][plane] = (SubHeader_if *)malloc(sizeof(SubHeader_if));
	}
    else if(strstr(line,"storage scale factor")) {
	if(frame < 0) return(NULL);
	if(plane < 0) return(NULL);
	sscanf(getstr(line),"%g",&ifh->sh[frame][plane]->storage_sf);
	}
    else if(strstr(line,"number of trues")) {
	if(frame < 0) return(NULL);
	if(plane < 0) return(NULL);
	ifh->sh[frame][plane]->trues = atoi(getstr(line));
	}
    else if(strstr(line,"number of randoms")) {
	if(frame < 0) return(NULL);
	if(plane < 0) return(NULL);
	ifh->sh[frame][plane]->randoms = atoi(getstr(line));
	}
    else if(strstr(line,"number of multiples")) {
	if(frame < 0) return(NULL);
	if(plane < 0) return(NULL);
	ifh->sh[frame][plane]->multiples = atoi(getstr(line));
	}
    else if(strstr(line,"deadtime correction factor")) {
	if(frame < 0) return(NULL);
	if(plane < 0) return(NULL);
	sscanf(getstr(line),"%g",&ifh->sh[frame][plane]->deadtime_corr);
	}
    else if(strstr(line,"user defined comment")) {
	string = getstr(line);
	if(string != NULL) {
	    ifh->sh[frame][plane]->comment = (char *)malloc(1+strlen(string));
	    strcpy(ifh->sh[frame][plane]->comment,string);
	    }
	}
    }

if(!strcmp(number,"signed integer") && bytes_pix == 1)
    ifh->mh->number_format = BYTE_IF;
if(!strcmp(number,"signed integer") && bytes_pix == 2)
    ifh->mh->number_format = SHORT_IF;
else if(!strcmp(number,"float") && bytes_pix == 4)
    ifh->mh->number_format = FLOAT_IF;
else
    ifh->mh->number_format = UNKNOWN;

if(ifh->sh == NULL) {
    ifh->fh = (FrameHeader_if **)
		malloc(ifh->mh->dim4*sizeof(FrameHeader_if *));
    ifh->sh = (SubHeader_if ***)
		malloc(ifh->mh->dim4*sizeof(SubHeader_if **));
    ifh->sh[0] = (SubHeader_if **)malloc(ifh->mh->dim3*sizeof(SubHeader_if *));
    for(i=0;i<ifh->mh->dim3;i++)
	ifh->sh[0][i] = NULL;
    ifh->fh[0] = (FrameHeader_if *)malloc(sizeof(FrameHeader_if));
    }

for(frame=0;frame<ifh->mh->dim4;frame++) {
    for(plane=0;plane<ifh->mh->dim3;plane++) {
 	if(ifh->sh[frame][plane] == NULL)
     	    ifh->sh[frame][plane] = (SubHeader_if *)malloc(sizeof(SubHeader_if));
	ifh->sh[frame][plane]->voxel_size_1 = ifh->mh->voxel_size_1;
	ifh->sh[frame][plane]->voxel_size_2 = ifh->mh->voxel_size_2;
	ifh->sh[frame][plane]->voxel_size_3 = ifh->mh->voxel_size_3;
	ifh->sh[frame][plane]->dim1 = ifh->mh->dim1;
	ifh->sh[frame][plane]->dim2 = ifh->mh->dim2;
	ifh->sh[frame][plane]->dim3 = ifh->mh->dim3;
	ifh->sh[frame][plane]->ndim = ifh->mh->ndim;
	ifh->sh[frame][plane]->number_format = ifh->mh->number_format;
	ifh->sh[frame][plane]->starting_time = ifh->fh[frame]->starting_time;
	ifh->sh[frame][plane]->duration = ifh->fh[frame]->duration;
	}
    }

free(hdrfil);
return(ifh);

}

/****************/
char *getstr(line)
/****************/

char	*line;

{

char	*ptr,*ptr1;

ptr = strstr(line,":=");
ptr += 2;
ptr1 = strstr(line,"\n");
if(ptr1 != NULL)
    *ptr1 = NULL;
while(ptr[0] == ' ')
    ++ptr;
return(ptr);

}


/*******************************************/
SubHeader_if *getsbhdr_if(filnam,plane,frame)
/*******************************************/

char	*filnam;
int	plane,frame;

{

SubHeader_if *sh;
IFheader *ifh;
char	*hdrfil;

hdrfil = header_file(filnam);
if((ifh=get_ifh(hdrfil)) == NULL) {
    if((ifh = gethdr_if(hdrfil)) == NULL) {
	fprintf(stderr,"Could not read header from %s in getsbhdr_if.\n",hdrfil);
	return(NULL);
	}
    put_ifh(hdrfil,ifh);
    }

sh = (SubHeader_if *)malloc(sizeof(SubHeader_if));
sh->comment = NULL;
sh->dim1 = ifh->sh[frame-1][plane-1]->dim1;
sh->dim2 = ifh->sh[frame-1][plane-1]->dim2;
sh->dim3 = ifh->sh[frame-1][plane-1]->dim3;
sh->ndim = ifh->sh[frame-1][plane-1]->ndim;
sh->number_format = ifh->sh[frame-1][plane-1]->number_format;
sh->voxel_size_1 = ifh->sh[frame-1][plane-1]->voxel_size_1;
sh->voxel_size_2 = ifh->sh[frame-1][plane-1]->voxel_size_2;
sh->voxel_size_3 = ifh->sh[frame-1][plane-1]->voxel_size_3;
sh->storage_sf = ifh->sh[frame-1][plane-1]->storage_sf;
sh->deadtime_corr = ifh->sh[frame-1][plane-1]->deadtime_corr;
sh->trues = ifh->sh[frame-1][plane-1]->trues;
sh->randoms = ifh->sh[frame-1][plane-1]->randoms;
sh->multiples = ifh->sh[frame-1][plane-1]->multiples;
sh->starting_time = ifh->fh[frame-1]->starting_time;
sh->duration = ifh->fh[frame-1]->duration;
if(ifh->sh[frame-1][plane-1]->comment != NULL) {
    sh->comment = (char *)malloc(1+strlen(ifh->sh[frame-1][plane-1]->comment));
    strcpy(sh->comment,ifh->sh[frame-1][plane-1]->comment);
    }

free(hdrfil);
return(sh);

}

/**************************/
int putmhdr_if(mh,filnam_in)
/**************************/

MainHeader_if	*mh;
char	*filnam_in;

{

IFheader *ifh;

FILE	*fpr,*fpw;

char	string[MAX_LINE],*hdrfil,*file[2000];

int	i,ikey,key_written[NUM_KEYS],bed,line,num_lines;

for(i=0;i<NUM_KEYS;i++)
    key_written[i] = 0;

hdrfil = header_file(filnam_in);

if((ifh = get_ifh(hdrfil)) == NULL)
    ifh = make_ifh(mh->dim3,mh->dim4);
else {
    free(ifh->mh->data_file);
    free(ifh->mh->patient_id);
    free(ifh->mh->study_date);
    free(ifh->mh->sw_revision);
    }
if(mh->data_file != NULL) {
    ifh->mh->data_file = (char *)malloc(1+strlen(mh->data_file));
    strcpy(ifh->mh->data_file,mh->data_file);
    }
else
    ifh->mh->data_file = NULL;
if(mh->patient_id != NULL) {
    ifh->mh->patient_id = (char *)malloc(1+strlen(mh->patient_id));
    strcpy(ifh->mh->patient_id,mh->patient_id);
    }
else
    ifh->mh->patient_id = NULL;
if(mh->study_date != NULL) {
    ifh->mh->study_date = (char *)malloc(1+strlen(mh->study_date));
    strcpy(ifh->mh->study_date,mh->study_date);
    }
else
    ifh->mh->study_date = NULL;
if(mh->sw_revision != NULL) {
    ifh->mh->sw_revision = (char *)malloc(strlen(mh->sw_revision)+1);
    strcpy(ifh->mh->sw_revision,mh->sw_revision);
    }
else
    ifh->mh->sw_revision = NULL;

ifh->mh->file_type = mh->file_type;
ifh->mh->number_format = mh->number_format;
ifh->mh->ndim = mh->ndim;
ifh->mh->dim1 = mh->dim1;
ifh->mh->dim2 = mh->dim2;
ifh->mh->dim3 = mh->dim3;
ifh->mh->dim4 = mh->dim4;
ifh->mh->orig_system = mh->orig_system;
ifh->mh->voxel_size_1 = mh->voxel_size_1;
ifh->mh->voxel_size_2 = mh->voxel_size_2;
ifh->mh->voxel_size_3 = mh->voxel_size_3;
ifh->mh->scale_factor = mh->scale_factor;
ifh->mh->nbed = mh->nbed;
ifh->mh->bed_elevation = mh->bed_elevation;
ifh->mh->init_bed_pos = mh->init_bed_pos;
for(i=0;i<16;i++)
    ifh->mh->bed_off[i] = mh->bed_off[i];

num_lines = 0;
if((fpr = fopen(hdrfil,"rb")) != NULL) {
    while(fgets(string,200,fpr) != NULL) {
	if(string != NULL) {
	    file[num_lines] = (char *)malloc(1+strlen(string));
	    strcpy(file[num_lines],string);
	    }
	++num_lines;
	}
    fclose(fpr);
    }

if((fpw = fopen(hdrfil,"wb")) == NULL) {
    return(NULL);
    }
put_ifh(hdrfil,ifh);

bed = 0;
for(line=0;line<num_lines;line++) {
    for(ikey=0;ikey<NUM_KEYS;ikey++) {
	if(strstr(file[line],key[ikey])) { /* Line is in my header definition */
	    break;
	    }
	}
    if(ikey == NUM_KEYS) /* Line is not in my header definition */
	fprintf(fpw,"%s",file[line]);
    else if(key_written[ikey] == 0) { /* Update value of line and write it out. */
	key_written[ikey] = 1;
	write_key(fpw,file[line],ifh,bed);
	if(!strcmp(key[ikey],"bed offset"))
	   ++bed;
	}
    free(file[line]);
    }

for(ikey=0;ikey<NUM_MHKEYS;ikey++) {
    if(key_written[ikey] == 0) 
	if(!strcmp(key[ikey],"bed offset")) {
	    ++bed;
	    write_key(fpw,key[ikey],ifh,bed);
	    }
	else
	    write_key(fpw,key[ikey],ifh,bed);
    }

fflush(fpw);
fclose(fpw);
free(hdrfil);

return(NULL);

}

/*****************************/
void write_key(fpw,line,ifh,bed)
/*****************************/

FILE	*fpw;
char	*line;
IFheader	*ifh;
int	bed;

{

char	*filnam;

if(strstr(line,"originating system"))
    fprintf(fpw,"originating system := %d\n",ifh->mh->orig_system);
else if(strstr(line,"INTERFILE"))
    fprintf(fpw,"INTERFILE :=\n");
else if(strstr(line,"number of dimensions"))
    fprintf(fpw,"number of dimensions:= %d\n",ifh->mh->ndim);
else if(strstr(line,"matrix size [1]"))
    fprintf(fpw,"matrix size [1] := %d\n",ifh->mh->dim1);
else if(strstr(line,"matrix size [2]"))
    fprintf(fpw,"matrix size [2] := %d\n",ifh->mh->dim2);
else if(strstr(line,"matrix size [3]"))
    fprintf(fpw,"matrix size [3] := %d\n",ifh->mh->dim3);
else if(strstr(line,"matrix size [4]"))
    fprintf(fpw,"matrix size [4] := %d\n",ifh->mh->dim4);
else if(strstr(line,"scaling factor (mm/pixel) [1]"))
    fprintf(fpw,"scaling factor (mm/pixel) [1] := %f\n",ifh->mh->voxel_size_1);
else if(strstr(line,"scaling factor (mm/pixel) [2]"))
    fprintf(fpw,"scaling factor (mm/pixel) [2] := %f\n",ifh->mh->voxel_size_2);
else if(strstr(line,"scaling factor (mm/pixel) [3]"))
    fprintf(fpw,"scaling factor (mm/pixel) [3] := %f\n",ifh->mh->voxel_size_3);
else if(strstr(line,"volume scale factor"))
    fprintf(fpw,"volume scale factor := %f\n",ifh->mh->scale_factor);
else if(strstr(line,"name of data file")) {
    /* Strip off directory name. */
    filnam = strrchr(ifh->mh->data_file,(char)'/');
    if(filnam != NULL)
	++filnam;
    else
	filnam = ifh->mh->data_file;
    fprintf(fpw,"name of data file := %s\n",filnam);
    }
else if(strstr(line,"patient ID")) {
    if(ifh->mh->patient_id != NULL) 
        fprintf(fpw,"patient ID := %s\n",ifh->mh->patient_id);
    }
else if(strstr(line,"study date")) {
    if(ifh->mh->study_date != NULL) 
        fprintf(fpw,"study date := %s\n",ifh->mh->study_date);
    }
else if(strstr(line,"program version")) {
    if(ifh->mh->sw_revision != NULL) 
        fprintf(fpw,"program version := %s\n",ifh->mh->sw_revision);
    }
else if(strstr(line,"number of bed positions"))
    fprintf(fpw,"number of bed positions := %d\n",ifh->mh->nbed);
else if(strstr(line,"bed elevation"))
    fprintf(fpw,"bed elevation := %f\n",ifh->mh->bed_elevation);
else if(strstr(line,"initial bed position"))
    fprintf(fpw,"initial bed position := %f\n",ifh->mh->init_bed_pos);
else if(strstr(line,"bed offset"))
    fprintf(fpw,"bed offset := %f\n",ifh->mh->bed_off[bed]);
else if(strstr(line,"number format")) {
    if(ifh->mh->number_format == BYTE_IF) {
        fprintf(fpw,"number format := signed integer\n");
        fprintf(fpw,"number of bytes per pixel := 1\n");
	}
    else if(ifh->mh->number_format == SHORT_IF) {
        fprintf(fpw,"number format := signed integer\n");
        fprintf(fpw,"number of bytes per pixel := 2\n");
	}
    else if(ifh->mh->number_format == FLOAT_IF) {
        fprintf(fpw,"number format := float\n");
        fprintf(fpw,"number of bytes per pixel := 4\n");
	}
    else {
	fprintf(stderr,"Invalid number format specified in write_key.\n");
	}
    }
else if(strstr(line,"number of bytes per pixel"))
    {}
else if(strstr(line,"frame number"))
    {}
else if(strstr(line,"frame starting time"))
    {}
else if(strstr(line,"frame duration"))
    {}
else if(strstr(line,"plane number"))
    {}
else if(strstr(line,"storage scale factor"))
    {}
else if(strstr(line,"number of trues"))
    {}
else if(strstr(line,"number of randoms"))
    {}
else if(strstr(line,"number of multiples"))
    {}
else if(strstr(line,"deadtime correction factor"))
    {}
else if(strstr(line,"user defined comment"))
    {}
else {
    fprintf(stderr,"Could not match key string in write_key, line: %s.\n",line);
    }

}


/***************************************/
int putsbhdr_if(sh,filnam_in,plane,frame)
/***************************************/

SubHeader_if	*sh;
char		*filnam_in;
int		plane,
		frame;

{

IFheader	*ifh;

FILE	*fpr;

char	line[MAX_LINE],*hdrfil;

int	last_frame=0,pln=0;

hdrfil = header_file(filnam_in);

if((ifh = get_ifh(hdrfil)) == NULL) {
    fprintf(stderr,"Main header must be written before subheader.\n");
    return(-1);
    }
if(frame > ifh->mh->dim4) {
    fprintf(stderr,"Frame number inconsistent with number of frames in main header in putsbhdr_if, %s\n",hdrfil);
    return(-1);
    }
if(plane > ifh->mh->dim3) {
    fprintf(stderr,"Plane number inconsistent with number of planes in main header in putsbhdr_if, %s\n",hdrfil);
    return(-1);
    }

if(ifh->sh[frame-1][plane-1] == NULL) 
    ifh->sh[frame-1][plane-1] = (SubHeader_if *)malloc(sizeof(SubHeader_if));
ifh->sh[frame-1][plane-1]->dim1 = sh->dim1;
ifh->sh[frame-1][plane-1]->dim2 = sh->dim2;
ifh->sh[frame-1][plane-1]->voxel_size_1 = sh->voxel_size_1;
ifh->sh[frame-1][plane-1]->voxel_size_2 = sh->voxel_size_2;
ifh->sh[frame-1][plane-1]->storage_sf = sh->storage_sf;
ifh->sh[frame-1][plane-1]->deadtime_corr = sh->deadtime_corr;
ifh->sh[frame-1][plane-1]->trues = sh->trues;
ifh->sh[frame-1][plane-1]->randoms = sh->randoms;
ifh->sh[frame-1][plane-1]->multiples = sh->multiples;
if(sh->comment != NULL) {
    ifh->sh[frame-1][plane-1]->comment = (char *)malloc(1+strlen(sh->comment));
    strcpy(ifh->sh[frame-1][plane-1]->comment,sh->comment);
    }

if(ifh->fh[frame-1] == NULL) 
    ifh->fh[frame-1] = (FrameHeader_if *)malloc(sizeof(FrameHeader_if));
ifh->fh[frame-1]->starting_time = sh->starting_time;
ifh->fh[frame-1]->duration = sh->duration;

if((fpr = fopen(hdrfil,"r+b")) == NULL)
    return(-1);
while(fgets(line,200,fpr) != NULL) {
    if(strstr(line,"frame number"))
	last_frame = atoi(getstr(line));
    else if(strstr(line,"plane number"))
	pln = atoi(getstr(line));
    if(last_frame == frame && pln == plane) {
	fprintf(fpr,"storage scale factor := %g\n",ifh->sh[frame-1][plane-1]->storage_sf);
	fprintf(fpr,"number of trues := %d\n",ifh->sh[frame-1][plane-1]->trues);
	fprintf(fpr,"number of randoms := %d\n",ifh->sh[frame-1][plane-1]->randoms);
	fprintf(fpr,"number of multiples := %d\n",ifh->sh[frame-1][plane-1]->multiples);
	fprintf(fpr,"deadtime correction factor := %f\n",ifh->sh[frame-1][plane-1]->deadtime_corr);
	if(ifh->sh[frame-1][plane-1]->comment != NULL)
	    fprintf(fpr,"user defined comment := %s\n",ifh->sh[frame-1][plane-1]->comment);
	else
	    fprintf(fpr,"user defined comment := \n");
	fflush(fpr);
	fclose(fpr);
	free(hdrfil);
	return(NULL);
	}
    }

if(frame > last_frame) {
    fprintf(fpr,"frame number := %d\n",frame);
    fprintf(fpr,"frame duration := %d\n",ifh->fh[frame-1]->duration);
    fprintf(fpr,"frame starting time := %d\n",ifh->fh[frame-1]->starting_time);
    }
else if(frame < last_frame) {
    fprintf(stderr,"Frames written out of order, putsbhdr_if aborted.\n");
    return(-1);
    }

fprintf(fpr,"plane number := %d\n",plane);
fprintf(fpr,"storage scale factor := %g\n",ifh->sh[frame-1][plane-1]->storage_sf);
fprintf(fpr,"number of trues := %d\n",ifh->sh[frame-1][plane-1]->trues);
fprintf(fpr,"number of randoms := %d\n",ifh->sh[frame-1][plane-1]->randoms);
fprintf(fpr,"number of multiples := %d\n",ifh->sh[frame-1][plane-1]->multiples);
fprintf(fpr,"deadtime correction factor := %f\n",ifh->sh[frame-1][plane-1]->deadtime_corr);
if(ifh->sh[frame-1][plane-1]->comment != NULL)
    fprintf(fpr,"user defined comment := %s\n",ifh->sh[frame-1][plane-1]->comment);
else
    fprintf(fpr,"user defined comment := \n");

fflush(fpr);
fclose(fpr);
free(hdrfil);
return(NULL);

}

/***********************/
char *header_file(filnam)
/***********************/

char	*filnam;

{

char	*ptr,*hdrfil=NULL;
int	len;

len = strlen(filnam) + 1;
hdrfil = (char *)malloc((size_t)len);
strcpy(hdrfil,filnam);
ptr = strrchr(hdrfil,'.');
if(ptr != NULL)
    *ptr = NULL;
strcat(hdrfil,".ifh");
return(hdrfil);

}

/*******************************/
MainHeader_if *getmhdr_if(filnam)
/*******************************/

char	*filnam;

{

int	i;
char	*hdrfil;
MainHeader_if *mh;
IFheader *ifh;

hdrfil = header_file(filnam);
if((ifh=get_ifh(hdrfil)) == NULL) {
    if((ifh = gethdr_if(hdrfil)) == NULL) {
	fprintf(stderr,"Could not read header from %s in getmhdr_if.\n",hdrfil);
	return(NULL);
	}
    put_ifh(hdrfil,ifh);
    }

mh = (MainHeader_if *)malloc(sizeof(MainHeader_if));
if(ifh->mh->data_file != NULL) {
    mh->data_file = (char *)malloc(1+strlen(ifh->mh->data_file));
    strcpy(mh->data_file,ifh->mh->data_file);
    }
else
    mh->data_file = NULL;
if(ifh->mh->patient_id != NULL) {
    mh->patient_id = (char *)malloc(1+strlen(ifh->mh->patient_id));
    strcpy(mh->patient_id,ifh->mh->patient_id);
    }
else
    mh->patient_id = NULL;
if(ifh->mh->study_date != NULL) {
    mh->study_date = (char *)malloc(1+strlen(ifh->mh->study_date));
    strcpy(mh->study_date,ifh->mh->study_date);
    }
else
    mh->study_date = NULL;
if(ifh->mh->sw_revision != NULL) {
    mh->sw_revision = (char *)malloc(strlen(ifh->mh->sw_revision)+1);
    strcpy(mh->sw_revision,ifh->mh->sw_revision);
    }
else
    mh->sw_revision = NULL;

mh->file_type = ifh->mh->file_type;
mh->number_format = ifh->mh->number_format;
mh->ndim = ifh->mh->ndim;
mh->dim1 = ifh->mh->dim1;
mh->dim2 = ifh->mh->dim2;
mh->dim3 = ifh->mh->dim3;
mh->dim4 = ifh->mh->dim4;
mh->orig_system = ifh->mh->orig_system;
mh->voxel_size_1 = ifh->mh->voxel_size_1;
mh->voxel_size_2 = ifh->mh->voxel_size_2;
mh->voxel_size_3 = ifh->mh->voxel_size_3;
mh->nbed = ifh->mh->nbed;
mh->bed_elevation = ifh->mh->bed_elevation;
mh->init_bed_pos = ifh->mh->init_bed_pos;
for(i=0;i<16;i++)
    mh->bed_off[i] = ifh->mh->bed_off[i];

free(hdrfil);
return(mh);

}

/****************/
void free_ifh(ifh)
/****************/

IFheader	*ifh;

{

int	i,j;

for(i=0;i<ifh->mh->dim4;i++) {
    free(ifh->fh[i]);
    for(j=0;j<ifh->mh->dim3;j++)
	free(ifh->sh[i][j]);
    }
free_ifmh(ifh->mh);
free(ifh);

}

/****************/
void free_ifmh(mh)
/****************/

MainHeader_if	*mh;

{

free(mh->data_file);
free(mh->patient_id);
free(mh->study_date);
free(mh->sw_revision);
free(mh);

}


/*********************************/
float *rdimg_if(filnam,plane,frame)
/*********************************/

char	*filnam;
int	plane,frame;

{

MainHeader_if 	*mh;
SubHeader_if	*sh;

int	i,bytes_per_pix,count,pln1,stat;

long	dskptr;

char	*bytimg,*hdrfil,*pos,data_file[MAXNAME];
short	*shtimg;
float	*fltimg,scale_factor;

FILE	*fp;

hdrfil = header_file(filnam);
if((mh = getmhdr_if(filnam)) == NULL) {
    fprintf(stderr,"Error reading mainheader from %s in rdimg.\n",filnam);
    return(NULL);
    }
if(plane <= 0)
    pln1 = 1;
else
    pln1 = plane;
if((sh = getsbhdr_if(filnam,pln1,frame)) == NULL) {
    fprintf(stderr,"Error reading subheader from %s in rdimg.\n",filnam);
    return(NULL);
    }
if(sh->storage_sf > 0)
    scale_factor = sh->storage_sf;
else {
    if(mh->scale_factor > 0)
        scale_factor = mh->scale_factor;
    else
	scale_factor = 1;
    }

strcpy(data_file,filnam);
if((pos=strrchr(data_file,'/')) != NULL) {
    *(pos+1) = NULL;
    strcat(data_file,mh->data_file);
    }
if((fp = getfp(data_file,"r")) == NULL) {
    fprintf(stderr,"Error opening %s in rdimg.\n",mh->data_file);
    return(NULL);
    }

if(plane > 0) { /* Read one plane at a time. */
    dskptr = ((frame-1)*mh->dim3 + (plane-1))*sh->dim1*sh->dim2;
    count = sh->dim1*sh->dim2;
    }
else { /* Read entire volume. */
    dskptr = (frame-1)*mh->dim3*sh->dim1*sh->dim2;
    count = sh->dim1*sh->dim2*mh->dim3;
    }
if(mh->number_format == BYTE_IF)
    bytes_per_pix = 1;
else if(mh->number_format == SHORT_IF)
    bytes_per_pix = 2;
else if(mh->number_format == FLOAT_IF)
    bytes_per_pix = 4;

dskptr *= bytes_per_pix;
if((stat=fseek(fp,(long)dskptr,SEEK_SET)) != NULL)
   return(NULL);

fltimg = (float *)malloc(count*sizeof(float));
if(mh->number_format == BYTE_IF) {
    bytimg = (char *)malloc(count*sizeof(char));
    if((stat=fread(bytimg,sizeof(char),count,fp)) != count)
        return(NULL);
    for(i=0;i<count;i++)
	fltimg[i] = scale_factor*bytimg[i];
    free(bytimg);
    }
else if(mh->number_format == SHORT_IF) {
    shtimg = (short *)malloc(count*sizeof(short));
    if((stat=fread(shtimg,sizeof(short),count,fp)) != count)
        return(NULL);
    for(i=0;i<count;i++)
	fltimg[i] = scale_factor*shtimg[i];
    free(shtimg);
    }
else if(mh->number_format == FLOAT_IF) {
    if((stat=fread(fltimg,sizeof(float),count,fp)) != count)
        return(NULL);
    for(i=0;i<count;i++)
	fltimg[i] *= scale_factor;
    }

free_ifmh(mh);
free(sh);
free(hdrfil);
return(fltimg);

}

/*********************************************/
int wrimg_if(filnam_in,image,mh,sh,plane,frame)
/*********************************************/

char		*filnam_in;
float		*image;
MainHeader_if	*mh;
SubHeader_if	*sh;
int		plane,frame;

{

FILE	*fp;

int	i,count,dskptr,stat,maxnum;

char	*hdrfil;

float	scl=1.,min,max;

short	*shtimg;

char	*bytimg;

if(plane > 0) { /* Write one plane at a time. */
    dskptr = ((frame-1)*mh->dim3 + (plane-1))*sh->dim1*sh->dim2;
    count = sh->dim1*sh->dim2;
    }
else { /* Write entire volume. */
    dskptr = (frame-1)*mh->dim3*sh->dim1*sh->dim2;
    count = sh->dim1*sh->dim2*mh->dim3;
    }

if(mh->number_format == SHORT_IF || mh->number_format == BYTE_IF) {
    if(mh->number_format == BYTE_IF)
        maxnum = 127;
    else
        maxnum = 32767;
    max = -1.e20;
    min = 1.e20;
    for(i=0;i<count;i++) {
        if(image[i] > max)
            max = image[i];
        if(image[i] < min)
            min = image[i];
        }
    if(max > -min) {
        scl =  maxnum/max;
        max = maxnum;
        min = min*scl;
        }
    else {
        scl = -maxnum/min;
        max = max*scl;
        min = -maxnum;
        }
    }
else
    scl = 1.;

sh->storage_sf = 1./scl;
hdrfil = header_file(filnam_in);
mh->data_file = filnam_in;
if((fp = getfp(mh->data_file,"r+")) == NULL) {
    fprintf(stderr,"Error opening %s in wrimg.\n",mh->data_file);
    free(hdrfil);
    return(-1);
    }

if(plane > 0)
    mh->scale_factor = 0.; /* Invalid value if scaled by plane. */
else
    mh->scale_factor = sh->storage_sf;

if(plane <= 1 && frame == 1) {
    mh->dim1 = sh->dim1;
    mh->dim2 = sh->dim2;
    mh->voxel_size_1 = sh->voxel_size_1;
    mh->voxel_size_2 = sh->voxel_size_2;
    if((putmhdr_if(mh,hdrfil)) != NULL) {
        fprintf(stderr,"Error writing main header to %s in wrimg.\n",mh->data_file);
        free(hdrfil);
        return(-1);
        }
    }

if(plane > 0) {
    if((putsbhdr_if(sh,hdrfil,plane,frame)) != NULL) {
        fprintf(stderr,"Error writing subheader to %s in wrimg.\n",mh->data_file);
        free(hdrfil);
        return(-1);
        }
    }

if(mh->number_format == BYTE_IF) {
    bytimg = (char *)malloc(count*sizeof(char));
    for(i=0;i<count;i++)
        bytimg[i] = scl*image[i];
    if(fseek(fp,(long)dskptr,SEEK_SET) != NULL) {
        free(hdrfil);
        return(NULL);
        }
    if((stat=fwrite(bytimg,sizeof(char),count,fp)) != count) {
        printf("Error occurred during write in wrimg_if, status = %d\n",stat);
        free(hdrfil);
        return(-1);
        }
    free(bytimg);
    }
else if(mh->number_format == SHORT_IF) {
    shtimg = (short *)malloc(count*sizeof(short));
    for(i=0;i<count;i++)
        shtimg[i] = scl*image[i];
    dskptr *= 2;
    if(fseek(fp,(long)dskptr,SEEK_SET) != NULL) {
        free(hdrfil);
        return(NULL);
        }
    if((stat=fwrite(shtimg,sizeof(short),count,fp)) != count) {
        printf("Error occurred during write in wrimg_if, status = %d\n",stat);
        free(hdrfil);
        return(-1);
        }
    free(shtimg);
    }
else if(mh->number_format == FLOAT_IF) {
    dskptr *= 4;
    if(fseek(fp,(long)dskptr,SEEK_SET) != NULL) {
        printf("Error occurred during write in wrimg_if, status = %d\n",stat);
        free(hdrfil);
        return(NULL);
        }
    if((stat=fwrite(image,sizeof(float),count,fp)) != count) {
        printf("Error occurred during write in wrimg_if, status = %d\n",stat);
        free(hdrfil);
        return(-1);
        }
    }
else {
    fprintf(stderr,"Unsupported data type in wrimg_if.\n");
    free(hdrfil);
    return(-1);
    }

free(hdrfil);
return(NULL);

}

/*************************/
FILE *write_fp(filnam,mode)
/*************************/
/* Get file pointer for file to be written. */

char	*filnam;
char	*mode;

{

int	fn;

char	cmd[MAXNAME];

FILE	*fp;

if(strstr(filnam,".scn") && strstr(filnam,".img") && strstr(filnam,".t88")) {
    fprintf(stderr,"Invalid CTI file name.\n");
    return(NULL);
    }

for(fn=0;fn<MAX_FILES;fn++) {
    if(!strcmp(filnam,file_list_if[fn])) {
	if(!strcmp("rb",mode_list_if[fn])) {
	    /* FILE opened in read-only mode. */
	    fclose(fp_list[fn]);
	    fp_list[fn] = NULL;
	    }
	else
	    return(fp_list[fn]);
	}
    }

/* FILE not open, assign it available slot. */
for(fn=0;fn<MAX_FILES;fn++) {
    if(fp_list[fn] == NULL) 
	break;
    }
if(fn == MAX_FILES) {
    fprintf(stderr,"Maximum number of open files exceeded in getfd\n");
    return(NULL);
    }

if((fp=fopen(filnam,"rb")) != NULL) { /* FILE exists. */
    if(!strcmp(mode,"wb")) {
	/* Delete the file if mode is write. */
        fclose(fp);
        sprintf(cmd,"rm %s\n",filnam);
        system(cmd);
        fprintf(stderr,"*** Deleted %s ***\n",filnam);
	}
    }
else {
    if(!strcmp(mode,"r+b")) {
	/* Can't open in mode r+ since it doesn't exist, change mode to w.*/
	mode = "wb";
	}
    }

if ((fp_list[fn] = fopen(filnam,mode)) == NULL)
    return(NULL);

strcpy(file_list_if[fn],filnam);
strcpy(mode_list_if[fn],mode);
return(fp_list[fn]);

}

/***********************/
IFheader *get_ifh(filnam)
/***********************/

char	*filnam;

{

int	fn;

for(fn=0;fn<MAX_FILES;fn++) {
    if(!strcmp(filnam,hdr_list[fn]))
	break;
    }

if(fn == MAX_FILES)
    return(NULL);
else
    return(ifh_list[fn]);

}

/**********************/
void put_ifh(hdrfil,ifh)
/**********************/

char	*hdrfil;
IFheader *ifh;

{


int	fn;

for(fn=0;fn<MAX_FILES;fn++) {
    if(!strcmp(hdrfil,hdr_list[fn]))
	break;
    }

if(fn < MAX_FILES) {
    if(ifh_list[fn] != ifh)
	free_ifh(ifh);
    ifh_list[fn] = ifh;
    }
else {
    for(fn=0;fn<MAX_FILES;fn++) {
        if(ifh_list[fn] == NULL) {
	    ifh_list[fn] = ifh;
	    strcpy(hdr_list[fn],hdrfil);
	    break;
	    }
	}
    }

}

/**********************/
FILE *getfp(filnam,mode)
/**********************/

char	*filnam,
	*mode;

{

int	fn;

FILE 	*fptest;

for(fn=0;fn<MAX_FILES;fn++) {
    if(!strcmp(filnam,file_list_if[fn])) {
	if(!strcmp(mode,mode_list_if[fn]))
	    return(fp_list[fn]);
	if(!strcmp(mode,"rb") && !strcmp(mode_list_if[fn],"r+b"))
	    return(fp_list[fn]);
	else {
	    /* FILE opened with wrong read/write mode. */
	    fclose(fp_list[fn]);
	    if((fp_list[fn] = fopen(file_list_if[fn],mode)) == NULL)
		return(NULL);
	    strcpy(mode_list_if[fn],mode);
	    return(fp_list[fn]);
	    }
	}
    }

/* FILE not open, assign it available slot. */
for(fn=0;fn<MAX_FILES;fn++) {
    if(fp_list[fn] == NULL) 
	break;
    }
if(fn == MAX_FILES) {
    fprintf(stderr,"Maximum number of open files exceeded in getfd\n");
    return(NULL);
    }

if(!strncmp(mode,"r+",2)) {
    if((fptest=fopen(filnam,"rb")) != NULL) /* FILE exists. */
        fclose(fptest);
    else
        mode = "wb";
    }

if ((fp_list[fn] = fopen(filnam,mode)) != NULL) {
    strcpy(file_list_if[fn],filnam);
    strcpy(mode_list_if[fn],mode);
    return(fp_list[fn]);
    }
else 
    return(NULL);

}

/*******************/
void close_if(filnam)
/*******************/

char *filnam;

{

int	fn;

for(fn=0;fn<MAX_FILES;fn++) {
    if(!strcmp(filnam,file_list_if[fn])) {
	fclose(fp_list[fn]);
	fp_list[fn] = NULL;
	if(ifh_list[fn] != NULL) {
	    free(ifh_list[fn]);
	    ifh_list[fn] = NULL;
	    }
	strcpy(file_list_if[fn]," ");
	strcpy(hdr_list[fn]," ");
	}
    }
}

/*************************/
SubHeader *ifsh_to_sh(ifsh)
/*************************/

SubHeader_if *ifsh;

{

SubHeader *sh;

sh = (SubHeader *)malloc(sizeof(SubHeader));

sh->file_format = INTERFILE;
sh->number_format = ifsh->number_format;
sh->ndim = ifsh->ndim;
sh->dim1 = ifsh->dim1;
sh->dim2 = ifsh->dim2;
sh->dim3 = ifsh->dim3;
sh->sample_size_1 = ifsh->voxel_size_1;
sh->sample_size_2 = ifsh->voxel_size_2;
sh->sample_size_3 = ifsh->voxel_size_3;
sh->scale_factor = ifsh->storage_sf;
sh->calibration_factor = 1.;
sh->start_time = ifsh->starting_time;
sh->duration = ifsh->duration;
sh->deadtime_corr = ifsh->deadtime_corr;
if(ifsh->comment != NULL) {
    sh->comment = (char *)malloc(1+strlen(ifsh->comment));
    strcpy(sh->comment,ifsh->comment);
    }
else
    sh->comment = NULL;
sh->whole_header = (void *)ifsh;

return(sh);

}

/**************************/
MainHeader *ifmh_to_mh(ifmh)
/**************************/

MainHeader_if	*ifmh;

{

MainHeader *mh;
int     i;

mh = (MainHeader *)malloc(sizeof(MainHeader));

if(ifmh->data_file != NULL) {
	mh->data_file = (char *)malloc(1+strlen(ifmh->data_file));
	strcpy(mh->data_file,ifmh->data_file);
	}
mh->file_format = INTERFILE;
mh->number_format = ifmh->number_format;
mh->scanner_type = ifmh->orig_system;
mh->filtyp = ifmh->file_type;
mh->start_time = -1;

if(ifmh->study_date != NULL)
    strcpy(mh->date_time,ifmh->study_date);

if(ifmh->sw_revision != NULL) {
    mh->sw_revision = (char *)malloc(strlen(ifmh->sw_revision)+1);
    strcpy(mh->sw_revision,ifmh->sw_revision);
    }
else
    mh->sw_revision = NULL;

if(ifmh->patient_id != NULL)
    strcpy(mh->patnum,ifmh->patient_id);

mh->nplane = ifmh->dim3;
mh->ngate = 1;
if(ifmh->nbed == 1) {
    mh->nframe = ifmh->dim4;
    mh->nbed = 1;
    }
else {
    mh->nframe = 1;
    mh->nbed = ifmh->dim4;
    }
mh->bed_elevation = ifmh->bed_elevation;
mh->init_bed_pos = ifmh->init_bed_pos;
for(i=0;i<15;i++)
    mh->bed_off[i] = ifmh->bed_off[i];
mh->slcthk = ifmh->voxel_size_3;
mh->calibration_factor = ifmh->scale_factor;
mh->whole_header = (void *)ifmh;

return(mh);

}


/**************************/
SubHeader_if *sh_to_ifsh(sh)
/**************************/

SubHeader *sh;

{

SubHeader_if *ifsh;

char	*stat;

ifsh = (SubHeader_if *)malloc(sizeof(SubHeader_if));
if(sh->whole_header != NULL && sh->file_format == INTERFILE)
    stat = memcpy((void *)ifsh,(void *)sh->whole_header,sizeof(SubHeader_if));

ifsh->number_format = sh->number_format;
ifsh->ndim = sh->ndim;
ifsh->dim1 = sh->dim1;
ifsh->dim2 = sh->dim2;
ifsh->dim3 = sh->dim3;
ifsh->voxel_size_1 = sh->sample_size_1;
ifsh->voxel_size_2 = sh->sample_size_2;
ifsh->voxel_size_3 = sh->sample_size_3;
ifsh->storage_sf = sh->scale_factor*sh->calibration_factor;
ifsh->trues = sh->total;
ifsh->randoms = sh->delayeds;
ifsh->multiples = sh->multiples;
ifsh->starting_time = sh->start_time;
ifsh->duration = sh->duration;
ifsh->deadtime_corr = sh->deadtime_corr;
if(sh->comment != NULL) {
    ifsh->comment = (char *)malloc(1+strlen(sh->comment));
    strcpy(ifsh->comment,sh->comment);
    }
else
    ifsh->comment = NULL;

return(ifsh);

}

/***************************/
MainHeader_if *mh_to_ifmh(mh)
/***************************/

MainHeader	*mh;

{

MainHeader_if *ifmh;
int     i;
char	*stat;

ifmh = (MainHeader_if *)malloc(sizeof(MainHeader_if));
if(mh->whole_header != NULL && mh->file_format == INTERFILE)
    stat = memcpy((void *)ifmh,(void *)mh->whole_header,sizeof(MainHeader_if));

if(mh->data_file != NULL) {
    ifmh->data_file = (char *)malloc(1+strlen(mh->data_file));
    strcpy(ifmh->data_file,mh->data_file);
    }
ifmh->number_format = mh->number_format;
ifmh->orig_system = mh->scanner_type;
ifmh->file_type = mh->filtyp;
if(mh->date_time != NULL) {
    ifmh->study_date = (char *)malloc(1+strlen(mh->date_time));
    strcpy(ifmh->study_date,mh->date_time);
    }
if(mh->patnum != NULL) {
    ifmh->patient_id = (char *)malloc(1+strlen(mh->patnum));
    strcpy(ifmh->patient_id,mh->patnum);
    }
if(mh->sw_revision != NULL) {
    ifmh->sw_revision = (char *)malloc(strlen(mh->sw_revision)+1);
    strcpy(ifmh->sw_revision,mh->sw_revision);
    }
else
    ifmh->sw_revision = NULL;
ifmh->dim3 = mh->nplane;
if(mh->nframe > 1)
    ifmh->dim4 = mh->nframe;
else if(mh->nbed > 0)
    ifmh->dim4 = mh->nbed;
else
    ifmh->dim4 = 1;
if(ifmh->dim3 > 1 && ifmh->dim4 > 1)
    ifmh->ndim = 4;
else if(ifmh->dim3 > 1 || ifmh->dim4 > 1)
    ifmh->ndim = 3;
else
    ifmh->ndim = 2;
ifmh->nbed = mh->nbed;
ifmh->bed_elevation = mh->bed_elevation;
ifmh->init_bed_pos = mh->init_bed_pos;
for(i=0;i<15;i++)
    ifmh->bed_off[i] = mh->bed_off[i];
ifmh->voxel_size_3 = mh->slcthk;
ifmh->scale_factor = mh->calibration_factor;

return(ifmh);

}


/***************************/
IFheader *make_ifh(dim3,dim4)
/***************************/

/* Allocate memory for subheader. */

int	dim3,
	dim4;

{

IFheader *ifh;

int	plane,frame;

ifh = (IFheader *)malloc(sizeof(IFheader));
ifh->mh = (MainHeader_if *)malloc(sizeof(MainHeader_if));
ifh->mh->study_date = NULL;
ifh->mh->sw_revision = NULL;
ifh->mh->patient_id = NULL;
ifh->mh->data_file = NULL;
ifh->fh = (FrameHeader_if **)malloc(dim4*sizeof(FrameHeader_if *));
ifh->sh = (SubHeader_if ***)malloc(dim4*sizeof(SubHeader_if **));
for(frame=0;frame<dim4;frame++) {
    ifh->fh[frame] = (FrameHeader_if *)malloc(sizeof(FrameHeader_if));
    ifh->sh[frame] = (SubHeader_if **)malloc(dim3*sizeof(SubHeader_if *));
    for(plane=0;plane<dim3;plane++) {
        ifh->sh[frame][plane] = (SubHeader_if *)malloc(sizeof(SubHeader_if));
	ifh->sh[frame][plane]->comment = NULL;
	}
    }

return(ifh);

}
@
