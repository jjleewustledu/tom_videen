head	1.22;
access;
symbols;
locks; strict;
comment	@ * @;


1.22
date	95.07.13.22.03.36;	author ty7777;	state Exp;
branches;
next	1.21;

1.21
date	95.07.12.19.40.16;	author ty7777;	state Exp;
branches;
next	1.20;

1.20
date	95.07.11.21.58.36;	author ty7777;	state Exp;
branches;
next	1.19;

1.19
date	95.07.11.16.48.43;	author ty7777;	state Exp;
branches;
next	1.18;

1.18
date	95.01.03.22.17.50;	author ty7777;	state Exp;
branches;
next	1.17;

1.17
date	93.11.10.16.08.42;	author ty7777;	state Exp;
branches;
next	1.16;

1.16
date	93.11.04.21.59.13;	author ty7777;	state Exp;
branches;
next	1.15;

1.15
date	93.11.04.21.08.54;	author ty7777;	state Exp;
branches;
next	1.14;

1.14
date	93.11.04.16.58.57;	author ty7777;	state Exp;
branches;
next	1.13;

1.13
date	93.11.03.22.22.47;	author ty7777;	state Exp;
branches;
next	1.12;

1.12
date	93.11.02.18.28.14;	author ty7777;	state Exp;
branches;
next	1.11;

1.11
date	93.10.29.14.48.01;	author ty7777;	state Exp;
branches;
next	1.10;

1.10
date	93.10.15.20.52.23;	author ty7777;	state Exp;
branches;
next	1.9;

1.9
date	93.10.12.21.20.28;	author ty7777;	state Exp;
branches;
next	1.8;

1.8
date	93.09.08.16.38.02;	author ty7777;	state Exp;
branches;
next	1.7;

1.7
date	93.08.13.17.31.47;	author ty7777;	state Exp;
branches;
next	1.6;

1.6
date	93.08.12.19.29.20;	author ty7777;	state Exp;
branches;
next	1.5;

1.5
date	93.05.12.21.02.44;	author ty7777;	state Exp;
branches;
next	1.4;

1.4
date	93.05.10.20.34.31;	author ty7777;	state Exp;
branches;
next	1.3;

1.3
date	93.05.06.19.24.26;	author ty7777;	state Exp;
branches;
next	1.2;

1.2
date	93.05.06.18.10.54;	author ty7777;	state Exp;
branches;
next	1.1;

1.1
date	93.05.05.16.38.52;	author ty7777;	state Exp;
branches;
next	;


desc
@imageweld initial checking in.
@


1.22
log
@ After (t + b) / 2 is implemented.
@
text
@/*$Id: imageweld.c,v 1.21 1995/07/12 19:40:16 ty7777 Exp ty7777 $*/
/*$Log: imageweld.c,v $
 * Revision 1.21  1995/07/12  19:40:16  ty7777
 * Added processing for simple_wled.
 *
 * Revision 1.20  1995/07/11  21:58:36  ty7777
 * After introducing noisy_slices.
 *
 * Revision 1.19  1995/07/11  16:48:43  ty7777
 * Changed id to header.
 *
 * Revision 1.18  1995/01/03  22:17:50  ty7777
 * Rename weldlist_mode imglist_mode.
 *
 * Revision 1.17  1993/11/10  16:08:42  ty7777
 * Use sprintf to get the date.
 *
 * Revision 1.16  1993/11/04  21:59:13  ty7777
 *
 * Revision 1.15  1993/11/04  21:08:54  ty7777
 * Processing for rec file.
 *
 * Revision 1.14  1993/11/04  16:58:57  ty7777
 * Added rec file.
 *
 * Revision 1.13  1993/11/03  22:22:47  ty7777
 * Processing for literal matrix file.
 *
 * Revision 1.12  1993/11/02  18:28:14  ty7777
 * Changed id to header.
 *
 * Revision 1.11  1993/10/29  14:48:01  ty7777
 * Added processing for literal list.
 *
 * Revision 1.10  1993/10/15  20:52:23  ty7777
 * Before Interpolation.
 *
 * Revision 1.9  1993/10/12  21:20:28  ty7777
 * Change the program so that it can generate two welded images for one subject line.
 *
 * Revision 1.8  1993/09/08  16:38:02  ty7777
 * Use parameter file and image list file as input.
 *
 * Revision 1.7  1993/08/13  17:31:47  ty7777
 * Get the number of overlaped slices and image mode automically.
 *
 * Revision 1.6  1993/08/12  19:29:20  ty7777
 * Added rcs.
 *
 * Revision 1.5  1993/05/12  21:02:44  ty7777
 * Making scaling factor correct.
 *
 * Revision 1.4  1993/05/10  20:34:31  ty7777
 * imageweld.c correctly working version.
 *
 * Revision 1.3  1993/05/06  19:24:26  ty7777
 * After making 2D work.
 *
 * Revision 1.2  1993/05/06  18:10:54  ty7777
 * Before adding 2D processing.
 *
 * Revision 1.1  1993/05/05  16:38:52  ty7777
 * Initial revision
 **/

/*_________________________________________________________________
  Description:	This program reads two ECAT images which represent the
		top and bottom scans of the brain with some overlapped
		slices. It then construct an ECAT image for the whole
		brain. The overlapped slices is constructed in such a
		way that the noise is minimum.

  History:	Created by Tom Yang on 05/05/93. 
_________________________________________________________________*/

#include <petutil/imglist.h>
#include "imageweld.h"
#define	MATRIX_FILE_EXT		".mat"

static char rcsid [] = "$Header: /data/petsun4/src/simple_weld/RCS/imageweld.c,v 1.21 1995/07/12 19:40:16 ty7777 Exp ty7777 $";

main (argc, argv)
	int	argc;
	char	**argv;
{
	BOOLEAN			simple_weld;
	BOOLEAN			demigrate;
	FILE			*recfp;
	IMAGE_LIST_DATA		*image_list;
	IMAGE_LIST_DATA		pseudo_image_list;
	LITERALIST_DATA		*literal_image_list;
	PARAMETER_DATA		parameter_data;
	char			complete_image_files [6][MAXPATH];
	char			complete_sxrfile [MAXPATH];
	char			date [MAXLINE];
	char			*image_list_file;
	char			image_recfile [MAXPATH];
	char			line [MAXLINE];
	char			*parameter_list_file;
	char			rec_file [MAXLINE];
	char			short_image_files [6][MAXLINE];
	char			short_matrix_file [MAXLINE];
	char			short_sxrfile [MAXLINE];
	char			short_weldedimg_files [6][MAXLINE];
	char			string [MAXLINE];
	char			subject_id [MAXNAME];
	char			*uid;
	float			bottomT4 [4][4];
	float			bottom_scaling_factor;
	float			normalization_factor;
	float			topT4 [4][4];
	float			top_scaling_factor;
	int			filter_mode;
	int			i;
	int			image_mode;
	int			j;
	int			k;
	int			noisy_slices;
	int			num_image_files;
	int			num_image_list;
	struct INFO_TYPE	finfo;

	/*
	 * Get command line arguments.
	 */
	parameter_list_file	= argv [1];
	image_list_file		= argv [2];
	noisy_slices		= atoi (argv [3]);
	simple_weld		= atoi (argv [4]);
	sprintf (date, "%s %s %s %s %s %s", argv [5], argv [6], argv [7], argv [8], argv [9], argv [10]);
	uid			= argv [11];

	/* 
	 * Read the parameters in the image parameters file to the structure
	 * INFO_TYPE finfo.
	 */
	if (readparm (parameter_list_file, &parameter_data) == FAIL)
	{
		fprintf (stderr, "Error: from readparm ().\n");
		free (image_list);
		exit (FAIL);
	}

	/* 
	 * Allocate memory for an array of image list structures. 
	 */
	if (parameter_data.imglist_mode != LITERAL_IMAGE_MODE)
	{
		image_list	= (IMAGE_LIST_DATA *) pkg_malloc (sizeof (IMAGE_LIST_DATA) 
				* MAX_IMAGE_LIST_SIZE, "imageweld", "image_list");

		/* 
	 	 * Read list from image_list_file to IMAGE_LIST_DATA structure list
	 	 * image_list for manipulation.
	 	 */
		if (readimglist (image_list_file, image_list, &num_image_list) == FAIL)
		{
			fprintf (stderr, "Error from readimglist () for list %s.\n", 
			image_list_file);
			free (image_list);
			exit (FAIL);
		}
	}
	else
	{
		literal_image_list	= (LITERALIST_DATA *) pkg_malloc (sizeof (LITERALIST_DATA) 
					* MAX_IMAGE_LIST_SIZE, "imageweld", "literal_image_list");

		if (read_literalist (image_list_file, literal_image_list, &num_image_list) == FAIL)
		{
			fprintf (stderr, "Error from read_literalist () for list %s.\n", 
			image_list_file);
			free (image_list);
			exit (FAIL);
		}

		/* 
	 	 * Fill the finfo structure for searching in archive.
	 	 */
		get_finfo (parameter_data, &finfo);
	}

	/* 
	 * Compute the mean for each image pair.
	 */
	demigrate	= TRUE;
	image_mode	= parameter_data.imglist_mode;	
	filter_mode	= RECFILTER_MODE;
	for (i = 0; i < num_image_list; i++)
	{
		/*
		 * Build the short names for top and bottom scans.
		 */
		if (parameter_data.imglist_mode != LITERAL_IMAGE_MODE)
		{
			if (build_shortnames (parameter_data, image_list [i], 
			image_mode, filter_mode, &num_image_files, short_image_files, 
			short_sxrfile) == FAIL)
			{
				fprintf (stderr, 
				"Error in building short names from image list %s %s %f %s %f %s\n",
				image_list [i].subject_id, 
				image_list [i].scanset1_id, image_list [i].mean1, 
				image_list [i].scanset2_id, image_list [i].mean2, 
				image_list [i].sxrid);
			}
		}
		else
		{
			strcpy (short_image_files [0], literal_image_list [i].topscan);
			strcpy (short_image_files [1], literal_image_list [i].bottomscan);
			num_image_files	= 2;
		}

		/*
		 * Clean the array of complete image files.
		 */
		for (j = 0; j < num_image_files; j++)
			strcpy (complete_image_files [j], "");

		/*
		 * Get the complete top and bottom scans files.
		 */
		if (parameter_data.imglist_mode != LITERAL_IMAGE_MODE)
		{
			if (checkimg (parameter_data, image_list [i], image_mode, demigrate, 
			num_image_files, short_image_files, complete_image_files) == FAIL)
			{
				fprintf (stderr, 
				"Error in checking files from image list %s %s %f %s %f %s\n\n",
				image_list [i].subject_id, 
				image_list [i].scanset1_id, image_list [i].mean1, 
				image_list [i].scanset2_id, image_list [i].mean2, 
				image_list [i].sxrid);
				exit (FAIL);
			}
		}
		else
		{
			for (j = 0; j < num_image_files; j++)
			{
				if (searchpath (parameter_data.datapath, short_image_files [j], 
				finfo, complete_image_files [j]) == FAIL)
				{
					fprintf (stderr, 
				"Error in checking files from literal list %s %s %s\n\n",
					literal_image_list [i].topscan, 
					literal_image_list [i].bottomscan, 
					literal_image_list [i].weldedscan);
					exit (FAIL);
				}
			}
		}

		/*
		 * Build the short whole scan files.
		 */
		if (parameter_data.imglist_mode == STDIMAGE_MODE)
		{
			build_shortnames (parameter_data, image_list [i], WELDED_IMAGE_MODE, 
			filter_mode, &num_image_files, short_weldedimg_files, short_sxrfile);
		}
		else if (parameter_data.imglist_mode == PREWELDED_IMAGE_MODE)
		{
			build_shortnames (parameter_data, image_list [i], STDIMAGE_MODE, 
			filter_mode, &num_image_files, short_weldedimg_files, short_sxrfile);
		}
		else if (parameter_data.imglist_mode == LITERAL_IMAGE_MODE)
		{
			strcpy (short_weldedimg_files [0], literal_image_list [i].weldedscan);
			num_image_files	= 1;
		}
		else
		{
			fprintf (stderr, "Error: Unknown weld_lstmode: %d in the parameter file %s.\n",
				parameter_list_file);
			exit (FAIL);
		}

		/*______________________________________________________
		 * Welds the top and bottom scans together.
		 *______________________________________________________*/
		for (j = 0; j < num_image_files; j++)
		{
			/*
			 * Construct the rec file name and creates the rec file header.
			 */
			strcpy (rec_file, short_weldedimg_files [j]);
			strcat (rec_file, REC_EXT);

			recfp	= fopen (rec_file, "w");
			if (recfp == (FILE *) NULL)
			{
				fprintf (stderr, "Error in opening rec file %s\n", rec_file);
				exit (FAIL);
			}
			fprintf (recfp, "rec %s %s %s\n", short_weldedimg_files [j], date, uid);
			fprintf (recfp, "imageweld %s %s\n", parameter_list_file, image_list_file);
			fprintf (recfp, "   %s\n\n", rcsid);

			/*
			 * Copy the parameter file to the rec file.
			 */
			fprintf (recfp, "prm\n");
			copyrec (recfp, parameter_list_file);
			fprintf (recfp, "endprm\n\n");

			/*
			 * Copy the relevant line from the image list file 
			 * to the rec file.
			 */
			fprintf (recfp, "imglist\n");
			if (parameter_data.imglist_mode != LITERAL_IMAGE_MODE)
			{
				fprintf (recfp, "%s %s %f %s %f %s\n",
					image_list [i].subject_id, 
					image_list [i].scanset1_id, image_list [i].mean1, 
					image_list [i].scanset2_id, image_list [i].mean2, 
					image_list [i].sxrid);
			}
			else
			{
				fprintf (recfp, "%s %s %s %s\n",
					literal_image_list [i].topscan, 
					literal_image_list [i].bottomscan, 
					literal_image_list [i].weldedscan, 
					literal_image_list [i].matfile);
			}
			fprintf (recfp, "endimglist\n\n");

			/*
			 * Find the matrix file.
			 */
			if (parameter_data.imglist_mode != LITERAL_IMAGE_MODE)
			{
				strcpy (subject_id, parameter_data.species);
				strcat (subject_id, image_list [i].subject_id);
				strcpy (short_matrix_file, subject_id);
				strcat (short_matrix_file, MATRIX_FILE_EXT);

				if (BuildTransform (parameter_data, image_list [i], image_mode, 
				short_image_files [2 * j], short_image_files [2 * j + 1], 
				complete_image_files [2 * j], complete_image_files [2 * j + 1],
				simple_weld, noisy_slices, topT4, bottomT4, &top_scaling_factor, 
				&bottom_scaling_factor, &normalization_factor, short_matrix_file, 
				recfp) == FAIL)
				{
					fprintf (stderr, "Error: BuildTransform () failed.\n");
					exit (FAIL);
				}
			}
			else
			{
				strcpy (short_matrix_file, literal_image_list [i].matfile);

				if (BuildTransform (parameter_data, pseudo_image_list, image_mode, 
				short_image_files [2 * j], short_image_files [2 * j + 1], 
				complete_image_files [2 * j], complete_image_files [2 * j + 1],
				simple_weld, noisy_slices, topT4, bottomT4, &top_scaling_factor, 
				&bottom_scaling_factor, &normalization_factor, short_matrix_file, 
				recfp) == FAIL)
				{
					fprintf (stderr, "Error: BuildTransform () failed.\n");
					exit (FAIL);
				}
			}

			/*
			 * Copy the image rec files if there are any.
			 */
			strcpy (image_recfile, complete_image_files [2 * j]);
			strcat (image_recfile, REC_EXT);
			copyrec (recfp, image_recfile);

			strcpy (image_recfile, complete_image_files [2 * j + 1]);
			strcat (image_recfile, REC_EXT);
			copyrec (recfp, image_recfile);

			if (WeldImages (complete_image_files [2 * j], 
			complete_image_files [2 * j + 1], short_weldedimg_files [j],
			simple_weld, noisy_slices, topT4, bottomT4, top_scaling_factor, 
			bottom_scaling_factor, normalization_factor, recfp, date, rcsid) == FAIL) 
			{
				fprintf (stderr, "Error: WeldedImages () failed.\n");
				exit (FAIL);
			}

			fprintf (recfp, "endrec\n");

			fclose (recfp);
		}
	}

	if (parameter_data.imglist_mode != LITERAL_IMAGE_MODE)
		free (image_list);
	else
		free (literal_image_list);	
}
@


1.21
log
@Added processing for simple_wled.
@
text
@d1 1
a1 1
/*$Id: imageweld.c,v 1.20 1995/07/11 21:58:36 ty7777 Exp ty7777 $*/
d3 3
d80 1
a80 1
static char rcsid [] = "$Header: /data/petsun4/src/simple_weld/RCS/imageweld.c,v 1.20 1995/07/11 21:58:36 ty7777 Exp ty7777 $";
d86 1
d129 3
a131 2
	sprintf (date, "%s %s %s %s %s %s", argv [4], argv [5], argv [6], argv [7], argv [8], argv [9]);
	uid			= argv [10];
d344 1
a344 1
				noisy_slices, topT4, bottomT4, &top_scaling_factor, 
d359 3
a361 2
				noisy_slices, topT4, bottomT4, &top_scaling_factor, &bottom_scaling_factor,
				&normalization_factor, short_matrix_file, recfp) == FAIL)
d381 2
a382 2
			noisy_slices, topT4, bottomT4, top_scaling_factor, bottom_scaling_factor,
			normalization_factor, recfp, date, rcsid) == FAIL) 
@


1.20
log
@After introducing noisy_slices.
@
text
@d1 1
a1 1
/*$Id: imageweld.c,v 1.19 1995/07/11 16:48:43 ty7777 Exp ty7777 $*/
d3 3
d77 1
a77 1
static char rcsid [] = "$Header: /data/petsun4/src/simple_weld/RCS/imageweld.c,v 1.19 1995/07/11 16:48:43 ty7777 Exp ty7777 $";
d375 1
a375 1
			topT4, bottomT4, top_scaling_factor, bottom_scaling_factor,
@


1.19
log
@Changed id to header.
@
text
@d1 1
a1 1
/*$Id: imageweld.c,v 1.18 1995/01/03 22:17:50 ty7777 Exp ty7777 $*/
d3 3
d74 1
a74 1
static char rcsid [] = "$Header$";
d111 1
d121 3
a123 2
	sprintf (date, "%s %s %s %s %s %s", argv[3], argv[4], argv[5], argv[6], argv[7], argv[8]);
	uid			= argv [9];
d336 3
a338 2
				topT4, bottomT4, &top_scaling_factor, &bottom_scaling_factor,
				&normalization_factor, short_matrix_file, recfp) == FAIL)
d351 1
a351 1
				topT4, bottomT4, &top_scaling_factor, &bottom_scaling_factor,
@


1.18
log
@Rename weldlist_mode imglist_mode.
@
text
@d1 1
a1 1
/*$Id: imageweld.c,v 1.17 1993/11/10 16:08:42 ty7777 Exp ty7777 $*/
d3 3
d71 1
a71 1
static char rcsid [] = "$Id: imageweld.c,v 1.17 1993/11/10 16:08:42 ty7777 Exp ty7777 $";
@


1.17
log
@Use sprintf to get the date.
@
text
@d1 1
a1 1
/*$Id: imageweld.c,v 1.16 1993/11/04 21:59:13 ty7777 Exp ty7777 $*/
d3 3
d68 1
a68 1
static char rcsid [] = "$Id: imageweld.c,v 1.16 1993/11/04 21:59:13 ty7777 Exp ty7777 $";
d131 1
a131 1
	if (parameter_data.weld_lstmode != LITERAL_IMAGE_MODE)
d171 1
a171 1
	image_mode	= parameter_data.weld_lstmode;	
d178 1
a178 1
		if (parameter_data.weld_lstmode != LITERAL_IMAGE_MODE)
d208 1
a208 1
		if (parameter_data.weld_lstmode != LITERAL_IMAGE_MODE)
d242 1
a242 1
		if (parameter_data.weld_lstmode == STDIMAGE_MODE)
d247 1
a247 1
		else if (parameter_data.weld_lstmode == PREWELDED_IMAGE_MODE)
d252 1
a252 1
		else if (parameter_data.weld_lstmode == LITERAL_IMAGE_MODE)
d297 1
a297 1
			if (parameter_data.weld_lstmode != LITERAL_IMAGE_MODE)
d318 1
a318 1
			if (parameter_data.weld_lstmode != LITERAL_IMAGE_MODE)
d376 1
a376 1
	if (parameter_data.weld_lstmode != LITERAL_IMAGE_MODE)
@


1.16
log
@Processing for time and version stamp.
@
text
@d1 1
a1 1
/*$Id: imageweld.c,v 1.15 1993/11/04 21:08:54 ty7777 Exp ty7777 $*/
d3 2
d65 1
a65 1
static char rcsid [] = "$Id: imageweld.c,v 1.15 1993/11/04 21:08:54 ty7777 Exp ty7777 $";
d79 1
a79 1
	char			*date;
a82 1
	char			*now;
a90 1
	char			*time;
d111 2
a112 4
	now			= argv [3];
	date			= argv [4];
	time			= argv [5];
	uid			= argv [6];
d278 1
a278 1
			fprintf (recfp, "rec %s %s %s\n", short_weldedimg_files [j], now, uid);
d361 1
a361 1
			normalization_factor, recfp, now, rcsid) == FAIL) 
@


1.15
log
@Processing for rec file.
@
text
@d1 1
a1 1
/*$Id: imageweld.c,v 1.14 1993/11/04 16:58:57 ty7777 Exp ty7777 $*/
d3 3
d63 1
a63 1
static char rcsid [] = "$Id: imageweld.c,v 1.14 1993/11/04 16:58:57 ty7777 Exp ty7777 $";
d363 1
a363 1
			normalization_factor, recfp) == FAIL) 
@


1.14
log
@Added rec file.
@
text
@d1 1
a1 1
/*$Id: imageweld.c,v 1.13 1993/11/03 22:22:47 ty7777 Exp ty7777 $*/
d3 3
d60 1
a60 1
static char rcsid [] = "$Id$";
d76 2
d85 1
d266 46
d325 1
a325 1
				&normalization_factor, short_matrix_file) == FAIL)
d339 1
a339 1
				&normalization_factor, short_matrix_file) == FAIL)
d346 6
a351 2
			strcpy (rec_file, short_weldedimg_files [j]);
			strcat (rec_file, REC_EXT);
d353 3
a355 9
			recfp = fopen (rec_file, "w");
			if (recfp == (FILE *) NULL)
			{
				fprintf (stderr, "Error in opening rec file %s\n", rec_file);
				return FAIL;
			}
			fprintf (recfp, "rec %s %s %s\n", short_weldedimg_files [j], now, uid);
			fprintf (recfp, "imageweld %s %s\n", parameter_list_file, image_list_file);
			fprintf (recfp, "%s\n", rcsid);
a356 3
			fprintf (recfp, "prm\n");
			fprintf (recfp, "endprm\n");

d360 1
a360 1
			normalization_factor) == FAIL) 
@


1.13
log
@Processing for literal matrix file.
@
text
@d1 1
a1 1
/*$Id: imageweld.c,v 1.12 1993/11/02 18:28:14 ty7777 Exp ty7777 $*/
d3 3
d57 1
a57 1
static char rcsid [] = "$Header: /home/petsun4/ty7777/src/imageweld/RCS/imageweld.c,v 1.12 1993/11/02 18:28:14 ty7777 Exp ty7777 $";
d64 1
d71 1
d73 1
d75 1
d81 2
d102 4
d294 16
d318 4
@


1.12
log
@Changed id to header.
@
text
@d1 1
a1 1
/*$Id: imageweld.c,v 1.11 1993/10/29 14:48:01 ty7777 Exp ty7777 $*/
d3 3
d52 1
d54 1
a54 1
static char rcsid [] = "$Header$";
d70 1
d73 1
d128 1
a128 1
					* MAX_IMAGE_LIST_SIZE, "imageweld", "image_list");
d204 1
a204 1
				finfo, complete_image_files [j], demigrate) == FAIL)
d246 3
d251 5
d260 1
a260 1
				&normalization_factor, parameter_data.weld_lstmode) == FAIL)
d268 2
d274 1
a274 1
				&normalization_factor) == FAIL)
@


1.11
log
@Added processing for literal list.
@
text
@d1 1
a1 1
/*$Id: imageweld.c,v 1.10 1993/10/15 20:52:23 ty7777 Exp ty7777 $*/
d3 3
d50 1
a50 1
static char rcsid []= "$Id: imageweld.c,v 1.10 1993/10/15 20:52:23 ty7777 Exp ty7777 $";
@


1.10
log
@Before Interpolation.
@
text
@d1 1
a1 1
/*$Id: imageweld.c,v 1.9 1993/10/12 21:20:28 ty7777 Exp ty7777 $*/
d3 3
d47 1
a47 1
static char rcsid []= "$Id: imageweld.c,v 1.9 1993/10/12 21:20:28 ty7777 Exp ty7777 $";
d55 2
d77 1
d99 4
a102 2
	image_list	= (IMAGE_LIST_DATA *) pkg_malloc (sizeof (IMAGE_LIST_DATA) 
			* MAX_IMAGE_LIST_SIZE, "imageweld", "image_list");
d104 13
a116 5
	/* 
	 * Read list from image_list_file to IMAGE_LIST_DATA structure list
	 * image_list for manipulation.
	 */
	if (readimglist (image_list_file, image_list, &num_image_list) == FAIL)
d118 15
a132 3
		fprintf (stderr, "Error: from readimglist ().\n");
		free (image_list);
		exit (FAIL);
d146 1
a146 2
		if (build_shortnames (parameter_data, image_list [i], image_mode, filter_mode, 
		&num_image_files, short_image_files, short_sxrfile) == FAIL)
d148 5
a152 1
			fprintf (stderr, 
d158 1
d160 6
d176 1
a176 2
		if (checkimg (parameter_data, image_list [i], image_mode, demigrate, 
		num_image_files, short_image_files, complete_image_files) == FAIL)
d178 4
a181 1
			fprintf (stderr, 
d187 2
a188 1
			exit (FAIL);
d190 16
d220 5
d237 1
a237 5
			if (BuildTransform (parameter_data, image_list [i], image_mode, 
			short_image_files [2 * j], short_image_files [2 * j + 1], 
			complete_image_files [2 * j], complete_image_files [2 * j + 1],
			topT4, bottomT4, &top_scaling_factor, &bottom_scaling_factor,
			&normalization_factor) == FAIL)
d239 9
a247 2
				fprintf (stderr, "Error: BuildTransform () failed.\n");
				exit (FAIL);
d249 12
d273 4
a276 1
	free (image_list);
@


1.9
log
@Change the program so that it can generate two welded images for one subject line.
@
text
@d1 1
a1 1
/*$Id: imageweld.c,v 1.8 1993/09/08 16:38:02 ty7777 Exp ty7777 $*/
d3 3
d41 1
a42 1
#include <petutil/imglist.h>
d44 1
a44 1
static char rcsid []= "$Id: imageweld.c,v 1.8 1993/09/08 16:38:02 ty7777 Exp ty7777 $";
d59 6
d69 1
d151 1
a151 1
		 * Build the short whole scan file.
d156 1
a156 1
			filter_mode, &num_image_files, short_image_files, short_sxrfile);
d161 1
a161 1
			filter_mode, &num_image_files, short_image_files, short_sxrfile);
d175 10
d186 3
a188 2
			complete_image_files [2 * j + 1], 
			short_image_files [j]) == FAIL) 
@


1.8
log
@Use parameter file and image list file as input.
@
text
@d1 1
a1 1
/*$Id: imageweld.c,v 1.7 1993/08/13 17:31:47 ty7777 Exp ty7777 $*/
d3 3
d41 1
a41 1
static char rcsid []= "$Id: imageweld.c,v 1.7 1993/08/13 17:31:47 ty7777 Exp ty7777 $";
a49 1
	char			complete_bottomscan_filename [MAXPATH];
a51 1
	char			complete_topscan_filename [MAXPATH];
a55 1
	char			wholescan_filename [MAXPATH];
a139 3
		strcpy (complete_topscan_filename, complete_image_files [0]);
		strcpy (complete_bottomscan_filename, complete_image_files [1]);

d144 4
a147 2
			build_shortnames (parameter_data, image_list [i], WELDED_IMAGE_MODE, filter_mode, 
				&num_image_files, short_image_files, short_sxrfile);
d149 4
a152 2
			build_shortnames (parameter_data, image_list [i], STDIMAGE_MODE, filter_mode, 
				&num_image_files, short_image_files, short_sxrfile);
a159 2
		strcpy (wholescan_filename, short_image_files [0]);

d163 1
a163 2
		if (WeldImages (complete_topscan_filename, complete_bottomscan_filename, 
		wholescan_filename) == FAIL) 
d165 7
a171 2
			fprintf (stderr, "Error: WeldedImages () failed.\n");
			exit (FAIL);
@


1.7
log
@Get the number of overlaped slices and image mode automically.
@
text
@d1 1
a1 1
/*$Id: imageweld.c,v 1.6 1993/08/12 19:29:20 ty7777 Exp ty7777 $*/
d3 3
d35 2
a36 3
#include <petutil/petutil.h>
#include <petutil/matrix.h>
#include <petutil/standard_deviations.h>
d38 1
a38 1
static char rcsid []= "$Id: imageweld.c,v 1.6 1993/08/12 19:29:20 ty7777 Exp ty7777 $";
a39 4
PRIVATE int GetBedPosition ();
PRIVATE int GetOverlappedSlices ();
PRIVATE int GetSamplingMode ();

d44 18
a61 46
	Image_subheader	**bottom_subheader_list;
	Image_subheader	**subheader_list;
	Image_subheader	**top_subheader_list;
	Main_header	*bottom_main_header;
	Main_header	*main_header;
	Main_header	*top_main_header;
	char		bottom_scan [MAXLINE];
	char		top_scan [MAXLINE];
	char		*whole_scan;
	float		average;
	float		bottom_average_variance;
	float		*bottom_image3d;
	float		*bottom_image3d_nonoverlap;
	float		*bottom_image3d_overlap;
	float		bottom_overlap_sum;
	float		bottom_weight;
	float		*image3d;
	float		*nonoverlap_image3d;
	float		offset;
	float		*overlap_image3d;
	float		scaling_factor;
	float		top_average_variance;
	float		*top_image3d;
	float		*top_image3d_overlap;
	float		top_overlap_sum;
	float		top_weight;
	float		pixel_size;
	float		plane_separation;
	float		*sigma3d	= standard_deviations3d;
	float		*weight_table;
	int		bottom_scan_overlap_end;
	int		dimension;
	int		i;
	int		j;
	int		num_overlapped_slices;
	int		num_shifted_slices;
	int		sampling_mode;
	int		scanner;
	int		slice_dim;
	int		top_scan_overlap_start;
	short		bottom_num_slices;
	short		height;
	short		num_slices;
	short		top_num_slices;
	short		width;
	struct Matval	matval;
d63 5
a67 8
	/*______________________________________________________
	 * Get command line arguments. We copy argv [2] and argv [3]
	 * to character strings so we can switch them if it is
	 * necessary.
	 *______________________________________________________*/
	strcpy (top_scan, argv [1]);
	strcpy (bottom_scan, argv [2]);
	whole_scan	= argv [3];
d69 5
a73 14
	/*______________________________________________________
	 * Assign default values for matval.
	 *______________________________________________________*/
	matval.frame	= 1;
	matval.plane	= 1;
	matval.gate	= 1;
	matval.data	= 0;
	matval.bed	= 0;

	/*______________________________________________________
	 * Get image type and do error checking.
	 *______________________________________________________*/
	if (getimagedim (top_scan, matval, &scanner, &width, &height, &top_num_slices, 
		&pixel_size, &pixel_size, &plane_separation) == FAIL) 
d75 2
a76 1
		fprintf (stderr, "Error: getimagedim () failed.\n");
d80 5
a84 5
	if (scanner != ECAT_SCANNER)
	{
		fprintf (stderr, "Error: top scan file %s is not an ECAT image.\n", top_scan);
		exit (FAIL);
	}
d86 5
a90 4
	/*______________________________________________________
	 * Determine the sampling mode.
	 *______________________________________________________*/
	if (GetSamplingMode (top_scan, &sampling_mode) == FAIL)
d92 2
a93 1
		fprintf (stderr, "Error: in GetSamplingMode for file %s\n", top_scan);
a95 2
	else
		fprintf (stdout, "Processing in %dD mode\n\n", sampling_mode);
d97 7
a103 4
	/*______________________________________________________
	 * Get the offset for the indexing scan.
	 *______________________________________________________*/
	if (GetIndexingScanOffset (top_scan, bottom_scan, &offset) == FAIL)
d105 13
a117 3
		fprintf (stderr, "Error: in GetIndexingScanOffset ().\n");
		exit (FAIL);
	}
d119 5
a123 5
	/*______________________________________________________
	 * Get the number of the overlapped slices.
	 *______________________________________________________*/
	num_shifted_slices	= ROUND (offset / (plane_separation * MMS_PER_CM));
	num_overlapped_slices	= top_num_slices - num_shifted_slices;
d125 5
a129 112
	if (offset - num_shifted_slices * plane_separation * MMS_PER_CM != 0.0)
	{
		fprintf (stdout, "\nImage shift differs from exact slice alignment by %.3f mm\n",
			num_shifted_slices * plane_separation * MMS_PER_CM - offset);
		fprintf (stdout, "Number of overlaped slices = %d\n", num_overlapped_slices);
	}
	else
		fprintf (stdout, "\nNumber of overlaped slices = %d\n", num_overlapped_slices);

	if (num_overlapped_slices > top_num_slices)
	{
		fprintf (stderr, "Error: number of overlapped slices %d is greater than %d.\n", 
			num_overlapped_slices, top_num_slices);
		exit (FAIL);
	}

	/*______________________________________________________
	 * Get data from the top scan.
	 *______________________________________________________*/
	top_subheader_list	= (Image_subheader **) pkg_malloc (top_num_slices * sizeof (caddr_t), 
					"imageweld", "top_subheader_list");

	slice_dim	= width * height;
	dimension	= slice_dim * top_num_slices;
	top_image3d	= (float *) pkg_malloc (dimension * sizeof (float), "imageweld", "top_image3d");
	top_main_header	= (Main_header *) calloc (1, sizeof (Main_header));

	if (getrealimg (top_scan, scanner, matval, width, height, top_num_slices, top_image3d, 
		top_main_header, top_subheader_list) == FAIL)
	{
		fprintf (stderr, "Error: getrealimg () failed.\n");
		free (top_subheader_list);
		free (top_main_header);
		free (top_image3d);
		exit (FAIL);
	}

	top_scan_overlap_start	= top_num_slices - num_overlapped_slices + 1;

	/*______________________________________________________
	 * Get data from the bottom scan.
	 *______________________________________________________*/
	if (getimagedim (bottom_scan, matval, &scanner, &width, &height, &bottom_num_slices, 
		&pixel_size, &pixel_size, &plane_separation) == FAIL) 
	{
		fprintf (stderr, "Error: getimagedim () failed.\n");
		exit (FAIL);
	}

	if (scanner != ECAT_SCANNER)
	{
		fprintf (stderr, "Error: bottom scan file %s is not an ECAT image.\n", bottom_scan);
		exit (FAIL);
	}

	if (num_overlapped_slices > bottom_num_slices)
	{
		fprintf (stderr, "Error: number of overlapped slices %d is greater than %d.\n", 
			num_overlapped_slices, bottom_num_slices);
		exit (FAIL);
	}

	bottom_subheader_list	= (Image_subheader **) pkg_malloc (bottom_num_slices * sizeof (caddr_t), 
					"imageweld", "bottom_subheader_list");

	dimension		= slice_dim * bottom_num_slices;
	bottom_image3d		= (float *) pkg_malloc (dimension * sizeof (float), 
						"imageweld", "bottom_image3d");
	bottom_main_header	= (Main_header *) calloc (1, sizeof (Main_header));

	if (getrealimg (bottom_scan, scanner, matval, width, height, bottom_num_slices, bottom_image3d, 
		bottom_main_header, bottom_subheader_list) == FAIL)
	{
		fprintf (stderr, "Error: getrealimg () failed.\n");
		free (bottom_subheader_list);
		free (bottom_main_header);
		free (bottom_image3d);
		exit (FAIL);
	}

	bottom_scan_overlap_end	= num_overlapped_slices;

	/*______________________________________________________
	 * Get scaling factor;
	 *______________________________________________________*/
	top_image3d_overlap	= top_image3d + top_scan_overlap_start * slice_dim;
	bottom_image3d_overlap	= bottom_image3d + slice_dim;

	top_overlap_sum		= 0.0;
	bottom_overlap_sum	= 0.0;
	j			= (num_overlapped_slices  - 2) * slice_dim;
	for (i = 0; i < j; i++)
	{
		top_overlap_sum		+= top_image3d_overlap [i];
		bottom_overlap_sum	+= bottom_image3d_overlap [i];
	}

	if (bottom_overlap_sum != 0.0)
		scaling_factor	= top_overlap_sum / bottom_overlap_sum;
	else
	{
		fprintf (stderr, "Error: the sum for the bottom scan %s is 0.0\n", bottom_scan);
		exit (FAIL);
	}

	fprintf (stdout, "\nGlobal bottom image multiplier = %f\n\n", scaling_factor);
	fprintf (stdout, "top	bottom	top/bottom	scaled\n");   
	for (i = 0; i < num_overlapped_slices - 2; i++)
	{
		top_overlap_sum		= 0.0;
		bottom_overlap_sum	= 0.0;
		for (j = 0; j < slice_dim; j++)
d131 7
a137 2
			top_overlap_sum		+= top_image3d_overlap [i * slice_dim + j];
			bottom_overlap_sum	+= bottom_image3d_overlap [i * slice_dim + j];
a138 5
		fprintf (stdout, "%d	%d	%f	%f\n", 
				top_scan_overlap_start + i + 1, 1 + (i + 1), 
				top_overlap_sum / bottom_overlap_sum, 
				top_overlap_sum / (bottom_overlap_sum * scaling_factor));
	}
d140 2
a141 10
	/*______________________________________________________
	 * Generate merged 3D real array.
	 *______________________________________________________*/
	num_slices	= top_num_slices + bottom_num_slices - num_overlapped_slices;
	subheader_list	= (Image_subheader **) pkg_malloc (num_slices * sizeof (caddr_t), 
					"imageweld", "subheader_list");
	main_header	= (Main_header *) calloc (1, sizeof (Main_header));
	bcopy (top_main_header, main_header, sizeof (Main_header));
	dimension	= slice_dim * num_slices;
	image3d		= (float *) pkg_malloc (dimension * sizeof (float), "imageweld", "image3d");
d143 10
a152 21
	/* 
	 * Copy the top planes.
	 */
	dimension	= top_scan_overlap_start * slice_dim;
	for (i = 0; i < dimension; i++)
	{
		image3d [i]	= top_image3d [i];
	}
	for (i = 0; i < top_scan_overlap_start; i++)
	{
		*(subheader_list + i)	= matrixx_init_image_subheader (*(top_subheader_list + i));
	}

	/*______________________________________________________
	 * Compute the weights.
	 *______________________________________________________*/
	weight_table	= (float *) pkg_malloc (STANDARD_DEVIATIONS3D_SIZE * sizeof (float), 
				"imageweld", "weight_table");
	if (sampling_mode == SAMPLING_MODE_3D)
	{
		for (i = 0; i < STANDARD_DEVIATIONS3D_SIZE; i++)
d154 3
a156 3
			weight_table [i]	= (1.0 / (sigma3d [i] * sigma3d [i])
						+ 1.0 / (sigma3d [(STANDARD_DEVIATIONS3D_SIZE - 1) -  i]
						* sigma3d [(STANDARD_DEVIATIONS3D_SIZE - 1) - i])) / 2;
a157 10
	}
	else
	{
		for (i = 0; i < STANDARD_DEVIATIONS3D_SIZE; i++)
		{
			weight_table [i]	= weight2d [i];
		}
	}
	weight_table [0]				= 0.0;
	weight_table [STANDARD_DEVIATIONS3D_SIZE - 1]	= 0.0;
d159 1
a159 8
	/* 
	 * Compute the overlapped planes.
	 */
	for (i = 0; i < num_overlapped_slices - 2; i++)
	{
		overlap_image3d 	= image3d + (top_scan_overlap_start + i) * slice_dim;
		top_image3d_overlap	= top_image3d + (top_scan_overlap_start + i) * slice_dim;
		bottom_image3d_overlap	= bottom_image3d + (1 + i) * slice_dim;
d161 5
a165 10
		*(subheader_list + top_scan_overlap_start + i)	
			= matrixx_init_image_subheader (*(top_subheader_list 
				+ top_scan_overlap_start + i));
		top_weight	= weight_table [top_scan_overlap_start + i] 
				/ (weight_table [top_scan_overlap_start + i] 
				+ weight_table [1 + i]);
		bottom_weight	= scaling_factor * weight_table [1 + i] 
				/ (weight_table [top_scan_overlap_start + i] 
				+ weight_table [1 + i]);
		for (j = 0; j < slice_dim; j++)
d167 2
a168 2
			overlap_image3d [j]	= top_weight * top_image3d_overlap [j]
						+ bottom_weight * bottom_image3d_overlap [j];
a170 1
	free (weight_table);
d172 1
a172 201
	for (i = 0; i < top_num_slices; i++)
	{
		free (top_subheader_list [i]);
	}
	free (top_subheader_list);
	free (top_main_header);
	free (top_image3d);

	/* 
	 * Copy the bottom planes.
	 */
	nonoverlap_image3d 		= image3d + (top_scan_overlap_start 
						+ num_overlapped_slices - 2) * slice_dim;
	bottom_image3d_nonoverlap	= bottom_image3d + (num_overlapped_slices - 1) * slice_dim;
	dimension			= (bottom_num_slices - (num_overlapped_slices - 1)) * slice_dim;
	for (i = 0; i < dimension; i++)
	{
		nonoverlap_image3d [i]	= bottom_image3d_nonoverlap [i] * scaling_factor;
	}
	for (i = num_overlapped_slices - 1; i < bottom_num_slices; i++)
	{
		*(subheader_list + (top_scan_overlap_start + num_overlapped_slices - 2) 
			+ (i - (num_overlapped_slices - 1)))	
		= matrixx_init_image_subheader (*(bottom_subheader_list + i));
	}

	for (i = 0; i < bottom_num_slices; i++)
	{
		free (bottom_subheader_list [i]);
	}
	free (bottom_subheader_list);
	free (bottom_main_header);
	free (bottom_image3d);

	/*______________________________________________________
	 * Write 3D image to an ECAT matrix file.
	 *______________________________________________________*/
	strcpy (main_header->study_description, "Welded Image");
	strcpy (main_header->facility_name, "Washington Univ");
	if (writerealimg (whole_scan, matval, width, height, num_slices, image3d, 
			main_header, subheader_list) == FAIL)
	{
		fprintf (stderr, "Error: writerealimg () failed.\n");
	}

	for (i = 0; i < num_slices; i++)
	{
		free (subheader_list [i]);
	}
	free (subheader_list);
	free (main_header);
	free (image3d);
}

PRIVATE int GetSamplingMode (ecat_filename, mode)
	char	*ecat_filename;
	int	*mode;
{
	MatrixData	*matrix_read ();
	MatrixFile	*matrix_open ();

	Image_subheader	*image_subheader;
	Main_header	*main_header;
	MatrixData	*matrixx_data;
	MatrixFile	*matfptr;
	Mlist		*mlist;
	int		diff;  /* number of differences between spec and actual */

	matfptr	= matrix_open (ecat_filename, "r");
	if (matfptr == NULL)
	{
		fprintf (stderr, "Error: matrix_open in GetSamplingMode ().\n");
		return FAIL;
	}

	main_header	= matfptr->mhptr;

	/*
	 * Check if the ECAT file is a really an ECAT image.
	 */
	if (main_header->data_type != IMAGE_DATA)
	{
		fprintf (stderr, "Error: Data type is not compatible with image data type.\n");
		matrix_close (matfptr);
		return FAIL;
	}

	/*
	 * The number of mats in a list always gives the correct number of slices.
 	 */
	mlist	= make_list (ecat_filename, (char *) NULL, "*;*;*;*", &diff);
	if (!mlist) 
	{
		fprintf (stderr, "make_list error in GetSamplingMode ().\n");
		matrix_close (matfptr);
		return FAIL;
	}

	/*
 	 * Get the image subheader for slice 1. 
 	 */
	matrixx_data	= matrix_read (matfptr, mlist->list [0]);
	if (matrixx_data == NULL)
	{
		fprintf (stderr, "Error: matrixx_read in GetSamplingMode ().\n");
		matrix_close (matfptr);
		free_Mlist (mlist);
		return FAIL;
	}
	image_subheader	= (Image_subheader *) matrixx_data->shptr;

	if (main_header->wobble_speed == 0 && image_subheader->filter_params [0] == 1.0)
		*mode	= SAMPLING_MODE_3D;
	else 
		*mode	= SAMPLING_MODE_2D;

	free_Mlist (mlist);
	free_matrix_data (matrixx_data);
	matrix_close (matfptr);

	return SUCCEED;
}

PRIVATE int GetIndexingScanOffset (top_scan, bottom_scan, offset)
	char	*top_scan;
	char	*bottom_scan;
	float	*offset;
{
	char	cbuffer [MAXLINE];
	float	bottom_scan_position;
	float	top_scan_position;

	if (GetBedPosition (top_scan, &top_scan_position) == FAIL)
	{
		fprintf (stderr, "Error in GetBedPosition () for %s\n", top_scan);
		return FAIL;
	}

	if (GetBedPosition (bottom_scan, &bottom_scan_position) == FAIL)
	{
		fprintf (stderr, "Error in GetBedPosition () for %s\n", bottom_scan);
		return FAIL;
	}

	if (top_scan_position <= bottom_scan_position)
		*offset	= bottom_scan_position - top_scan_position;
	else
	{
		*offset	= top_scan_position - bottom_scan_position;
		strcpy (cbuffer, top_scan);
		strcpy (top_scan, bottom_scan);
		strcpy (bottom_scan, cbuffer);
	}

	return SUCCEED;
}

PRIVATE int GetBedPosition (ecat_filename, scan_position)
	char	*ecat_filename;
	float	*scan_position;
{
	MatrixFile	*matrix_open ();

	Main_header	*main_header;
	MatrixFile	*matfptr;

	matfptr	= matrix_open (ecat_filename, "r");
	if (matfptr == NULL)
	{
		fprintf (stderr, "Error: matrix_open in opening %s ().\n", ecat_filename);
		return FAIL;
	}

	main_header	= matfptr->mhptr;

	/*
	 * Check if the ECAT file is a really an ECAT image.
	 */
	if (main_header->data_type != IMAGE_DATA)
	{
		fprintf (stderr, "Error: Data type is not compatible with image data type.\n");
		matrix_close (matfptr);
		return FAIL;
	}

	*scan_position		= main_header->init_bed_position;
	matrix_close (matfptr);

	/*
	 * Check if the scan_position is 0.
	 */
	if (*scan_position == 0.0)
	{
		fprintf (stdout, "The horizontal bed position in image file %s main header is 0.0.\n",
			ecat_filename);
		fprintf (stdout, "Please specify the horizontal bed position for file %s in mm.\n",
			ecat_filename);
		scanf ("%f", scan_position);
	}

	return SUCCEED;
@


1.6
log
@Added rcs.
@
text
@d1 1
a1 1
/*$Id: imageweld.c,v 1.5 1993/05/12 21:02:44 ty7777 Exp $*/
d3 3
d36 1
a36 1
static char rcsid []= "$Id$";
d38 4
d52 2
a53 2
	char		*bottom_scan;
	char		*top_scan;
d64 1
d81 1
d94 3
a96 1
	 * Get command line arguments.
d98 3
a100 5
	num_overlapped_slices	= atoi (argv [1]);
	top_scan		= argv [2];
	bottom_scan		= argv [3];
	whole_scan		= argv [4];
	sampling_mode		= atoi (argv [5]);
d112 1
a112 1
	 * Get data from the top scan.
d127 35
d169 3
d254 1
a254 1
		fprintf (stderr, "There is something wrong with the bottom scan %s\n", bottom_scan);
d401 149
@


1.5
log
@Making scaling factor correct.
@
text
@d1 1
a1 1
/*$Id: imageweld.c,v 1.4 1993/05/10 20:34:31 ty7777 Exp ty7777 $*/
d3 3
d33 2
d211 2
a212 2
	fprintf (stdout, "\nscaling_factor = %f\n\n", scaling_factor);
	fprintf (stdout, "top	bottom	slivce_scale	normalization\n");   
@


1.4
log
@imageweld.c correctly working version.
@
text
@d1 1
a1 1
/*$Id: imageweld.c,v 1.3 1993/05/06 19:24:26 ty7777 Exp ty7777 $*/
d3 3
d198 2
a199 2
	if (top_overlap_sum != 0.0)
		scaling_factor	= bottom_overlap_sum / top_overlap_sum;
d201 4
a204 1
		scaling_factor	= top_overlap_sum / bottom_overlap_sum;
d206 2
a207 2
/*
printf ("\n%f\n", scaling_factor);
d217 4
a220 3
printf ("%d %d %f %f\n", top_scan_overlap_start + i + 1, 1 + (i + 1), 
	bottom_overlap_sum / top_overlap_sum, 
	bottom_overlap_sum / (top_overlap_sum * scaling_factor));
a221 1
*/
d314 1
a314 1
		nonoverlap_image3d [i]	= bottom_image3d_nonoverlap [i];
@


1.3
log
@After making 2D work.
@
text
@d1 1
a1 1
/*$Id: imageweld.c,v 1.2 1993/05/06 18:10:54 ty7777 Exp ty7777 $*/
d3 3
d43 1
d48 2
a49 1
	float		*initial_image3d;
d59 1
a182 1
	top_overlap_sum	= 0.0;
d184 1
a184 5
	j			= (num_overlapped_slices  - 2) * slice_dim;
	for (i = 0; i < j; i++)
	{
		top_overlap_sum	+= top_image3d_overlap [i];
	}
d186 1
d188 1
a188 1
	bottom_image3d_overlap	= bottom_image3d + slice_dim;
d191 1
d200 17
d241 6
a246 4
	/* 
	 * Compute the overlapped planes.
	 */
	for (i = 0; i < num_overlapped_slices - 2; i++)
d248 1
a248 1
		if (sampling_mode == SAMPLING_MODE_3D)
d250 3
a252 22
			average			= (sigma3d [top_scan_overlap_start + i]
						+ sigma3d [top_num_slices + 1 
						- (top_scan_overlap_start + i)]) / 2;
			top_average_variance	= average * average;
			average			= (sigma3d [1 + i]
						+ sigma3d [top_num_slices + 1 - (1 + i)]) / 2;
			bottom_average_variance	= average * average;

			if (top_overlap_sum != 0.0)
			{
				top_weight	= top_average_variance
						/ (top_average_variance + bottom_average_variance);
				bottom_weight	= scaling_factor * bottom_average_variance
						/ (top_average_variance + bottom_average_variance);
			}
			else
			{
				top_weight	= scaling_factor * top_average_variance
						/ (top_average_variance + bottom_average_variance);
				bottom_weight	= bottom_average_variance
						/ (top_average_variance + bottom_average_variance);
			}
d254 4
a257 1
		else
d259 1
a259 18
			if (top_overlap_sum != 0.0)
			{
				top_weight	= ((float) weight2d [top_scan_overlap_start + i])
							/ (weight2d [top_scan_overlap_start + i] 
							+ weight2d [1 + i]);
				bottom_weight	= (scaling_factor * weight2d [1 + i])
							/ (weight2d [top_scan_overlap_start + i] 
							+ weight2d [1 + i]);
			}
			else
			{
				top_weight	= (scaling_factor * weight2d [top_scan_overlap_start + i])
							/ (weight2d [top_scan_overlap_start + i] 
							+ weight2d [1 + i]);
				bottom_weight	= ((float) weight2d [1 + i])
							/ (weight2d [top_scan_overlap_start + i] 
							+ weight2d [1 + i]);
			}
d261 3
d265 6
a272 1
		initial_image3d 	= image3d + dimension + i * slice_dim;
d277 6
d285 1
a285 1
			initial_image3d [j]	= top_weight * top_image3d_overlap [j]
d289 1
a290 3
	/* 
	 * Copy the bottom planes.
	 */
d299 7
a305 4
	initial_image3d 	= image3d + (top_scan_overlap_start + num_overlapped_slices - 2) 
					* slice_dim;
	bottom_image3d_overlap	= bottom_image3d + (bottom_scan_overlap_end - 1) * slice_dim;
	dimension		= (bottom_num_slices - num_overlapped_slices + 1) * slice_dim;
d308 1
a308 1
		initial_image3d [i]	= bottom_image3d_overlap [i];
d310 1
a310 1
	for (i = bottom_scan_overlap_end - 1; i < bottom_num_slices; i++)
d313 1
a313 1
			+ (i - bottom_scan_overlap_end + 1))	
d329 1
@


1.2
log
@Before adding 2D processing.
@
text
@d1 1
a1 1
/*$Id: imageweld.c,v 1.1 1993/05/05 16:38:52 ty7777 Exp ty7777 $*/
d3 3
d37 2
d46 1
d59 1
d77 1
d208 3
d221 3
d226 1
a226 1
		if (top_overlap_sum != 0.0)
d228 22
a249 9
			top_weight	= sigma3d [top_scan_overlap_start + i] 
					* sigma3d [top_scan_overlap_start + i]
					/ (sigma3d [top_scan_overlap_start + i]
					* sigma3d [top_scan_overlap_start + i]
					+ sigma3d [1 + i] * sigma3d [1 + i]);
			bottom_weight	= scaling_factor * (sigma3d [1 + i] * sigma3d [1 + i])
					/ (sigma3d [top_scan_overlap_start + i]
					* sigma3d [top_scan_overlap_start + i]
					+ sigma3d [1 + i] * sigma3d [1 + i]);
d253 18
a270 9
			top_weight	= scaling_factor * (sigma3d [top_scan_overlap_start + i] 
					* sigma3d [top_scan_overlap_start + i])
					/ (sigma3d [top_scan_overlap_start + i]
					* sigma3d [top_scan_overlap_start + i]
					+ sigma3d [1 + i] * sigma3d [1 + i]);
			bottom_weight	= (sigma3d [1 + i] * sigma3d [1 + i])
					/ (sigma3d [top_scan_overlap_start + i]
					* sigma3d [top_scan_overlap_start + i]
					+ sigma3d [1 + i] * sigma3d [1 + i]);
d287 3
@


1.1
log
@Initial revision
@
text
@d1 5
a5 2
/*$Id$*/
/*$Log$*/
d19 1
d26 1
d29 1
d35 6
d42 3
d47 2
d50 2
d54 3
d59 1
a62 1

d66 4
a69 4
	num_overlapped_slices		= atoi (argv [1]);
	top_scan			= argv [2];
	bottom_scan			= argv [3];
	whole_scan			= argv [4];
d81 1
a81 1
	 * Get data from top scan.
d83 1
a83 1
	if (getimagedim (top_scan, matval, &scanner, &width, &height, &num_slices, 
d96 1
a96 1
	if (num_overlapped_slices > num_slices)
d99 1
a99 1
			num_overlapped_slices, num_slices);
d103 1
a103 1
	top_subheader_list	= (Image_subheader **) pkg_malloc (num_slices * sizeof (caddr_t), 
d106 2
a107 1
	dimension	= width * height * num_slices;
d111 1
a111 1
	if (getrealimg (top_scan, scanner, matval, width, height, num_slices, top_image3d, 
d116 1
a117 1
		free (top_main_header);
d120 179
@
