head	1.2;
access;
symbols;
locks; strict;
comment	@ * @;


1.2
date	95.10.31.14.51.32;	author tom;	state Exp;
branches;
next	1.1;

1.1
date	95.10.16.18.53.48;	author ty7777;	state Exp;
branches;
next	;


desc
@Initial checking in, working version.
@


1.2
log
@*** empty log message ***
@
text
@/*$Id: rfa_xdr.c,v 1.1 1995/10/16 18:53:48 ty7777 Exp tom $*/
/*$Log: rfa_xdr.c,v $
 * Revision 1.1  1995/10/16  18:53:48  ty7777
 * Initial revision
 **/

/*
 * Please do not edit this file.
 * It was generated using rpcgen.
 */

#include "rfa_xdr.h"

static char rcsid [] = "$Header: /home/npggw/tom/src/libecat7/RCS/rfa_xdr.c,v 1.1 1995/10/16 18:53:48 ty7777 Exp tom $";

bool_t xdr_RFA_FUNCTIONS(xdrs, objp)
XDR *xdrs;
RFA_FUNCTIONS *objp;
{
	if (!xdr_enum(xdrs, (char *)objp)) {
		return (FALSE);
	}
	return (TRUE);
}

bool_t xdr_RREN_args(xdrs, objp)
XDR *xdrs;
RREN_args *objp;
{
	if (!xdr_string(xdrs, &objp->oldName, 80)) {
		return (FALSE);
	}
	if (!xdr_string(xdrs, &objp->newName, 80)) {
		return (FALSE);
	}
	return (TRUE);
}

bool_t xdr_RCPY_args(xdrs, objp)
XDR *xdrs;
RCPY_args *objp;
{
	if (!xdr_string(xdrs, &objp->oldName, 80)) {
		return (FALSE);
	}
	if (!xdr_string(xdrs, &objp->newName, 80)) {
		return (FALSE);
	}
	if (!xdr_long(xdrs, (char*)&objp->fileSize)) {
		return (FALSE);
	}
	return (TRUE);
}

bool_t xdr_RDIR_args(xdrs, objp)
XDR *xdrs;
RDIR_args *objp;
{
	if (!xdr_string(xdrs, &objp->dirPath, 80)) {
		return (FALSE);
	}
	if (!xdr_int(xdrs, (char*)&objp->currDirNo)) {
		return (FALSE);
	}
	return (TRUE);
}

bool_t xdr_RDIR_resp(xdrs, objp)
XDR *xdrs;
RDIR_resp *objp;
{
	if (!xdr_string(xdrs, &objp->dirEntry, 80)) {
		return (FALSE);
	}
	if (!xdr_int(xdrs, (char*)&objp->nextDirNo)) {
		return (FALSE);
	}
	if (!xdr_int(xdrs, (char*)&objp->freeChunk)) {
		return (FALSE);
	}
	return (TRUE);
}
@


1.1
log
@Initial revision
@
text
@d1 5
a5 2
/*$Id$*/
/*$Log$*/
d12 1
a12 1
#include <rfa_xdr.h>
d14 1
a14 1
static char rcsid [] = "$Header$";
@
