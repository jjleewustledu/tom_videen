head	1.15;
access;
symbols;
locks; strict;
comment	@ * @;


1.15
date	96.03.12.22.43.02;	author tom;	state Exp;
branches;
next	1.14;

1.14
date	96.01.05.19.37.34;	author tom;	state Exp;
branches;
next	1.13;

1.13
date	96.01.03.19.50.06;	author tom;	state Exp;
branches;
next	1.12;

1.12
date	96.01.03.18.03.48;	author tom;	state Exp;
branches;
next	1.11;

1.11
date	95.12.20.04.18.42;	author tom;	state Exp;
branches;
next	1.10;

1.10
date	95.12.15.21.25.20;	author tom;	state Exp;
branches;
next	1.9;

1.9
date	95.12.13.23.04.36;	author tom;	state Exp;
branches;
next	1.8;

1.8
date	95.12.13.21.11.30;	author tom;	state Exp;
branches;
next	1.7;

1.7
date	95.12.12.17.58.17;	author tom;	state Exp;
branches;
next	1.6;

1.6
date	95.12.11.19.07.43;	author tom;	state Exp;
branches;
next	1.5;

1.5
date	95.12.07.14.45.10;	author tom;	state Exp;
branches;
next	1.4;

1.4
date	95.12.04.21.44.28;	author tom;	state Exp;
branches;
next	1.3;

1.3
date	95.12.01.21.55.53;	author tom;	state Exp;
branches;
next	1.2;

1.2
date	95.11.30.18.19.00;	author tom;	state Exp;
branches;
next	1.1;

1.1
date	95.11.28.20.11.33;	author tom;	state Exp;
branches;
next	;


desc
@@


1.15
log
@*** empty log message ***
@
text
@/*  $Id: cti.c,v 1.14 1996/01/05 19:37:34 tom Exp tom $
    $Log: cti.c,v $
 * Revision 1.14  1996/01/05  19:37:34  tom
 * set sh->calibration_factor to 1 when it is 0 (problem with ver 6 3D images)
 *
 * Revision 1.13  1996/01/03  19:50:06  tom
 * fixed identification of reconstruction and filtername
 *
 * Revision 1.12  1996/01/03  18:03:48  tom
 * add mh fields for archive type identification
 *
 * Revision 1.11  1995/12/20  04:18:42  tom
 * date format forced to 2 digits per item
 *
 * Revision 1.10  1995/12/15  21:25:20  tom
 * add scale_ish
 *
 * Revision 1.9  1995/12/13  23:04:36  tom
 * fixed data_type <-> number_format in header conversions
 *
 * Revision 1.8  1995/12/13  21:11:30  tom
 * *** empty log message ***
 *
 * Revision 1.7  1995/12/12  17:58:17  tom
 * time -> ptm
 *
 * Revision 1.6  1995/12/11  19:07:43  tom
 * add existimgfrm
 *
 * Revision 1.5  1995/12/07  14:45:10  tom
 * changed padding in padtensor
 *
 * Revision 1.4  1995/12/04  21:44:28  tom
 * add tensor functions
 *
 * Revision 1.3  1995/12/01  21:55:53  tom
 * *** empty log message ***
 *
 * Revision 1.2  1995/11/30  18:19:00  tom
 * *** empty log message ***
 *
 * Revision 1.1  1995/11/28  20:11:33  tom
 * Initial revision
 *
 */
/* =============================================================================
 *  Module:         cti.c
 *  Date:           Nov-95
 *  Author:         John Ollinger
 *  Description:    Routines for image & sinogram I/O (ECAT, PETT VI, Interfile).
 *	Functions:
 *		getsbhdr	-	Read subheader; Version 6 or 7.
 *		ssh7_to_sh	-	Fill subheader structure from version 7 scan subheader.
 *		ish7_to_sh	-	Fill subheader structure from version 7 image subheader.
 *		ssh6_to_sh	-	Fill subheader structure from version 6 scan subheader.
 *		ish6_to_sh	-	Fill subheader structure from version 6 image subheader.
 *		sh_to_ssh7	-	Fill version 7 scan subheader from subheader structure.
 *		sh_to_ish7	-	Fill version 7 image subheader from subheader structure.
 *		sh_to_ssh6	-	Fill version 6 scan subheader from subheader structure.
 *		sh_to_ish6	-	Fill version 6 image subheader from subheader structure.
 *		getmhdr		-	Read main header; Version 6 or 7.
 *		mh6_to_mh	-	Fill main header structure from version 6 mainheader.
 *		mh7_to_mh	-	Fill main header structure from version 7 mainheader.
 *		mhnames6	-	Fill main header names for archive from version 6 main and subheaders.
 *		mhnames7	-	Fill main header names for archive from version 7 main and subheaders.
 *		mh_to_mh6	-	Fill version 6 mainheader from main header structure.
 *		mh_to_mh7	-	Fill version 6 mainheader from main header structure.
 *		rdimg		-	Read image data; Version 6 or 7.
 *		putsbhdr	-	Write subheader; Version 6 or 7.
 *		putmhdr		-	Write main header; Version 6 or 7.
 *		wrimg		-	Write image data; Version 6 or 7.
 *		get_filetype -	Get type of file.
 *		free_mh		-	Free MainHeader.
 *		free_sh		-	Free SubHeader.
 *		make_mainheader - Malloc and fill main header.
 *		make_subheader - Malloc and fill subheader.
 *		readimgfrm	-	Read one frame of an image into a 1-D array.
 *		writeimgfrm	-	Write one frame of an image from a 1-D array.
 *		flipimg		-	Reverse right/left in an image.
 *		padplane	-	Pad a plane with zeros in x-, y- dimensions.
 *		existimgfrm	-	Check if an image frame exists (without issuing error messages).
 *		scale_ish	-	Scale and image by changing subheader scale factors.
 *	History:
 *		Dec-95	Modified by Tom Videen.
 * =============================================================================
 */
#ifndef lint
static char     rcsid[] = "$Header: /home/petsun19/tom/src/libimg/RCS/cti.c,v 1.14 1996/01/05 19:37:34 tom Exp tom $";
#endif

#include <stdio.h>
#include <string.h>
#include <fcntl.h>
#include <unistd.h>
#include <math.h>
#include <time.h>
#include <libimg.h>
#include <nr.h>
#include <nrutil.h>

/* =============================================================================
 *	Function:		getsbhdr
 *	Description:	Read file subheader.
 *	Note:	A generic subheader is returned which contains a field pointing
 *			to the original version 6 or 7 subheader.
 *			Since ver 7 subheaders contain a pointer to a copy of the original
 *			and the original may be freed after the generic subheader is created.
 *			Ver 6 subheaders do not contain this copy and should not be freed
 *			as the generic subheader points to the original.
 *	Modified:
 *		Dec-95 TOV to call mhnames6 or mhnames7 to complete mh structure for archive.
 * =============================================================================
 */
SubHeader      *getsbhdr (mh, filnam, plane, frame, gate, data, bed)
	MainHeader     *mh;
	char           *filnam;
	int             plane, frame, gate, data, bed;

{
	int             fformat;
	DataSetType		datatype;
	SubHeader      *sh;
	Main_header7    *mh7;
	Main_header     *mh6;
	Scan_subheader *ssh6;
	Image_subheader *ish6;
	Scan3D_subheader7 *ssh7;
	Image_subheader7 *ish7;
	SubHeader_if   *ifsh;
	PETT6HDR       *p6h;

	fformat = mh->file_format;
	datatype = (DataSetType ) mh->filtyp;

	if (fformat == MATRIX_REV7) {
		mh7 = mh_to_mh7 (mh);
		if (datatype == Sinogram) {
			ssh7 = (Scan3D_subheader7 *) getsbhdr7 (mh7, filnam, frame, gate, data, bed);
			if (ssh7 == NULL)
				return (NULL);
			else {
				sh = ssh7_to_sh (ssh7);
				free (ssh7);
			}
		} else if (datatype == PetVolume) {
			ish7 = (Image_subheader7 *) getsbhdr7 (mh7, filnam, frame, gate, data, bed);
			if (ish7 == NULL)
				return (NULL);
			else
				sh = ish7_to_sh (ish7);
				mhnames7 (mh, ish7);
		} else {
			fprintf (stderr, "ERROR [getsbhdr]: Unsupported data type %d in %s\n",
				 datatype, filnam);
			return (NULL);
		}
		sh->file_format = MATRIX_REV7;

	} else if (fformat == MATRIX_REV6) {
		mh6 = mh_to_mh6 (mh);
		if (datatype == Sinogram) {	
			ssh6 = (Scan_subheader *) getsbhdr6 (mh6, filnam, plane, frame, gate, data, bed);
			if (ssh6 == NULL)
				return (NULL);
			else
				sh = ssh6_to_sh (ssh6, mh6);
		} else if (datatype == PetImage) {
			ish6 = (Image_subheader *) getsbhdr6 (mh6, filnam, plane, frame, gate, data, bed);
			if (ish6 == NULL)
				return (NULL);
			else
				sh = ish6_to_sh (ish6, mh6);
				mhnames6 (mh, ish6);
		} else {
			fprintf (stderr, "ERROR [getsbhdr]: Unsupported data type %d in %s\n",
				 datatype, filnam);
			return (NULL);
		}
		sh->file_format = MATRIX_REV6;

	} else if (fformat == PETT6) {
		if ((p6h = getp6hdr (filnam, plane)) == NULL)
			return (NULL);
		else 
			sh = p6h_to_sh (p6h);
		sh->file_format = PETT6;

	} else if (fformat == INTERFILE) {
		ifsh = getsbhdr_if (filnam, plane, frame);
		if (ifsh == NULL)
			return (NULL);
		sh = ifsh_to_sh (ifsh);
		sh->file_format = INTERFILE;

	} else
		return (NULL);
	return (sh);
}

/* =============================================================================
 *	Function:		ssh7_to_sh
 *	Description:	Fill structure sh from Version 7 scan subheader
 * =============================================================================
 */
SubHeader      *ssh7_to_sh (ssh7)
	Scan3D_subheader7 *ssh7;

{
	int             i;
	SubHeader      *sh;

	sh = (SubHeader *) malloc (sizeof (SubHeader));

	if (ssh7->data_type == BYTE_TYPE)
		sh->number_format = BYTE_DATA;
	else if (ssh7->data_type == SUN_I2 || ssh7->data_type == VAX_I2)
		sh->number_format = SHORT_DATA;
	else if (ssh7->data_type == IEEE_R4)
		sh->number_format = FLOAT_DATA;
	else
		sh->number_format = SHORT_DATA;
	sh->file_format = MATRIX_REV7;
	sh->ndim = ssh7->num_dimensions;
	sh->dim1 = ssh7->num_r_elements;
	sh->dim2 = ssh7->num_angles;
	for (i = 0, sh->dim3 = 0; i < ssh7->ring_difference; i++)
		sh->dim3 += ssh7->num_z_elements[i];
	sh->ring_diff = ssh7->ring_difference;
	sh->total = ssh7->prompts;
	sh->delayeds = ssh7->delayed;
	sh->multiples = ssh7->multiples;
	sh->trues = ssh7->net_trues;
	sh->scale_factor = ssh7->scale_factor;
	sh->min = ssh7->scan_min;
	sh->max = ssh7->scan_max;
	sh->deadtime_corr = ssh7->loss_correction_fctr;
	sh->sample_size_1 = ssh7->x_resolution;
	sh->sample_size_2 = ssh7->y_resolution;
	sh->sample_size_3 = ssh7->z_resolution;
	sh->start_time = ssh7->frame_start_time;
	sh->duration = ssh7->frame_duration;
	sh->filter_code = 0;
	sh->filter_cutoff_frequency = 0.;
	sh->filter_resolution = 0.;
	sh->filter_ramp_slope = 0.;
	sh->filter_order = 0.;
	sh->filter_scatter_fraction = 0.;
	sh->filter_scatter_slope = 0.;
	sh->comment = NULL;
	sh->whole_header = ssh7->whole_header;

	return (sh);
}

/* =============================================================================
 *	Function:		ish7_to_sh
 *	Description:	Fill structure sh from Version 7 image subheader
 * =============================================================================
 */
SubHeader      *ish7_to_sh (ish7)
	Image_subheader7 *ish7;

{
	SubHeader      *sh;

	sh = (SubHeader *) malloc (sizeof (SubHeader));

	if (ish7->data_type == BYTE_TYPE)
		sh->number_format = BYTE_DATA;
	else if (ish7->data_type == SUN_I2 || ish7->data_type == VAX_I2)
		sh->number_format = SHORT_DATA;
	else if (ish7->data_type == IEEE_R4)
		sh->number_format = FLOAT_DATA;
	else
		sh->number_format = SHORT_DATA;
	sh->file_format = MATRIX_REV7;
	sh->ndim = ish7->num_dimensions;
	sh->dim1 = ish7->x_dimension;
	sh->dim2 = ish7->y_dimension;
	sh->dim3 = ish7->z_dimension;
	sh->total = 0;
	sh->delayeds = 0;
	sh->multiples = 0;
	sh->trues = 0;
	sh->scale_factor = ish7->scale_factor;
	sh->calibration_factor = 1.;		 /* Stored in main header for rev. 7 */
	sh->min = ish7->image_min;
	sh->max = ish7->image_max;
	sh->sample_size_1 = ish7->x_pixel_size;
	sh->sample_size_2 = ish7->y_pixel_size;
	sh->sample_size_3 = ish7->z_pixel_size;
	sh->start_time = ish7->frame_start_time;
	sh->duration = ish7->frame_duration;
	sh->filter_code = (int) ish7->filter_code;
	sh->filter_cutoff_frequency = ish7->filter_cutoff_frequency;
	sh->filter_resolution = ish7->filter_resolution;
	sh->filter_ramp_slope = ish7->filter_ramp_slope;
	sh->filter_order = ish7->filter_order;
	sh->filter_scatter_fraction = ish7->filter_scatter_fraction;
	sh->filter_scatter_slope = ish7->filter_scatter_slope;
	sh->comment = NULL;
	sh->whole_header = (void *) ish7;
	return (sh);
}

/* =============================================================================
 *	Function:		ssh6_to_sh
 *	Description:	Fill structure sh from Version 6 scan subheader
 * =============================================================================
 */
SubHeader      *ssh6_to_sh (ssh6, mh6)
	Scan_subheader *ssh6;
	Main_header    *mh6;

{
	SubHeader      *sh;

	sh = (SubHeader *) malloc (sizeof (SubHeader));

	sh->number_format = ssh6->data_type;
	if (ssh6->data_type == BYTE_TYPE)
		sh->number_format = BYTE_DATA;
	else if (ssh6->data_type == SUN_I2 || ssh6->data_type == VAX_I2)
		sh->number_format = SHORT_DATA;
	else if (ssh6->data_type == IEEE_R4)
		sh->number_format = FLOAT_DATA;
	else
		sh->number_format = SHORT_DATA;
	sh->file_format = MATRIX_REV6;
	sh->ndim = 2;
	sh->dim1 = ssh6->dimension_1;
	sh->dim2 = ssh6->dimension_2;
	sh->dim3 = mh6->num_planes;
	sh->ring_diff = 0;
	sh->total = ssh6->prompts;
	sh->delayeds = ssh6->delayed;
	sh->multiples = ssh6->multiples;
	sh->trues = ssh6->net_trues;
	sh->scale_factor = ssh6->scale_factor;
	sh->min = ssh6->scan_min;
	sh->max = ssh6->scan_max;
	sh->deadtime_corr = ssh6->loss_correction_fctr;
	sh->sample_size_1 = ssh6->sample_distance;
	sh->sample_size_2 = 0.;
	sh->sample_size_3 = 0.;
	sh->start_time = ssh6->frame_start_time;
	sh->duration = ssh6->frame_duration;
	sh->filter_code = 0;
	sh->filter_cutoff_frequency = 0.;
	sh->filter_resolution = 0.;
	sh->filter_ramp_slope = 0.;
	sh->filter_order = 0.;
	sh->filter_scatter_fraction = 0.;
	sh->filter_scatter_slope = 0.;
	sh->comment = NULL;
	sh->whole_header = (void *) ssh6;
	return (sh);
}

/* =============================================================================
 *	Function:		ish6_to_sh
 *	Description:	Fill structure sh from Version 6 image subheader
 * =============================================================================
 */
SubHeader      *ish6_to_sh (ish6, mh6)
	Image_subheader *ish6;
	Main_header    *mh6;

{
	SubHeader      *sh;

	sh = (SubHeader *) malloc (sizeof (SubHeader));

	if (ish6->data_type == BYTE_TYPE)
		sh->number_format = BYTE_DATA;
	else if (ish6->data_type == SUN_I2 || ish6->data_type == VAX_I2)
		sh->number_format = SHORT_DATA;
	else if (ish6->data_type == IEEE_R4)
		sh->number_format = FLOAT_DATA;
	else
		sh->number_format = SHORT_DATA;
	sh->file_format = MATRIX_REV6;
	sh->ndim = ish6->num_dimensions;
	sh->dim1 = ish6->dimension_1;
	sh->dim2 = ish6->dimension_2;
	sh->dim3 = mh6->num_planes;
	sh->total = 0;
	sh->delayeds = 0;
	sh->multiples = 0;
	sh->trues = 0;
	sh->scale_factor = ish6->quant_scale;
	sh->calibration_factor = ish6->ecat_calibration_fctr;
	if (sh->calibration_factor <= 0.)
		sh->calibration_factor = 1.;
	sh->min = ish6->image_min;
	sh->max = ish6->image_max;
	sh->deadtime_corr = ish6->loss_corr_fctr;
	sh->sample_size_1 = ish6->pixel_size;
	sh->sample_size_2 = ish6->pixel_size;
	sh->sample_size_3 = ish6->slice_width;
	sh->start_time = ish6->frame_start_time;
	sh->duration = ish6->frame_duration;
	sh->filter_code = (int) ish6->filter_code;
	sh->filter_cutoff_frequency = ish6->filter_params[0];
	sh->filter_resolution = ish6->filter_params[1];
	sh->filter_ramp_slope = ish6->filter_params[2];
	sh->filter_order = ish6->filter_params[3];
	sh->filter_scatter_fraction = ish6->filter_params[4];
	sh->filter_scatter_slope = ish6->filter_params[5];
	sh->comment = NULL;
	sh->whole_header = (void *) ish6;
	return (sh);
}

/* =============================================================================
 *	Function:		sh_to_ssh7
 *	Description:	Fill Version 7 scan subheader from structure sh
 * =============================================================================
 */
Scan3D_subheader7 *sh_to_ssh7 (sh)
	SubHeader      *sh;

{
	Scan3D_subheader7 *ssh7;
	short          *hdr, *hdr0;
	int             i;

	ssh7 = (Scan3D_subheader7 *) malloc (sizeof (Scan3D_subheader7));
	if (sh->whole_header != NULL && sh->file_format == MATRIX_REV7) {
		hdr = (short *) ssh7;
		hdr0 = (short *) sh->whole_header;
		for (i = 0; i < LENREC_S; i++)
			hdr[i] = hdr0[i];
	}
	if (sh->number_format == BYTE_DATA)
		ssh7->data_type = BYTE_TYPE;
	else if (sh->number_format == SHORT_DATA)
		ssh7->data_type = SUN_I2;
	else if (sh->number_format == FLOAT_DATA)
		ssh7->data_type = IEEE_R4;
	else
		ssh7->data_type = SUN_I2;
	ssh7->num_dimensions = sh->ndim;
	ssh7->num_r_elements = sh->dim1;
	ssh7->num_angles = sh->dim2;
	ssh7->num_z_elements[0] = sh->dim3;
	ssh7->ring_difference = sh->ring_diff;
	ssh7->x_resolution = sh->sample_size_1;
	ssh7->y_resolution = sh->sample_size_2;
	ssh7->z_resolution = sh->sample_size_3;
	ssh7->scale_factor = sh->scale_factor;
	ssh7->scan_min = sh->min;
	ssh7->scan_max = sh->max;
	ssh7->prompts = sh->total;
	ssh7->delayed = sh->delayeds;
	ssh7->multiples = sh->multiples;
	ssh7->net_trues = sh->trues;
	ssh7->frame_start_time = sh->start_time;
	ssh7->frame_duration = sh->duration;
	ssh7->loss_correction_fctr = sh->deadtime_corr;
	ssh7->whole_header = sh->whole_header;
	return (ssh7);
}

/* =============================================================================
 *	Function:		sh_to_ish7
 *	Description:	Fill Version 7 image subheader from structure sh
 *	Note:	The structure returned points to the whole_header field of sh.
 * =============================================================================
 */
Image_subheader7 *sh_to_ish7 (sh)
	SubHeader      *sh;

{
	Image_subheader7 *ish7;
	short          *hdr, *hdr0;
	int             i;

	ish7 = (Image_subheader7 *) malloc (sizeof (Image_subheader7));
	if (sh->whole_header != NULL && sh->file_format == MATRIX_REV7) {
		hdr = (short *) ish7;
		hdr0 = (short *) sh->whole_header;
		for (i = 0; i < LENREC_S; i++)
			hdr[i] = hdr0[i];
	}
	if (sh->number_format == BYTE_DATA)
		ish7->data_type = BYTE_TYPE;
	else if (sh->number_format == SHORT_DATA)
		ish7->data_type = SUN_I2;
	else if (sh->number_format == FLOAT_DATA)
		ish7->data_type = IEEE_R4;
	else
		ish7->data_type = SUN_I2;
	ish7->num_dimensions = sh->ndim;
	ish7->x_dimension = sh->dim1;
	ish7->y_dimension = sh->dim2;
	ish7->z_dimension = sh->dim3;
	ish7->scale_factor = sh->scale_factor;
	ish7->image_min = sh->min;
	ish7->image_max = sh->max;
	ish7->x_pixel_size = sh->sample_size_1;
	ish7->y_pixel_size = sh->sample_size_2;
	ish7->z_pixel_size = sh->sample_size_3;
	ish7->frame_start_time = sh->start_time;
	ish7->frame_duration = sh->duration;
	ish7->filter_code = sh->filter_code;
	ish7->filter_cutoff_frequency = sh->filter_cutoff_frequency;
	ish7->filter_resolution = sh->filter_resolution;
	ish7->filter_ramp_slope = sh->filter_ramp_slope;
	ish7->filter_order = sh->filter_order;
	ish7->filter_scatter_fraction = sh->filter_scatter_fraction;
	ish7->filter_scatter_slope = sh->filter_scatter_slope;
	return (ish7);
}

/* =============================================================================
 *	Function:		sh_to_ssh6
 *	Description:	Fill Version 6 scan subheader from structure sh
 * =============================================================================
 */
Scan_subheader *sh_to_ssh6 (sh)
	SubHeader      *sh;

{
	Scan_subheader *ssh6;

	if (sh->whole_header != NULL && sh->file_format == MATRIX_REV6)
		ssh6 = (Scan_subheader *) sh->whole_header;
	else
		ssh6 = (Scan_subheader *) malloc (sizeof (Scan_subheader));

	if (sh->number_format == BYTE_DATA)
		ssh6->data_type = BYTE_TYPE;
	else if (sh->number_format == SHORT_DATA)
		ssh6->data_type = SUN_I2;
	else if (sh->number_format == FLOAT_DATA)
		ssh6->data_type = IEEE_R4;
	else
		ssh6->data_type = SUN_I2;
	ssh6->dimension_1 = sh->dim1;
	ssh6->dimension_2 = sh->dim2;
	ssh6->sample_distance = sh->sample_size_1;
	ssh6->scale_factor = sh->scale_factor;
	ssh6->scan_min = sh->min;
	ssh6->scan_max = sh->max;
	ssh6->prompts = sh->total;
	ssh6->delayed = sh->delayeds;
	ssh6->multiples = sh->multiples;
	ssh6->net_trues = sh->trues;
	ssh6->frame_start_time = sh->start_time;
	ssh6->frame_duration = sh->duration;
	ssh6->loss_correction_fctr = sh->deadtime_corr;

	return (ssh6);
}

/* =============================================================================
 *	Function:		sh_to_ish6
 *	Description:	Fill Version 6 image subheader from structure sh
 * =============================================================================
 */
Image_subheader *sh_to_ish6 (sh)
	SubHeader      *sh;

{
	Image_subheader *ish6;

	if (sh->whole_header != NULL && sh->file_format == MATRIX_REV6)
		ish6 = (Image_subheader *) sh->whole_header;
	else {
		ish6 = (Image_subheader *) malloc (sizeof (Image_subheader));
		ish6->x_origin = 0.;
		ish6->y_origin = 0.;
		ish6->recon_scale = 0.;
		ish6->recon_duration = 0;
		ish6->scan_matrix_num = 0;
		ish6->norm_matrix_num = 0;
		ish6->atten_cor_matrix_num = 0;
		ish6->image_rotation = 0.;
		ish6->plane_eff_corr_fctr = 0.;
		ish6->decay_corr_fctr = 0.;
		ish6->loss_corr_fctr = 0.;
		ish6->intrinsic_tilt = 0.;
		ish6->well_counter_cal_fctr = 0.;
		strcpy (ish6->annotation, "");
	}

	if (sh->number_format == BYTE_DATA)
		ish6->data_type = BYTE_TYPE;
	else if (sh->number_format == SHORT_DATA)
		ish6->data_type = SUN_I2;
	else if (sh->number_format == FLOAT_DATA)
		ish6->data_type = IEEE_R4;
	else
		ish6->data_type = SUN_I2;
	ish6->num_dimensions = sh->ndim;
	ish6->dimension_1 = sh->dim1;
	ish6->dimension_2 = sh->dim2;
	ish6->quant_scale = sh->scale_factor;
	ish6->image_min = sh->min;
	ish6->image_max = sh->max;
	ish6->pixel_size = sh->sample_size_1;
	ish6->slice_width = sh->sample_size_3;
	ish6->frame_duration = sh->duration;
	ish6->frame_start_time = sh->start_time;
	ish6->ecat_calibration_fctr = sh->calibration_factor;
	ish6->loss_corr_fctr = sh->deadtime_corr;
	ish6->filter_code = (short) sh->filter_code;
	ish6->filter_params[0] = sh->filter_cutoff_frequency;
	ish6->filter_params[1] = sh->filter_resolution;
	ish6->filter_params[2] = sh->filter_ramp_slope;
	ish6->filter_params[3] = sh->filter_order;
	ish6->filter_params[4] = sh->filter_scatter_fraction;
	ish6->filter_params[5] = sh->filter_scatter_slope;
	return (ish6);
}

/* =============================================================================
 *	Function:		getmhdr
 *	Description:	Get main header from ECAT file
 *	Note:	A generic mainheader is returned which contains a field pointing
 *			to the original version 6 or 7 mainheader.
 *			Since ver 7 mainheaders contain a pointer to a copy of the original
 *			and the original may be freed after the generic mainheader is created.
 *			Ver 6 mainheaders do not contain this copy and should not be freed
 *			as the generic mainheader points to the original.
 * =============================================================================
 */
MainHeader     *getmhdr (filnam)
	char           *filnam;

{
	int             fformat;
	MainHeader     *mh;
	Main_header    *mh6;
	Main_header7   *mh7;
	MainHeader_if  *mh1;
	PETT6HDR       *ph;

	fformat = get_filetype (filnam);

	if (fformat == MATRIX_REV7) {		 /* Matrix file version 7 */
		mh7 = getmhdr7 (filnam);
		mh = mh7_to_mh (mh7);
	} else if (fformat == MATRIX_REV6) {	 /* Matrix file version 6 */
		mh6 = getmhdr6 (filnam);
		mh = mh6_to_mh (mh6);
	} else if (fformat == PETT6) {		 /* PETT VI */
		ph = getp6hdr (filnam, 1);
		mh = p6h_to_mh (ph);
	} else if (fformat == INTERFILE) {	 /* Interfile file. */
		mh1 = getmhdr_if (filnam);
		mh = ifmh_to_mh (mh1);
	} else {
		fprintf (stderr,"ERROR [getmhdr]: Unsupported file format %d in %s\n", fformat, filnam);
		return (NULL);
	}
	free (mh->data_file);
	mh->data_file = (char *) malloc (strlen (filnam) + 1);
	strcpy (mh->data_file, filnam);
	return (mh);
}

/* =============================================================================
 *	Function:		mh6_to_mh
 *	Description:	Fill generic mainheader structure, mh, from Version 6 mainheader
 * =============================================================================
 */
#define CRIT 0.001

MainHeader     *mh6_to_mh (mh6)
	Main_header    *mh6;

{
	MainHeader     *mh;
	int             i;
	int				year;

	mh = (MainHeader *) malloc (sizeof (MainHeader));

	mh->data_file = NULL;
	mh->file_format = MATRIX_REV6;
	if (mh6->data_type == VAX_I2 || mh6->data_type == SUN_I2)
		mh->number_format = SHORT_DATA;
	else if (mh6->data_type == BYTE_TYPE)
		mh->number_format = BYTE_DATA;
	else if (mh6->data_type == IEEE_R4)
		mh->number_format = FLOAT_DATA;
	mh->version = (int) mh6->sw_version;
	mh->filtyp = mh6->file_type;
	mh->nplane = mh6->num_planes;
	mh->nframe = mh6->num_frames;
	mh->ngate = mh6->num_gates;
	mh->nbed = mh6->num_bed_pos;
	mh->scanner_type = mh6->system_type;
	year = mh6->scan_start_year;
	if (year > 2000)
		year -= 2000;
	else if (year > 1900)
		year -= 1900;
	sprintf (mh->date_time, "%02d/%02d/%02d, %02d:%02d:%02d",
		 mh6->scan_start_month, mh6->scan_start_day, year,
		 mh6->scan_start_hour, mh6->scan_start_minute, mh6->scan_start_second);
	mh->start_time = -1;
	mh->wobble_speed = (int) mh6->wobble_speed;
	for (i = 0; i < 16; i++)
		mh->patnum[i] = mh6->patient_id[i];
	mh->bed_elevation = mh6->bed_elevation;
	mh->init_bed_pos = mh6->init_bed_position;
	for (i = 0; i < 15; i++)
		mh->bed_off[i] = mh6->bed_offset[i];
	mh->slcthk = mh6->plane_separation;
	mh->calibration_factor = 1.;
	for (i = 0; i < 8; i++)
		mh->isotope[i] = mh6->isotope_code[i];
	for (i = 0; i < 32; i++)
		mh->radiopharmaceutical[i] = mh6->radiopharmaceutical[i];
	comment2info (mh, mh6->study_description);
	mh->sw_revision = (char *) malloc (strlen (mh6->physician_name) + 1);
	strcpy (mh->sw_revision, mh6->physician_name);
	mh->gen_data = NULL;
	mh->filetime = (char *) malloc (strlen (mh6->operator_name) + 1);
	strcpy (mh->filetime, mh6->operator_name);
	if (mh6->system_type == 953)
		strcpy (mh->scanner, "953");
	else if (mh6->system_type == 961)
		strcpy (mh->scanner, "961");
	else
		strcpy (mh->scanner, "");
	if (mh6->wobble_speed == 0)
		strcpy (mh->acquisition, "sta");
	else
		strcpy (mh->acquisition, "wob");
	strcpy (mh->reconstruction, "");
	strcpy (mh->filtername, "");
	mh->whole_header = (void *) mh6;
	return (mh);
}

/* =============================================================================
 *	Function:		mh7_to_mh
 *	Description:	Fill generic mainheader structure, mh, from Version 7 mainheader
 * =============================================================================
 */
MainHeader     *mh7_to_mh (mh7)
	Main_header7   *mh7;

{
	int             i;
	MainHeader     *mh;
	struct tm      *ptm;

	mh = (MainHeader *) malloc (sizeof (MainHeader));
	mh->data_file = NULL;
	mh->file_format = MATRIX_REV7;
	mh->version = (int) mh7->sw_version;
	mh->filtyp = mh7->file_type;
	mh->nplane = mh7->num_planes;
	mh->nframe = mh7->num_frames;
	mh->ngate = mh7->num_gates;
	mh->nbed = mh7->num_bed_pos;
	mh->scanner_type = mh7->system_type;
	ptm = localtime (&mh7->scan_start_time);
	sprintf (mh->date_time, "%02d/%02d/%02d, %02d:%02d:%02d", ptm->tm_mon + 1, ptm->tm_mday,
		 ptm->tm_year, ptm->tm_hour, ptm->tm_min, ptm->tm_sec);
	mh->start_time = mh7->scan_start_time;
	mh->wobble_speed = (int) mh7->wobble_speed;
	for (i = 0; i < 16; i++)
		mh->patnum[i] = mh7->patient_id[i];
	mh->bed_elevation = mh7->bed_elevation;
	mh->init_bed_pos = mh7->init_bed_position;
	for (i = 0; i < 16; i++)
		mh->bed_off[i] = mh7->bed_offset[i];
	mh->slcthk = mh7->plane_separation;
	mh->calibration_factor = mh7->calibration_factor;
	for (i = 0; i < 8; i++)
		mh->isotope[i] = mh7->isotope_code[i];
	for (i = 0; i < 32; i++)
		mh->radiopharmaceutical[i] = mh7->radiopharmaceutical[i];
	comment2info (mh, mh7->study_description);
	mh->sw_revision = (char *) malloc (strlen (mh7->physician_name) + 1);
	strcpy (mh->sw_revision, mh7->physician_name);
	mh->gen_data = NULL;
	mh->filetime = (char *) malloc (strlen (mh7->operator_name) + 1);
	strcpy (mh->filetime, mh7->operator_name);
	if (mh7->system_type == 953)
		strcpy (mh->scanner, "953");
	else if (mh7->system_type == 961)
		strcpy (mh->scanner, "961");
	else if (mh7->system_type == 6)
		strcpy (mh->scanner, "pett6");
	else
		strcpy (mh->scanner, "");
	if (mh7->septa_state == 0)
		strcpy (mh->acquisition, "2d");
	else if (mh7->septa_state == 1)
		strcpy (mh->acquisition, "3d");
	else if (mh7->septa_state == -1)		/* for PETT VI */
		strcpy (mh->acquisition, "low");
	else if (mh7->septa_state == -2)		/* for PETT VI */
		strcpy (mh->acquisition, "high");
	else
		strcpy (mh->acquisition, "");
	strcpy (mh->reconstruction, "");
	strcpy (mh->filtername, "");
	mh->whole_header = (void *) mh7;
	return (mh);
}

/* =============================================================================
 *	Function:		mhnames6
 *	Description:	Fill main header names for archive from version 6 main and subheaders.
 * =============================================================================
 */
void     mhnames6 (mh, ish6)
	MainHeader     *mh;
	Image_subheader *ish6;

{
	if (strncmp (mh->acquisition, "sta", 3) == 0) {
		if (fabs(ish6->filter_params[0] - 1.0) <= CRIT)
			strcpy (mh->acquisition, "3d");
		else if (fabs(ish6->filter_params[0] - 0.5) <= CRIT)
			strcpy (mh->acquisition, "sta");
		else
			strcpy (mh->acquisition, "unknown");
	}

	if (fabs(ish6->filter_params[0] - 1.0) <= CRIT) {
		if (strstr (mh->sw_revision, "bkproj3d") != NULL
			&& strstr (mh->sw_revision, "scatcor") != NULL
			&& strstr (mh->filetime, "makenorm") != NULL)
			strcpy (mh->reconstruction, "3dbpjmon");
		else if (strstr (mh->sw_revision, "bkproj3d") != NULL
 			&& strstr (mh->filetime, "makenorm") != NULL)
			strcpy (mh->reconstruction, "3dbpjmos");
		else
			strcpy (mh->reconstruction, "3dbp");
	} else if (fabs(ish6->filter_params[0] - 0.5) <= CRIT)
		strcpy (mh->reconstruction, "fb");
	else if (fabs(ish6->filter_params[0] - 0.25) <= CRIT)
		strcpy (mh->reconstruction, "fb");
	else
		strcpy (mh->reconstruction, "unknown");

	if (abs(ish6->filter_code) == 1)
		strcpy (mh->filtername, "ramp");
	else if (ish6->filter_code == 2)
		strcpy (mh->filtername, "butterworth");
	else if (ish6->filter_code == 3)
		strcpy (mh->filtername, "hann");
	else if (ish6->filter_code == 4)
		strcpy (mh->filtername, "hamming");
	else if (ish6->filter_code == 5)
		strcpy (mh->filtername, "parzen");
	else if (ish6->filter_code == 6)
		strcpy (mh->filtername, "shepp");
	else if (abs(ish6->filter_code - 100) == 1)
		strcpy (mh->filtername, "3d_gaussian");
	else if (abs(ish6->filter_code - 200) == 1)
		strcpy (mh->filtername, "3d_butterworth");
	else
		strcpy (mh->filtername, "unknown");
}

/* =============================================================================
 *	Function:		mhnames7
 *	Description:	Fill main header names for archive from version 7 main and subheaders.
 * =============================================================================
 */
void     mhnames7 (mh, ish7)
	MainHeader     *mh;
	Image_subheader7 *ish7;

{
	if (fabs(ish7->filter_cutoff_frequency - 1.0) <= CRIT) {
		if (strstr (mh->sw_revision, "bkproj3d") != NULL
			&& strstr (mh->sw_revision, "scatcor") != NULL
			&& strstr (mh->filetime, "makenorm") != NULL)
			strcpy (mh->reconstruction, "3dbpjmon");
		else if (strstr (mh->sw_revision, "bkproj3d") != NULL
 			&& strstr (mh->filetime, "makenorm") != NULL)
			strcpy (mh->reconstruction, "3dbpjmos");
		else
			strcpy (mh->reconstruction, "3dbp");
	} else if (fabs(ish7->filter_cutoff_frequency - 0.5) <= CRIT) {
		if (ish7->filter_scatter_fraction > 0 && ish7->filter_scatter_slope > 0)
			strcpy (mh->reconstruction, "fb");
		else
			strcpy (mh->reconstruction, "fbu");
	} else
		strcpy (mh->reconstruction, "unknown");

	if (ish7->filter_code == 1)
		strcpy (mh->filtername, "ramp");
	else if (ish7->filter_code == 2)
		strcpy (mh->filtername, "butterworth");
	else if (ish7->filter_code == 3)
		strcpy (mh->filtername, "hann");
	else if (ish7->filter_code == 4)
		strcpy (mh->filtername, "hamming");
	else if (ish7->filter_code == 5)
		strcpy (mh->filtername, "parzen");
	else if (ish7->filter_code == 6)
		strcpy (mh->filtername, "shepp");
	else if (ish7->filter_code == 101)
		strcpy (mh->filtername, "3d_gaussian");
	else if (ish7->filter_code == 201)
		strcpy (mh->filtername, "3d_butterworth");
	else
		strcpy (mh->filtername, "unknown");
}

/* =============================================================================
 *	Function:		mh_to_mh6
 *	Description:	Allocate and fill a Version 6 main header
 *					using fields from the generic MainHeader.
 *	Note:	If a version 6 main header exists in the whole_header field of mh,
 *			then the pointer returned points to it.
 * =============================================================================
 */
Main_header    *mh_to_mh6 (mh)
	MainHeader     *mh;

{
	Main_header    *mh6;
	char            comment[32];
	char           *ptr;
	int             i;

	if (mh == NULL) {
		fprintf (stderr, "ERROR [mh_to_mh6]: Null MainHeader\n");
		return (NULL);
	}
	if (mh->whole_header != NULL && mh->file_format == MATRIX_REV6)
		mh6 = (Main_header *) mh->whole_header;
	else {
		mh6 = (Main_header *) malloc (sizeof (Main_header));
		mh6->sw_version = 6;
		mh6->isotope_halflife = 0.;
		mh6->gantry_tilt = 0.;
		mh6->gantry_rotation = 0.;
		mh6->rot_source_speed = 0;
		mh6->wobble_speed = 0;
		mh6->transm_source_type = 0;
		mh6->axial_fov = 0.;
		mh6->transaxial_fov = 0.;
		mh6->transaxial_samp_mode = 0;
		mh6->coin_samp_mode = 0;
		mh6->axial_samp_mode = 0;
		mh6->calibration_units = 0;
		mh6->compression_code = 0;
		mh6->acquisition_type = 0;
		mh6->bed_type = 0;
		mh6->septa_type = 0;
		mh6->lwr_sctr_thres = 0;
		mh6->lwr_sctr_thres = 0;
		mh6->lwr_true_thres = 0;
		mh6->upr_true_thres = 0;
		mh6->collimator = 0.;
		mh6->acquisition_mode = 0;
	}

	strncpy (mh6->original_file_name, mh->data_file, 19);
	if (mh->version != 6 && mh->version != 64 && mh->version != 65)
		mh6->sw_version = 6;
	if (mh->number_format == BYTE_DATA)
		mh6->data_type = BYTE_TYPE;
	else if (mh->number_format == SHORT_DATA)
		mh6->data_type = VAX_I2;
	else if (mh->number_format == FLOAT_DATA)
		mh6->data_type = IEEE_R4;
	else
		mh6->data_type = SUN_I2;
	mh6->system_type = mh->scanner_type;
	mh6->file_type = mh->filtyp;

	for (i = 0; i < 32; i++)
		comment[i] = ' ';
	ptr = mh->date_time;
	strncpy (comment, ptr+3, 2);
	mh6->scan_start_day = atoi (comment);
	strncpy (comment, ptr, 2);
	mh6->scan_start_month = atoi (comment);
	strncpy (comment, ptr+6, 2);
	mh6->scan_start_year = atoi (comment);
	strncpy (comment, ptr+10, 2);
	mh6->scan_start_hour = atoi (comment);
	strncpy (comment, ptr+13, 2);
	mh6->scan_start_minute = atoi (comment);
	strncpy (comment, ptr+16, 2);
	mh6->scan_start_second = atoi (comment);
	for (i = 0; i < 8; i++)
		mh6->isotope_code[i] = mh->isotope[i];
	
	for (i = 0; i < 32; i++)
		mh6->radiopharmaceutical[i] = mh->radiopharmaceutical[i];

	mh6->bed_elevation = mh->bed_elevation;
	mh6->calibration_factor = mh->calibration_factor;

	for (i = 0; i < 16; i++)
		mh6->patient_id[i] = mh->patnum[i];
	if (mh->sw_revision != NULL)
		strncpy (mh6->physician_name, mh->sw_revision, sizeof (mh6->physician_name) - 1);
	if (mh->filetime != NULL)
		strncpy (mh6->operator_name, mh->filetime, sizeof (mh6->operator_name) - 1);
	info2comment (mh, comment);
	strncpy (mh6->study_description, comment, 31);

	mh6->num_planes = mh->nplane;
	mh6->num_frames = mh->nframe;
	mh6->num_gates = mh->ngate;
	mh6->num_bed_pos = mh->nbed;
	mh6->bed_elevation = mh->bed_elevation;
	mh6->init_bed_position = mh->init_bed_pos;
	for (i = 0; i < 15; i++)
		mh6->bed_offset[i] = mh->bed_off[i];
	mh6->plane_separation = mh->slcthk;
	return (mh6);
}

/* =============================================================================
 *	Function:		mh_to_mh7
 *	Description:	Allocate and fill a Version 7 main header
 *					using fields from the generic MainHeader.
 *	Note:	If a version 7 main header exists in the whole_header field of mh,
 *			then the pointer returned points to it.
 * =============================================================================
 */
Main_header7   *mh_to_mh7 (mh)
	MainHeader     *mh;

{
	int             i;
	Main_header7   *mh7;
	char            comment[32];

	if (mh == NULL) {
		fprintf (stderr, "ERROR [mh_to_mh7]: Null MainHeader\n");
		return (NULL);
	}
	if (mh->whole_header != NULL && mh->file_format == MATRIX_REV7)
		mh7 = (Main_header7 *) mh->whole_header;
	else
		mh7 = (Main_header7 *) malloc (sizeof (Main_header7));

	mh7->system_type = mh->scanner_type;
	mh7->file_type = mh->filtyp;
	mh7->scan_start_time = mh->start_time;
	for (i = 0; i < 8; i++)
		mh7->isotope_code[i] = mh->isotope[i];
	for (i = 0; i < 16; i++)
		mh7->patient_id[i] = mh->patnum[i];
	mh7->num_planes = mh->nplane;
	mh7->num_frames = mh->nframe;
	mh7->num_gates = mh->ngate;
	mh7->num_bed_pos = mh->nbed;
	mh7->bed_elevation = mh->bed_elevation;
	mh7->init_bed_position = mh->init_bed_pos;
	for (i = 0; i < 16; i++)
		mh7->bed_offset[i] = mh->bed_off[i];
	mh7->plane_separation = mh->slcthk;

/*	For PETT VI images in MATRIX7 files */

	if (strncmp (mh->acquisition, "low", 3) == 1)
		mh7->septa_state == -1;
	else if (strncmp (mh->acquisition, "high", 4) == 1)
		mh7->septa_state == -2;

	info2comment (mh, comment);
	strncpy (mh7->study_description, comment, 31);
	if (mh->sw_revision != NULL)
		strncpy (mh7->physician_name, mh->sw_revision, sizeof (mh7->physician_name) - 1);
	if (mh->filetime != NULL)
		strncpy (mh7->operator_name, mh->filetime, sizeof (mh7->operator_name) - 1);
	return (mh7);
}

/* =============================================================================
 *	Function:		rdimg
 *	Description:	Read Version 6 or 7 image file
 * =============================================================================
 */
float          *rdimg (mh, filnam, plane, frame, gate, data, bed)
	MainHeader	   *mh;
	char           *filnam;
	int             plane, frame, gate, data, bed;

{
	float          *image;
	int             fformat;
	Main_header7    *mh7;
	Main_header     *mh6;

	fformat = mh->file_format;
	if (fformat == MATRIX_REV7) {
		mh7 = mh_to_mh7 (mh);
		image = rdimg7 (mh7, filnam, plane, frame, gate, data, bed);
	} else if (fformat == MATRIX_REV6) {
		mh6 = mh_to_mh6 (mh);
		image = rdimg6 (mh6, filnam, plane, frame, gate, data, bed);
	} else if (fformat == PETT6) {
		image = rdimgp6 (filnam, plane);
	} else if (fformat == INTERFILE) {
		image = rdimg_if (filnam, plane, frame);
	} else
		return (NULL);
	return (image);
}

/* =============================================================================
 *	Function:		putsbhdr
 *	Description:	Write Version 6, 7 or Interfile scan or image subheaders
 *					after converting a generic subheader.
 * =============================================================================
 */
int             putsbhdr (mh, sh, filnam, plane, frame, gate, data, bed)
	MainHeader     *mh;
	SubHeader      *sh;
	char           *filnam;
	int             plane, frame, gate, data, bed;

{
	int             fformat;
	DataSetType		dtype;
	Main_header7    *mh7;
	Main_header     *mh6;
	void           *sh1;

	fformat = mh->file_format;
	dtype = (DataSetType) mh->filtyp;

	if (fformat == MATRIX_REV7) {
		mh7 = mh_to_mh7 (mh);
		if (dtype == Sinogram)
			sh1 = (void *) sh_to_ssh7 (sh);
		else if (dtype == PetVolume)
			sh1 = (void *) sh_to_ish7 (sh);
		else {
			fprintf (stderr, "ERROR [putsbhr]: Unsupported data type %d in %s\n", dtype, filnam);
			return (ERROR);
		}
		if ((putsbhdr7 (mh7, sh1, filnam, plane, frame, gate, data, bed)) != NULL) {
			fprintf (stderr, "ERROR [putsbhr]: Error writing subheader for plane %d of %s\n",
				 plane, filnam);
			return (ERROR);
		}
		free (sh1);
	} else if (fformat == MATRIX_REV6) {
		mh6 = mh_to_mh6 (mh);
		if (dtype == Sinogram)
			sh1 = (void *) sh_to_ssh6 (sh);
		else if (dtype == PetImage)
			sh1 = (void *) sh_to_ish6 (sh);
		else {
			fprintf (stderr, "ERROR [putsbhr]: Unsupported data type %d in %s\n", dtype, filnam);
			return (ERROR);
		}
		if ((putsbhdr6 (mh6, sh1, filnam, plane, frame, gate, data, bed)) != NULL) {
			fprintf (stderr, "ERROR [putsbhr]: Error writing subheader for plane %d of %s\n",
				 plane, filnam);
			return (ERROR);
		}
	} else if (fformat == INTERFILE) {
		sh1 = (void *) sh_to_ifsh (sh);
		if (putsbhdr_if (sh1, filnam, plane, frame) != NULL) {
			fprintf (stderr, "ERROR [putsbhr]: Error writing subheader for plane %d of %s\n",
				 plane, filnam);
			return (ERROR);
		}
	} else {
		fprintf (stderr, "ERROR [putsbhr]: Unsupported file format %d in %s\n",
			fformat, filnam);
		return (ERROR);
	}
	return (OK);
}

/* =============================================================================
 *	Function:		putmhdr
 *	Description:	Write Version 6 or 7 scan or image main headers.
 * =============================================================================
 */
int             putmhdr (filnam, mh)
	char           *filnam;
	MainHeader     *mh;

{
	int     		fformat;
	Main_header7    *mh7;
	Main_header     *mh6;
	MainHeader_if   *mh1;

	fformat = mh->file_format;

	if (fformat == MATRIX_REV7) {
		mh7 =  mh_to_mh7 (mh);
		if ((putmhdr7 (filnam, mh7)) == ERROR) {
			fprintf (stderr, "ERROR [putmhdr]: Error writing main header for %s\n", filnam);
			return (ERROR);
		}
	} else if (fformat == MATRIX_REV6) {
		mh6 = mh_to_mh6 (mh);
		if ((putmhdr6 (filnam, mh6)) == ERROR) {
			fprintf (stderr, "ERROR [putmhdr]: Error writing main header for %s\n", filnam);
			return (ERROR);
		}
	} else if (fformat == INTERFILE) {
		mh1 = mh_to_ifmh (mh);
		if ((putmhdr_if (mh1, filnam)) != NULL) {
			fprintf (stderr, "ERROR [putmhdr]: Error writing main header for %s\n", filnam);
			return (ERROR);
		}
		free (mh1);
	} else {
		fprintf (stderr, "ERROR [putmhdr]: Unsupported file format %d for %s\n", fformat, filnam);
		return (ERROR);
	}
	return (OK);
}

/* =============================================================================
 *	Function:		wrimg
 *	Description:	Write Version 6 or 7 scan or image data.
 * =============================================================================
 */
int             wrimg (filnam, image, mh, sh, plane, frame, gate, data, bed)
	char           *filnam;
	float          *image;
	MainHeader     *mh;
	char           *sh;
	int             plane, frame, gate, data, bed;

{
	int				fformat;
	DataSetType		dtype;
	Main_header7   *mh7;
	Main_header    *mh6;
	MainHeader_if  *mh1;
	void           *sh1;
	PETT6HDR       *p6h;

	fformat = mh->file_format;
	dtype = (DataSetType) mh->filtyp;

	if (fformat == MATRIX_REV7) {
		mh7 = mh_to_mh7 (mh);
		if (dtype == Sinogram)
			sh1 = (void *) sh_to_ssh7 (sh);
		else if (dtype == PetVolume)
			sh1 = (void *) sh_to_ish7 (sh);
		else {
			fprintf (stderr, "ERROR [wrimg]: Unsupported data type %d in %s\n", dtype, filnam);
			return (ERROR);
		}
		if ((wrimg7 (filnam, image, mh7, sh1, plane, frame, gate, data, bed)) != NULL) {
			fprintf (stderr, "ERROR [wrimg]: Could not write plane %d to %s\n", plane, filnam);
			return (ERROR);
		}
		free (sh1);
	} else if (fformat == MATRIX_REV6) {
		mh6 = mh_to_mh6 (mh);
		if (dtype == Sinogram)
			sh1 = (void *) sh_to_ssh6 (sh);
		else if (dtype == PetImage)
			sh1 = (void *) sh_to_ish6 (sh);
		else {
			fprintf (stderr, "ERROR [wrimg]: Unsupported data type %d in %s\n", dtype, filnam);
			return (ERROR);
		}
		if ((wrimg6 (filnam, image, mh6, sh1, plane, frame, gate, data, bed)) != NULL) {
			fprintf (stderr, "ERROR [wrimg]: ERROR [wrimg]: Could not write ",
				 "plane %d to %s\n", plane, filnam);
			return (ERROR);
		}
	} else if (fformat == PETT6) {
		p6h = mh_to_p6h (mh, sh);
		if (wrimgp6 (filnam, image, p6h) != NULL) {
			fprintf (stderr, "ERROR [wrimg]: ERROR [wrimg]: Could not write ",
				 "plane %d to %s\n", plane, filnam);
			return (ERROR);
		}
	} else if (fformat == INTERFILE) {
		mh1 = mh_to_ifmh (mh);
		sh1 = (void *) sh_to_ifsh (sh);
		if ((wrimg_if (filnam, image, mh1, sh1, plane, frame)) != NULL) {
			fprintf (stderr, "ERROR [wrimg]: Could not write plane %d to %s\n", plane, filnam);
			return (ERROR);
		}
		free (sh1);
		free (mh1);
	} else {
		fprintf (stderr, "ERROR [wrimg]: Unsupported file format %d in %s\n", fformat, filnam);
		return (ERROR);
	}
	return (OK);
}

/* =============================================================================
 *  Function:       get_filetype
 *  Description:    Return type of file (types defined in imagio.h)
 *		1 = MATRIX_REV6
 *		2 = MATRIX_REV7
 *		3 = INTERFILE
 *		4 = PETT6
 * =============================================================================
 */
#define TESTLEN 28

int             get_filetype (filnam)
	char           *filnam;

{
	union conv {
		short           s[TESTLEN];
		char            c[2 * TESTLEN];
	}               test;

	FILE           *fp;
	int             filetype;
	short           system, data_type, sw_version;
	char            hdrfil[MAXFNAME], *ptr;

	if ((fp = fopen (filnam, "r")) == NULL) {
		fprintf (stderr, "ERROR [get_filetype]: Could not open %s\n", filnam);
		return (NULL);
	}
	if (fread (test.s, sizeof (short), TESTLEN, fp) != TESTLEN) {
		fprintf (stderr, "ERROR [get_filetype]: Could not read %s\n", filnam);
		return (NULL);
	}
	fclose (fp);
	test.c[TESTLEN - 1] = NULL;

	data_type = (((test.s[25] & 0xff) << 8) | ((test.s[25] & 0xff00) >> 8));
	if (data_type == VAX_I2) {
		system = (((test.s[26] & 0xff) << 8) | ((test.s[26] & 0xff00) >> 8));
		sw_version = (((test.s[24] & 0xff) << 8) | ((test.s[24] & 0xff00) >> 8));
	} else {
		system = test.s[26];
		sw_version = test.s[24];
	}

	if (strncmp (test.c, "MATRIX7", 7) == 0) /* Matrix file version 7. */
		filetype = MATRIX_REV7;
	else if (((system == 921) || (system == 951) || (system == 953) || (system == 961)) &&
		 ((sw_version == 64) || (sw_version == 6)))
		filetype = MATRIX_REV6;
	else if (strncmp (test.c, "**", 2) == 0)
		filetype = PETT6;
	else {
		strcpy (hdrfil, filnam);
		ptr = strrchr (hdrfil, '.');
		if (ptr != NULL)
			*ptr = NULL;
		strcat (hdrfil, ".ifh");
		if ((fp = fopen (hdrfil, "r")) == NULL)
			filetype = NULL;
		else {
			if (fread (test.s, sizeof (short), TESTLEN, fp) != TESTLEN) {
				filetype = NULL;
				fclose (fp);
			} else {
				if (strncmp (test.c, "INTERFILE", 9) == 0)	/* Interfile file. */
					filetype = INTERFILE;
				else
					filetype = NULL;
			}
		}
	}
	return (filetype);
}

/* =============================================================================
 *	Function:		free_mh
 *	Description:	free main header and its malloced data.
 * =============================================================================
 */

void            free_mh (mh)
	MainHeader     *mh;

{
	free (mh->data_file);
	free (mh->sw_revision);
	free (mh->filetime);
	free (mh->gen_data);
	free (mh->whole_header);
	free (mh);
}

/* =============================================================================
 *	Function:		free_sh
 *	Description:	free subheader and its malloced data.
 * =============================================================================
 */
void            free_sh (sh)
	SubHeader      *sh;

{
	free (sh->comment);
	free (sh->whole_header);
	free (sh);
}


/* =============================================================================
 *	Function:		make_mainheader
 *	Description:	Malloc and fill main header.
 * =============================================================================
 */
MainHeader     *make_mainheader (file_format, number_format, nplane, nframe, nbed)
	int             file_format, number_format, nplane, nframe, nbed;

{
	MainHeader     *mh;

	mh = (MainHeader *) malloc (sizeof (MainHeader));

	mh->data_file = NULL;
	mh->file_format = file_format;
	mh->number_format = number_format;
	mh->nplane = nplane;
	mh->ngate = 0;
	mh->nframe = nframe;
	mh->nbed = nbed;
	mh->version = 0;
	mh->filtyp = 0;
	mh->scanner_type = 0;
	strcpy (mh->date_time, " ");
	strcpy (mh->patnum, " ");
	mh->start_time = 0;
	mh->bed_elevation = 0.;
	mh->init_bed_pos = 0.;
	mh->slcthk = 0.;
	mh->calibration_factor = 1.;
	mh->sw_revision = NULL;
	mh->filetime = NULL;
	mh->whole_header = NULL;
	return (mh);
}

/* =============================================================================
 *	Function:		make_subheader
 *	Description:	Malloc and fill subheader.
 * =============================================================================
 */
SubHeader      *make_subheader (file_format, number_format, ndim, dim1, dim2, dim3,
				                sample_size_1, sample_size_2, sample_size_3)
	int             file_format, number_format, ndim, dim1, dim2, dim3;
	float           sample_size_1, sample_size_2, sample_size_3;

{
	SubHeader      *sh;

	sh = (SubHeader *) malloc (sizeof (SubHeader));

	sh->file_format = file_format;
	sh->number_format = number_format;
	sh->ndim = ndim;
	sh->dim1 = dim1;
	sh->dim2 = dim2;
	sh->dim3 = dim3;
	sh->sample_size_1 = sample_size_1;
	sh->sample_size_2 = sample_size_2;
	sh->sample_size_3 = sample_size_3;
	sh->ring_diff = 0;
	sh->total = 0;
	sh->delayeds = 0;
	sh->multiples = 0;
	sh->trues = 0;
	sh->count_rate = 0;
	sh->scale_factor = 1.;
	sh->calibration_factor = 1.;
	sh->min = 0;
	sh->max = 0;
	sh->deadtime_corr = 0.;
	sh->start_time = 0;
	sh->duration = 0;
	sh->comment = NULL;
	sh->whole_header = NULL;
	return (sh);
}

/* =============================================================================
 *	Function:		readimgfrm
 *	Description:	Read all planes of one frame into a 1-D array.
 * =============================================================================
 */
float              *readimgfrm (filnam, frame, mh, sh)
	char           *filnam;
	int				frame;
	MainHeader     *mh;
	SubHeader      *sh;

{
	Main_header7   *mh7;
	Main_header    *mh6;
	float			*image;
	float			*img;
    int             fformat;
	int				dim1, dim2, dim3, size;
	int				pln;
	int				indx, i;
	int				gate = 1, data = 0, bed = 0;

    fformat = mh->file_format;
	dim1 = sh->dim1;
	dim2 = sh->dim2;
	dim3 = sh->dim3;
	size = dim1 * dim2;

	if ((image = (float *) malloc (dim3 * size * sizeof (float))) ==  NULL) {
		fprintf (stderr, "ERROR [readimgfrm]: Cannot malloc image for %s\n",filnam);
		return (NULL);
	}

    if (fformat == MATRIX_REV7) {
        mh7 = mh_to_mh7 (mh);
		for (pln = 1; pln <= dim3; pln++) {
			indx = (pln-1) * size;
        	if ((img = rdimg7 (mh7, filnam, pln, frame, gate, data, bed)) == NULL) {
				fprintf (stderr, "ERROR [readimgfrm]: Cannot read frame %d plane %d of %s\n",
					frame, pln, filnam);
				return (NULL);
			}
			if (mh->orientation != 0)
				img = flipimg (img, mh, sh);
			for (i = 0; i < size; i++)
				image[indx + i] = img[i];
			free (img);
		}
    } else if (fformat == MATRIX_REV6) {
        mh6 = mh_to_mh6 (mh);
		for (pln = 1; pln <= dim3; pln++) {
			indx = (pln-1) * size;
        	if ((img = rdimg6 (mh6, filnam, pln, frame, gate, data, bed)) == NULL) {
				fprintf (stderr, "ERROR [readimgfrm]: Cannot read frame %d plane %d of %s\n",
					frame, pln, filnam);
				return (NULL);
			}
			if (mh->orientation != 0)
				img = flipimg (img, mh, sh);
			for (i = 0; i < size; i++)
				image[indx + i] = img[i];
			free (img);
		}
    } else if (fformat == PETT6) {
		for (pln = 1; pln <= dim3; pln++) {
			indx = (pln-1) * size;
        	if ((img = rdimgp6 (filnam, pln)) == NULL) {
				fprintf (stderr, "ERROR [readimgfrm]: Cannot read frame %d plane %d of %s\n",
					frame, pln, filnam);
				return (NULL);
			}
			for (i = 0; i < size; i++)
				image[indx + i] = img[i];
			free (img);
		}
    } else if (fformat == INTERFILE) {
		for (pln = 1; pln <= dim3; pln++) {
			indx = (pln-1) * size;
        	if ((img = rdimg_if (filnam, pln, frame)) == NULL) {
				fprintf (stderr, "ERROR [readimgfrm]: Cannot read frame %d plane %d of %s\n",
					frame, pln, filnam);
				return (NULL);
			}
			if (mh->orientation != 0)
				img = flipimg (img, mh, sh);
			for (i = 0; i < size; i++)
				image[indx + i] = img[i];
			free (img);
		}
    } else
        return (NULL);

    return (image);
} 

/* =============================================================================
 *	Function:		writeimgfrm
 *	Description:	Write all planes of one frame from a 1-D array.
 * =============================================================================
 */
int                 writeimgfrm (filnam, frame, mh, sh, image)
	char           *filnam;
	int				frame;
	MainHeader     *mh;
	SubHeader      *sh;
	float			*image;

{
	Main_header7   *mh7;
	Image_subheader7    *sh7;
	Main_header    *mh6;
	Image_subheader     *sh6;
	PETT6HDR	   *p6h;
	float			*img;
    int             fformat;
	int				dim1, dim2, dim3, size;
	int				pln;
	int				indx, i;
	int				gate = 1, data = 0, bed = 0;

    fformat = mh->file_format;
	dim1 = sh->dim1;
	dim2 = sh->dim2;
	dim3 = sh->dim3;
	size = dim1 * dim2;

	if ((img = (float *) malloc (size * sizeof (float))) ==  NULL) {
		fprintf (stderr, "ERROR [writeimgfrm]: Cannot malloc img for writing %s\n",filnam);
		return (ERROR);
	}

    if (fformat == MATRIX_REV7) {
        mh7 = mh_to_mh7 (mh);
        sh7 = sh_to_ish7 (sh);
		for (pln = 1; pln <= dim3; pln++) {
			indx = (pln-1) * size;
			for (i = 0; i < size; i++)
				img[i] = image[indx + i];
        	if (wrimg7 (filnam, img, mh7, sh7, pln, frame, gate, data, bed) == ERROR) {
				fprintf (stderr, "ERROR [writeimgfrm]: Cannot write frame %d plane %d of %s\n",
					frame, pln, filnam);
				free (img);
				return (ERROR);
			}
		}
		free (sh7);
    } else if (fformat == MATRIX_REV6) {
        mh6 = mh_to_mh6 (mh);
        sh6 = sh_to_ish6 (sh);
		for (pln = 1; pln <= dim3; pln++) {
			indx = (pln-1) * size;
			for (i = 0; i < size; i++)
				img[i] = image[indx + i];
        	if (wrimg6 (filnam, img, mh6, sh6, pln, frame, gate, data, bed) == ERROR) {
				fprintf (stderr, "ERROR [writeimgfrm]: Cannot write frame %d plane %d of %s\n",
					frame, pln, filnam);
				free (img);
				return (ERROR);
			}
		}
    } else if (fformat == PETT6) {
		for (pln = 1; pln <= dim3; pln++) {
        	p6h = mh_to_p6h (mh, sh);
			indx = (pln-1) * size;
			for (i = 0; i < size; i++)
				img[i] = image[indx + i];
        	if (wrimgp6 (filnam, img, p6h) == ERROR) {
				fprintf (stderr, "ERROR [writeimgfrm]: Cannot write frame %d plane %d of %s\n",
					frame, pln, filnam);
				free (img);
				return (ERROR);
			}
		}
    } else if (fformat == INTERFILE) {
		for (pln = 1; pln <= dim3; pln++) {
			indx = (pln-1) * size;
			for (i = 0; i < size; i++)
				img[i] = image[indx + i];
        	if (wrimg_if (filnam, img, mh, sh, pln, frame) == ERROR) {
				fprintf (stderr, "ERROR [writeimgfrm]: Cannot write frame %d plane %d of %s\n",
					frame, pln, filnam);
				free (img);
				return (ERROR);
			}
		}
    } else {
		free (img);
        return (ERROR);
	}
	free (img);
    return (OK);
}

/* =============================================================================
 *	Function:		flipimg
 *	Description:	Reverse right/left in an image.
 * =============================================================================
 */
float          *flipimg (img, mh, sh)
	float          *img;
	MainHeader     *mh;
	SubHeader      *sh;

{
	float          *rimg;
	int             xdim, ydim, len;
	int             i, j, m, n;

	xdim = sh->dim1;
	ydim = sh->dim2;
	len = xdim * ydim;
	if ((rimg = (float *) malloc (len * sizeof (float))) == NULL) {
		fprintf (stderr, "ERROR [flipimg]: Could not malloc memory for rimg\n");
		return (NULL);
	}
	for (j = 0; j < ydim; j++) {
		m = j * xdim;
		n = (j + 1) * xdim - 1;
		for (i = 0; i < xdim; i++)
			rimg[m + i] = img[n - i];
	}
	mh->orientation = 0;
	free (img);
	return (rimg);
}

/* =============================================================================
 *	Function:		padplane
 *	Description:	Pad a 2-D image (single plane) with zeros in x- and y-dimensions.
 * =============================================================================
 */
float          *padplane (img, sh, newx, newy)
	float          *img;
	SubHeader      *sh;
	int				newx;
	int				newy;

{
	float          *pimg;
	int             xdim, ydim, len;
	int             ix, jx, i, j, m, n;

	xdim = sh->dim1;
	ydim = sh->dim2;
	if (xdim >= newx && ydim >= newy)
		return (img);

	len = newx * newy;
	if ((pimg = (float *) calloc (len, sizeof (float))) == NULL) {
		fprintf (stderr, "ERROR [padxyimg]: Could not malloc memory for pimg\n");
		return (NULL);
	}
	if (newx >= xdim)
		ix = (newx-xdim)/2;
	else
		ix = 0;
	if (newy >= ydim)
		jx = (newy-ydim)/2;
	else
		jx = 0;

	for (j = 0; j < ydim; j++) {
		n = ((j + jx) * newx) + ix;
		m = (j * xdim);
		for (i = 0; i < xdim; i++)
			pimg[n + i] = img[m + i];
	}
	sh->dim1 = newx;
	sh->dim2 = newy;
	free (img);
	return (pimg);
}

/* =============================================================================
 *	Function:		existimgfrm
 *	Description:	Check if an image frame exists.
 *					Bypasses calls with error messages.
 * =============================================================================
 */

int      existimgfrm (mh, filnam, plane, frame, gate, data, bed)
	MainHeader     *mh;
	char           *filnam;
	int             plane, frame, gate, data, bed;

{
	int             fformat;

	fformat = mh->file_format;
	if (fformat == MATRIX_REV7)
		return (existfrm7 (mh, filnam, frame, gate, data, bed));
	else if (fformat == MATRIX_REV6)
		return (existfrm6 (mh, filnam, plane, frame, gate, data, bed));
	else if (fformat == PETT6)
		return (existp6 (filnam));
	else if (fformat == INTERFILE)		/* implement this later */
		return (OK);
	else
		return (ERROR);
}
/* =============================================================================
 *	Function:		scale_ish
 *	Description:	Scale and image by changing subheader scale factors.
 *	Note:	Avoids assumption of SUN data type made by putsbhdr.
 * =============================================================================
 */
int      scale_ish (mh, filnam, frame, gate, data, bed, factor)
	MainHeader     *mh;
	char           *filnam;
	int             frame, gate, data, bed;
	float			factor;

{
	int             fformat;
	DataSetType		datatype;
	Main_header7    *mh7;
	Main_header     *mh6;
	int				stat;
	int				pln, nplanes;

	fformat = mh->file_format;
	datatype = (DataSetType ) mh->filtyp;

	if (fformat == MATRIX_REV7) {
		mh7 = mh_to_mh7 (mh);
		if (datatype != PetVolume) {
			fprintf (stderr, "ERROR [scale_ish]: Unsupported data type %d\n", datatype);
			return (ERROR);
		}
		stat = scale_ish7 (mh7, filnam, frame, gate, data, bed, factor);
		if (stat != 0)
			return (ERROR);
		return (OK);

	} else if (fformat == MATRIX_REV6) {
		mh6 = mh_to_mh6 (mh);
		if (datatype != PetImage) {
			fprintf (stderr, "ERROR [scale_ish]: Unsupported data type %d\n", datatype);
			return (ERROR);
		}
		nplanes = mh->nplane;
		for (pln = 1; pln <= nplanes; pln++) {
			stat = scale_ish6 (mh6, filnam, pln, frame, gate, data, bed, factor);
			if (stat != 0)
				return (ERROR);
		}
		return (OK);

	} else if (fformat == PETT6) {
		fprintf (stderr, "ERROR [scale_ish]: PETT6 format not supported\n");
		return (ERROR);

	} else if (fformat == INTERFILE) {
		fprintf (stderr, "ERROR [scale_ish]: INTERFILE format not supported\n");
		return (ERROR);

	} else {
		fprintf (stderr, "ERROR [scale_ish]: Unsupported file format\n");
		return (ERROR);
	}
	
}
@


1.14
log
@set sh->calibration_factor to 1 when it is 0 (problem with ver 6 3D images)
@
text
@d1 1
a1 1
/*  $Id: cti.c,v 1.13 1996/01/03 19:50:06 tom Exp tom $
d3 3
d88 1
a88 1
static char     rcsid[] = "$Header: /home/npggw/tom/src/libimg/RCS/cti.c,v 1.13 1996/01/03 19:50:06 tom Exp tom $";
d570 1
a570 1
	else
d572 15
d790 2
d798 4
d926 1
d928 1
a928 1
	Main_header    *mh6;
d937 1
a937 1
	else
d939 24
d964 3
d977 25
d1004 7
d1019 1
a1019 6
	info2comment (mh, comment);
	strncpy (mh6->study_description, comment, 31);
	if (mh->sw_revision != NULL)
		strncpy (mh6->physician_name, mh->sw_revision, sizeof (mh6->physician_name) - 1);
	if (mh->filetime != NULL)
		strncpy (mh6->operator_name, mh->filetime, sizeof (mh6->operator_name) - 1);
d1051 2
d1064 8
@


1.13
log
@fixed identification of reconstruction and filtername
@
text
@d1 1
a1 1
/*  $Id: cti.c,v 1.12 1996/01/03 18:03:48 tom Exp tom $
d3 3
d85 1
a85 1
static char     rcsid[] = "$Header: /home/npggw/tom/src/libimg/RCS/cti.c,v 1.12 1996/01/03 18:03:48 tom Exp tom $";
d390 2
@


1.12
log
@add mh fields for archive type identification
@
text
@d1 1
a1 1
/*  $Id: cti.c,v 1.11 1995/12/20 04:18:42 tom Exp tom $
d3 3
d82 1
a82 1
static char     rcsid[] = "$Header: /home/npggw/tom/src/libimg/RCS/cti.c,v 1.11 1995/12/20 04:18:42 tom Exp tom $";
d791 1
a791 1
	if (mh->acquisition == 0) {
d810 1
a810 1
	} else if (fabs(ish6->filter_params[0] - 0.25) <= CRIT)
d812 2
d817 1
a817 1
	if (ish6->filter_code == 1)
@


1.11
log
@date format forced to 2 digits per item
@
text
@d1 1
a1 1
/*  $Id: cti.c,v 1.10 1995/12/15 21:25:20 tom Exp tom $
d3 3
d55 2
d79 1
a79 1
static char     rcsid[] = "$Header: /home/npggw/tom/src/libimg/RCS/cti.c,v 1.10 1995/12/15 21:25:20 tom Exp tom $";
d101 2
d142 1
d164 1
d643 2
d698 12
d760 14
d776 102
@


1.10
log
@add scale_ish
@
text
@d1 1
a1 1
/*  $Id: cti.c,v 1.9 1995/12/13 23:04:36 tom Exp tom $
d3 3
d74 1
a74 1
static char     rcsid[] = "$Header: /home/npggw/tom/src/libimg/RCS/cti.c,v 1.9 1995/12/13 23:04:36 tom Exp tom $";
d640 1
d659 7
a665 2
	sprintf (mh->date_time, "%d/%d/%02d, %d:%02d:%02d",
		 mh6->scan_start_month, mh6->scan_start_day, mh6->scan_start_year,
d684 1
d715 1
a715 1
	sprintf (mh->date_time, "%d/%d/%02d, %d:%02d:%02d", ptm->tm_mon + 1, ptm->tm_mday,
d734 1
d1151 1
@


1.9
log
@fixed data_type <-> number_format in header conversions
@
text
@d1 1
a1 1
/*  $Id: cti.c,v 1.8 1995/12/13 21:11:30 tom Exp tom $
d3 3
d65 1
d71 1
a71 1
static char     rcsid[] = "$Header: /home/npggw/tom/src/libimg/RCS/cti.c,v 1.8 1995/12/13 21:11:30 tom Exp tom $";
d1536 62
@


1.8
log
@*** empty log message ***
@
text
@d1 1
a1 1
/*  $Id: cti.c,v 1.7 1995/12/12 17:58:17 tom Exp tom $
d3 3
d67 1
a67 1
static char     rcsid[] = "$Header: /home/npggw/tom/src/libimg/RCS/cti.c,v 1.7 1995/12/12 17:58:17 tom Exp tom $";
d189 8
a196 1
	sh->number_format = ssh7->data_type;
d243 8
a250 1
	sh->number_format = ish7->data_type;
d296 8
d349 8
a356 1
	sh->number_format = ish6->data_type;
d408 8
a415 1
	ssh7->data_type = sh->number_format;
d459 8
a466 1
	ish7->data_type = sh->number_format;
d505 8
a512 1
	ssh6->data_type = sh->number_format;
d546 8
a553 1
	ish6->data_type = sh->number_format;
a692 1
	mh->number_format = SHORT_DATA;
d757 2
@


1.7
log
@time -> ptm
@
text
@d1 1
a1 1
/*  $Id: cti.c,v 1.6 1995/12/11 19:07:43 tom Exp tom $
d3 3
d64 1
a64 1
static char     rcsid[] = "$Header: /home/npggw/tom/src/libimg/RCS/cti.c,v 1.6 1995/12/11 19:07:43 tom Exp tom $";
d836 1
a863 1
	free (sh1);
d886 1
a886 1
		if ((putmhdr7 (filnam, mh7)) != NULL) {
d892 1
a892 1
		if ((putmhdr6 (filnam, mh6)) != NULL) {
a895 1
		free (mh6);
@


1.6
log
@add existimgfrm
@
text
@d1 1
a1 1
/*  $Id: cti.c,v 1.5 1995/12/07 14:45:10 tom Exp tom $
d3 3
d61 1
a61 1
static char     rcsid[] = "$Header: /home/npggw/tom/src/libimg/RCS/cti.c,v 1.5 1995/12/07 14:45:10 tom Exp tom $";
d625 1
a625 1
	struct tm      *time;
d638 3
a640 3
	time = localtime (&mh7->scan_start_time);
	sprintf (mh->date_time, "%d/%d/%02d, %d:%02d:%02d", time->tm_mon + 1, time->tm_mday,
		 time->tm_year, time->tm_hour, time->tm_min, time->tm_sec);
@


1.5
log
@changed padding in padtensor
@
text
@d1 1
a1 1
/*  $Id: cti.c,v 1.4 1995/12/04 21:44:28 tom Exp tom $
d3 3
a49 5
 *		readtensor	-	Read one frame of an image into a Numerical Recipes 3-D tensor.
 *		writetensor	-	Write one frame of an image from a Numerical Recipes 3-D tensor.
 *		padtensor	-	Pad tensor (with cosine interpolation in dim3).
 *		trimtensor	-	Trim tensor.
 *		freetensor	-	Free tensor, MainHeader and SubHeader.
d51 4
d58 1
a58 1
static char     rcsid[] = "$Header: /home/npggw/tom/src/libimg/RCS/cti.c,v 1.4 1995/12/04 21:44:28 tom Exp tom $";
d1361 2
a1362 2
 *	Function:		readtensor
 *	Description:	Read one frame of an image into a Numerical Recipes 3-D tensor.
d1365 2
a1366 3
float            ***readtensor (filnam, frame, mh, sh)
	char           *filnam;
	int				frame;
d1371 3
a1373 9
	Main_header7   *mh7;
	Main_header    *mh6;
	float		 ***image;
	float			*img;
    int             fformat;
	int				reverse;
	long			dim1, dim2, dim3;
	long			i, j, indx, pln;
	int				gate = 1, data = 0, bed = 0;
d1375 5
a1379 8
    fformat = mh->file_format;
	reverse = mh->orientation;
	dim1 = (long) sh->dim1;
	dim2 = (long) sh->dim2;
	dim3 = (long) sh->dim3;

	if ((image = f3tensor(1, dim3, 1, dim2, 1, dim1)) ==  NULL) {
		fprintf (stderr, "ERROR [readtensor]: Cannot malloc image for %s\n",filnam);
d1382 5
a1386 113

    if (fformat == MATRIX_REV7) {
        mh7 = mh_to_mh7 (mh);
		for (pln = 1; pln <= dim3; pln++) {
        	if ((img = rdimg7 (mh7, filnam, pln, frame, gate, data, bed)) == NULL) {
				fprintf (stderr, "ERROR [readimgfrm]: Cannot read frame %d plane %d of %s\n",
					frame, pln, filnam);
				return (NULL);
			}
			if (reverse != 0)
				img = flipimg (img, mh, sh);
			indx = 0;
			for (j = 1; j <= dim2; j++) {
				for (i = 1; i <= dim1; i++) {
					image[pln][j][i] = img[indx];
					indx++;
				}
			}
			free (img);
		}
    } else if (fformat == MATRIX_REV6) {
        mh6 = mh_to_mh6 (mh);
		for (pln = 1; pln <= dim3; pln++) {
        	if ((img = rdimg6 (mh6, filnam, pln, frame, gate, data, bed)) == NULL) {
				fprintf (stderr, "ERROR [readimgfrm]: Cannot read frame %d plane %d of %s\n",
					frame, pln, filnam);
				return (NULL);
			}
			if (reverse != 0)
				img = flipimg (img, mh, sh);
			indx = 0;
			for (j = 1; j <= dim2; j++) {
				for (i = 1; i <= dim1; i++) {
					image[pln][j][i] = img[indx];
					indx++;
				}
			}
			free (img);
		}
    } else if (fformat == PETT6) {
		for (pln = 1; pln <= dim3; pln++) {
        	if ((img = rdimgp6 (filnam, pln)) == NULL) {
				fprintf (stderr, "ERROR [readimgfrm]: Cannot read frame %d plane %d of %s\n",
					frame, pln, filnam);
				return (NULL);
			}
			indx = 0;
			for (j = 1; j <= dim2; j++) {
				for (i = 1; i <= dim1; i++) {
					image[pln][j][i] = img[indx];
					indx++;
				}
			}
			free (img);
		}
    } else if (fformat == INTERFILE) {
		for (pln = 1; pln <= dim3; pln++) {
        	if ((img = rdimg_if (filnam, pln, frame)) == NULL) {
				fprintf (stderr, "ERROR [readimgfrm]: Cannot read frame %d plane %d of %s\n",
					frame, pln, filnam);
				return (NULL);
			}
			if (reverse != 0)
				img = flipimg (img, mh, sh);
			indx = 0;
			for (j = 1; j <= dim2; j++) {
				for (i = 1; i <= dim1; i++) {
					image[pln][j][i] = img[indx];
					indx++;
				}
			}
			free (img);
		}
    } else
        return (NULL);

    return (image);
} 

/* =============================================================================
 *	Function:		writetensor
 *	Description:	Write one frame of an image into a Numerical Recipes 3-D tensor.
 * =============================================================================
 */
int                 writetensor (filnam, frame, mh, sh, image)
	char           *filnam;
	int				frame;
	MainHeader     *mh;
	SubHeader      *sh;
	float		***image;

{
	Main_header7   *mh7;
	Image_subheader7    *sh7;
	Main_header    *mh6;
	Image_subheader     *sh6;
	PETT6HDR	   *p6h;
	float			*img;
    int             fformat;
	long			size;
	long			dim1, dim2, dim3;
	long			indx, pln, i, j;
	int				gate = 1, data = 0, bed = 0;

    fformat = mh->file_format;
	dim1 = (long) sh->dim1;
	dim2 = (long) sh->dim2;
	dim3 = (long) sh->dim3;
	size = (sh->dim1) * (sh->dim2);

	if ((img = (float *) malloc (size * sizeof (float))) ==  NULL) {
		fprintf (stderr, "ERROR [writetensor]: Cannot malloc img for writing %s\n",filnam);
		return (ERROR);
d1388 1
a1388 75

    if (fformat == MATRIX_REV7) {
        mh7 = mh_to_mh7 (mh);
        sh7 = sh_to_ish7 (sh);
		for (pln = 1; pln <= dim3; pln++) {
			indx = 0;
			for (j = 1; j <= dim2; j++) {
				for (i = 1; i <= dim1; i++) {
					img[indx] = image[pln][j][i];
					indx++;
				}
			}
        	if (wrimg7 (filnam, img, mh7, sh7, pln, frame, gate, data, bed) == ERROR) {
				fprintf (stderr, "ERROR [writetensor]: Cannot write frame %d plane %d of %s\n",
					frame, pln, filnam);
				free (img);
				return (ERROR);
			}
		}
		free (sh7);
    } else if (fformat == MATRIX_REV6) {
        mh6 = mh_to_mh6 (mh);
        sh6 = sh_to_ish6 (sh);
		for (pln = 1; pln <= dim3; pln++) {
			indx = 0;
			for (j = 1; j <= dim2; j++) {
				for (i = 1; i <= dim1; i++) {
					img[indx] = image[pln][j][i];
					indx++;
				}
			}
        	if (wrimg6 (filnam, img, mh6, sh6, pln, frame, gate, data, bed) == ERROR) {
				fprintf (stderr, "ERROR [writetensor]: Cannot write frame %d plane %d of %s\n",
					frame, pln, filnam);
				free (img);
				return (ERROR);
			}
		}
    } else if (fformat == PETT6) {
		for (pln = 1; pln <= dim3; pln++) {
        	p6h = mh_to_p6h (mh, sh);
			indx = 0;
			for (j = 1; j <= dim2; j++) {
				for (i = 1; i <= dim1; i++) {
					img[indx] = image[pln][j][i];
					indx++;
				}
			}
        	if (wrimgp6 (filnam, img, p6h) == ERROR) {
				fprintf (stderr, "ERROR [writetensor]: Cannot write frame %d plane %d of %s\n",
					frame, pln, filnam);
				free (img);
				return (ERROR);
			}
		}
    } else if (fformat == INTERFILE) {
		for (pln = 1; pln <= dim3; pln++) {
			indx = 0;
			for (j = 1; j <= dim2; j++) {
				for (i = 1; i <= dim1; i++) {
					img[indx] = image[pln][j][i];
					indx++;
				}
			}
        	if (wrimg_if (filnam, img, mh, sh, pln, frame) == ERROR) {
				fprintf (stderr, "ERROR [writetensor]: Cannot write frame %d plane %d of %s\n",
					frame, pln, filnam);
				free (img);
				return (ERROR);
			}
		}
    } else {
		free (img);
        return (ERROR);
	}
d1390 1
a1390 1
    return (OK);
d1394 2
a1395 4
 *	Function:		padtensor
 *	Description:	Pad tensor
 *	Note:			Copy top and bottom slices to 3 adjacent slices and then
 *					ramp down to zero over next 6 slices.
d1398 5
a1403 5
float            ***padtensor (old, od1, od2, od3, nd1, nd2, nd3)
	float		 ***old;
	long			od1, od2, od3;		/* original dimensions */
	long			nd1, nd2, nd3;		/* new dimensions */

d1405 3
a1407 22
	float		***new;
	long		   i, j, k;
	long		   ix, jx, kx;	/* offset of new tensor */
	long		   k1, k2;		/* first and last original slice in new */
	float		   f;			/* scaling fraction */
	
	if ((new = f3tensor(1, nd3, 1, nd2, 1, nd1)) ==  NULL) {
		fprintf (stderr, "ERROR [padtensor]: Cannot malloc new tensor\n");
		return (NULL);
	}
	if (nd1 >= od1)
		ix = (nd1-od1)/2;
	else
		ix = 0;
	if (nd2 >= od2)
		jx = (nd2-od2)/2;
	else
		jx = 0;
	if (nd3 >= od3)
		kx = (nd3-od3)/2;
	else
		kx = 0;
d1409 4
a1412 31
	for (k = 1; k <= nd3; k++)
		for (j = 1; j <= nd2; j++)
			for (i = 1; i <= nd1; i++)
				new[k][j][i] = 0.;
	
	for (k = 1; k <= od3; k++)
		for (j = 1; j <= od2; j++)
			for (i = 1; i <= od1; i++)
				new[k + kx][j + jx][i + ix] = old[k][j][i];
	
	if (kx >= 9) {
		k1 = kx+1;
		k2 = kx+od3;
		for (k = 1; k <= 9 ; k++) {
			if (k < 4)
				f = 1.0;
			else
				f = (float) (10-k) / 7.;
			for (j = 1; j <= nd2; j++) {
				for (i = 1; i <= nd1; i++) {
					new[k1-k][j][i] = f * new[k1][j][i];
					new[k2+k][j][i] = f * new[k2][j][i];
				}
			}
		}
	} else
		fprintf (stderr,"Warning [padtensor]: May be inadequate padding in dim3\n");
	
	free_f3tensor (old, 1, od3, 1, od2, 1, od1);
	return (new);
}
d1414 3
a1416 18
/* =============================================================================
 *	Function:		trimtensor
 *	Description:	Trim tensor
 * =============================================================================
 */

float            ***trimtensor (old, od1, od2, od3, nd1, nd2, nd3)
	float		 ***old;
	long			od1, od2, od3;		/* original dimensions */
	long			nd1, nd2, nd3;		/* new dimensions */

{
	float		***new;
	long		   i, j, k;
	long		   ix, jx, kx;	/* offset of new tensor */
	
	if ((new = f3tensor(1, nd3, 1, nd2, 1, nd1)) ==  NULL) {
		fprintf (stderr, "ERROR [trimtensor]: Cannot malloc new tensor\n");
d1419 2
a1420 2
	if (od1 >= nd1)
		ix = (od1-nd1)/2;
d1423 2
a1424 2
	if (od2 >= nd2)
		jx = (od2-nd2)/2;
a1426 4
	if (od3 >= nd3)
		kx = (od3-nd3)/2;
	else
		kx = 0;
d1428 10
a1437 7
	for (k = 1; k <= nd3; k++)
		for (j = 1; j <= nd2; j++)
			for (i = 1; i <= nd1; i++)
				new[k][j][i] = old[k + kx][j + jx][i + ix];
	
	free_f3tensor (old, 1, od3, 1, od2, 1, od1);
	return (new);
d1439 1
d1441 3
a1443 2
 *	Function:		freetensor
 *	Description:	Free tensor and it main and subheaders.
d1447 1
a1447 1
void            freetensor (mh, sh, img)
d1449 2
a1450 2
	SubHeader      *sh;
	float		 ***img;
d1453 1
a1453 1
	long			dim1, dim2, dim3;
d1455 11
a1465 39
	dim1 = (long) sh->dim1;
	dim2 = (long) sh->dim2;
	dim3 = (long) sh->dim3;
	free_f3tensor(img, 1, dim3, 1, dim2, 1, dim1);
	free_sh (sh);
	free_mh (mh);
}

/* =============================================================================
 *	Function:		flipimg
 *	Description:	Reverse right/left in an image.
 * =============================================================================
 */
float          *flipimg (img, mh, sh)
	float          *img;
	MainHeader     *mh;
	SubHeader      *sh;

{
	float          *rimg;
	int             xdim, ydim, len;
	int             i, j, m, n;

	xdim = sh->dim1;
	ydim = sh->dim2;
	len = xdim * ydim;
	if ((rimg = (float *) malloc (len * sizeof (float))) == NULL) {
		fprintf (stderr, "ERROR [flipimg]: Could not malloc memory for rimg\n");
		return (NULL);
	}
	for (j = 0; j < ydim; j++) {
		m = j * xdim;
		n = (j + 1) * xdim - 1;
		for (i = 0; i < xdim; i++)
			rimg[m + i] = img[n - i];
	}
	mh->orientation = 0;
	free (img);
	return (rimg);
@


1.4
log
@add tensor functions
@
text
@d1 1
a1 1
/*  $Id: cti.c,v 1.3 1995/12/01 21:55:53 tom Exp tom $
d3 3
d20 1
a20 1
 *  Description:    Routines for ECAT image I/O
d49 1
a49 1
 *		padtensor	-	Pad tensor.
d56 1
a56 1
static char     rcsid[] = "$Header: /export/home/npggw/tom/src/libimg/RCS/cti.c,v 1.3 1995/12/01 21:55:53 tom Exp tom $";
d799 1
a799 1
	void           *sh;
d1586 2
d1600 2
d1629 18
@


1.3
log
@*** empty log message ***
@
text
@d1 1
a1 1
/*  $Id: cti.c,v 1.2 1995/11/30 18:19:00 tom Exp tom $
d3 3
d44 6
a49 1
 *		wrimg_easy	-	Write image.
d53 1
a53 1
static char     rcsid[] = "$Header: /home/npggw/tom/src/libimg/RCS/cti.c,v 1.2 1995/11/30 18:19:00 tom Exp tom $";
d63 2
d1025 1
a1025 1
		 (sw_version == 6))
d1083 1
d1356 2
a1357 2
 *	Function:		wrimg_easy
 *	Description:
d1360 1
a1360 3
int             wrimg_easy (filnam, image, plane, file_format, number_format, ndim, dim1, dim2, dim3,
			                    sample_size_1, sample_size_2, sample_size_3)
	float          *image;
d1362 3
a1364 2
	int             plane, ndim, number_format, dim1, dim2, dim3;
	float           sample_size_1, sample_size_2, sample_size_3;
d1367 107
d1476 1
d1478 21
a1498 2
	if (file_format != MATRIX_REV7 && file_format != INTERFILE) {
		fprintf (stderr, "Illegal file format in wrimg_vol.\n");
a1500 1
	mh = make_mainheader (file_format, number_format, dim3, 1, 1);
d1502 73
a1574 7
	sh = make_subheader (file_format, number_format, ndim, dim1, dim2, dim3,
			     sample_size_1, sample_size_2, sample_size_3);

	if ((wrimg (filnam, image, mh, sh, plane, 1, 1, 0, 0)) != NULL) {
		free (mh);
		free (sh);
		return (ERROR);
d1576 145
a1720 3
	free (sh);
	free (mh);
	return (NULL);
@


1.2
log
@*** empty log message ***
@
text
@d1 1
a1 1
/*  $Id: cti.c,v 1.1 1995/11/28 20:11:33 tom Exp tom $
d3 3
d39 2
d45 1
a45 1
static char     rcsid[] = "$Header: /home/npggw/tom/src/libimg/RCS/cti.c,v 1.1 1995/11/28 20:11:33 tom Exp tom $";
d118 1
a118 1
				sh = ssh6_to_sh (ssh6);
d124 1
a124 1
				sh = ish6_to_sh (ish6);
d248 1
a248 1
SubHeader      *ssh6_to_sh (ssh6)
d250 1
d262 1
a262 1
	sh->dim3 = 1;
d294 1
a294 1
SubHeader      *ish6_to_sh (ish6)
d296 1
d308 1
a308 1
	sh->dim3 = ish6->slice_width;
d1149 193
@


1.1
log
@Initial revision
@
text
@d1 5
a5 2
/*  $Id$
    $Log$
d40 1
a40 1
static char     rcsid[] = "$Header$";
a50 4
#define MAX_FILES 50
#define MAXFNAME 120
#define TESTLEN 28

d62 2
a63 1
SubHeader      *getsbhdr (filnam, plane, frame, gate, data, bed)
d65 2
a66 1
	int             frame, gate, data, bed;
d68 2
a69 3

	int             filetype;
	int             datatype;
d71 2
d80 2
a81 2
	filetype = get_filetype (filnam);
	datatype = get_datatype (filnam);
d83 4
a86 3
	if (filetype == MATRIX_REV7) {		 /* Matrix file version 7. */
		if (datatype == RAW_DATA) {	 /* 3D scan file. */
			ssh7 = (Scan3D_subheader7 *) getsbhdr7 (filnam, frame, gate, data, bed);
d93 2
a94 2
		} else if (datatype == IMAGE_DATA) {	/* 3D image file. */
			ish7 = (Image_subheader7 *) getsbhdr7 (filnam, frame, gate, data, bed);
d97 1
a97 1
			else {
a98 2
				free (ish7);
			}
d100 2
a101 2
			fprintf (stderr, "ERROR [getsbhdr]: Data type %d ",
				 "not recognized, %f\n", datatype, filnam);
d106 4
a109 3
	} else if (filetype == MATRIX_REV6) {	 /* Matrix file version 6. */
		if (datatype == RAW_DATA) {	 /* Scan file. */
			ssh6 = (Scan_subheader *) getsbhdr6 (filnam, plane, frame, gate, data, bed);
d114 2
a115 2
		} else if (datatype == IMAGE_DATA) {	/* 3D image file. */
			ish6 = (Image_subheader *) getsbhdr6 (filnam, plane, frame, gate, data, bed);
d121 2
a122 2
			fprintf (stderr, "ERROR [getsbhdr]: Data type %d ",
				 "not recognized, %f\n", datatype, filnam);
d127 1
a127 1
	} else if (filetype == PETT6) {
d130 1
a130 1
		else {
a131 1
		}
d134 1
a134 1
	} else if (filetype == INTERFILE) {	 /* Interfile file. */
d153 1
a154 1

d234 1
a234 2
	sh->whole_header = ish7->whole_header;

a237 1

a279 1

a324 1

d338 2
a339 2
	short			 *hdr, *hdr0;
	int				i;
d343 1
a343 1
		hdr = (short *) ssh7; 
d346 1
a346 1
        	hdr[i] = hdr0[i];
a347 1

a367 1

d382 2
a383 2
	short			 *hdr, *hdr0;
	int				i;
d387 1
a387 1
		hdr = (short *) ish7; 
d390 1
a390 1
        	hdr[i] = hdr0[i];
a391 1

a411 2
	ish7->whole_header = sh->whole_header;

a484 1

d503 1
a503 1
	int             filetype;
d507 1
a507 1
	MainHeader_if  *ifmh;
d510 1
a510 1
	filetype = get_filetype (filnam);
d512 1
a512 1
	if (filetype == MATRIX_REV7) {		 /* Matrix file version 7 */
d515 1
a515 2
		free (mh7);
	} else if (filetype == MATRIX_REV6) {	 /* Matrix file version 6 */
d518 1
a518 1
	} else if (filetype == PETT6) {		 /* PETT VI */
d521 3
a523 3
	} else if (filetype == INTERFILE) {	 /* Interfile file. */
		ifmh = getmhdr_if (filnam);
		mh = ifmh_to_mh (ifmh);
d525 1
d581 4
a584 4
    mh->sw_revision = (char *) malloc (strlen (mh6->physician_name) + 1);
    strcpy (mh->sw_revision, mh6->physician_name);
    mh->filetime = (char *) malloc (strlen (mh6->operator_name) + 1);
    strcpy (mh->filetime, mh6->operator_name);
a585 1

d607 1
a607 4
	if (mh7->file_type == 7)
		mh->filtyp = 2;					/* Some filetypes appear to be 7 for images */
	else
		mh->filtyp = mh7->file_type;
d631 5
a635 6
    mh->sw_revision = (char *) malloc (strlen (mh7->physician_name) + 1);
    strcpy (mh->sw_revision, mh7->physician_name);
    mh->filetime = (char *) malloc (strlen (mh7->operator_name) + 1);
    strcpy (mh->filetime, mh7->operator_name);
	mh->whole_header = mh7->whole_header;

d651 1
a651 1
	char			comment[32];
d681 1
a681 1
		mh6->init_bed_position = mh->bed_off[i];
d685 1
a685 1
    	strncpy (mh6->physician_name, mh->sw_revision, sizeof (mh6->physician_name) -1);
d687 1
a687 2
    	strncpy (mh6->operator_name, mh->filetime, sizeof (mh6->operator_name) -1);

d705 1
a705 1
	char			comment[32];
d733 1
a733 1
    	strncpy (mh7->physician_name, mh->sw_revision, sizeof (mh7->physician_name) -1);
d735 1
a735 3
    	strncpy (mh7->operator_name, mh->filetime, sizeof (mh7->operator_name) -1);
	mh7->whole_header = mh->whole_header;

d744 2
a745 1
float          *rdimg (filnam, plane, frame, gate, data, bed)
d751 3
a753 1
	int             filetype;
d755 8
a762 7
	filetype = get_filetype (filnam);

	if (filetype == MATRIX_REV7)
		image = rdimg7 (filnam, plane, frame, gate, data, bed);
	else if (filetype == MATRIX_REV6)	 /* Matrix file version 6 */
		image = rdimg6 (filnam, plane, frame, gate, data, bed);
	else if (filetype == PETT6)
d764 1
a764 1
	else if (filetype == INTERFILE)
d766 1
a766 1
	else
d777 2
a778 1
int             putsbhdr (sh, filnam, plane, frame, gate, data, bed)
d784 4
a787 1
	int             filetype;
d790 2
a791 1
	filetype = get_filetype (filnam);
d793 3
a795 2
	if (filetype == MATRIX_REV7) {
		if (strstr (filnam, ".S"))	 /* Scan file. */
d797 1
a797 1
		else if (strstr (filnam, ".v"))	 /* 3D image file. */
d800 1
a800 1
			fprintf (stderr, "ERROR [putsbhr]: Invalid file type, %s\n", filnam);
d803 3
a805 3
		if ((putsbhdr_if (sh1, filnam, plane)) != NULL) {
			fprintf (stderr, "ERROR [putsbhr]: Error writing subheader for ",
				 "%d, %s\n", plane, filnam);
d808 3
a810 2
	} else if (filetype == MATRIX_REV6) {	 /* Matrix file version 6 */
		if (strstr (filnam, ".scn"))	 /* Scan file. */
d812 1
a812 1
		else if (strstr (filnam, ".img"))/* 3D image file. */
d815 1
a815 1
			fprintf (stderr, "ERROR [putsbhr]: Invalid file type, %s\n", filnam);
d818 3
a820 3
		if ((putsbhdr6 (sh1, filnam, plane, frame, gate, data, bed)) != NULL) {
			fprintf (stderr, "ERROR [putsbhr]: Error writing subheader for ",
				 "%d, %s\n", plane, filnam);
d823 1
a823 1
	} else if (filetype == INTERFILE) {
d825 3
a827 3
		if ((putsbhdr7 (sh1, filnam, plane, frame, gate, data, bed)) != NULL) {
			fprintf (stderr, "ERROR [putsbhr]: Error writing subheader for ",
				 "%d, %s\n", plane, filnam);
d831 2
d849 4
a852 2
	int             filetype;
	void           *mh1;
d854 1
a854 1
	filetype = get_filetype (filnam);
d856 3
a858 3
	if (filetype == MATRIX_REV7) {
		mh1 = (void *) mh_to_mh7 (mh);
		if ((putmhdr7 (filnam, mh1)) != NULL) {
d862 3
a864 3
	} else if (filetype == MATRIX_REV6) {	 /* Matrix file version 6 */
		mh1 = (void *) mh_to_mh6 (mh);
		if ((putmhdr6 (filnam, mh1)) != NULL) {
d868 3
a870 2
	} else if (filetype == INTERFILE) {
		mh1 = (void *) mh_to_ifmh (mh);
d874 5
a878 2
		} else
			return (ERROR);
a879 1
	free (mh1);
d896 6
a901 1
	void           *mh1, *sh1;
d904 6
a909 3
	if (mh->file_format == MATRIX_REV7) {
		mh1 = (void *) mh_to_mh7 (mh);
		if (strstr (filnam, ".S"))	 /* Scan file. */
d911 1
a911 1
		else if (strstr (filnam, ".v"))	 /* 3D image file. */
d914 1
a914 1
			fprintf (stderr, "ERROR [wrimg]: Invalid file type, %s\n", filnam);
d917 1
a917 1
		if ((wrimg7 (filnam, image, mh1, sh1, plane, frame, gate, data, bed)) != NULL) {
d922 3
a924 3
	} else if (mh->file_format == MATRIX_REV6) {
		mh1 = (void *) mh_to_mh6 (mh);
		if (strstr (filnam, ".scn"))	 /* Scan file. */
d926 1
a926 1
		else if (strstr (filnam, ".img"))/* 3D image file. */
d929 1
a929 1
			fprintf (stderr, "ERROR [wrimg]: Invalid file type, %s\n", filnam);
d932 1
a932 1
		if ((wrimg6 (filnam, image, mh1, sh1, plane, frame, gate, data, bed)) != NULL) {
d937 1
a937 1
	} else if (mh->file_format == PETT6) {
d939 1
a939 1
		if ((wrimgp6 (filnam, image, p6h, plane)) != NULL) {
a941 1
			free (p6h);
d944 2
a945 2
	} else if (mh->file_format == INTERFILE) {
		mh1 = (void *) mh_to_ifmh (mh);
d954 1
a954 1
		fprintf (stderr, "ERROR [wrimg]: Invalid file format in %s\n", filnam);
d969 2
a1035 24
 *  Function:       get_datatype
 *  Description:    Return type of file (types defined in imagio.h)
 *		1 = raw
 *		2 = image
 * =============================================================================
 */
int             get_datatype (filnam)
	char           *filnam;
{
	MainHeader     *mh;
	int             datatype;

	mh = getmhdr (filnam);
	if (mh == NULL) {
		fprintf (stderr, "Could not read main header, %s\n", filnam);
		return (OK);
	} else {
		datatype = mh->filtyp;
		free_mh (mh);
		return (datatype);
	}
}

/* =============================================================================
d1041 1
a1041 1
void	free_mh (mh)
d1057 2
a1059 3
void	free_sh (sh)
	SubHeader     *sh;

a1098 1

a1106 1

a1109 1

a1140 1

d1150 1
a1150 1
			                    sample_size_1, sample_size_2, sample_size_3, comment)
a1154 1
	char           *comment;
a1156 1

@
