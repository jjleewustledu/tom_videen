head	1.9;
access;
symbols;
locks; strict;
comment	@# @;


1.9
date	99.02.15.14.26.34;	author tom;	state Exp;
branches;
next	1.8;

1.8
date	94.12.30.20.52.43;	author ty7777;	state Exp;
branches;
next	1.7;

1.7
date	94.10.25.18.47.58;	author ty7777;	state Exp;
branches;
next	1.6;

1.6
date	94.09.06.14.32.11;	author ty7777;	state Exp;
branches;
next	1.5;

1.5
date	94.08.25.18.11.37;	author ty7777;	state Exp;
branches;
next	1.4;

1.4
date	94.02.18.20.38.16;	author ty7777;	state Exp;
branches;
next	1.3;

1.3
date	93.04.21.14.59.22;	author ty7777;	state Exp;
branches;
next	1.2;

1.2
date	93.03.31.16.36.44;	author ty7777;	state Exp;
branches;
next	1.1;

1.1
date	93.03.08.22.50.15;	author ty7777;	state Exp;
branches;
next	;


desc
@xlabel.callbacks working version.
@


1.9
log
@start to update & port
@
text
@/*$Header: /home/npggw/tom/src/xlabel/RCS/xlabel.callbacks,v 1.8 1994/12/30 20:52:43 ty7777 Exp tom $*/
/*$Log: xlabel.callbacks,v $
# Revision 1.8  1994/12/30  20:52:43  ty7777
# Added processing for big fonts.
#
# Revision 1.7  1994/10/25  18:47:58  ty7777
# Before using copy in steps.
#
# Revision 1.6  1994/09/06  14:32:11  ty7777
# Same as the last version.
#
# Revision 1.5  1994/08/25  18:11:37  ty7777
# Before porting to X11R5.
#
# Revision 1.4  1994/02/18  20:38:16  ty7777
# LoadXwd () is changed.
#
# Revision 1.3  1993/04/21  14:59:22  ty7777
# After making save xwd working.
#
# Revision 1.2  1993/03/31  16:36:44  ty7777
# Error checking for file name.
#
# Revision 1.1  1993/03/08  22:50:15  ty7777
# Initial revision
#
# Revision 1.6  92/11/23  22:18:48  22:18:48  ty7777 (Tongzeng -Tom- Yang)
# Bewfore moving xwdwud.c to the library.
#
# Revision 1.5  1992/09/28  16:39:46  ty7777
# After AF3D Menu Worked.
#*/

void            QuitCallback (w, clientData, callData)
	Widget          w;
	caddr_t         clientData;
	caddr_t         callData;
{
	exit (0);
}

void            CancelCallback (w, clientData, callData)
	Widget          w;
	caddr_t         clientData;
	caddr_t         callData;
{
	Widget          dialog = (Widget) clientData;
	XtUnmanageChild (dialog);
}

void            ShowMenuCallback (w, clientData, callData)
	Widget          w;
	caddr_t         clientData;
	caddr_t         callData;
{
	Widget          dialog = (Widget) clientData;
	XtManageChild (dialog);
}

/*________________________________________________________________________
	Procedure:
		ClearWindowCallback
	Parameters:
		w: Widget, widget where callback was triggered.
		clientData: caddr_t, client data.
		call_data: caddr_t, callback data.
	Description:
		Callback function for clearing data and window.
		Author: Tom Yang
		(06/01/91)
_________________________________________________________________________*/
void            ClearWindowCallback (w, clientData, callData)
	Widget          w;
	caddr_t         clientData;
	caddr_t         callData;
{
	DRAW_DATA      *drawData = (DRAW_DATA *) clientData;
	XClearArea (drawData->display, drawData->window, 0, 0,
		    DRAW_AREA_WIDTH, DRAW_AREA_HEIGHT, FALSE);
}

/*____________________________________________________________________________
	Procedure:
		NonImageColorCallback
	Parameters:
		w: Widget, widget where callback was triggered.
		clientData: caddr_t, client data.
		call_data: caddr_t, callback data.
	Description:
		Callback function for setting the colors for background.
		Author: Tom Yang
		(07/16/91)
___________________________________________________________________________*/

void            NonImageColorCallback (w, clientData, callData)
	Widget          w;
	caddr_t         clientData;
	caddr_t         callData;
{
	NONIMAGE_COLOR_DATA *nonImageColorData = (NONIMAGE_COLOR_DATA *) clientData;
	Display        *display = nonImageColorData->display;
	int             n = 0;
	Arg             arglist[1];
	Pixel           selected_color_pixel;
	Widget          selected_color_button;
	XColor          color;
	Colormap        dcmap;

	selected_color_button
		= GetActiveWidget (nonImageColorData->back_color_set,
				   MAX_NONIMAGE_COLOR);
	n = 0;
	XtSetArg (arglist[n], XtNbackground, &selected_color_pixel);
	n++;
	XtGetValues (selected_color_button, arglist, n);

	color.pixel = selected_color_pixel;
	dcmap = XDefaultColormap (display, DefaultScreen (display));
	XQueryColor (display, dcmap, &color);

	nonImageColorData->rgb_value->red = color.red;
	nonImageColorData->rgb_value->green = color.green;
	nonImageColorData->rgb_value->blue = color.blue;

	AppColormap (display, nonImageColorData->root_window);

	XtUnmanageChild (*nonImageColorData->dialog);
}

void            SetRadioToggleCallback (w, clientData, callData)
	Widget          w;
	caddr_t         clientData;
	caddr_t         callData;
{
	int             n = 0;
	Arg             arglist[1];
	if (XmToggleButtonGetState (w)) {
		XtSetArg (arglist[n], XmNset, TRUE);
		n++;
		XtSetValues (w, arglist, n);
	}
}

/*____________________________________________________________________________
	Procedure:
		ShowFileSelectionCallback
	Parameters:
		w: Widget, widget where callback was triggered.
		clientData: caddr_t, client data.
		call_data: caddr_t, callback data.
	Description:
		Callback function for displaying labels of file selection menu.
		Author: Tom Yang
		(06/07/91)
___________________________________________________________________________*/

void            ShowFileSelectionCallback (w, clientData, callData)
	Widget          w;
	caddr_t         clientData;
	caddr_t         callData;
{
	FILE_SELECTION_DATA *fileSelectionData
	= (FILE_SELECTION_DATA *) clientData;

	int             n;
	Arg             arglist[2];

	n = 0;
	XtSetArg (arglist[n], XmNselectionLabelString,
		  fileSelectionData->label_selection);
	n++;
	XtSetArg (arglist[n], XmNfilterLabelString,
		  fileSelectionData->label_path);
	n++;
	XtSetValues (fileSelectionData->dialog, arglist, n);

	cFileState = fileSelectionData->file_state;

	XtManageChild (fileSelectionData->dialog);
}

/*_________________________________________________________________________________
	Procedure:
		SetPointerStatusCallback
	Parameters:
		w: Widget, widget where callback was triggered.
		clientData: caddr_t, client data.
		call_data: caddr_t, callback data.
	Description:
		Callback function for setting pointer state.
		display state.
		Author: Tom Yang
		(05/21/91)
_________________________________________________________________________________*/

void            SetPointerStatusCallback (w, clientData, call_data)
	Widget          w;
	caddr_t         clientData;
	caddr_t         call_data;
{
	PointerStatus   state = (PointerStatus) clientData;
	cPointerState = state;
}

/*_________________________________________________________________________________
	Procedure:
		BrowseListCallback
	Parameters:
		w: Widget, widget where callback was triggered.
		clientData: caddr_t, client data.
		call_data: caddr_t, callback data.
	Description:
		Callback function to browse list and set selected item to a text fields.
		Author: Tom (Tongzeng) Yang
		(07/21/91)
_________________________________________________________________________________*/
void            BrowseListCallback (w, clientData, callData)
	Widget          w;

	caddr_t         clientData;
	caddr_t         callData;
{
	Widget          text_widget = (Widget) clientData;
	XmListCallbackStruct *call_data = (XmListCallbackStruct *) callData;
	char           *text;
	XmStringGetLtoR (call_data->item, XmSTRING_DEFAULT_CHARSET, &text);
	XmTextSetString (text_widget, text);
}

/*_________________________________________________________________________________
	Procedure:
		SetTextFontCallback
	Parameters:
		w: Widget, widget where callback was triggered.
		clientData: caddr_t, client data.
		call_data: caddr_t, callback data.
	Description:
		Callback function to set font for label text.
		Author: Tom (Tongzeng) Yang
		(07/24/91)
_________________________________________________________________________________*/
void            SetTextFontCallback (w, clientData, callData)
	Widget          w;
	caddr_t         clientData;
	caddr_t         callData;
{
	static char    *function = "SetTextFontCallback";
	FONT_DATA      *font_data = (FONT_DATA *) clientData;
	Display        *display = font_data->draw_data->display;
	GC              gc = font_data->draw_data->gc;
	char           *alignment = &cAlignment;
	char           *font_string;
	char           *buffer;
	int             point_size;
	char            size_string[MAXLINE];
	char            font_color_name[MAXLINE];
	XFontStruct    *font_struct;
	int             i;
	int             n;
	Arg             arglist[1];
	Widget          widget_buffer;
	char           *color_index = &cTextColorIndex;
	char           *slant_index = &cFontSlantIndex;
	char           *weight_index = &cFontWeightIndex;
	char           *orient_index = &cFontOrientIndex;

	widget_buffer = GetActiveWidget (font_data->font_color_set,
					 MAX_NONIMAGE_COLOR);
	if (font_data->node_flag != 2) {

		n = 0;
		XtSetArg (arglist[n], XtNbackground, &pixelTextColor);
		n++;
		XtGetValues (widget_buffer, arglist, n);
		*color_index
			= (char) GetActiveIndex (font_data->font_color_set,
						 MAX_NONIMAGE_COLOR);

		*slant_index = GetActiveIndex (font_data->slant_set, SLANT_NUM);
		*weight_index = GetActiveIndex (font_data->weight_set, WEIGHT_NUM);
		*orient_index = GetActiveIndex (font_data->orient_set, 2);
		*alignment = GetActiveIndex (font_data->alignment_set, 2);

		XmScaleGetValue (font_data->line_spacing, &nLineSpacing);

		font_string = GetFontName (font_data->font_list,
					   font_data->font_name,
					   font_data->weight_set,
					   font_data->slant_set,
					   font_data->size_list,
					   font_data->size_name);

		/*
		 * Free old font and load new font.
		 */
		font_struct = XLoadQueryFont (display, font_string);
		if (font_struct == 0)
			fprintf (stderr, "Can Not Find Font %s\n", font_string);
		else {
			XFreeFont (display, FontStruct);
			FontStruct = font_struct;
		}

		free (font_string);
	} else {
		SetSelectData (widget_buffer, False);
		SetSelectData (font_data->font_color_set[cTextColorIndex], True);

		XmListSelectPos (*font_data->font_list, nFontNameIndex, True);
		XmTextSetString (*font_data->font_name, fontTable[nFontNameIndex - 1]);

		XmListSelectPos (*font_data->size_list, nFontSizeIndex, True);
		XmTextSetString (*font_data->size_name, fontSizeTable[nFontSizeIndex - 1]);

		widget_buffer
			= GetActiveWidget (font_data->slant_set, SLANT_NUM);
		SetSelectData (widget_buffer, False);
		SetSelectData (font_data->slant_set[*slant_index], True);

		widget_buffer
			= GetActiveWidget (font_data->weight_set, WEIGHT_NUM);
		SetSelectData (widget_buffer, False);
		SetSelectData (font_data->weight_set[*weight_index], True);

		widget_buffer
			= GetActiveWidget (font_data->orient_set, WEIGHT_NUM);
		SetSelectData (widget_buffer, False);
		SetSelectData (font_data->orient_set[*orient_index], True);

		widget_buffer = GetActiveWidget (font_data->alignment_set, 2);
		SetSelectData (widget_buffer, False);
		SetSelectData (font_data->alignment_set[*alignment], True);

		XmScaleSetValue (font_data->line_spacing, nLineSpacing);
	}
	XtUnmanageChild (font_data->frame);
}

/*_________________________________________________________________________________
	Procedure:
		SetLineAttribCallback
	Parameters:
		w: Widget, widget where callback was triggered.
		clientData: caddr_t, client data.
		call_data: caddr_t, callback data.
	Description:
		Callback function to set line attributes.
		Author: Tom (Tongzeng) Yang
		(11/19/91)
_________________________________________________________________________________*/
void            SetLineAttribCallback (w, clientData, callData)
	Widget          w;
	caddr_t         clientData;
	caddr_t         callData;
{
	LINE_ATTRIB_DATA *line_attrib = (LINE_ATTRIB_DATA *) clientData;
	int            *line_width = &nLineWidth;
	char           *color_index = &cLineColorIndex;
	int             n;
	Arg             arglist[1];
	Widget          selected_color_button;

	selected_color_button
		= GetActiveWidget (line_attrib->line_color_set,
				   MAX_NONIMAGE_COLOR);
	if (line_attrib->node_flag != 2) {
		n = 0;
		XtSetArg (arglist[n], XtNbackground, &pixelLineColor);
		n++;
		XtGetValues (selected_color_button, arglist, n);
		*color_index
			= (char) GetActiveIndex (line_attrib->line_color_set,
						 MAX_NONIMAGE_COLOR);

		XmScaleGetValue (line_attrib->line_width, line_width);
	} else {
		SetSelectData (selected_color_button, False);
		SetSelectData (line_attrib->line_color_set[*color_index], True);

		XmScaleSetValue (line_attrib->line_width, *line_width);
	}

	XtUnmanageChild (line_attrib->frame);
}

/*_________________________________________________________________________________
	Procedure:
		SetArrowOptionsCallback
	Parameters:
		w: Widget, widget where callback was triggered.
		clientData: caddr_t, client data.
		call_data: caddr_t, callback data.
	Description:
		Callback function to set arrow attributes.
		Author: Tom (Tongzeng) Yang
		(07/05/92)
_________________________________________________________________________________*/
void            SetArrowOptionsCallback (w, clientData, callData)
	Widget          w;
	caddr_t         clientData;
	caddr_t         callData;
{
	ARROW_OPTIONS_DATA *arrow_options = (ARROW_OPTIONS_DATA *) clientData;
	int            *arrow_width = &nArrowWidth;
	int            *arrow_length = &nArrowLength;

	if (arrow_options->node_flag != 2) {
		XmScaleGetValue (arrow_options->arrow_width, arrow_width);
		XmScaleGetValue (arrow_options->arrow_length, arrow_length);
	} else {
		XmScaleSetValue (arrow_options->arrow_width, *arrow_width);
		XmScaleSetValue (arrow_options->arrow_length, *arrow_length);
	}

	XtUnmanageChild (arrow_options->frame);
}

/*_________________________________________________________________________________
	Procedure:
		ButtonDownEventHandler
	Parameters:
		w: Widget, widget where callback was triggered.
		clientData: caddr_t, client data.
		event: XEvent, callback data.
	Description:
		Event handling function to for button down.
		Author: Tom (Tongzeng) Yang
		(07/30/91)
_________________________________________________________________________________*/
void            ButtonDownEventHandler (w, clientData, event)
	Widget          w;
	caddr_t         clientData;
	XEvent         *event;
{
	GRAPHICS_DATA  *graphics_data = (GRAPHICS_DATA *) clientData;
	Display        *display = graphics_data->draw_data->display;
	GC              gc = graphics_data->draw_data->gc;
	GC              xorgc = graphics_data->xorgc;
	PointerStatus  *pointer_state = &cPointerState;
	Window          root_window = DefaultRootWindow (display);
	Window          window = graphics_data->draw_data->window;
	XGCValues       values;			 /* values structure */
	XImage         *retimage;
	XFontStruct    *font_struct = FontStruct;
	char            alignment_flag = cAlignment;
	char            orient = cFontOrientIndex;
	char           *text_string = szTextString;
	int             format;
	int             left;
	int             nitems;
	int             symbol_size = nSymbolSize;
	int             type;
	int             x;
	int             y;
	unsigned long   valuemask;		 /* mask bits */

	cPolyState = *pointer_state;

	if ((*pointer_state == LinePathState ||
	     *pointer_state == PolygonState) &&
	    graphics_data->point_num > 0) {
		graphics_data->start_x = graphics_data->last_x;
		graphics_data->start_y = graphics_data->last_y;
	} else {
		graphics_data->start_x = event->xbutton.x;
		graphics_data->start_y = event->xbutton.y;

		if (*pointer_state == LinePathState ||
		    *pointer_state == PolygonState ||
		    *pointer_state == FreeHandState) {
			graphics_data->point_num = 0;
			graphics_data->points[graphics_data->point_num].x
				= graphics_data->start_x;
			graphics_data->points[graphics_data->point_num].y
				= graphics_data->start_y;
			graphics_data->point_num++;
		}
	}

	graphics_data->last_x = event->xbutton.x;
	graphics_data->last_y = event->xbutton.y;

	graphics_data->button_down_first = TRUE;

	switch (*pointer_state) {
	case SaveRegionState:
	case CutState:
	case CopyState:
	case RectState:
		DrawRectangle (display, window, xorgc,
			       graphics_data->start_x, graphics_data->start_y,
			       graphics_data->last_x, graphics_data->last_y);

		break;
	case PasteState:
		if (XGetWindowProperty (display, root_window, XA_PRIMARY,
					0, sizeof (XImage), FALSE, IMAGE_DATA_TYPE,
					&type, &format, &nitems, &left, &retimage)
		    == Success && type == IMAGE_DATA_TYPE) {
			wClipboard = retimage->width;
			hClipboard = retimage->height;
			XDestroyImage (retimage);
		}
		DrawRectangle (display, window, xorgc,
			       graphics_data->start_x,
			       graphics_data->start_y,
			       graphics_data->start_x + wClipboard,
			       graphics_data->start_y + hClipboard);

		break;
	case LabelState:
		GetLabelDim (font_struct, szTextString, nLineSpacing, orient,
			     &graphics_data->label_width, &graphics_data->label_height);

		x = graphics_data->start_x;
		y = graphics_data->start_y;
		GetTextStart (orient, alignment_flag, graphics_data->label_width,
			      graphics_data->label_height, &x, &y);

		XDrawRectangle (display, window, xorgc, x, y - font_struct->ascent,
				graphics_data->label_width,
				graphics_data->label_height);

		break;
	case SymbolState:
		valuemask = GCForeground | GCLineWidth | GCLineStyle
			| GCCapStyle | GCJoinStyle;
		values.foreground = pixelSymbolColor;
		values.line_width = nLineWidth;
		values.line_style = LineSolid;
		values.cap_style = CapButt;
		values.join_style = JoinRound;
		XChangeGC (display, gc, valuemask, &values);

		DrawSymbol (display, window, gc,
			    graphics_data->start_x - symbol_size / 2,
			    graphics_data->start_y - symbol_size / 2,
			    symbol_size,
			    symbol_size,
			    cSymbolType);
		break;
	case FreeHandState:
	case ArrowState:
	case LineState:
	case HoriLineState:
	case VertLineState:
	case LinePathState:
	case PolygonState:
		GetLineEnd (*pointer_state, graphics_data->start_x, graphics_data->start_y,
			    graphics_data->last_x, graphics_data->last_y, &x, &y);
		DrawLine (display, window, xorgc,
			  graphics_data->start_x, graphics_data->start_y, x, y);

		break;
	case EllipseState:
		DrawEllipse (display, window, xorgc,
			     graphics_data->start_x, graphics_data->start_y,
			     graphics_data->last_x, graphics_data->last_y);

		break;
	case CircleState:
		DrawCircle (display, window, xorgc,
			    graphics_data->start_x, graphics_data->start_y,
			    graphics_data->last_x, graphics_data->last_y);

		break;
	case FilledRectState:
		DrawFilledRectangle (display, window, xorgc,
				     graphics_data->start_x, graphics_data->start_y,
				     graphics_data->last_x, graphics_data->last_y);
		break;
	case FilledEllipseState:
		DrawFilledEllipse (display, window, xorgc,
				   graphics_data->start_x, graphics_data->start_y,
				   graphics_data->last_x, graphics_data->last_y);
		break;
	case FilledCircleState:
		DrawFilledCircle (display, window, xorgc,
				  graphics_data->start_x, graphics_data->start_y,
				  graphics_data->last_x, graphics_data->last_y);

		break;
	default:
		break;
	}
}

/*_________________________________________________________________________________
	Procedure:
		ButtonMoveEventHandler
	Parameters:
		w: Widget, widget where callback was triggered.
		clientData: caddr_t, client data.
		event: XEvent, callback data.
	Description:
		Event handling function for button move.
		Author: Tom (Tongzeng) Yang
		(08/15/91)
_________________________________________________________________________________*/
void            ButtonMoveEventHandler (w, clientData, event)
	Widget          w;
	caddr_t         clientData;
	XEvent         *event;
{
	GRAPHICS_DATA  *graphics_data = (GRAPHICS_DATA *) clientData;
	Display        *display = graphics_data->draw_data->display;
	Window          window = graphics_data->draw_data->window;
	GC              gc = graphics_data->draw_data->gc;
	GC              xorgc = graphics_data->xorgc;
	PointerStatus  *pointer_state = &cPointerState;
	XFontStruct    *font_struct = FontStruct;
	char            alignment_flag = cAlignment;
	char            orient = cFontOrientIndex;
	int             x, y;
	unsigned int   *wclipboard = &wClipboard;
	unsigned int   *hclipboard = &hClipboard;

	if (graphics_data->button_down_first) {
		switch (*pointer_state) {
		case SaveRegionState:
		case CutState:
		case CopyState:
		case RectState:
			DrawRectangle (display, window, xorgc,
				       graphics_data->start_x, graphics_data->start_y,
				       graphics_data->last_x, graphics_data->last_y);

			graphics_data->last_x = event->xbutton.x,
				graphics_data->last_y = event->xbutton.y,

				DrawRectangle (display, window, xorgc,
					       graphics_data->start_x, graphics_data->start_y,
					       graphics_data->last_x, graphics_data->last_y);
			break;
		case PasteState:
			DrawRectangle (display, window, xorgc,
				       graphics_data->start_x,
				       graphics_data->start_y,
				       graphics_data->start_x + *wclipboard,
				       graphics_data->start_y + *hclipboard);

			graphics_data->start_x = event->xbutton.x,
				graphics_data->start_y = event->xbutton.y,

				DrawRectangle (display, window, xorgc,
					       graphics_data->start_x,
					       graphics_data->start_y,
					       graphics_data->start_x + *wclipboard,
					       graphics_data->start_y + *hclipboard);

			break;
		case LabelState:
			x = graphics_data->start_x;
			y = graphics_data->start_y;
			GetTextStart (orient, alignment_flag, graphics_data->label_width,
				      graphics_data->label_height, &x, &y);

			XDrawRectangle (display, window, xorgc,
					x, y - font_struct->ascent,
					graphics_data->label_width, graphics_data->label_height);

			x = graphics_data->start_x = event->xbutton.x;
			y = graphics_data->start_y = event->xbutton.y;
			GetTextStart (orient, alignment_flag, graphics_data->label_width,
				      graphics_data->label_height, &x, &y);

			XDrawRectangle (display, window, xorgc, x, y - font_struct->ascent,
					graphics_data->label_width, graphics_data->label_height);

			break;
		case FreeHandState:
			graphics_data->start_x = graphics_data->last_x;
			graphics_data->start_y = graphics_data->last_y;
			graphics_data->last_x = event->xbutton.x,
				graphics_data->last_y = event->xbutton.y,

				DrawLine (display, window, xorgc,
					  graphics_data->start_x, graphics_data->start_y,
					  graphics_data->last_x, graphics_data->last_y);

			graphics_data->points[graphics_data->point_num].x
				= graphics_data->last_x;
			graphics_data->points[graphics_data->point_num].y
				= graphics_data->last_y;
			graphics_data->point_num++;
			break;
		case ArrowState:
		case LineState:
		case HoriLineState:
		case VertLineState:
		case LinePathState:
		case PolygonState:
			GetLineEnd (*pointer_state,
				    graphics_data->start_x, graphics_data->start_y,
				    graphics_data->last_x, graphics_data->last_y, &x, &y);
			DrawLine (display, window, xorgc,
				  graphics_data->start_x, graphics_data->start_y, x, y);

			graphics_data->last_x = event->xbutton.x,
				graphics_data->last_y = event->xbutton.y,

				GetLineEnd (*pointer_state,
					    graphics_data->start_x, graphics_data->start_y,
					    graphics_data->last_x, graphics_data->last_y, &x, &y);
			DrawLine (display, window, xorgc,
				  graphics_data->start_x, graphics_data->start_y, x, y);

			break;
		case EllipseState:
			DrawEllipse (display, window, xorgc,
				     graphics_data->start_x, graphics_data->start_y,
				     graphics_data->last_x, graphics_data->last_y);

			graphics_data->last_x = event->xbutton.x,
				graphics_data->last_y = event->xbutton.y,

				DrawEllipse (display, window, xorgc,
					     graphics_data->start_x, graphics_data->start_y,
					     graphics_data->last_x, graphics_data->last_y);
			break;
		case CircleState:
			DrawCircle (display, window, xorgc,
				    graphics_data->start_x, graphics_data->start_y,
				    graphics_data->last_x, graphics_data->last_y);

			graphics_data->last_x = event->xbutton.x,
				graphics_data->last_y = event->xbutton.y,

				DrawCircle (display, window, xorgc,
					    graphics_data->start_x, graphics_data->start_y,
					    graphics_data->last_x, graphics_data->last_y);
			break;
		case FilledRectState:
			DrawFilledRectangle (display, window, xorgc,
					     graphics_data->start_x, graphics_data->start_y,
					     graphics_data->last_x, graphics_data->last_y);

			graphics_data->last_x = event->xbutton.x,
				graphics_data->last_y = event->xbutton.y,

				DrawFilledRectangle (display, window, xorgc,
						   graphics_data->start_x, graphics_data->start_y,
						     graphics_data->last_x, graphics_data->last_y);

			break;
		case FilledEllipseState:
			DrawFilledEllipse (display, window, xorgc,
					   graphics_data->start_x, graphics_data->start_y,
					   graphics_data->last_x, graphics_data->last_y);

			graphics_data->last_x = event->xbutton.x,
				graphics_data->last_y = event->xbutton.y,

				DrawFilledEllipse (display, window, xorgc,
						   graphics_data->start_x, graphics_data->start_y,
						   graphics_data->last_x, graphics_data->last_y);

			break;
		case FilledCircleState:
			DrawFilledCircle (display, window, xorgc,
					  graphics_data->start_x, graphics_data->start_y,
					  graphics_data->last_x, graphics_data->last_y);

			graphics_data->last_x = event->xbutton.x,
				graphics_data->last_y = event->xbutton.y,

				DrawFilledCircle (display, window, xorgc,
						  graphics_data->start_x, graphics_data->start_y,
						  graphics_data->last_x, graphics_data->last_y);

			break;
		default:
			break;
		}
	}
}

/*_________________________________________________________________________________
	Procedure:
		ButtonReleaseEventHandler
	Parameters:
		w: Widget, widget where callback was triggered.
		clientData: caddr_t, client data.
		event: XEvent, callback data.
	Description:
		Event handling function for button release.
		Author: Tom (Tongzeng) Yang
		(08/16/91)
_________________________________________________________________________________*/
void            ButtonReleaseEventHandler (w, clientData, event)
	Widget          w;
	caddr_t         clientData;
	XEvent         *event;
{
	GRAPHICS_DATA  *graphics_data = (GRAPHICS_DATA *) clientData;
	Display        *display = graphics_data->draw_data->display;
	Window          window = graphics_data->draw_data->window;
	Window          root_window = DefaultRootWindow (display);
	XWindowAttributes win_info;
	GC              gc = graphics_data->draw_data->gc;
	GC              xorgc = graphics_data->xorgc;
	PointerStatus  *pointer_state;
	int             x;
	int             y;
	int             x2;
	int             y2;
	int            *line_width = &nLineWidth;
	char            alignment_flag = cAlignment;
	char            orient = cFontOrientIndex;
	char            szBuffer[MAXLINE];
	char           *text_string = szTextString;
	XFontStruct    *font_struct = FontStruct;
	unsigned long   valuemask;		 /* mask bits */
	XGCValues       values;			 /* values structure */
	unsigned int   *wclipboard = &wClipboard;
	unsigned int   *hclipboard = &hClipboard;
	int             result;
	long            itemid, dataid;
	int             length, id;
	XmString        clip_label;
	static int      cnt;
	XImage         *image;
	XImage         *retimage;
	char           *image_data;
	char           *retimage_data;
	XColor         *colors;
	XColor         *retcolors;
	int             ncolors;
	int            *retncolors;
	int             i;
	unsigned int    buffer_size;
	int             type, format, nitems, left;
	Colormap        colormap;
	RGB_COLOR      *rgb_background = &rgbBackground;
	XColor          color;
	pointer_state = &cPointerState;

	if (graphics_data->button_down_first) {
		valuemask = GCForeground | GCLineWidth | GCLineStyle
			| GCCapStyle | GCJoinStyle;
		values.foreground = pixelLineColor;
		values.line_width = *line_width;
		values.line_style = LineSolid;
		values.cap_style = CapButt;
		values.join_style = JoinRound;
		XChangeGC (display, gc, valuemask, &values);

		switch (*pointer_state) {
		case SaveRegionState:
		case CutState:
		case CopyState:
			DrawRectangle (display, window, xorgc,
				       graphics_data->start_x, graphics_data->start_y,
				       graphics_data->last_x, graphics_data->last_y);

			graphics_data->last_x = event->xbutton.x,
				graphics_data->last_y = event->xbutton.y,

				x = graphics_data->start_x;
			y = graphics_data->start_y;
			x2 = graphics_data->last_x;
			y2 = graphics_data->last_y;
			CheckPoints (&x, &y, &x2, &y2);
			if (x == x2 || y == y2)
				break;

			*wclipboard = x2 - x;
			*hclipboard = y2 - y;

			if (*pointer_state != SaveRegionState) {
				if (!XGetWindowAttributes (display, window, &win_info))
					fprintf (stderr, "Can't get target window attributes.");

				ncolors = GetXColors (display, &win_info, &colors);

				image = XGetImage (display, window, x, y,
						   x2 - x, y2 - y, AllPlanes, ZPixmap);
				if (!image) {
					fprintf (stderr, "unable to get image at %dx%d+%d+%d\n",
						 x2 - x, y2 - y, x, y);
					exit (1);
				}
				XChangeProperty (display, root_window, XA_PRIMARY,
						 IMAGE_DATA_TYPE, 32, PropModeReplace,
						 (unsigned char *) image,
						 sizeof (XImage) / 4);

				XChangeProperty (display, root_window, XA_SECONDARY,
						 IMAGE_COLOR_TYPE, 32, PropModeReplace,
						 (unsigned char *) colors,
						 ncolors * sizeof (XColor) / 4);

				XChangeProperty (display, root_window, IMAGE_NCOLOR,
						 XA_INTEGER, 16, PropModeReplace,
						 (unsigned char *) &ncolors,
						 sizeof (int) / 2);

				if (ncolors > 0)
					free (colors);

				if ((*pointer_state == CutState) && x2 > x && y2 > y)
					XClearArea (display, window,
						    x, y, x2 - x, y2 - y, FALSE);

/*
 * Alloc the pixel buffer.
 */
				buffer_size = Image_Size (image);
				if ((image_data = (char *) malloc (buffer_size)) == NULL)
					fprintf (stderr, "Can't malloc data buffer\n");
				for (i = 0; i < buffer_size; i++)
					image_data[i] = image->data[i];

/*
 * Begin the copy. If the clipboard is locked, keep trying.
 */
				clip_label = XmStringCreateSimple ("to_clipboard");
				while ((result =
					XmClipboardStartCopy (display, window, clip_label,
							      XtLastTimestampProcessed (display),
						       NULL, NULL, &itemid)) != ClipboardSuccess);
				XmStringFree (clip_label);

/*
 * Copy the data.
 */
				while ((result =
					XmClipboardCopy (display, window, itemid,
							 "STRING", image_data, buffer_size,
							 cnt, NULL)) != ClipboardSuccess);

/*
 * End the transaction.
 */
				while ((result =
					XmClipboardEndCopy (display, window, itemid))
				       != ClipboardSuccess);

				free (image_data);
				XDestroyImage (image);
			} else {
				WindowDump (display, window, TRUE,
					    x, y, x2 - x, y2 - y, szSaveFileName);
			}

			break;
		case PasteState:
			DrawRectangle (display, window, xorgc,
				       graphics_data->start_x,
				       graphics_data->start_y,
				       graphics_data->start_x + *wclipboard,
				       graphics_data->start_y + *hclipboard);

			graphics_data->start_x = event->xbutton.x;
			graphics_data->start_y = event->xbutton.y;

			if (XGetWindowProperty (display, root_window, XA_PRIMARY,
						0, sizeof (XImage), FALSE, IMAGE_DATA_TYPE,
						&type, &format, &nitems, &left, &retimage)
			    == Success && type == IMAGE_DATA_TYPE) {
				if (XGetWindowProperty (display, root_window,
							IMAGE_NCOLOR, 0, sizeof (int), FALSE,
							XA_INTEGER, &type, &format, &nitems,
							&left, &retncolors)
				    != Success || type != XA_INTEGER) {
					return;
				}
				if (XGetWindowProperty (display, root_window,
						   XA_SECONDARY, 0, *retncolors * sizeof (XColor),
							FALSE, IMAGE_COLOR_TYPE, &type, &format,
							&nitems, &left, &retcolors)
				    != Success || type != IMAGE_COLOR_TYPE) {
					return;
				}

				/*
				 * Retrieve the current contents of the clipboard.
				 */
				do {
					result = XmClipboardInquireLength (display,
								       window, "STRING", &length);
				} while (result == ClipboardLocked);

				if (length == 0)
					return;

				retimage_data = XtMalloc (length);

				do {
					result = XmClipboardRetrieve (display, window,
							"STRING", retimage_data, length, &x, &id);
				} while (result == ClipboardLocked);

				retimage->data = retimage_data;

				colormap = DefaultColormap (display,
							    DefaultScreen (display));
				DoPseudo (display, &colormap, *retncolors,
					  retcolors, retimage, retimage);

				XPutImage (display, window, gc, retimage, 0, 0,
					   graphics_data->start_x,
					   graphics_data->start_y,
					   retimage->width, retimage->height);

				XtFree (retncolors);
				XtFree (retcolors);

				XtFree (retimage_data);

				XDestroyImage (retimage);

				AppColormap (display, graphics_data->root_window);
			}
			break;
		case LabelState:
			x = graphics_data->start_x;
			y = graphics_data->start_y;
			GetTextStart (orient, alignment_flag, graphics_data->label_width,
				      graphics_data->label_height, &x, &y);

			XDrawRectangle (display, window, xorgc, x, y - font_struct->ascent,
					graphics_data->label_width, graphics_data->label_height);

			graphics_data->start_x = event->xbutton.x;
			graphics_data->start_y = event->xbutton.y;

			DrawLabel (display, window, gc,
				   graphics_data->start_x, graphics_data->start_y,
				   graphics_data->last_x, graphics_data->last_y,
				   pixelTextColor, font_struct, text_string,
				   alignment_flag, nLineSpacing, orient);

			XtFree (text_string);

			sprintf (szBuffer, "%d", graphics_data->start_x);
			XmTextSetString (graphics_data->xtext_edit_coord, szBuffer);
			sprintf (szBuffer, "%d", graphics_data->start_y);
			XmTextSetString (graphics_data->ytext_edit_coord, szBuffer);

			*pointer_state = NoState;

			break;
		case FreeHandState:
			graphics_data->start_x = graphics_data->last_x;
			graphics_data->start_y = graphics_data->last_y;
			graphics_data->last_x = event->xbutton.x,
				graphics_data->last_y = event->xbutton.y,

				DrawLine (display, window, xorgc,
					  graphics_data->start_x, graphics_data->start_y,
					  graphics_data->last_x, graphics_data->last_y);

			graphics_data->points[graphics_data->point_num].x
				= graphics_data->last_x;
			graphics_data->points[graphics_data->point_num].y
				= graphics_data->last_y;
			graphics_data->point_num++;

			XDrawLines (display, window, xorgc,
				    graphics_data->points,
				    graphics_data->point_num,
				    CoordModeOrigin);
			XDrawLines (display, window, gc,
				    graphics_data->points,
				    graphics_data->point_num,
				    CoordModeOrigin);
			graphics_data->point_num = 0;
			break;
		case ArrowState:
			DrawLine (display, window, xorgc,
				  graphics_data->start_x, graphics_data->start_y,
				  graphics_data->last_x, graphics_data->last_y);

			graphics_data->last_x = event->xbutton.x,
				graphics_data->last_y = event->xbutton.y,

				DrawInwardFlatArrow (display, window, gc, *line_width,
						   graphics_data->start_x, graphics_data->start_y,
						     graphics_data->last_x, graphics_data->last_y);
			break;
		case LineState:
		case HoriLineState:
		case VertLineState:
		case LinePathState:
		case PolygonState:
			GetLineEnd (*pointer_state,
				    graphics_data->start_x, graphics_data->start_y,
				    graphics_data->last_x, graphics_data->last_y, &x, &y);
			DrawLine (display, window, xorgc,
				  graphics_data->start_x, graphics_data->start_y, x, y);

			graphics_data->last_x = event->xbutton.x,
				graphics_data->last_y = event->xbutton.y,

				GetLineEnd (*pointer_state,
					    graphics_data->start_x, graphics_data->start_y,
					    graphics_data->last_x, graphics_data->last_y, &x, &y);
			if (*pointer_state != LinePathState &&
			    *pointer_state != PolygonState) {
				DrawLine (display, window, gc,
					  graphics_data->start_x,
					  graphics_data->start_y, x, y);

			} else {
				DrawLine (display, window, xorgc,
					  graphics_data->start_x,
					  graphics_data->start_y, x, y);

				graphics_data->points[graphics_data->point_num].x
					= graphics_data->last_x;
				graphics_data->points[graphics_data->point_num].y
					= graphics_data->last_y;
				graphics_data->point_num++;
			}
			break;
		case RectState:
			DrawRectangle (display, window, xorgc,
				       graphics_data->start_x, graphics_data->start_y,
				       graphics_data->last_x, graphics_data->last_y);

			graphics_data->last_x = event->xbutton.x,
				graphics_data->last_y = event->xbutton.y,

				DrawRectangle (display, window, gc,
					       graphics_data->start_x, graphics_data->start_y,
					       graphics_data->last_x, graphics_data->last_y);

			break;
		case EllipseState:
			DrawEllipse (display, window, xorgc,
				     graphics_data->start_x, graphics_data->start_y,
				     graphics_data->last_x, graphics_data->last_y);

			graphics_data->last_x = event->xbutton.x,
				graphics_data->last_y = event->xbutton.y,

				DrawEllipse (display, window, gc,
					     graphics_data->start_x, graphics_data->start_y,
					     graphics_data->last_x, graphics_data->last_y);

			break;
		case CircleState:
			DrawCircle (display, window, xorgc,
				    graphics_data->start_x, graphics_data->start_y,
				    graphics_data->last_x, graphics_data->last_y);

			graphics_data->last_x = event->xbutton.x,
				graphics_data->last_y = event->xbutton.y,

				DrawCircle (display, window, gc,
					    graphics_data->start_x, graphics_data->start_y,
					    graphics_data->last_x, graphics_data->last_y);

			break;
		case FilledRectState:
			DrawFilledRectangle (display, window, xorgc,
					     graphics_data->start_x, graphics_data->start_y,
					     graphics_data->last_x, graphics_data->last_y);

			graphics_data->last_x = event->xbutton.x,
				graphics_data->last_y = event->xbutton.y,

				DrawFilledRectangle (display, window, gc,
						   graphics_data->start_x, graphics_data->start_y,
						     graphics_data->last_x, graphics_data->last_y);

			break;
		case FilledEllipseState:
			DrawFilledEllipse (display, window, xorgc,
					   graphics_data->start_x, graphics_data->start_y,
					   graphics_data->last_x, graphics_data->last_y);

			graphics_data->last_x = event->xbutton.x,
				graphics_data->last_y = event->xbutton.y,

				DrawFilledEllipse (display, window, gc,
						   graphics_data->start_x, graphics_data->start_y,
						   graphics_data->last_x, graphics_data->last_y);

			break;
		case FilledCircleState:
			DrawFilledCircle (display, window, xorgc,
					  graphics_data->start_x, graphics_data->start_y,
					  graphics_data->last_x, graphics_data->last_y);

			graphics_data->last_x = event->xbutton.x,
				graphics_data->last_y = event->xbutton.y,

				DrawFilledCircle (display, window, gc,
						  graphics_data->start_x, graphics_data->start_y,
						  graphics_data->last_x, graphics_data->last_y);

			break;
		default:
			break;
		}
	}
	if (*pointer_state != LinePathState && *pointer_state != PolygonState) {
		*pointer_state = NoState;
		graphics_data->point_num = 0;
	}
	graphics_data->button_down_first = FALSE;
}

/*________________________________________________________________________________________________
	Procedure:
		TextEditCallback
	Parameters:
		Widget	w;
		caddr_t clientData;
		caddr_t callData;
	Description:
		Callback function to select text for labels.
		Author: Tom (Tongzeng) Yang
		(08/1/91)
________________________________________________________________________________________________*/
Widget TextEditCallback (w, clientData, callData)
	Widget          w;
	caddr_t         clientData;
	caddr_t         callData;
{
	TEXT_EDIT_DATA *text_edit_data = (TEXT_EDIT_DATA *) clientData;
	PointerStatus  *pointer_state;
	char           *str1;
	char           *str2;
	char            szBuffer[MAXLINE];
	char           *text_string;
	short          *xstart = &xTextEditStart;
	short          *ystart = &yTextEditStart;
	pointer_state = &cPointerState;

	/*
	 * Get the string of text.
	 */
	if (text_edit_data->node_flag == MOUSE_SELECT
	    || text_edit_data->node_flag == SELECT) {
		text_string = szTextString = XmTextGetString (text_edit_data->text);
	}

	/*
	 * Set the pointer status.
	 */
	if (text_edit_data->node_flag == MOUSE_SELECT) {
		*pointer_state = LabelState;
	} else {
		*pointer_state = NoState;
	}

	/*
	 * Processing.
	 */
	if (text_edit_data->node_flag == SELECT) {
		str1 = XmTextGetString (text_edit_data->xstart);
		str2 = XmTextGetString (text_edit_data->ystart);

		if (strlen (str1) > 0 && strlen (str2) > 0) {
			*xstart = atoi (str1);
			*ystart = atoi (str2);
		}
		XtFree (str1);
		XtFree (str2);

		DrawLabel (text_edit_data->draw_data->display,
			   text_edit_data->draw_data->window,
			   text_edit_data->draw_data->gc,
			   *xstart, *ystart, 0, 0,
			   pixelTextColor, FontStruct, szTextString,
			   cAlignment, nLineSpacing, cFontOrientIndex);
		XtFree (text_string);
	} else if (text_edit_data->node_flag == 2) {
		sprintf (szBuffer, "%d", *xstart);
		XmTextSetString (text_edit_data->xstart, szBuffer);
		sprintf (szBuffer, "%d", *ystart);
		XmTextSetString (text_edit_data->ystart, szBuffer);
	}
	XtUnmanageChild (text_edit_data->dialog);
}

/*_________________________________________________________________________________
	Procedure:
		RefreshCallback
	Parameters:
		Widget	w;
		caddr_t clientData;
		caddr_t callData;
	Description:
		Callback function for refreshing a screen.
		Author: Tom (Tongzeng) Yang
		(11/26/91)
___________________________________________________________________________________*/
void            RefreshCallback (w, clientData, callData)
	Widget          w;
	caddr_t         clientData;
	caddr_t         callData;
{
	GRAPHICS_DATA  *graphics_data = (GRAPHICS_DATA *) clientData;
	Display        *display = graphics_data->draw_data->display;
	Window          window = graphics_data->draw_data->window;
	GC              gc = graphics_data->draw_data->gc;

	if (strlen (szImageFileName) > 0)
		LoadXwd (display, window, gc, szImageFileName, 0, 0, FALSE);
}

/*_________________________________________________________________________________
	Procedure:
		LinePathCallback
	Parameters:
		Widget	w;
		caddr_t clientData;
		caddr_t callData;
	Description:
		Callback function for drawing line path.
		Author: Tom (Tongzeng) Yang
		(11/27/91)
___________________________________________________________________________________*/
void            LinePathCallback (w, clientData, callData)
	Widget          w;
	caddr_t         clientData;
	caddr_t         callData;
{
	GRAPHICS_DATA  *graphics_data = (GRAPHICS_DATA *) clientData;
	Display        *display = graphics_data->draw_data->display;
	Window          window = graphics_data->draw_data->window;
	GC              gc = graphics_data->draw_data->gc;
	GC              xorgc = graphics_data->xorgc;

	PointerStatus  *pointer_state = &cPolyState;

	if (graphics_data->point_num > 0) {
		XDrawLines (display, window, xorgc, graphics_data->points,
			    graphics_data->point_num, CoordModeOrigin);
		if (*pointer_state == LinePathState)
			XDrawLines (display, window, gc, graphics_data->points,
				    graphics_data->point_num, CoordModeOrigin);
		else if (*pointer_state == PolygonState)
			XFillPolygon (display, window, gc, graphics_data->points,
				      graphics_data->point_num, Complex, CoordModeOrigin);
		graphics_data->point_num = 0;
	}
}

/*_________________________________________________________________________________
	Procedure:
		SaveWinDumpCallback
	Parameters:
		Widget	w;
		caddr_t clientData;
		caddr_t callData;
	Description:
		Callback function for saving window in window dump format.
		Author: Tom (Tongzeng) Yang
		(12/03/91)
___________________________________________________________________________________*/
Widget SaveWinDumpCallback (w, clientData, callData)
	Widget          w;
	caddr_t         clientData;
	caddr_t         callData;
{
	DRAW_DATA      *draw_data = (DRAW_DATA *) clientData;
	Display        *display = draw_data->display;
	Window          window = draw_data->window;
	WindowDump (display, window, FALSE, 0, 0, 0, 0, szSaveFileName);
}

/*_________________________________________________________________________________
	Procedure:
		DefaultsParCallback
	Parameters:
		Widget	w;
		caddr_t clientData;
		caddr_t callData;
	Description:
		Callback function for processing defaults parameters.
		Author: Tom (Tongzeng) Yang
		(12/10/91)
___________________________________________________________________________________*/
void            DefaultsParCallback (w, clientData, callData)
	Widget          w;
	caddr_t         clientData;
	caddr_t         callData;
{
	DATA_FILE_SELECTION *selectFileData = (DATA_FILE_SELECTION *) clientData;
	Widget          dialog = selectFileData->dialog;
	Display        *display = selectFileData->draw_data->display;
	Window          window = selectFileData->draw_data->window;
	GC              gc = selectFileData->draw_data->gc;
	Widget          text_file;
	Widget          file_list;
	char           *file_name;
	char            szBuffer[MAXLINE];
	char           *string;
	XmString        item;
	RGB_COLOR      *rgb_background = &rgbBackground;
	XColor          color;
	char           *extension;

	text_file = XmSelectionBoxGetChild (dialog, XmDIALOG_TEXT);
	file_name = XmTextGetString (text_file);
	file_list = XmSelectionBoxGetChild (dialog, XmDIALOG_LIST);

	/*
	 * Make sure there is a file.
	 */
	extension = strrchr (file_name, '/');
	if (strlen (file_name) == 0 || (extension != NULL && strcmp (extension, "/") == 0)) {
		XtManageChild (errorMessageBox);
		return;
	}
	switch (cFileState) {
	case OpenWinDump:
		strcpy (szImageFileName, file_name);
		LoadXwd (display, window, gc, file_name, 0, 0, FALSE);

		AppColormap (display, selectFileData->root_window);
		break;
	case SaveWinDump:
		string = strstr (file_name, ".xwd");
		strcpy (szBuffer, file_name);
		if (string == NULL || strcmp (string, ".xwd") != 0)
			strcat (szBuffer, ".xwd");
		strcpy (szSaveFileName, szBuffer);

		item = XmStringCreate (szBuffer, XmSTRING_DEFAULT_CHARSET);
		if (!XmListItemExists (file_list, item)) {
			XmListAddItem (file_list, item, 1);
			XmListSelectItem (file_list, item, True);
		} else
			XtFree (item);

		XtManageChild (selectFileData->information);
		break;
	case GetDefaults:
		GetDefaultParameters (display, selectFileData->root_window, gc,
				      file_name, selectFileData->default_parameters);
		break;
	case SaveDefaults:
		string = strstr (file_name, ".defaults");
		strcpy (szBuffer, file_name);
		if (string == NULL || strcmp (string, ".defaults") != 0)
			strcat (szBuffer, ".defaults");
		SaveDefaultParameters (szBuffer,
				       selectFileData->default_parameters);

		item = XmStringCreate (szBuffer, XmSTRING_DEFAULT_CHARSET);
		if (!XmListItemExists (file_list, item)) {
			XmListAddItem (file_list, item, 1);
			XmListSelectItem (file_list, item, True);
		} else
			XtFree (item);
	}

	XtFree (file_name);
	XtUnmanageChild (dialog);
}

/*________________________________________________________________________________________________
	Procedure:
		ToggleLabelCallback
	Parameters:
		w: Widget, widget where callback was triggered.
		clientData: caddr_t, client data.
		call_data: caddr_t, callback data.
	Description:
		Callback function for changing the toggle label.
		Author: Tom Yang
		(12/05/91)
________________________________________________________________________________________________*/

void            ToggleLabelCallback (w, clientData, callData)
	Widget          w;
	caddr_t         clientData;
	caddr_t         callData;
{
	XmToggleButtonCallbackStruct *ToggleData
	= (XmToggleButtonCallbackStruct *) callData;

	LABEL_CHANGE_DATA *labelChangeData
	= (LABEL_CHANGE_DATA *) clientData;

	int             n = 0;
	Arg             arglist[2];
	BOOLEAN         status;
	char            szBuffer[MAXLINE];

	status = ToggleData->set;
	XtSetArg (arglist[n], XmNset, status ? TRUE : FALSE);
	n++;
	if (status)
		strcpy (szBuffer, labelChangeData->label_true);
	else
		strcpy (szBuffer, labelChangeData->label_false);
	XtSetArg (arglist[n], XmNlabelString,
		  XmStringCreate (szBuffer, XmSTRING_DEFAULT_CHARSET));
	n++;
	XtSetValues (w, arglist, n);
}

/*________________________________________________________________________________________________
	Procedure:
		SaveOptionsCallback
	Parameters:
		w: Widget, widget where callback was triggered.
		clientData: caddr_t, client data.
		call_data: caddr_t, callback data.
	Description:
		Callback function for processing "Save Options" menu.
		Author: Tom Yang
		(12/05/91)
________________________________________________________________________________________________*/

void            SaveOptionsCallback (w, clientData, callData)
	Widget          w;
	caddr_t         clientData;
	caddr_t         callData;
{
	SAVE_IMAGE_DATA *save_image_data = (SAVE_IMAGE_DATA *) clientData;
	BOOLEAN        *windump_format = &bWinDumpFile;
	BOOLEAN        *save_whole_screen = &bSaveWholeScreen;
	int             n;
	Arg             arglist[2];
	char            buffer[MAXLINE];

	if (save_image_data->node_flag != 2) {

		*windump_format
			= XmToggleButtonGetState (save_image_data->file_format);
		*save_whole_screen
			= XmToggleButtonGetState (save_image_data->area_saved);

		if (*windump_format) {
			if (*save_whole_screen)
				XtManageChild (save_image_data->information);
			else
				cPointerState = SaveRegionState;
		}
	} else {
		n = 0;
		XtSetArg (arglist[n], XmNset, *windump_format);
		n++;
		if (*windump_format)
			strcpy (buffer, "File Format: Window Dump ");
		else
			strcpy (buffer, "File Format: PostScript ");
		XtSetArg (arglist[n], XmNlabelString, XmStringCreate (buffer,
								      XmSTRING_DEFAULT_CHARSET));
		n++;
		XtSetValues (save_image_data->file_format, arglist, n);

		n = 0;
		XtSetArg (arglist[n], XmNset, *save_whole_screen);
		n++;
		if (*save_whole_screen)
			strcpy (buffer, "Area Saved: Entire Window");
		else
			strcpy (buffer, "Area Saved: User Defined ");
		XtSetArg (arglist[n], XmNlabelString, XmStringCreate (buffer,
								      XmSTRING_DEFAULT_CHARSET));
		n++;
		XtSetValues (save_image_data->area_saved, arglist, n);
	}

	XtUnmanageChild (save_image_data->dialog);
}

/*___________________________________________________________________________________
	Procedure:
		SetToggleCallback
	Parameters:
		w: Widget, widget where callback was triggered.
		clientData: caddr_t, client data.
		call_data: caddr_t, callback data.
	Description:
		Callback function for Select Data menu widget to set the current
		display state.
		Author: Tom Yang
		(05/21/91)
_____________________________________________________________________________________*/

void            SetToggleCallback (w, clientData, callData)
	Widget          w;
	caddr_t         clientData;
	caddr_t         callData;
{
	XmToggleButtonCallbackStruct *ToggleData
	= (XmToggleButtonCallbackStruct *) callData;

	int             n = 0;
	Arg             arglist[1];

	XtSetArg (arglist[n], XmNset, (ToggleData->set) ? TRUE : FALSE);
	n++;
	XtSetValues (w, arglist, n);
}

/*___________________________________________________________________________________
	Procedure:
		view25dCallback
	Parameters:
		w: Widget, widget where callback was triggered.
		clientData: caddr_t, client data.
		call_data: caddr_t, callback data.
	Description:
		Callback function for invoking view25d.
		Author: Tom Yang
		(09/24/92)
_____________________________________________________________________________________*/

void            view25dCallback (w, clientData, callData)
	Widget          w;
	caddr_t         clientData;
	caddr_t         callData;
{
	system ("view25d &");
}

/*____________________________________________________________________________
	Procedure:
		AF3DSymbolCallback
	Parameters:
		w: Widget, widget where callback was triggered.
		clientData: caddr_t, client data.
		call_data: caddr_t, callback data.
	Description:
		Callback function for setting AF3D symbol attributes.
		Author: Tom Yang
		(09/25/91)
____________________________________________________________________________*/

void            AF3DSymbolCallback (w, clientData, callData)
	Widget          w;
	caddr_t         clientData;
	caddr_t         callData;
{
	SYMBOL_DATA    *symbol_data = (SYMBOL_DATA *) clientData;
	SYMBOL_MENU    *symbol_menu = symbol_data->symbol_menu;
	char           *color_index = &cSymbolColorIndex;
	char           *symbol_type = &cSymbolType;
	int            *symbol_size = &nSymbolSize;
	char            symbol_index;
	BOOLEAN         filled;
	int             n;
	Arg             arglist[3];

	PointerStatus  *pointer_state = &cPointerState;

	if (symbol_data->node_flag == SELECT) {
		*color_index = (char) GetActiveIndex (symbol_menu->toggle_color_set, MAX_NONIMAGE_COLOR);

		n = 0;
		XtSetArg (arglist[n], XtNbackground, &pixelSymbolColor);
		n++;
		XtGetValues (symbol_menu->toggle_color_set[*color_index], arglist, n);

		*symbol_type = (char) GetActiveIndex (symbol_menu->toggle_symbol_set, MAX_SYMBOL_NUM);

		if (XmToggleButtonGetState (*symbol_menu->filled))
			*symbol_type += FILLED_SYMBOL_START;

		XmScaleGetValue (*symbol_menu->size_scale, symbol_size);
		*pointer_state = SymbolState;
	} else {
		SetSelectData (symbol_menu->toggle_color_set[*color_index], True);

		if (*symbol_type < FILLED_SYMBOL_START) {
			symbol_index = *symbol_type;;
			filled = FALSE;
		} else {
			symbol_index = *symbol_type - FILLED_SYMBOL_START;
			filled = TRUE;
		}
		SetSelectData (symbol_menu->toggle_symbol_set[symbol_index], True);
		SetSelectData (*symbol_menu->filled, filled);

		XmScaleSetValue (*symbol_menu->size_scale, *symbol_size);
		*pointer_state = NoState;
	}

	XtUnmanageChild (symbol_data->dialog);
}
@


1.8
log
@Added processing for big fonts.
@
text
@d1 1
a1 1
/*$Header: /home/petsun4/ty7777/src/xlabel/RCS/xlabel.callbacks,v 1.7 1994/10/25 18:47:58 ty7777 Exp ty7777 $*/
d3 3
d29 1
a29 1
# 
d34 4
a37 4
void QuitCallback (w, clientData, callData)
Widget w;
caddr_t clientData;
caddr_t callData;
d42 4
a45 4
void CancelCallback (w, clientData, callData)
Widget w;
caddr_t clientData;
caddr_t callData;
d47 1
a47 1
	Widget dialog = (Widget) clientData;
d51 4
a54 4
void ShowMenuCallback (w, clientData, callData)
Widget w;
caddr_t clientData;
caddr_t callData;
d56 1
a56 1
	Widget dialog = (Widget) clientData;
d60 1
a60 2

/*________________________________________________________________________	
d69 1
a69 1
		Author: Tom Yang 
d72 4
a75 4
void ClearWindowCallback (w, clientData, callData)
Widget w;
caddr_t clientData;
caddr_t callData;
d77 3
a79 4
	DRAW_DATA	*drawData	= (DRAW_DATA *) clientData;

	XClearArea (drawData->display, drawData->window, 0, 0, 
			DRAW_AREA_WIDTH, DRAW_AREA_HEIGHT, FALSE);
d82 1
a82 2

/*____________________________________________________________________________	
d91 1
a91 1
		Author: Tom Yang 
d95 4
a98 4
void NonImageColorCallback (w, clientData, callData)
Widget w;
caddr_t clientData;
caddr_t callData;
d100 8
a107 8
	NONIMAGE_COLOR_DATA	*nonImageColorData	= (NONIMAGE_COLOR_DATA *) clientData;
	Display			*display		= nonImageColorData->display;
	int			n			= 0;
	Arg			arglist [1];
	Pixel			selected_color_pixel;
	Widget			selected_color_button;
	XColor			color;
	Colormap		dcmap;
d109 6
a114 5
	selected_color_button	
		= GetActiveWidget (nonImageColorData->back_color_set, 
					MAX_NONIMAGE_COLOR);
	n	= 0;
	XtSetArg (arglist [n], XtNbackground, &selected_color_pixel); n++;
d117 3
a119 3
	color.pixel	= selected_color_pixel;
	dcmap		= XDefaultColormap (display, DefaultScreen (display));
	XQueryColor (display, dcmap, &color); 
d121 3
a123 3
	nonImageColorData->rgb_value->red	= color.red;
	nonImageColorData->rgb_value->green	= color.green;
	nonImageColorData->rgb_value->blue	= color.blue;
d130 4
a133 4
void SetRadioToggleCallback (w, clientData, callData)
Widget	w;
caddr_t clientData;
caddr_t callData;
d135 5
a139 6
	int	n = 0;
	Arg	arglist [1];

	if (XmToggleButtonGetState (w))
	{
		XtSetArg (arglist [n], XmNset, TRUE); n++;
d144 1
a144 2

/*____________________________________________________________________________	
d153 1
a153 1
		Author: Tom Yang 
d157 4
a160 4
void ShowFileSelectionCallback (w, clientData, callData)
Widget w;
caddr_t clientData;
caddr_t callData;
d162 2
a163 4
	FILE_SELECTION_DATA	*fileSelectionData	
				= (FILE_SELECTION_DATA *) clientData;
	int			n;
	Arg			arglist [2];
d165 2
a166 6
	n	= 0;
	XtSetArg (arglist [n], XmNselectionLabelString, 
		fileSelectionData->label_selection); n++;
	XtSetArg (arglist[n], XmNfilterLabelString, 
		fileSelectionData->label_path); n++;
	XtSetValues (fileSelectionData->dialog, arglist, n); 
d168 8
a175 1
	cFileState	= fileSelectionData->file_state;
d177 2
d182 1
a182 2

/*_________________________________________________________________________________	
d192 1
a192 1
		Author: Tom Yang 
d196 4
a199 4
void SetPointerStatusCallback (w, clientData, call_data)
Widget	w;
caddr_t	clientData;
caddr_t	call_data;
d201 2
a202 3
	PointerStatus	state	= (PointerStatus) clientData;

	cPointerState	= state;			
d205 1
a205 2

/*_________________________________________________________________________________	
d214 1
a214 1
		Author: Tom (Tongzeng) Yang 
d217 5
a221 4
void BrowseListCallback (w, clientData, callData)
Widget	w;
caddr_t clientData;
caddr_t callData;
d223 3
a225 4
	Widget			text_widget	= (Widget) clientData;
	XmListCallbackStruct	*call_data	= (XmListCallbackStruct *) callData;
	char			*text;

d227 1
a227 1
	XmTextSetString (text_widget, text); 
d230 1
a230 2

/*_________________________________________________________________________________	
d239 1
a239 1
		Author: Tom (Tongzeng) Yang 
d242 4
a245 4
void SetTextFontCallback (w, clientData, callData)
Widget	w;
caddr_t clientData;
caddr_t callData;
d247 19
a265 19
	static char	*function	= "SetTextFontCallback";
	FONT_DATA	*font_data	= (FONT_DATA *)	clientData;
	Display		*display	= font_data->draw_data->display;
	GC		gc		= font_data->draw_data->gc;
	char		*alignment	= &cAlignment;
	char		*font_string;
	char		*buffer;
	int		point_size;
	char		size_string [MAXLINE];
	char		font_color_name [MAXLINE];
	XFontStruct	*font_struct;
	int		i;
	int		n;
	Arg		arglist [1];
	Widget		widget_buffer;
	char		*color_index	= &cTextColorIndex;
	char		*slant_index	= &cFontSlantIndex;
	char		*weight_index	= &cFontWeightIndex;
	char		*orient_index	= &cFontOrientIndex;
d267 3
a269 4
	widget_buffer	= GetActiveWidget (font_data->font_color_set, 
						MAX_NONIMAGE_COLOR);
	if (font_data->node_flag != CANCEL)
	{
d271 3
a273 2
		n	= 0;
		XtSetArg (arglist [n], XtNbackground, &pixelTextColor); n++;
d275 3
a277 3
		*color_index	
			= (char) GetActiveIndex (font_data->font_color_set, 
							MAX_NONIMAGE_COLOR);
d279 4
a282 5
		*slant_index	= GetActiveIndex (font_data->slant_set, SLANT_NUM);
		*weight_index	= GetActiveIndex (font_data->weight_set, WEIGHT_NUM);
		*orient_index	= GetActiveIndex (font_data->orient_set, ORIENT_NUM);
		*alignment	= GetActiveIndex (font_data->alignment_set,
						ALIGNMENT_NUM);
d286 6
a291 6
		font_string	= GetFontName (font_data->font_list, 
						font_data->font_name,
						font_data->weight_set,
						font_data->slant_set,
						font_data->size_list,
						font_data->size_name);
d293 2
a294 2
		/* 
		 * Free old font and load new font. 
d296 1
a296 1
		font_struct	= XLoadQueryFont (display, font_string);
d299 1
a299 2
		else
		{
d301 1
a301 1
			FontStruct	= font_struct;
d305 1
a305 3
	}
	else
	{
d310 1
a310 1
		XmTextSetString (*font_data->font_name, fontTable [nFontNameIndex - 1]);
d313 1
a313 1
		XmTextSetString (*font_data->size_name, fontSizeTable [nFontSizeIndex - 1]);
d315 1
a315 1
		widget_buffer	
d320 1
a320 1
		widget_buffer	
d325 1
a325 1
		widget_buffer	
d330 1
a330 3
		widget_buffer	
			= GetActiveWidget (font_data->alignment_set, 
					ALIGNMENT_NUM);
a335 2


d339 1
a339 2

/*_________________________________________________________________________________	
d348 1
a348 1
		Author: Tom (Tongzeng) Yang 
d351 4
a354 4
void SetLineAttribCallback (w, clientData, callData)
Widget	w;
caddr_t clientData;
caddr_t callData;
d356 6
a361 7
	LINE_ATTRIB_DATA	*line_attrib	= (LINE_ATTRIB_DATA *) clientData;
	int			*line_width	= &nLineWidth;
	char			*color_index	= &cLineColorIndex;
	int			n;
	Arg			arglist [1];
	Widget			selected_color_button;
	
d363 7
a369 7
	selected_color_button	
		= GetActiveWidget (line_attrib->line_color_set, 
					MAX_NONIMAGE_COLOR);
	if (line_attrib->node_flag != CANCEL)
	{
		n	= 0;
		XtSetArg (arglist [n], XtNbackground, &pixelLineColor); n++;
d371 3
a373 3
		*color_index	
			= (char) GetActiveIndex (line_attrib->line_color_set, 
							MAX_NONIMAGE_COLOR);
d376 1
a376 3
	}
	else
	{
d378 1
a378 1
		SetSelectData (line_attrib->line_color_set [*color_index], True);
d386 1
a386 2

/*_________________________________________________________________________________	
d395 1
a395 1
		Author: Tom (Tongzeng) Yang 
d398 4
a401 4
void SetArrowOptionsCallback (w, clientData, callData)
Widget	w;
caddr_t clientData;
caddr_t callData;
d403 3
a405 3
	ARROW_OPTIONS_DATA	*arrow_options	= (ARROW_OPTIONS_DATA *) clientData;
	int			*arrow_width	= &nArrowWidth;
	int			*arrow_length	= &nArrowLength;
d407 1
a407 2
	if (arrow_options->node_flag != CANCEL)
	{
d410 1
a410 3
	}
	else
	{
d418 1
a418 2

/*_________________________________________________________________________________	
d427 1
a427 1
		Author: Tom (Tongzeng) Yang 
d430 4
a433 4
void ButtonDownEventHandler (w, clientData, event)
Widget	w;
caddr_t clientData;
XEvent	*event;
d435 21
a455 21
	GRAPHICS_DATA	*graphics_data	= (GRAPHICS_DATA *) clientData;
	Display		*display	= graphics_data->draw_data->display;
	GC		gc		= graphics_data->draw_data->gc;
	GC		xorgc		= graphics_data->xorgc;
	PointerStatus	*pointer_state	= &cPointerState;
	Window		root_window	= DefaultRootWindow (display);
	Window		window		= graphics_data->draw_data->window;
	XGCValues	values;					/* values structure */
	XImage		*retimage;
	XFontStruct	*font_struct	= FontStruct;
	char		alignment_flag	= cAlignment;
	char		orient		= cFontOrientIndex;
	char		*text_string	= szTextString;
	int		format;
	int		left;
	int		nitems;
	int		symbol_size	= nSymbolSize;
	int		type;
	int		x;
	int		y;
	unsigned long	valuemask;				/* mask bits */
d457 1
a457 1
	cPolyState	= *pointer_state;
d459 3
a461 4
	if ((*pointer_state == LinePathState || 
		*pointer_state == PolygonState) && 
		graphics_data->point_num > 0) 
	{ 
d464 1
a464 3
	}
	else
	{
d469 7
a475 8
			*pointer_state == PolygonState ||
			*pointer_state == FreeHandState)
		{
			graphics_data->point_num	= 0;
			graphics_data->points [graphics_data->point_num].x
				= graphics_data->start_x; 
			graphics_data->points [graphics_data->point_num].y
				= graphics_data->start_y; 
d483 1
a483 1
	graphics_data->button_down_first	= TRUE;
d485 8
a492 9
	switch (*pointer_state)
	{
		case	SaveRegionState:
		case	CutState:
		case	CopyState:
		case	RectState:
			DrawRectangle (display, window, xorgc, 
					graphics_data->start_x, graphics_data->start_y,
					graphics_data->last_x, graphics_data->last_y);
d494 15
a508 16
			break;
		case	PasteState:
			if (XGetWindowProperty (display, root_window, XA_PRIMARY,
					0, sizeof (XImage), FALSE, IMAGE_DATA_TYPE, 
					&type, &format, &nitems, &left, &retimage) 
					== Success && type == IMAGE_DATA_TYPE)
			{
				wClipboard	= retimage->width;
				hClipboard	= retimage->height;
				XDestroyImage (retimage);
			}
			DrawRectangle (display, window, xorgc, 
					graphics_data->start_x, 
					graphics_data->start_y,
					graphics_data->start_x + wClipboard, 
					graphics_data->start_y + hClipboard);
d510 4
a513 4
			break;
		case	LabelState:
			GetLabelDim (font_struct, szTextString, nLineSpacing, orient, 
			&graphics_data->label_width, &graphics_data->label_height);
d515 4
a518 4
			x	= graphics_data->start_x;
			y	= graphics_data->start_y;
			GetTextStart (orient, alignment_flag, graphics_data->label_width, 
				graphics_data->label_height, &x, &y);
d520 3
a522 3
			XDrawRectangle (display, window, xorgc, x, y - font_struct->ascent,
					graphics_data->label_width,
					graphics_data->label_height);
d524 10
a533 10
			break;
		case	SymbolState:
			valuemask		= GCForeground | GCLineWidth | GCLineStyle 
							| GCCapStyle | GCJoinStyle;
			values.foreground	= pixelSymbolColor;
			values.line_width	= nLineWidth;
			values.line_style	= LineSolid;
			values.cap_style	= CapButt;
			values.join_style	= JoinRound;
			XChangeGC (display, gc, valuemask, &values);
d535 18
a552 18
			DrawSymbol (display, window, gc, 
				graphics_data->start_x - symbol_size / 2,
				graphics_data->start_y - symbol_size / 2,
				symbol_size, 
				symbol_size, 
				cSymbolType);
			break;
		case	FreeHandState:
		case	ArrowState:
		case	LineState:
		case	HoriLineState:
		case	VertLineState:
		case	LinePathState:
		case	PolygonState:
			GetLineEnd (*pointer_state, graphics_data->start_x, graphics_data->start_y,
					graphics_data->last_x, graphics_data->last_y, &x, &y);
			DrawLine (display, window, xorgc, 
					graphics_data->start_x, graphics_data->start_y, x, y);
d554 5
a558 5
			break;
		case	EllipseState:
			DrawEllipse (display, window, xorgc, 
					graphics_data->start_x, graphics_data->start_y,
					graphics_data->last_x, graphics_data->last_y);
d560 5
a564 5
			break;
		case	CircleState:
			DrawCircle (display, window, xorgc, 
					graphics_data->start_x, graphics_data->start_y,
					graphics_data->last_x, graphics_data->last_y);
d566 15
a580 15
			break;
		case	FilledRectState:
			DrawFilledRectangle (display, window, xorgc, 
					graphics_data->start_x, graphics_data->start_y,
					graphics_data->last_x, graphics_data->last_y);
			break;
		case	FilledEllipseState:
			DrawFilledEllipse (display, window, xorgc, 
					graphics_data->start_x, graphics_data->start_y,
					graphics_data->last_x, graphics_data->last_y);
			break;
		case	FilledCircleState:
			DrawFilledCircle (display, window, xorgc, 
					graphics_data->start_x, graphics_data->start_y,
					graphics_data->last_x, graphics_data->last_y);
d582 3
a584 3
			break;
		default:
			break;
d588 1
a588 2

/*_________________________________________________________________________________	
d597 1
a597 1
		Author: Tom (Tongzeng) Yang 
d600 4
a603 4
void ButtonMoveEventHandler (w, clientData, event)
Widget	w;
caddr_t clientData;
XEvent	*event;
d605 12
a616 12
	GRAPHICS_DATA	*graphics_data	= (GRAPHICS_DATA *) clientData;
	Display		*display	= graphics_data->draw_data->display;
	Window		window		= graphics_data->draw_data->window;
	GC		gc		= graphics_data->draw_data->gc;
	GC		xorgc		= graphics_data->xorgc;
	PointerStatus	*pointer_state	= &cPointerState;
	XFontStruct	*font_struct	= FontStruct;
	char		alignment_flag	= cAlignment;
	char		orient		= cFontOrientIndex;
	int		x, y;
	unsigned int	*wclipboard	= &wClipboard;
	unsigned int	*hclipboard	= &hClipboard;
d618 9
a626 11
	if (graphics_data->button_down_first)
	{
		switch (*pointer_state)
		{
			case	SaveRegionState:
			case	CutState:
			case	CopyState:
			case	RectState:
				DrawRectangle (display, window, xorgc, 
					graphics_data->start_x, graphics_data->start_y, 
					graphics_data->last_x, graphics_data->last_y);
d628 2
a629 2
				graphics_data->last_x	= event->xbutton.x,
				graphics_data->last_y	= event->xbutton.y,
d631 10
a640 10
				DrawRectangle (display, window, xorgc, 
					graphics_data->start_x, graphics_data->start_y, 
					graphics_data->last_x, graphics_data->last_y);
				break;
			case	PasteState:
				DrawRectangle (display, window, xorgc, 
					graphics_data->start_x, 
					graphics_data->start_y,
					graphics_data->start_x + *wclipboard, 
					graphics_data->start_y + *hclipboard);
d642 2
a643 2
				graphics_data->start_x	= event->xbutton.x,
				graphics_data->start_y	= event->xbutton.y,
d645 5
a649 5
				DrawRectangle (display, window, xorgc, 
					graphics_data->start_x, 
					graphics_data->start_y,
					graphics_data->start_x + *wclipboard, 
					graphics_data->start_y + *hclipboard);
d651 6
a656 6
				break;
			case	LabelState:
				x	= graphics_data->start_x;
				y	= graphics_data->start_y;
				GetTextStart (orient, alignment_flag, graphics_data->label_width, 
					graphics_data->label_height, &x, &y);
d658 3
a660 3
				XDrawRectangle (display, window, xorgc, 
				x, y - font_struct->ascent,
				graphics_data->label_width, graphics_data->label_height);
d662 4
a665 4
				x	= graphics_data->start_x	= event->xbutton.x;
				y	= graphics_data->start_y	= event->xbutton.y;
				GetTextStart (orient, alignment_flag, graphics_data->label_width, 
					graphics_data->label_height, &x, &y);
d667 2
a668 2
				XDrawRectangle (display, window, xorgc, x, y - font_struct->ascent,
				graphics_data->label_width, graphics_data->label_height);
d670 6
a675 6
				break;
			case	FreeHandState:
				graphics_data->start_x	= graphics_data->last_x;
				graphics_data->start_y	= graphics_data->last_y;
				graphics_data->last_x	= event->xbutton.x,
				graphics_data->last_y	= event->xbutton.y,
d677 3
a679 3
				DrawLine (display, window, xorgc, 
					graphics_data->start_x, graphics_data->start_y, 
					graphics_data->last_x, graphics_data->last_y);
d681 17
a697 17
				graphics_data->points [graphics_data->point_num].x	
					= graphics_data->last_x;
				graphics_data->points [graphics_data->point_num].y	
					= graphics_data->last_y;
				graphics_data->point_num++;
				break;
			case	ArrowState:
			case	LineState:
			case	HoriLineState:
			case	VertLineState:
			case	LinePathState:
			case	PolygonState:
				GetLineEnd (*pointer_state, 
					graphics_data->start_x, graphics_data->start_y,
					graphics_data->last_x, graphics_data->last_y, &x, &y);
				DrawLine (display, window, xorgc, 
					graphics_data->start_x, graphics_data->start_y, x, y);
d699 2
a700 2
				graphics_data->last_x	= event->xbutton.x,
				graphics_data->last_y	= event->xbutton.y,
d702 5
a706 5
				GetLineEnd (*pointer_state, 
					graphics_data->start_x, graphics_data->start_y,
					graphics_data->last_x, graphics_data->last_y, &x, &y);
				DrawLine (display, window, xorgc, 
					graphics_data->start_x, graphics_data->start_y, x, y);
d708 5
a712 5
				break;
			case	EllipseState:
				DrawEllipse (display, window, xorgc, 
					graphics_data->start_x, graphics_data->start_y, 
					graphics_data->last_x, graphics_data->last_y);
d714 2
a715 2
				graphics_data->last_x	= event->xbutton.x,
				graphics_data->last_y	= event->xbutton.y,
d717 8
a724 8
				DrawEllipse (display, window, xorgc, 
					graphics_data->start_x, graphics_data->start_y, 
					graphics_data->last_x, graphics_data->last_y);
				break;
			case	CircleState:
				DrawCircle (display, window, xorgc, 
					graphics_data->start_x, graphics_data->start_y, 
					graphics_data->last_x, graphics_data->last_y);
d726 2
a727 2
				graphics_data->last_x	= event->xbutton.x,
				graphics_data->last_y	= event->xbutton.y,
d729 8
a736 8
				DrawCircle (display, window, xorgc, 
					graphics_data->start_x, graphics_data->start_y, 
					graphics_data->last_x, graphics_data->last_y);
				break;
			case	FilledRectState:
				DrawFilledRectangle (display, window, xorgc, 
					graphics_data->start_x, graphics_data->start_y, 
					graphics_data->last_x, graphics_data->last_y);
d738 2
a739 2
				graphics_data->last_x	= event->xbutton.x,
				graphics_data->last_y	= event->xbutton.y,
d741 3
a743 3
				DrawFilledRectangle (display, window, xorgc, 
					graphics_data->start_x, graphics_data->start_y, 
					graphics_data->last_x, graphics_data->last_y);
d745 5
a749 5
				break;
			case	FilledEllipseState:
				DrawFilledEllipse (display, window, xorgc, 
					graphics_data->start_x, graphics_data->start_y, 
					graphics_data->last_x, graphics_data->last_y);
d751 2
a752 2
				graphics_data->last_x	= event->xbutton.x,
				graphics_data->last_y	= event->xbutton.y,
d754 3
a756 3
				DrawFilledEllipse (display, window, xorgc, 
					graphics_data->start_x, graphics_data->start_y, 
					graphics_data->last_x, graphics_data->last_y);
d758 5
a762 5
				break;
			case	FilledCircleState:
				DrawFilledCircle (display, window, xorgc, 
					graphics_data->start_x, graphics_data->start_y, 
					graphics_data->last_x, graphics_data->last_y);
d764 2
a765 2
				graphics_data->last_x	= event->xbutton.x,
				graphics_data->last_y	= event->xbutton.y,
d767 3
a769 3
				DrawFilledCircle (display, window, xorgc, 
					graphics_data->start_x, graphics_data->start_y, 
					graphics_data->last_x, graphics_data->last_y);
d771 3
a773 3
				break;
			default:
				break;
d778 1
a778 2

/*_________________________________________________________________________________	
d787 1
a787 1
		Author: Tom (Tongzeng) Yang 
d790 4
a793 4
void ButtonReleaseEventHandler (w, clientData, event)
Widget	w;
caddr_t clientData;
XEvent	*event;
d795 42
a836 41
	GRAPHICS_DATA		*graphics_data	= (GRAPHICS_DATA *) clientData;
	Display			*display	= graphics_data->draw_data->display;
	Window			window		= graphics_data->draw_data->window;
	Window			root_window	= DefaultRootWindow (display);
	XWindowAttributes	win_info;
	GC			gc		= graphics_data->draw_data->gc;
	GC			xorgc		= graphics_data->xorgc;
	PointerStatus		*pointer_state;
	int			x;
	int			y;
	int			x2;
	int			y2;
	int			*line_width	= &nLineWidth;
	char			alignment_flag	= cAlignment;
	char			orient		= cFontOrientIndex;
	char			szBuffer [MAXLINE];
	char			*text_string	= szTextString;
	XFontStruct		*font_struct	= FontStruct;
	unsigned long		valuemask;				/* mask bits */
	XGCValues		values;					/* values structure */
	unsigned int		*wclipboard	= &wClipboard;
	unsigned int		*hclipboard	= &hClipboard;
	int			result;
	long			itemid, dataid;
	int			length, id;
	XmString		clip_label;
	static int		cnt;
	XImage			*image;
	XImage			*retimage;
	char			*image_data;
	char			*retimage_data;
	XColor			*colors;
	XColor			*retcolors;
	int			ncolors;
	int			*retncolors;
	int			i;
	unsigned int		buffer_size;
	int			type, format, nitems, left;
	Colormap		colormap;
	RGB_COLOR		*rgb_background	= &rgbBackground;
	XColor			color;
d838 8
a845 11
	pointer_state	= &cPointerState;

	if (graphics_data->button_down_first)
	{
		valuemask		= GCForeground | GCLineWidth | GCLineStyle 
						| GCCapStyle | GCJoinStyle;
		values.foreground	= pixelLineColor;
		values.line_width	= *line_width;
		values.line_style	= LineSolid;
		values.cap_style	= CapButt;
		values.join_style	= JoinRound;
d848 7
a854 8
		switch (*pointer_state)
		{
			case	SaveRegionState:
			case	CutState:
			case	CopyState:
				DrawRectangle (display, window, xorgc, 
					graphics_data->start_x, graphics_data->start_y, 
					graphics_data->last_x, graphics_data->last_y);
d856 2
a857 2
				graphics_data->last_x	= event->xbutton.x,
				graphics_data->last_y	= event->xbutton.y,
d859 7
a865 7
				x	= graphics_data->start_x;
				y	= graphics_data->start_y;
				x2	= graphics_data->last_x;
				y2	= graphics_data->last_y;
				CheckPoints (&x, &y, &x2, &y2);
				if (x == x2 || y == y2)
					break;
d867 2
a868 2
				*wclipboard	= x2 - x;
				*hclipboard	= y2 - y;
d870 3
a872 4
				if (*pointer_state != SaveRegionState) 
				{
					if (!XGetWindowAttributes (display, window, &win_info)) 
						fprintf (stderr, "Can't get target window attributes.");
d874 1
a874 1
					ncolors	= GetXColors (display, &win_info, &colors);
d876 11
a886 8
					image	= XGetImage (display, window, x, y, 
							x2 - x, y2 - y, AllPlanes, ZPixmap);
					if (!image) 
					{
						fprintf (stderr, "unable to get image at %dx%d+%d+%d\n",
							x2 -x, y2 - y, x, y);
						exit (1);
					}
d888 4
a891 4
					XChangeProperty (display, root_window, XA_PRIMARY,
						IMAGE_DATA_TYPE, 32, PropModeReplace,
						(unsigned char *) image,
						sizeof (XImage) / 4);
d893 4
a896 4
					XChangeProperty (display, root_window, XA_SECONDARY,
						IMAGE_COLOR_TYPE, 32, PropModeReplace,
						(unsigned char *) colors,
						ncolors * sizeof (XColor) / 4);
d898 2
a899 4
					XChangeProperty (display, root_window, IMAGE_NCOLOR,
						XA_INTEGER, 16, PropModeReplace,
						(unsigned char *) &ncolors,
						sizeof (int) / 2);
d901 3
a903 2
					if (ncolors > 0) 
						free (colors);
d905 8
a912 3
					if ((*pointer_state == CutState) && x2 > x && y2 > y)
						XClearArea (display, window, 
							x, y, x2 - x, y2 - y, FALSE);
d914 9
a922 20
					/* 
					 * Alloc the pixel buffer. 
					 */
					buffer_size	= Image_Size (image);
					if ((image_data = malloc (buffer_size)) == NULL)
						printf (stderr, "Can't malloc data buffer.");
					for (i = 0; i < buffer_size; i++)
						image_data [i] = image->data [i];
					
					/* 
					 * Begin the copy. If the clipboard is locked,
					 * keep trying.
					 */
					clip_label = XmStringCreateSimple ("to_clipboard");
					while ((result = 
						XmClipboardStartCopy (display, window, clip_label,
							XtLastTimestampProcessed (display),
							NULL, NULL, &itemid)) != ClipboardSuccess)
						;
					XmStringFree (clip_label);
d924 7
a930 8
					/*
					 * Copy the data.
					 */
					while ((result = 
						XmClipboardCopy (display, window, itemid,
							"STRING", image_data, buffer_size,
							cnt, NULL)) != ClipboardSuccess)
						;
d932 6
a937 7
					/*
					 * End the transaction.
					 */
					while ((result = 
						XmClipboardEndCopy (display, window, itemid)) 
						!= ClipboardSuccess)
						;
d939 6
a944 8
					free (image_data);
					XDestroyImage (image);
				}
				else
				{
					WindowDump (display, window, TRUE, 
						x, y, x2 - x, y2 - y, szSaveFileName);
				}
d946 7
a952 7
				break;
			case	PasteState:
				DrawRectangle (display, window, xorgc, 
					graphics_data->start_x, 
					graphics_data->start_y,
					graphics_data->start_x + *wclipboard, 
					graphics_data->start_y + *hclipboard);
d954 2
a955 2
				graphics_data->start_x	= event->xbutton.x;
				graphics_data->start_y	= event->xbutton.y;
d957 18
a974 13
				if (XGetWindowProperty (display, root_window, XA_PRIMARY,
						0, sizeof (XImage), FALSE, IMAGE_DATA_TYPE, 
						&type, &format, &nitems, &left, &retimage) 
						== Success && type == IMAGE_DATA_TYPE)
				{
					if (XGetWindowProperty (display, root_window, 
						IMAGE_NCOLOR, 0, sizeof (int), FALSE, 
						XA_INTEGER, &type, &format, &nitems, 
						&left, &retncolors) 
						!= Success || type != XA_INTEGER)
					{
						return;
					}
d976 7
a982 8
					if (XGetWindowProperty (display, root_window, 
						XA_SECONDARY, 0, *retncolors * sizeof (XColor), 
						FALSE, IMAGE_COLOR_TYPE, &type, &format, 
						&nitems, &left, &retcolors) 
						!= Success || type != IMAGE_COLOR_TYPE)
					{
						return;
					}
d984 2
a985 8
					/*
				 	 * Retrieve the current contents of the clipboard.
				 	 */
					do 
					{
						result	= XmClipboardInquireLength (display,
							window, "STRING", &length);
					} while (result == ClipboardLocked);
d987 1
a987 2
					if (length == 0)
						return;
d989 2
a990 5
					retimage_data	= XtMalloc (length);

					do
					{
						result = XmClipboardRetrieve (display, window,
d992 1
a992 1
					} while (result == ClipboardLocked);
d994 1
a994 1
					retimage->data	= retimage_data;
d996 4
a999 4
					colormap	= DefaultColormap (display, 
								DefaultScreen (display));
					DoPseudo (display, &colormap, *retncolors, 
							retcolors, retimage, retimage);
d1001 4
a1004 4
					XPutImage(display, window, gc, retimage, 0, 0, 
						graphics_data->start_x, 
						graphics_data->start_y, 
			  			retimage->width, retimage->height);
d1006 2
a1007 2
					XtFree (retncolors);
					XtFree (retcolors);
d1009 1
a1009 1
					XtFree (retimage_data);
d1011 1
a1011 1
					XDestroyImage (retimage);
d1013 8
a1020 2
					AppColormap (display, graphics_data->root_window);
				}
d1022 1
a1022 8
				break;
			case	LabelState:
				x	= graphics_data->start_x;
				y	= graphics_data->start_y;
				GetTextStart (orient, alignment_flag, graphics_data->label_width, 
					graphics_data->label_height, &x, &y);

				XDrawRectangle (display, window, xorgc, x, y - font_struct->ascent,
d1025 2
a1026 2
				graphics_data->start_x	= event->xbutton.x;
				graphics_data->start_y	= event->xbutton.y;
d1028 5
a1032 5
				DrawLabel (display, window, gc, 
					graphics_data->start_x, graphics_data->start_y, 
					graphics_data->last_x, graphics_data->last_y, 
					pixelTextColor, font_struct, text_string, 
					alignment_flag, nLineSpacing, orient);
d1034 1
a1034 1
				XtFree (text_string);
d1036 4
a1039 4
				sprintf (szBuffer, "%d", graphics_data->start_x);
				XmTextSetString (graphics_data->xtext_edit_coord, szBuffer);
				sprintf (szBuffer, "%d", graphics_data->start_y);
				XmTextSetString (graphics_data->ytext_edit_coord, szBuffer);
d1041 1
a1041 1
				*pointer_state	= NoState; 
d1043 6
a1048 6
				break;
			case	FreeHandState:
				graphics_data->start_x	= graphics_data->last_x;
				graphics_data->start_y	= graphics_data->last_y;
				graphics_data->last_x	= event->xbutton.x,
				graphics_data->last_y	= event->xbutton.y,
d1050 3
a1052 3
				DrawLine (display, window, xorgc, 
					graphics_data->start_x, graphics_data->start_y, 
					graphics_data->last_x, graphics_data->last_y);
d1054 5
a1058 5
				graphics_data->points [graphics_data->point_num].x	
						= graphics_data->last_x;
				graphics_data->points [graphics_data->point_num].y	
						= graphics_data->last_y;
				graphics_data->point_num++;
d1060 14
a1073 14
				XDrawLines (display, window, xorgc, 
					graphics_data->points,
					graphics_data->point_num, 
					CoordModeOrigin);
				XDrawLines (display, window, gc, 
					graphics_data->points,
					graphics_data->point_num, 
					CoordModeOrigin);
				graphics_data->point_num	= 0;
				break;
			case	ArrowState:
				DrawLine (display, window, xorgc, 
					graphics_data->start_x, graphics_data->start_y,
					graphics_data->last_x, graphics_data->last_y);
d1075 2
a1076 2
				graphics_data->last_x	= event->xbutton.x,
				graphics_data->last_y	= event->xbutton.y,
d1078 14
a1091 14
				DrawInwardFlatArrow (display, window, gc, *line_width, 
					graphics_data->start_x, graphics_data->start_y,
					graphics_data->last_x, graphics_data->last_y);
				break;
			case	LineState:
			case	HoriLineState:
			case	VertLineState:
			case	LinePathState:
			case	PolygonState:
				GetLineEnd (*pointer_state, 
					graphics_data->start_x, graphics_data->start_y,
					graphics_data->last_x, graphics_data->last_y, &x, &y);
				DrawLine (display, window, xorgc, 
					graphics_data->start_x, graphics_data->start_y, x, y);
d1093 2
a1094 2
				graphics_data->last_x	= event->xbutton.x,
				graphics_data->last_y	= event->xbutton.y,
d1096 8
a1103 9
				GetLineEnd (*pointer_state, 
					graphics_data->start_x, graphics_data->start_y,
					graphics_data->last_x, graphics_data->last_y, &x, &y);
				if (*pointer_state != LinePathState &&
					*pointer_state != PolygonState)
				{
					DrawLine (display, window, gc, 
						graphics_data->start_x, 
						graphics_data->start_y, x, y);
d1105 4
a1108 6
				}
				else
				{
					DrawLine (display, window, xorgc, 
						graphics_data->start_x, 
						graphics_data->start_y, x, y);
d1110 11
a1120 11
					graphics_data->points [graphics_data->point_num].x	
						= graphics_data->last_x;
					graphics_data->points [graphics_data->point_num].y	
						= graphics_data->last_y;
					graphics_data->point_num++;
				}
				break;
			case	RectState:
				DrawRectangle (display, window, xorgc, 
					graphics_data->start_x, graphics_data->start_y, 
					graphics_data->last_x, graphics_data->last_y);
d1122 2
a1123 2
				graphics_data->last_x	= event->xbutton.x,
				graphics_data->last_y	= event->xbutton.y,
d1125 3
a1127 3
				DrawRectangle (display, window, gc, 
					graphics_data->start_x, graphics_data->start_y, 
					graphics_data->last_x, graphics_data->last_y);
d1129 5
a1133 5
				break;
			case	EllipseState:
				DrawEllipse (display, window, xorgc, 
					graphics_data->start_x, graphics_data->start_y, 
					graphics_data->last_x, graphics_data->last_y);
d1135 2
a1136 2
				graphics_data->last_x	= event->xbutton.x,
				graphics_data->last_y	= event->xbutton.y,
d1138 3
a1140 3
				DrawEllipse (display, window, gc, 
					graphics_data->start_x, graphics_data->start_y, 
					graphics_data->last_x, graphics_data->last_y);
d1142 5
a1146 5
				break;
			case	CircleState:
				DrawCircle (display, window, xorgc, 
					graphics_data->start_x, graphics_data->start_y, 
					graphics_data->last_x, graphics_data->last_y);
d1148 2
a1149 2
				graphics_data->last_x	= event->xbutton.x,
				graphics_data->last_y	= event->xbutton.y,
d1151 3
a1153 3
				DrawCircle (display, window, gc, 
					graphics_data->start_x, graphics_data->start_y, 
					graphics_data->last_x, graphics_data->last_y);
d1155 5
a1159 5
				break;
			case	FilledRectState:
				DrawFilledRectangle (display, window, xorgc, 
					graphics_data->start_x, graphics_data->start_y, 
					graphics_data->last_x, graphics_data->last_y);
d1161 2
a1162 2
				graphics_data->last_x	= event->xbutton.x,
				graphics_data->last_y	= event->xbutton.y,
d1164 3
a1166 3
				DrawFilledRectangle (display, window, gc, 
					graphics_data->start_x, graphics_data->start_y, 
					graphics_data->last_x, graphics_data->last_y);
d1168 5
a1172 5
				break;
			case	FilledEllipseState:
				DrawFilledEllipse (display, window, xorgc, 
					graphics_data->start_x, graphics_data->start_y, 
					graphics_data->last_x, graphics_data->last_y);
d1174 2
a1175 2
				graphics_data->last_x	= event->xbutton.x,
				graphics_data->last_y	= event->xbutton.y,
d1177 3
a1179 3
				DrawFilledEllipse (display, window, gc, 
					graphics_data->start_x, graphics_data->start_y, 
					graphics_data->last_x, graphics_data->last_y);
d1181 5
a1185 5
				break;
			case	FilledCircleState:
				DrawFilledCircle (display, window, xorgc, 
					graphics_data->start_x, graphics_data->start_y, 
					graphics_data->last_x, graphics_data->last_y);
d1187 2
a1188 2
				graphics_data->last_x	= event->xbutton.x,
				graphics_data->last_y	= event->xbutton.y,
d1190 3
a1192 3
				DrawFilledCircle (display, window, gc, 
					graphics_data->start_x, graphics_data->start_y, 
					graphics_data->last_x, graphics_data->last_y);
d1194 3
a1196 3
				break;
			default:
				break;
d1199 3
a1201 5

	if (*pointer_state != LinePathState && *pointer_state != PolygonState)
	{
		*pointer_state			= NoState; 
		graphics_data->point_num	= 0;
d1203 1
a1203 1
	graphics_data->button_down_first	= FALSE;
d1206 1
a1206 2

/*________________________________________________________________________________________________	
d1215 1
a1215 1
		Author: Tom (Tongzeng) Yang 
d1219 3
a1221 3
Widget	w;
caddr_t clientData;
caddr_t callData;
d1223 9
a1231 1
	TEXT_EDIT_DATA	*text_edit_data	= (TEXT_EDIT_DATA *) clientData;
a1232 10
	PointerStatus	*pointer_state; 
	char		*str1;
	char		*str2;
	char		szBuffer [MAXLINE];
	char		*text_string;
	short		*xstart		= &xTextEditStart;
	short		*ystart		= &yTextEditStart;

	pointer_state	= &cPointerState; 

d1236 2
a1237 3
	if (text_edit_data->node_flag == MOUSE_SELECT 
	|| text_edit_data->node_flag == SELECT)
	{
d1244 4
a1247 3
	if (text_edit_data->node_flag == MOUSE_SELECT)
	{
		*pointer_state	= LabelState; 
a1248 4
	else
	{
		*pointer_state	= NoState; 
	}
d1253 1
a1253 2
	if (text_edit_data->node_flag == SELECT)
	{
d1257 3
a1259 4
		if (strlen (str1) > 0 && strlen (str2) > 0)
		{
			*xstart	= atoi (str1);
			*ystart	= atoi (str2);
d1264 6
a1269 6
		DrawLabel (text_edit_data->draw_data->display, 
			text_edit_data->draw_data->window, 
			text_edit_data->draw_data->gc, 
			*xstart, *ystart, 0, 0, 
			pixelTextColor, FontStruct, szTextString, 
			cAlignment, nLineSpacing, cFontOrientIndex);
d1271 1
a1271 3
	}
	else if (text_edit_data->node_flag == CANCEL)
	{
a1276 1

d1280 1
a1280 2

/*_________________________________________________________________________________	
d1289 1
a1289 1
		Author: Tom (Tongzeng) Yang 
d1292 4
a1295 4
void RefreshCallback (w, clientData, callData)
Widget	w;
caddr_t clientData;
caddr_t callData;
d1297 4
a1300 4
	GRAPHICS_DATA	*graphics_data	= (GRAPHICS_DATA *) clientData;
	Display		*display	= graphics_data->draw_data->display;
	Window		window		= graphics_data->draw_data->window;
	GC		gc		= graphics_data->draw_data->gc;
d1306 1
a1306 2

/*_________________________________________________________________________________	
d1315 1
a1315 1
		Author: Tom (Tongzeng) Yang 
d1318 4
a1321 4
void LinePathCallback (w, clientData, callData)
Widget	w;
caddr_t clientData;
caddr_t callData;
d1323 5
a1327 6
	GRAPHICS_DATA	*graphics_data	= (GRAPHICS_DATA *) clientData;
	Display		*display	= graphics_data->draw_data->display;
	Window		window		= graphics_data->draw_data->window;
	GC		gc		= graphics_data->draw_data->gc;
	GC		xorgc		= graphics_data->xorgc;
	PointerStatus	*pointer_state	= &cPolyState;
d1329 3
a1331 2
	if (graphics_data->point_num > 0)
	{
d1333 1
a1333 1
				graphics_data->point_num, CoordModeOrigin);
d1336 1
a1336 1
				graphics_data->point_num, CoordModeOrigin);
d1339 2
a1340 2
				graphics_data->point_num, Complex, CoordModeOrigin);
		graphics_data->point_num	= 0;
d1344 1
a1344 2

/*_________________________________________________________________________________	
d1352 2
a1353 2
		Callback function for saving window in window dump format. 
		Author: Tom (Tongzeng) Yang 
d1357 3
a1359 3
Widget	w;
caddr_t clientData;
caddr_t callData;
d1361 3
a1363 4
	DRAW_DATA	*draw_data	= (DRAW_DATA *) clientData;
	Display		*display	= draw_data->display;
	Window		window		= draw_data->window;

d1367 1
a1367 2

/*_________________________________________________________________________________	
d1376 1
a1376 1
		Author: Tom (Tongzeng) Yang 
d1379 4
a1382 4
void DefaultsParCallback (w, clientData, callData)
Widget	w;
caddr_t clientData;
caddr_t callData;
d1384 14
a1397 14
	DATA_FILE_SELECTION	*selectFileData	= (DATA_FILE_SELECTION *) clientData;
	Widget			dialog		= selectFileData->dialog;
	Display			*display	= selectFileData->draw_data->display;
	Window			window		= selectFileData->draw_data->window;
	GC			gc		= selectFileData->draw_data->gc;
	Widget			text_file;
	Widget			file_list;
	char			*file_name;
	char			szBuffer [MAXLINE];
	char			*string;
	XmString		item;
	RGB_COLOR		*rgb_background	= &rgbBackground;
	XColor			color;
	char			*extension;
d1399 3
a1401 3
	text_file	= XmSelectionBoxGetChild (dialog, XmDIALOG_TEXT);
	file_name	= XmTextGetString (text_file);
	file_list	= XmSelectionBoxGetChild (dialog, XmDIALOG_LIST);
d1406 2
a1407 3
	extension	= strrchr (file_name, '/');
	if (strlen (file_name) == 0 || (extension != NULL && strcmp (extension, "/") == 0)) 
	{
d1411 4
d1416 8
a1423 5
	switch (cFileState)
	{
		case OpenWinDump:
			strcpy (szImageFileName, file_name);
			LoadXwd (display, window, gc, file_name, 0, 0, FALSE);
d1425 6
a1430 8
			AppColormap (display, selectFileData->root_window);
			break;
		case SaveWinDump:
			string	= strstr (file_name, ".xwd");
			strcpy (szBuffer, file_name);
			if (string == NULL || strcmp (string, ".xwd") != 0)
				strcat (szBuffer, ".xwd");
			strcpy (szSaveFileName, szBuffer);
d1432 13
a1444 8
			item	= XmStringCreate (szBuffer, XmSTRING_DEFAULT_CHARSET);
			if (!XmListItemExists (file_list, item))
			{
				XmListAddItem (file_list, item, 1);
				XmListSelectItem (file_list, item, True);
			}
			else
				XtFree (item);
d1446 6
a1451 22
			XtManageChild (selectFileData->information);
			break;
		case GetDefaults:
			GetDefaultParameters (display, selectFileData->root_window, gc,
				file_name, selectFileData->default_parameters);
			break;
		case SaveDefaults:
			string	= strstr (file_name, ".defaults");
			strcpy (szBuffer, file_name);
			if (string == NULL || strcmp (string, ".defaults") != 0)
				strcat (szBuffer, ".defaults");
			SaveDefaultParameters (szBuffer, 
				selectFileData->default_parameters);

			item	= XmStringCreate (szBuffer, XmSTRING_DEFAULT_CHARSET);
			if (!XmListItemExists (file_list, item))
			{
				XmListAddItem (file_list, item, 1);
				XmListSelectItem (file_list, item, True);
			}
			else
				XtFree (item);
d1458 1
a1458 2

/*________________________________________________________________________________________________	
d1467 1
a1467 1
		Author: Tom Yang 
d1471 4
a1474 4
void		ToggleLabelCallback (w, clientData, callData)
Widget		w;
caddr_t		clientData;
caddr_t		callData;
d1476 2
a1477 8
	XmToggleButtonCallbackStruct	*ToggleData		
					= (XmToggleButtonCallbackStruct *) callData;
	LABEL_CHANGE_DATA		*labelChangeData	
					= (LABEL_CHANGE_DATA *) clientData;
	int				n = 0;
	Arg				arglist [2];
	BOOLEAN				status;
	char				szBuffer [MAXLINE];
d1479 11
a1489 2
	status	= ToggleData->set;
	XtSetArg (arglist [n], XmNset, status? TRUE: FALSE); n++;
d1494 3
a1496 2
	XtSetArg (arglist [n], XmNlabelString,
		XmStringCreate (szBuffer, XmSTRING_DEFAULT_CHARSET)); n++;
d1500 1
a1500 2

/*________________________________________________________________________________________________	
d1509 1
a1509 1
		Author: Tom Yang 
d1513 4
a1516 4
void		SaveOptionsCallback (w, clientData, callData)
Widget		w;
caddr_t		clientData;
caddr_t		callData;
d1518 6
a1523 6
	SAVE_IMAGE_DATA		*save_image_data	= (SAVE_IMAGE_DATA *) clientData;
	BOOLEAN			*windump_format		= &bWinDumpFile;
	BOOLEAN			*save_whole_screen	= &bSaveWholeScreen;
	int			n;
	Arg			arglist [2];
	char			buffer [MAXLINE];
d1525 1
a1525 7
	if (save_image_data->node_flag != CANCEL)
	{
		
		*windump_format	
		= XmToggleButtonGetState (save_image_data->file_format);
		*save_whole_screen	
		= XmToggleButtonGetState (save_image_data->area_saved);
d1527 6
a1532 2
		if (*windump_format)
		{
d1536 1
a1536 1
				cPointerState	= SaveRegionState;			
d1538 4
a1541 5
	}
	else
	{
		n	= 0;
		XtSetArg (arglist[n], XmNset, *windump_format); n++;
d1546 3
a1548 2
		XtSetArg (arglist[n], XmNlabelString, XmStringCreate (buffer, 
				XmSTRING_DEFAULT_CHARSET)); n++;
d1551 3
a1553 2
		n	= 0;
		XtSetArg (arglist[n], XmNset, *save_whole_screen); n++;
d1558 3
a1560 2
		XtSetArg (arglist[n], XmNlabelString, XmStringCreate (buffer, 
				XmSTRING_DEFAULT_CHARSET)); n++;
d1567 1
a1567 2

/*___________________________________________________________________________________	
d1577 1
a1577 1
		Author: Tom Yang 
d1581 4
a1584 4
void SetToggleCallback (w, clientData, callData)
Widget		w;
caddr_t		clientData;
caddr_t		callData;
d1586 2
a1587 4
	XmToggleButtonCallbackStruct		*ToggleData 
					= (XmToggleButtonCallbackStruct *) callData;
	int				n = 0;
	Arg				arglist [1];
d1589 5
a1593 1
	XtSetArg (arglist [n], XmNset, (ToggleData->set)? TRUE: FALSE); n++;
d1597 1
a1597 2

/*___________________________________________________________________________________	
d1606 1
a1606 1
		Author: Tom Yang 
d1610 4
a1613 4
void view25dCallback (w, clientData, callData)
Widget		w;
caddr_t		clientData;
caddr_t		callData;
d1618 1
a1618 2

/*____________________________________________________________________________	
d1627 1
a1627 1
		Author: Tom Yang 
d1631 4
a1634 4
void		AF3DSymbolCallback (w, clientData, callData)
Widget		w;
caddr_t		clientData;
caddr_t		callData;
d1636 9
a1644 10
	SYMBOL_DATA	*symbol_data	= (SYMBOL_DATA *) clientData;
	SYMBOL_MENU	*symbol_menu	= symbol_data->symbol_menu;
	char		*color_index	= &cSymbolColorIndex;
	char		*symbol_type	= &cSymbolType;
	int		*symbol_size	= &nSymbolSize;
	char		symbol_index;
	BOOLEAN		filled;
	int		n;
	Arg		arglist [3];
	PointerStatus	*pointer_state	= &cPointerState; 
d1646 1
a1646 3
	if (symbol_data->node_flag == SELECT)
	{
		*color_index	= (char) GetActiveIndex (symbol_menu->toggle_color_set, MAX_NONIMAGE_COLOR);
d1648 2
a1649 3
		n	= 0;
		XtSetArg (arglist [n], XtNbackground, &pixelSymbolColor); n++;
		XtGetValues (symbol_menu->toggle_color_set [*color_index], arglist, n);
d1651 4
a1654 1
		*symbol_type	= (char) GetActiveIndex (symbol_menu->toggle_symbol_set, MAX_SYMBOL_NUM);
d1656 2
d1659 1
a1659 1
			*symbol_type	+= FILLED_SYMBOL_START;
d1662 3
a1664 5
		*pointer_state	= SymbolState; 
	}
	else
	{
		SetSelectData (symbol_menu->toggle_color_set [*color_index], True);
d1666 6
a1671 4
		if (*symbol_type < FILLED_SYMBOL_START)
		{
			symbol_index	= *symbol_type;; 
			filled		= FALSE;
d1673 1
a1673 6
		else
		{
			symbol_index	= *symbol_type - FILLED_SYMBOL_START; 
			filled		= TRUE;
		}
		SetSelectData (symbol_menu->toggle_symbol_set [symbol_index], True);
d1677 1
a1677 1
		*pointer_state	= NoState; 
@


1.7
log
@Before using copy in steps.
@
text
@d1 1
a1 1
/*$Header: /home/petsun4/ty7777/src/xlabel/RCS/xlabel.callbacks,v 1.6 1994/09/06 14:32:11 ty7777 Exp ty7777 $*/
d3 3
d308 1
a308 1
		XtFree (font_string);
@


1.6
log
@Same as the last version.
@
text
@d1 1
a1 1
/*$Header: /home/petsun4/ty7777/src/xlabel/RCS/xlabel.callbacks,v 1.5 1994/08/25 18:11:37 ty7777 Exp ty7777 $*/
d3 3
a932 1

d1290 1
a1290 1
	|| text_edit_data->node_flag == COORD_SELECT)
d1310 1
a1310 1
	if (text_edit_data->node_flag == COORD_SELECT)
d1490 1
d1492 2
a1493 2
				strcat (file_name, ".xwd");
			strcpy (szSaveFileName, file_name);
d1495 1
a1495 1
			item	= XmStringCreate (file_name, XmSTRING_DEFAULT_CHARSET);
d1512 1
d1514 2
a1515 2
				strcat (file_name, ".defaults");
			SaveDefaultParameters (file_name, 
d1518 1
a1518 1
			item	= XmStringCreate (file_name, XmSTRING_DEFAULT_CHARSET);
@


1.5
log
@Before porting to X11R5.
@
text
@d1 1
a1 1
/*$Header: /home/petsun4/ty7777/src/xlabel/RCS/xlabel.callbacks,v 1.4 1994/02/18 20:38:16 ty7777 Exp ty7777 $*/
d3 3
@


1.4
log
@LoadXwd () is changed.
@
text
@d1 1
a1 1
/*$Header: /home/petsun4/ty7777/src/xlabel/RCS/xlabel.callbacks,v 1.3 1993/04/21 14:59:22 ty7777 Exp ty7777 $*/
d3 3
d454 3
d528 2
a529 5
			DrawLabel (display, window, gc, 
				graphics_data->start_x, graphics_data->start_y, 
				graphics_data->last_x, graphics_data->last_y, 
				pixelTextColor, FontStruct, text_string, 
				cAlignment, nLineSpacing, cFontOrientIndex);
d531 4
a534 2
			XtFree (text_string);
			*pointer_state	= NoState; 
d536 4
d628 3
d671 19
d828 5
d1056 28
d1252 1
a1252 1
/*_________________________________________________________________________________	
d1263 1
a1263 1
___________________________________________________________________________________*/
a1269 1
	PointerStatus	*pointer_state	= &cPointerState; 
d1271 15
a1285 1
	if (text_edit_data->node_flag != CANCEL)
d1287 8
a1295 1
		szTextString	= XmTextGetString (text_edit_data->text);
d1298 1
d1300 1
d1302 32
a1333 1
	XmTextSetString (text_edit_data->text, "");
@


1.3
log
@After making save xwd working.
@
text
@d1 1
a1 1
/*$Header: /home/petsun4/ty7777/src/xlabel/RCS/xlabel.callbacks,v 1.2 1993/03/31 16:36:44 ty7777 Exp ty7777 $*/
d3 3
d1244 1
a1244 1
		LoadXwd (display, window, gc, szImageFileName);
d1362 1
a1362 1
			LoadXwd (display, window, gc, file_name);
@


1.2
log
@Error checking for file name.
@
text
@d1 1
a1 1
/*$Header: /home/petsun4/ty7777/src/xlabel/RCS/xlabel.callbacks,v 1.1 1993/03/08 22:50:15 ty7777 Exp ty7777 $*/
d3 3
d1349 1
a1349 1
	if (strlen (file_name) == 0 || strcmp (extension, "/") == 0) 
@


1.1
log
@Initial revision
@
text
@d1 5
a5 2
/*$Header: xlabel.callbacks,v 1.6 92/11/23 22:18:48 ty7777 Exp $*/
/*$Log:	xlabel.callbacks,v $
d1227 1
a1227 1
Widget RefreshCallback (w, clientData, callData)
d1254 1
a1254 1
Widget LinePathCallback (w, clientData, callData)
d1318 1
a1318 1
Widget DefaultsParCallback (w, clientData, callData)
d1336 1
d1341 10
@
