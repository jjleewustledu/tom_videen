head	1.13;
access;
symbols;
locks; strict;
comment	@ * @;


1.13
date	99.02.15.14.26.34;	author tom;	state Exp;
branches;
next	1.12;

1.12
date	94.12.30.20.51.36;	author ty7777;	state Exp;
branches;
next	1.11;

1.11
date	94.12.30.17.49.30;	author ty7777;	state Exp;
branches;
next	1.10;

1.10
date	94.08.25.18.10.42;	author ty7777;	state Exp;
branches;
next	1.9;

1.9
date	93.03.30.22.23.43;	author ty7777;	state Exp;
branches;
next	1.8;

1.8
date	93.03.12.21.25.41;	author ty7777;	state Exp;
branches;
next	1.7;

1.7
date	93.03.10.18.09.59;	author ty7777;	state Exp;
branches;
next	1.6;

1.6
date	93.03.09.20.21.20;	author ty7777;	state Exp;
branches;
next	1.5;

1.5
date	93.02.17.20.38.09;	author ty7777;	state Exp;
branches;
next	1.4;

1.4
date	92.09.28.16.33.15;	author ty7777;	state Exp;
branches;
next	1.3;

1.3
date	92.08.26.20.01.11;	author ty7777;	state Exp;
branches;
next	1.2;

1.2
date	92.07.22.18.30.34;	author ty7777;	state Exp;
branches;
next	1.1;

1.1
date	92.04.29.15.37.51;	author ty7777;	state Exp;
branches;
next	;


desc
@Xlabel Source Code Version 1.
@


1.13
log
@start to update & port
@
text
@/*$Header: /home/npggw/tom/src/xlabel/RCS/utility.c,v 1.12 1994/12/30 20:51:36 ty7777 Exp tom $*/
/*$Log: utility.c,v $
 * Revision 1.12  1994/12/30  20:51:36  ty7777
 * Same as the last version.
 *
 * Revision 1.11  1994/12/30  17:49:30  ty7777
 * Added processing for big fonts.
 *
 * Revision 1.10  1994/08/25  18:10:42  ty7777
 * Before porting to X11R5.
 *
 * Revision 1.9  1993/03/30  22:23:43  ty7777
 * Before modifying.
 *
 * Revision 1.8  1993/03/12  21:25:41  ty7777
 * Alignment of texts by tabs.
 *
 * Revision 1.7  1993/03/10  18:09:59  ty7777
 * Making tabs align correctly.
 *
 * Revision 1.5  1993/02/17  20:38:09  ty7777
 * After fixing multiline with null line bug.
 *
 * Revision 1.4  1992/09/28  16:33:15  ty7777
 * After Symbol Menu Worked.
 **/

/*_________________________________________________________________________
	File Name:
		utility.c

	Description:
		Support functions for program xlabel.c. 
	Author:
		Tom Yang
		12/06/91

	Modifications:
	Pending:
		All comments which include the string "FIX" have information
		on current limitation, bugs, or noted problems.

______________________________________________________________________________*/

#include "app.h"
#include "utility.h"
#include <unistd.h>
#include <Xm/ToggleB.h>
#include <Xm/Text.h>
#include <math.h>
#include <winutil.h>

void GetCircleInfo ();


/*______________________________________________________________________________	
	Procedure:
		SetSelectData
	Parameters:
		w:		Widget, widget where callback was triggered.
		status_flag:	BOOLEAN, either on or off.
	Description:
		Callback function for Select Data menu widget to set the current
		display state.
		Author: Tom Yang 
		(05/21/91)
_____________________________________________________________________________*/

void SetSelectData (w, status_flag)
Widget		w;
BOOLEAN		status_flag;
{
	int				n = 0;
	Arg				args[1];

	if (status_flag != XmToggleButtonGetState (w))
	{
		XmToggleButtonSetState (w, status_flag, FALSE);

		XtSetArg (args[n], XmNset, (status_flag)? TRUE: FALSE); n++;
		XtSetValues (w, args, n);
	}
}


/*________________________________________________________________________________________________	
	Function:
		Swap	
	Arguments:
		int *: first integet pointer
		int *: second integet pointer
	Description:
		Swap two integer pointers.

	Author:
		Tom (Tongzeng) Yang
		(05/14/1991)
_______________________________________________________________________________________________*/

void Swap (pnFirst, pnSecond)
int	*pnFirst;
int	*pnSecond;
{
	int	temp;		/* temp int buffer */

	temp		= *pnFirst;
	*pnFirst	= *pnSecond;
	*pnSecond	= temp;
}


/*________________________________________________________________________________________________	
	Function:
		DrawInwardFlatArrow	
	Arguments:
	Description:
		Draw an inward flat arrow for a line segment.

	Author:
		Tom (Tongzeng) Yang
		(11/15/1991)
_______________________________________________________________________________________________*/

void DrawInwardFlatArrow (display, window, gc, line_width, x, y, x2, y2)
	Display	*display;
	Window	window;
	GC	gc;
	int	line_width;
	int	x, y, x2, y2;
{
	double	line_length;
	double	cos_phi;
	double	sin_phi;
	int	arrow_width;
	int	arrow_length	= nArrowLength;
	int	x1, y1;
	double	xe, ye;
	XPoint	points [3];

	line_length	= sqrt (((double)x2 - x) * (x2 - x) + ((double)y2 - y) * (y2 - y));
	cos_phi		= (x2 - x) / line_length;
	sin_phi		= (y2 - y) / line_length;
	arrow_width	= pkg_max (line_width, nArrowWidth);  

	x1		= ROUND (x2 - arrow_length * cos_phi);
	y1		= ROUND (y2 - arrow_length * sin_phi);
	xe		= x2 - (arrow_length + 2) * cos_phi;
	ye		= y2 - (arrow_length + 2) * sin_phi;

	points [0].x	= x2;
	points [0].y	= y2;
	points [1].x	= ROUND (xe + arrow_width * sin_phi / 2);
	points [1].y	= ROUND (ye - arrow_width * cos_phi / 2);
	points [2].x	= ROUND (xe - arrow_width * sin_phi / 2);
	points [2].y	= ROUND (ye + arrow_width * cos_phi / 2);

	XDrawLine (display, window, gc, x, y, x1, y1);
	XFillPolygon (display, window, gc, points, 3, Convex, CoordModeOrigin);
}

void GetLineEnd (pointer_state, x, y, x2, y2, xe, ye)
	PointerStatus	pointer_state;
	int		x, y, x2, y2;
	int		*xe, *ye;
{
	*xe	= x2;
	*ye	= y2;
	if (pointer_state	== HoriLineState)
		*ye	= y;
	else if (pointer_state	== VertLineState)
		*xe	= x;
}

void DrawLine (display, window, gc, x, y, x2, y2)
	Display	*display;
	Window	window;
	GC	gc;
	int	x, y, x2, y2;
{
	XDrawLine (display, window, gc, x, y, x2, y2);
}

void DrawRectangle (display, window, gc, x, y, x2, y2)
	Display	*display;
	Window	window;
	GC	gc;
	int	x, y, x2, y2;
{
	CheckPoints (&x, &y, &x2, &y2);
	XDrawRectangle (display, window, gc,  x, y, x2 - x, y2 - y);
}

void DrawFilledRectangle (display, window, gc, x, y, x2, y2)
	Display	*display;
	Window	window;
	GC	gc;
	int	x, y, x2, y2;
{
	CheckPoints (&x, &y, &x2, &y2);
	XFillRectangle (display, window, gc, x, y, x2 - x, y2 - y);
}

void CheckPoints (x, y, x2, y2)
	int	*x, *y, *x2, *y2;
{
	if (*x2 < *x)
		Swap (x2, x);
	if (*y2 < *y)
		Swap (y2, y);
}

void DrawEllipse (display, window, gc, x, y, x2, y2)
	Display	*display;
	Window	window;
	GC	gc;
	int	x, y, x2, y2;
{
	CheckPoints (&x, &y, &x2, &y2);
	XDrawArc(display, window, gc, x, y, x2 - x, y2 - y, 0, 64 * 360);
}

void DrawFilledEllipse (display, window, gc, x, y, x2, y2)
	Display	*display;
	Window	window;
	GC	gc;
	int	x, y, x2, y2;
{
	CheckPoints (&x, &y, &x2, &y2);
	XFillArc (display, window, gc, x, y, x2 - x, y2 - y, 0, 64 * 360);
}

void GetCircleInfo (x, y, x2, y2, xc, yc, r)
	int		x, y, x2, y2;
	int		*xc, *yc;
	unsigned int	*r;
{
	*xc	= (x + x2) / 2;	
	*yc	= (y + y2) / 2;	
	*r	= pkg_min (abs (x2 - x), abs (y2 - y));	 
}

void DrawCircle (display, window, gc, x, y, x2, y2)
	Display	*display;
	Window	window;
	GC	gc;
	int	x, y, x2, y2;
{
	int		xc, yc;
	unsigned int	r;

	CheckPoints (&x, &y, &x2, &y2);
	GetCircleInfo (x, y, x2, y2, &xc, &yc, &r);
	XDrawArc(display, window, gc, xc - r / 2, yc - r / 2, r, r, 0, 64 * 360);
}

void DrawFilledCircle (display, window, gc, x, y, x2, y2)
	Display	*display;
	Window	window;
	GC	gc;
	int	x, y, x2, y2;
{
	int		xc, yc;
	unsigned int	r;

	CheckPoints (&x, &y, &x2, &y2);
	GetCircleInfo (x, y, x2, y2, &xc, &yc, &r);
	XFillArc(display, window, gc, xc - r / 2, yc - r / 2, r, r, 0, 64 * 360);
}

void GetLabelDim (font_struct, text_string, line_spacing, text_orient, label_width, label_height)
	XFontStruct	*font_struct;
	char		*text_string;
	int		line_spacing;
	char		text_orient;
	short		*label_width;
	short		*label_height;
{
	XCharStruct	overall;
	char		*pure_string;
	char		*string_buffer;
	int		direction_hint;	
	int		font_ascent;
	int		font_descent;
	int		font_height;
	int		font_width;
	int		i, j, k, m;
	int		string_width;
	int		tabspaces;
	int		tabspaces_per_line;
	int		text_length;
	short		num_lines;
	short		width;
	short		height;
	static char	*function	= "GetLabelDim";

	text_length	= strlen (text_string);
	font_struct	= FontStruct;
	font_height	= font_struct->ascent + font_struct->descent;

	string_buffer	= (char *) pkg_malloc (text_length, function, "string_buffer");
	pure_string	= (char *) pkg_malloc (text_length, function, "pure_string");

	strncpy (string_buffer, "\0", text_length);
	strncpy (pure_string, "\0", text_length);

	XTextExtents (font_struct, "x", 1, &direction_hint, &font_ascent, &font_descent, &overall);
	font_width	= overall.rbearing - overall.lbearing;

	i		= 0;
	width		= 0;
	height		= 0;
	num_lines	= 0;

	while (i < text_length)
	{
		j			= 0;
		k			= 0;
		m			= 0;
		tabspaces_per_line	= 0;
		while (i < text_length && text_string [i] != '\n')
		{
			if (text_string [i] != '\t')
			{
				pure_string [k++]	= text_string [i];
				m++;
			}
			else
			{
				tabspaces_per_line	+= (m / 8 + 1) * 8 - m;
				m	+= tabspaces_per_line;
			}
			string_buffer [j++]	= text_string [i];

			i++;
		} 

		string_buffer [j++]	= text_string [i];
		pure_string [j++]	= text_string [i];
		i++;

		switch (text_orient) 
		{
			case ORIENT_HORI: 	
				if (strlen (string_buffer) > 0)
				{
					string_width	= XTextWidth (font_struct, pure_string, 
								strlen (pure_string)) 
								+ tabspaces_per_line * font_width;
					if (string_width > width)
						width	= string_width;
				}

				num_lines++;
				break;
			case ORIENT_VERT:
				string_width	= font_height * strlen (string_buffer);
				if (height > string_width)
					height	= string_width;

				num_lines++;
				break;
		}

		strncpy (string_buffer, "\0", text_length);
		strncpy (pure_string, "\0", text_length);
	}
	XtFree (string_buffer);
	XtFree (pure_string);

	if (text_orient == ORIENT_HORI)
	{
		*label_width	= width;
		*label_height	= ((num_lines - 1) * font_height * line_spacing) 
				/ LINE_SPACING_FACTOR + font_height;
	}
	else if (text_orient == ORIENT_VERT)
	{
		*label_width	= ((num_lines - 1) * font_width * line_spacing) 
				/ LINE_SPACING_FACTOR + font_width;
		*label_height	= height;
	}
}

void DrawLabel (display, window, gc, x, y, x2, y2, color_pixel, font_struct, 
			text_string, alignment_flag, line_spacing, text_orient)
	Display		*display;
	Window		window;
	GC		gc;
	int		x, y, x2, y2;
	Pixel		color_pixel;
	XFontStruct	*font_struct;
	char		*text_string;
	char		alignment_flag;
	int		line_spacing;
	char		text_orient;
{
	char		*pure_string;
	char		*string_buffer;
	int		font_height;
	int		font_width;
	int		i, j, k, m;
	int		tabspaces;
	int		tabspaces_per_line;
	int		string_width;
	int		text_length;
	int		xinitial;
	int		yinitial;
	int		xstart;
	int		ystart;
	int		direction_hint;	
	int		font_ascent;
	int		font_descent;
	XCharStruct	overall;
	static char	*function	= "DrawLabel";

	text_length	= strlen (text_string);
	font_struct	= FontStruct;
	font_height	= font_struct->ascent + font_struct->descent;

	string_buffer	= (char *) pkg_malloc (text_length, function, "string_buffer");
	pure_string	= (char *) pkg_malloc (text_length, function, "pure_string");

	strncpy (string_buffer, "\0", text_length);
	strncpy (pure_string, "\0", text_length);
	XSetFont (display, gc, font_struct->fid);
	XSetForeground (display, gc, color_pixel);

	XTextExtents (font_struct, "x", 1, &direction_hint, &font_ascent, &font_descent, &overall);
	font_width	= overall.rbearing - overall.lbearing;

	i	= 0;
	xstart	= x;
	ystart	= y;
	while (i < text_length)
	{
		j			= 0;
		k			= 0;
		m			= 0;
		tabspaces_per_line	= 0;
		while (i < text_length && text_string [i] != '\n')
		{
			if (text_string [i] != '\t')
			{
				pure_string [k++]	= text_string [i];
				m++;
			}
			else
			{
				tabspaces_per_line	+= (m / 8 + 1) * 8 - m;
				m	+= tabspaces_per_line;
			}
			string_buffer [j++]	= text_string [i];

			i++;
		} 

		string_buffer [j++]	= text_string [i];
		pure_string [j++]	= text_string [i];
		i++;

		switch (text_orient) 
		{
			case ORIENT_HORI: 	
				if (strlen (string_buffer) > 0)
				{
					string_width	= XTextWidth (font_struct, pure_string, 
								strlen (pure_string)) 
								+ tabspaces_per_line * font_width;

					xstart	= x;
					if (alignment_flag == ALIGNMENT_CENTER)
					{
						xstart	-= string_width / 2;
					}
					else if (alignment_flag == ALIGNMENT_RIGHT)
					{
						xstart	-= string_width;
					}
					xinitial	= xstart;

					strncpy (pure_string, "\0", text_length);
					j	= 0;
					k	= 0;
					m	= 0;
					while (j <= strlen (string_buffer))
					{
						if (j < strlen (string_buffer) && string_buffer [j] != '\t')
						{
							pure_string [k++]	= string_buffer [j];
							m++;
						}
						else
						{
							XDrawString (display, window, gc, xstart, ystart, 
								pure_string, k);

							m	= (m / 8 + 1) * 8;
							xstart	= xinitial + m * font_width;
							strncpy (pure_string, "\0", text_length);
							k	= 0;
						}

						j++;
					}
				}

				ystart	+= (font_height * line_spacing) / LINE_SPACING_FACTOR;
				break;
			case ORIENT_VERT:
				ystart	= y;

				string_width	= font_height * strlen (string_buffer);

				if (alignment_flag == ALIGNMENT_CENTER)
				{
					ystart	-= string_width / 2;
				}
				else if (alignment_flag == ALIGNMENT_RIGHT)
				{
					ystart	-= string_width;
				}

				for (k = 0; k < strlen (string_buffer); k++) 
				{
					XDrawString (display, window, gc, 
						xstart, ystart + (font_height * k), 
						string_buffer + k, 1);
				}

				xstart	+= (font_height * line_spacing) / LINE_SPACING_FACTOR;
				break;
		}

		strncpy (string_buffer, "\0", text_length);
		strncpy (pure_string, "\0", text_length);
	}

	XtFree (string_buffer);
	XtFree (pure_string);
}


/*________________________________________________________________________________________________	
	Function:
		GetActiveIndex	
	Arguments:
	Description:
		Get the index of the current selected widget from a group of widgets.

	Author:
		Tom (Tongzeng) Yang
		(12/09/1991)
_______________________________________________________________________________________________*/

int GetActiveIndex (widget_set, num_widget)
	Widget	*widget_set;
	int	num_widget;
{
	int	i;
	int	index;

	for (i = 0; i < num_widget; i++)
	{
		if (XmToggleButtonGetState (widget_set[i]))
		{
			index	= i;
			break;
		}
	}

	return	index;
}


/*________________________________________________________________________________________________	
	Function:
		GetActiveWidget	
	Arguments:
	Description:
		Get the current select widget from a group of widgets.

	Author:
		Tom (Tongzeng) Yang
		(12/05/1991)
_______________________________________________________________________________________________*/

Widget GetActiveWidget (widget_set, num_widget)
	Widget	*widget_set;
	int	num_widget;
{
	int	index;

	index	= GetActiveIndex (widget_set, num_widget);
	return *(widget_set + index);
}


/*________________________________________________________________________________________________	
	Function:
		GetNameFromWidget	
	Arguments:
	Description:
		Get the color name form the current selected widget.

	Author:
		Tom (Tongzeng) Yang
		(12/05/1991)
_______________________________________________________________________________________________*/

void GetNameFromWidget (widget_set, num_widget, mode, name)
	Widget	*widget_set;
	int	num_widget;
	char	mode;
	char	*name;
{
	int	index;

	index	= GetActiveIndex (widget_set, num_widget);
	switch (mode)
	{
		case TOGGLE_COLOR: 
			strcpy (name, nonImageColorList [index]);
			break;
		case TOGGLE_ALIGN: 
			strcpy (name, alignmentList [index]);
			break;
		case TOGGLE_SLANT: 
			strcpy (name, slantList [index]);
			break;
		case TOGGLE_WEIGHT: 
			strcpy (name, weightList [index]);
			break;
		case TOGGLE_ORIENT: 
			strcpy (name, orientList [index]);
			break;
	}
}


/*________________________________________________________________________________________________	
	Function:
		GetIndex	
	Arguments:
	Description:
		Get the index from the name of a widget.

	Author:
		Tom (Tongzeng) Yang
		(12/09/1991)
_______________________________________________________________________________________________*/

int GetIndexFromName (name, mode)
	char	*name;
	char	mode;
{
	char	lower_name [MAXLINE];
	char	**symbol_names	= symbolNames;
	int	index;

	strcpy (lower_name, name);
	Lowered (lower_name, strlen (lower_name));

	switch (mode)
	{
		case TOGGLE_COLOR:
			if (strncmp (lower_name, "black", 5) == 0)
				index	= BLACK;
			else if (strncmp (lower_name, "blue", 4) == 0)
				index	= BLUE;
			else if (strncmp (lower_name, "cyan", 4) == 0)
				index	= CYAN;
			else if (strncmp (lower_name, "green", 5) == 0)
				index	= GREEN;
			else if (strncmp (lower_name, "yellow", 6) == 0)
				index	= YELLOW;
			else if (strncmp (lower_name, "magenta", 7) == 0)
				index	= MAGENTA;
			else if (strncmp (lower_name, "red", 3) == 0)
				index	= RED;
			else 
				index	= WHITE;
			break;
		case TOGGLE_ALIGN:
			if (strncmp (lower_name, "left", 4) == 0)
				index	= ALIGNMENT_LEFT;
			else if (strncmp (lower_name, "center", 5) == 0)
				index	= ALIGNMENT_CENTER;
			else 
				index	= ALIGNMENT_RIGHT;
			break;
		case TOGGLE_SLANT:
			if (strncmp (lower_name, "roman", 5) == 0)
				index	= SLANT_ROMAN;
			else if (strncmp (lower_name, "italic", 6) == 0)
				index	= SLANT_ITALIC;
			else 
				index	= SLANT_OBLIQUE;
			break;
		case TOGGLE_WEIGHT:
			if (strncmp (lower_name, "medium", 6) == 0)
				index	= WEIGHT_MEDIUM;
			else 
				index	= WEIGHT_BOLD;
			break;
		case TOGGLE_ORIENT:
			if (strncmp (lower_name, "horizontal", 10) == 0)
				index	= ORIENT_HORI;
			else 
				index	= ORIENT_VERT;
			break;
		case TOGGLE_SYMBOL_SHAPE:
			for (index = 0; index < 2 * MAX_SYMBOL_NUM; index++)
			{
				if (strcmp (lower_name, symbol_names [index]) == 0)
					break;
			}
			break;
	}

	return	index;
}


/*______________________________________________________________________________________	
	Function:
		GetWidgetFormName	
	Arguments:
	Description:
		Get the current select widget from a group of widgets.

	Author:
		Tom (Tongzeng) Yang
		(12/05/1991)
_____________________________________________________________________________________*/

Widget GetWidgetFromName (widget_set, name, mode)
	Widget	*widget_set;
	char	*name;
	char	mode;
{
	char	*lower_name;
	int	index;

	index	= GetIndexFromName (name, mode);

	return	*(widget_set + index);
}


/*_________________________________________________________________________________	
	Function:
		GetFontName	
	Arguments:
	Description:
		Get the font name from the settings in the Font menu.

	Author:
		Tom (Tongzeng) Yang
		(12/09/1991)
_________________________________________________________________________________*/

char *GetFontName (font_list, font_name, weight_set, 
			slant_set, size_list, size_name)
	Widget	*font_list;
	Widget	*font_name;
	Widget	*weight_set;
	Widget	*slant_set;
	Widget	*size_list;
	Widget	*size_name;
{
	char		*buffer;
	char		*font_string;
	char		*lower_name;
	char		size_string [MAXLINE];
	int		i;
	int		point_size;

	font_string	= (char *) pkg_malloc (MAXLINE, "GetFontName", "font_string");

	strcpy (font_string, "-*-");
	buffer	= XmTextGetString (*font_name);
	nFontNameIndex	= XmListItemPos (*font_list,
				XmStringCreate (buffer, XmSTRING_DEFAULT_CHARSET));
	strcat (font_string, buffer);
	XtFree (buffer);

	if (XmToggleButtonGetState (weight_set[0]))
		strcat (font_string, "-medium");
	else 
		strcat (font_string, "-bold");

	if (XmToggleButtonGetState (slant_set[0]))
		strcat (font_string, "-r");
	else if (XmToggleButtonGetState (slant_set[1]))
		strcat (font_string, "-i");
	else 
		strcat (font_string, "-o");
	strcat (font_string, "-*-*-");

	buffer	= XmTextGetString (*size_name);
	nFontSizeIndex	= XmListItemPos (*size_list,
				XmStringCreate (buffer, XmSTRING_DEFAULT_CHARSET));
	strcat (font_string, buffer);
	point_size	= PIXEL_POINT_FACTOR * atoi (buffer);
	sprintf (size_string, "-%d", point_size);
	strcat (font_string, size_string);
	XtFree (buffer);

	if (strstr (font_string, "symbol") == NULL)
		strcat (font_string, "-75-75-*-*-iso8859-1");
	else
		strcat (font_string, "-75-75-*-*-*-*");

	return font_string;
}

void GetDefaultParameters (display, root_window, gc, file_name, default_parameters)
	Display		*display;
	Window		root_window;
	GC		gc;
	char		*file_name;
	PARAMETERS_DATA	*default_parameters;
{
	Arg		arglist[2];
	BOOLEAN		filled;
	FILE		*file;
	SYMBOL_MENU	*symbol_menu	= default_parameters->symbol_menu;
	Widget		widget_buffer;
	char		*font_name;
	char		label [MAXLINE];
	char		line [MAXLINE];
	char		*symbol_shape	= &cSymbolType;
	char		value [MAXLINE];
	int		n;

	file	= fopen (file_name, "r");
	if (file == NULL)
	{
		fprintf (stderr, "Erroe: Cannot Open file %s\n", file_name);
	}

	while ( fgets (line, MAXLINE, file) != NULL)
	{
		if (sscanf (line, "%s %s", label, value) == 2) 
		{
			if (strcmp (label, "BackgroundColor:") == 0)
			{
				n	= 0;
				XtSetArg (arglist [n], XmNset, False); n++;
				XtSetValues (GetActiveWidget (default_parameters->back_color_set, 
						MAX_NONIMAGE_COLOR), arglist, n);

				widget_buffer	
				= GetWidgetFromName (default_parameters->back_color_set,
							value, TOGGLE_COLOR);

				n	= 0;
				XtSetArg (arglist [n], XmNset, True); n++;
				XtSetValues (widget_buffer, arglist, n);

				continue;
			}

			if (strcmp (label, "FontColor:") == 0)
			{
				n	= 0;
				XtSetArg (arglist [n], XmNset, False); n++;
				XtSetValues (GetActiveWidget (default_parameters->font_color_set, 
						MAX_NONIMAGE_COLOR), arglist, n);

				widget_buffer	
				= GetWidgetFromName (default_parameters->font_color_set,
							value, TOGGLE_COLOR);

				n	= 0;
				XtSetArg (arglist [n], XmNset, True); n++;
				XtSetValues (widget_buffer, arglist, n);
				cTextColorIndex	
				= (char) GetActiveIndex (default_parameters->font_color_set, 
								MAX_NONIMAGE_COLOR);

				continue;
			}

			if (strcmp (label, "FontName:") == 0)
			{
				n	= XmListItemPos (*default_parameters->font_list,
					XmStringCreate (value, XmSTRING_DEFAULT_CHARSET));
				nFontNameIndex	= n; 
				XmListSelectPos (*default_parameters->font_list, n, True);
				XmTextSetString (*default_parameters->font_name, value);
				continue;
			}

			if (strcmp (label, "FontSize:") == 0)
			{
				n	= XmListItemPos (*default_parameters->size_list,
					XmStringCreate (value, XmSTRING_DEFAULT_CHARSET));
				nFontSizeIndex	= n; 
				XmListSelectPos (*default_parameters->size_list, n, True);
				XmTextSetString (*default_parameters->font_size, value);
				continue;
			}

			if (strcmp (label, "FontSlant:") == 0)
			{
				n	= 0;
				XtSetArg (arglist [n], XmNset, False); n++;
				XtSetValues (GetActiveWidget (default_parameters->text_slant, 
						SLANT_NUM), arglist, n);

				widget_buffer	
				= GetWidgetFromName (default_parameters->text_slant,
							value, TOGGLE_SLANT);
				n	= 0;
				XtSetArg (arglist [n], XmNset, True); n++;
				XtSetValues (widget_buffer, arglist, n);
				cFontSlantIndex	
				= (char) GetActiveIndex (default_parameters->text_slant, 
								SLANT_NUM);

				continue;
			}

			if (strcmp (label, "FontWeight:") == 0)
			{
				n	= 0;
				XtSetArg (arglist [n], XmNset, False); n++;
				XtSetValues (GetActiveWidget (default_parameters->text_weight, 
						WEIGHT_NUM), arglist, n);

				widget_buffer	
				= GetWidgetFromName (default_parameters->text_weight,
							value, TOGGLE_WEIGHT);
				n	= 0;
				XtSetArg (arglist [n], XmNset, True); n++;
				XtSetValues (widget_buffer, arglist, n);
				cFontWeightIndex	
				= (char) GetActiveIndex (default_parameters->text_weight, 
								WEIGHT_NUM);

				continue;
			}

			if (strcmp (label, "FontOrientation:") == 0)
			{
				n	= 0;
				XtSetArg (arglist [n], XmNset, False); n++;
				XtSetValues (GetActiveWidget (default_parameters->text_orient, 
						ORIENT_NUM), arglist, n);

				widget_buffer	
				= GetWidgetFromName (default_parameters->text_orient,
							value, TOGGLE_ORIENT);
				n	= 0;
				XtSetArg (arglist [n], XmNset, True); n++;
				XtSetValues (widget_buffer, arglist, n);
				cFontOrientIndex	
				= (char) GetActiveIndex (default_parameters->text_orient, 
								ORIENT_NUM);

				continue;
			}

			if (strcmp (label, "TextInterLineSpace:") == 0)
			{
				XmScaleSetValue (*default_parameters->line_space, 
						atoi (value));
				nLineSpacing	= atoi (value);
				continue;
			}

			if (strcmp (label, "TextAlignment:") == 0)
			{
				n	= 0;
				XtSetArg (arglist [n], XmNset, False); n++;
				XtSetValues (GetActiveWidget (default_parameters->text_alignment, 
						ALIGNMENT_NUM), arglist, n);

				widget_buffer	
				= GetWidgetFromName (default_parameters->text_alignment,
							value, TOGGLE_ALIGN);
				n	= 0;
				XtSetArg (arglist [n], XmNset, True); n++;
				XtSetValues (widget_buffer, arglist, n);
				cAlignment	
				= GetActiveIndex (default_parameters->text_alignment, 
								ALIGNMENT_NUM);

				continue;
			}

			if (strcmp (label, "LineColor:") == 0)
			{
				n	= 0;
				XtSetArg (arglist [n], XmNset, False); n++;
				XtSetValues (GetActiveWidget (default_parameters->line_color_set, 
						MAX_NONIMAGE_COLOR), arglist, n);

				widget_buffer	
				= GetWidgetFromName (default_parameters->line_color_set,
							value, TOGGLE_COLOR);

				n	= 0;
				XtSetArg (arglist [n], XmNset, True); n++;
				XtSetValues (widget_buffer, arglist, n);
				cLineColorIndex	
				= (char) GetActiveIndex (default_parameters->line_color_set, 
								MAX_NONIMAGE_COLOR);

				continue;
			}

			if (strcmp (label, "LineWidth:") == 0)
			{
				XmScaleSetValue (*default_parameters->line_width, 
						atoi (value));
				nLineWidth	= atoi (value);
				continue;
			}

			if (strcmp (label, "ArrowHeadWidth:") == 0)
			{
				XmScaleSetValue (*default_parameters->arrow_width, 
						atoi (value));
				nArrowWidth	= atoi (value);
				continue;
			}

			if (strcmp (label, "ArrowHeadLength:") == 0)
			{
				XmScaleSetValue (*default_parameters->arrow_length, 
						atoi (value));
				nArrowLength	= atoi (value);
				continue;
			}

			if (strcmp (label, "SaveFileFormat:") == 0)
			{
				n	= 0;
				if (strcmp (value, "PostScript") == 0)
				{
					XtSetArg (arglist[n], XmNset, False); n++;
					XtSetArg (arglist[n], XmNlabelString,
						XmStringCreate ("File Format: PostScript ", 
						XmSTRING_DEFAULT_CHARSET)); n++;
					bWinDumpFile	= FALSE;
				}
				else
				{
					XtSetArg (arglist[n], XmNset, True); n++;
					XtSetArg (arglist[n], XmNlabelString,
						XmStringCreate ("File Format: Window Dump ", 
						XmSTRING_DEFAULT_CHARSET)); n++;
					bWinDumpFile	= TRUE;
				}
				XtSetValues (*default_parameters->save_format, arglist, n);

				continue;
			}

			if (strcmp (label, "SaveArea:") == 0)
			{
				n	= 0;
				if (strcmp (value, "UserDefined") == 0)
				{
					XtSetArg (arglist[n], XmNset, False); n++;
					XtSetArg (arglist[n], XmNlabelString,
						XmStringCreate ("Area Saved: User Defined ", 
						XmSTRING_DEFAULT_CHARSET)); n++;
					bSaveWholeScreen	= FALSE;
				}
				else
				{
					XtSetArg (arglist[n], XmNset, True); n++;
					XtSetArg (arglist[n], XmNlabelString,
						XmStringCreate ("Area Saved: Entire Window", 
						XmSTRING_DEFAULT_CHARSET)); n++;
					bSaveWholeScreen	= TRUE;
				}
				XtSetValues (*default_parameters->save_area, arglist, n);

				continue;
			}

			if (strcmp (label, "SymbolColor:") == 0)
			{
				n	= 0;
				XtSetArg (arglist [n], XmNset, False); n++;
				XtSetValues (GetActiveWidget (symbol_menu->toggle_color_set, 
						MAX_NONIMAGE_COLOR), arglist, n);

				widget_buffer	
				= GetWidgetFromName (symbol_menu->toggle_color_set,
							value, TOGGLE_COLOR);

				n	= 0;
				XtSetArg (arglist [n], XmNset, True); n++;
				XtSetValues (widget_buffer, arglist, n);
				cSymbolColorIndex	
				= (char) GetActiveIndex (symbol_menu->toggle_color_set, 
								MAX_NONIMAGE_COLOR);

				continue;
			}

			if (strcmp (label, "SymbolShape:") == 0)
			{

				*symbol_shape	= GetIndexFromName (value, TOGGLE_SYMBOL_SHAPE);

				if (*symbol_shape >= MAX_SYMBOL_NUM)
				{
					n	= *symbol_shape - MAX_SYMBOL_NUM;
					filled	= TRUE;
				}
				else
				{
					n	= *symbol_shape;
					filled	= FALSE;
				}

				SetSelectData (GetActiveWidget (symbol_menu->toggle_symbol_set, 
									MAX_SYMBOL_NUM), FALSE);
				SetSelectData (symbol_menu->toggle_symbol_set [n], TRUE);

				SetSelectData (*symbol_menu->filled, filled);

				continue;
			}

			if (strcmp (label, "SymbolSize:") == 0)
			{
				XmScaleSetValue (*symbol_menu->size_scale, atoi (value));
				nSymbolSize	= atoi (value);
				continue;
			}


		}
		else
		{
			fprintf (stderr, "Erroe: GetDefaultParameters\n");
		}
	}

	SetColorParameters (display, root_window, DefaultScreen (display), default_parameters);

	font_name	= GetFontName (*default_parameters->font_list,
					*default_parameters->font_name,
					default_parameters->text_weight,
					default_parameters->text_slant,
					*default_parameters->size_list,
					*default_parameters->font_size);
	FontStruct	= XLoadQueryFont (display, font_name);
	if (FontStruct == 0)
		fprintf (stderr, "Can Not Find Font %s\n", font_name);
	else
	{
		XSetFont (display, gc, FontStruct->fid);
	}
	free (font_name);

	fclose (file);
}

void SaveDefaultParameters (file_name, default_parameters)
	char		*file_name;
	PARAMETERS_DATA	*default_parameters;
{
	FILE		*file;
	int		int_buffer;
	char		value [MAXLINE];
	char		*string;
	SYMBOL_MENU	*symbol_menu	= default_parameters->symbol_menu;
	char		**symbol_names	= symbolNames;

	file	= fopen (file_name, "w");
	if (file == NULL)
	{
		fprintf (stderr, "Erroe: Cannot Open file %s\n", file_name);
		return;
	}

	GetNameFromWidget (default_parameters->back_color_set, 
				MAX_NONIMAGE_COLOR, TOGGLE_COLOR, value); 
	fprintf (file, "BackgroundColor:	%s\n", value);

	GetNameFromWidget (default_parameters->font_color_set, 
				MAX_NONIMAGE_COLOR, TOGGLE_COLOR, value); 
	fprintf (file, "FontColor:		%s\n", value);

	string	= XmTextGetString (*default_parameters->font_name);
	fprintf (file, "FontName:		%s\n", string);
	XtFree (string);

	string	= XmTextGetString (*default_parameters->font_size);
	fprintf (file, "FontSize:		%s\n", string);
	XtFree (string);

	GetNameFromWidget (default_parameters->text_slant, 
				SLANT_NUM, TOGGLE_SLANT, value); 
	fprintf (file, "FontSlant:		%s\n", value);

	GetNameFromWidget (default_parameters->text_weight, 
				WEIGHT_NUM, TOGGLE_WEIGHT, value); 
	fprintf (file, "FontWeight:		%s\n", value);

	GetNameFromWidget (default_parameters->text_orient, 
				ORIENT_NUM, TOGGLE_ORIENT, value); 
	fprintf (file, "FontOrientation:	%s\n", value);

	XmScaleGetValue (*default_parameters->line_space, &int_buffer);
	fprintf (file, "TextInterLineSpace:	%d\n", int_buffer);

	GetNameFromWidget (default_parameters->text_alignment, 
				ALIGNMENT_NUM, TOGGLE_ALIGN, value); 
	fprintf (file, "TextAlignment:		%s\n", value);

	GetNameFromWidget (default_parameters->line_color_set, 
				MAX_NONIMAGE_COLOR, TOGGLE_COLOR, value); 
	fprintf (file, "LineColor:		%s\n", value);

	XmScaleGetValue (*default_parameters->line_width, &int_buffer);
	fprintf (file, "LineWidth:		%d\n", int_buffer);

	XmScaleGetValue (*default_parameters->arrow_width, &int_buffer);
	fprintf (file, "ArrowHeadWidth:		%d\n", int_buffer);

	XmScaleGetValue (*default_parameters->arrow_length, &int_buffer);
	fprintf (file, "ArrowHeadLength:	%d\n", int_buffer);

	if (XmToggleButtonGetState (*default_parameters->save_format))
		fprintf (file, "SaveFileFormat:		WindowDump\n");
	else
		fprintf (file, "SaveFileFormat:		PostScript\n");

	if (XmToggleButtonGetState (*default_parameters->save_area))
		fprintf (file, "SaveArea:		EntireWindow\n");
	else
		fprintf (file, "SaveArea:		UserDefined\n");

	GetNameFromWidget (symbol_menu->toggle_color_set, 
				MAX_NONIMAGE_COLOR, TOGGLE_COLOR, value); 
	fprintf (file, "SymbolColor:		%s\n", value);

	fprintf (file, "SymbolShape:		%s\n", symbol_names [cSymbolType]);

	XmScaleGetValue (*symbol_menu->size_scale, &int_buffer);
	fprintf (file, "SymbolSize:		%d\n", int_buffer);

	fclose (file);
}
@


1.12
log
@Same as the last version.
@
text
@d1 1
a1 1
/*$Header: /home/petsun4/ty7777/src/xlabel/RCS/utility.c,v 1.11 1994/12/30 17:49:30 ty7777 Exp ty7777 $*/
d3 3
d45 1
d51 1
d53 1
a53 1
PRIVATE void GetCircleInfo ();
d69 1
a69 1
PUBLIC void SetSelectData (w, status_flag)
d100 1
a100 1
PUBLIC void Swap (pnFirst, pnSecond)
d124 1
a124 1
PUBLIC void DrawInwardFlatArrow (display, window, gc, line_width, x, y, x2, y2)
d161 1
a161 1
PUBLIC void GetLineEnd (pointer_state, x, y, x2, y2, xe, ye)
d174 1
a174 1
PUBLIC void DrawLine (display, window, gc, x, y, x2, y2)
d183 1
a183 1
PUBLIC void DrawRectangle (display, window, gc, x, y, x2, y2)
d193 1
a193 1
PUBLIC void DrawFilledRectangle (display, window, gc, x, y, x2, y2)
d203 1
a203 1
PUBLIC void CheckPoints (x, y, x2, y2)
d212 1
a212 1
PUBLIC void DrawEllipse (display, window, gc, x, y, x2, y2)
d222 1
a222 1
PUBLIC void DrawFilledEllipse (display, window, gc, x, y, x2, y2)
d232 1
a232 1
PRIVATE void GetCircleInfo (x, y, x2, y2, xc, yc, r)
d242 1
a242 1
PUBLIC void DrawCircle (display, window, gc, x, y, x2, y2)
d256 1
a256 1
PUBLIC void DrawFilledCircle (display, window, gc, x, y, x2, y2)
d270 1
a270 1
PUBLIC void GetLabelDim (font_struct, text_string, line_spacing, text_orient, label_width, label_height)
d384 1
a384 1
PUBLIC void DrawLabel (display, window, gc, x, y, x2, y2, color_pixel, font_struct, 
d555 1
a555 1
PUBLIC int GetActiveIndex (widget_set, num_widget)
d587 1
a587 1
PUBLIC Widget GetActiveWidget (widget_set, num_widget)
d610 1
a610 1
PUBLIC void GetNameFromWidget (widget_set, num_widget, mode, name)
d652 1
a652 1
PUBLIC int GetIndexFromName (name, mode)
d736 1
a736 1
PUBLIC Widget GetWidgetFromName (widget_set, name, mode)
d762 1
a762 1
PUBLIC char *GetFontName (font_list, font_name, weight_set, 
d817 1
a817 1
PUBLIC void GetDefaultParameters (display, root_window, gc, file_name, default_parameters)
d1167 1
a1167 1
PUBLIC void SaveDefaultParameters (file_name, default_parameters)
@


1.11
log
@Added processing for big fonts.
@
text
@d1 1
a1 1
/*$Header: /home/petsun4/ty7777/src/xlabel/RCS/utility.c,v 1.10 1994/08/25 18:10:42 ty7777 Exp ty7777 $*/
d3 3
@


1.10
log
@Before porting to X11R5.
@
text
@d1 1
a1 1
/*$Header: /home/petsun4/ty7777/src/xlabel/RCS/utility.c,v 1.9 1993/03/30 22:23:43 ty7777 Exp ty7777 $*/
d3 3
d763 1
d765 1
a765 2
	char		*buffer;
	int		point_size;
a766 1
	char		*lower_name;
d768 1
d772 1
a772 1
	strcpy (font_string, "*");
d785 1
a785 1
		strcat (font_string, "-r*");
d787 1
a787 1
		strcat (font_string, "-i*");
d789 2
a790 1
		strcat (font_string, "-o*");
d797 1
a797 1
	sprintf (size_string, "*%d", point_size);
d801 4
a804 1
	strcat (font_string, "*75-75*");
d1154 1
a1154 1
	XtFree (font_name);
@


1.9
log
@Before modifying.
@
text
@d1 1
a1 1
/*$Header: /home/petsun4/ty7777/src/xlabel/RCS/utility.c,v 1.8 1993/03/12 21:25:41 ty7777 Exp ty7777 $*/
d3 3
d259 114
a630 28
		Lowered
	Arguments:
	Description:
		Convert a character string to lower case.
	Author:
		Tom (Tongzeng) Yang
		(12/08/1991)
_______________________________________________________________________________________________*/

PUBLIC char *Lowered (string, length)
	char	*string;
	int	length;
{
	char	*lower_name;
	int	i;

	lower_name	= (char *) pkg_malloc (length + 1, "Lowered", "lower_name");
	strncpy (lower_name, "\0", length + 1);

	for (i = 0; i < length; i++)
		lower_name [i] = tolower (*(string + i));

	return	lower_name;
}


/*________________________________________________________________________________________________	
	Function:
d645 2
a646 1
	char	*lower_name;
a647 1
	char	**symbol_names	= symbolNames;
d649 2
a650 1
	lower_name	= Lowered (name, strlen (name));
a707 2

	XtFree (lower_name);
@


1.8
log
@Alignment of texts by tabs.
@
text
@d1 1
a1 1
/*$Header: /home/petsun4/ty7777/src/xlabel/RCS/utility.c,v 1.7 1993/03/10 18:09:59 ty7777 Exp ty7777 $*/
d3 3
d367 1
a367 1
								pure_string, strlen (pure_string));
@


1.7
log
@Making tabs align correctly.
@
text
@d1 1
a1 1
/*$Header: /usr/local/src/xlabel/RCS/utility.c,v 1.5 1993/02/17 20:38:09 ty7777 Exp $*/
d3 3
d275 2
d318 2
a319 3
				m	= (m / 8 + 1) * 8;
				k	= 0;
				strncpy (pure_string, "\0", text_length);
a327 1
		tabspaces_per_line	= m;
d348 1
d367 1
a367 1
							xstart	= x + m * font_width;
a375 1
				xstart	= x;
@


1.6
log
@Version not working.
@
text
@d1 1
a1 1
/*$Header: /home/petsun4/ty7777/src/xlabel/RCS/utility.c,v 1.5 1993/02/17 20:38:09 ty7777 Exp $*/
d263 1
a263 1
	char		*actual_text_string;
a264 1
	int		actual_text_length;
d267 3
a269 1
	int		i, j, k;
d284 2
a285 11
	j	= 0;
	for (i = 0; i < text_length; i++)
	{
		if (text_string [i] != '\t')
			j	+= 1;
		else
		{
			j	+= (j / 8 + 1) * 8 - j;
		}
	}
	actual_text_length	= j;
d287 2
a288 17
	actual_text_string	= (char *) pkg_malloc (actual_text_length, function, "actual_text_string");
	string_buffer		= (char *) pkg_malloc (actual_text_length, function, "string_buffer");

	j	= 0;
	for (i = 0; i < text_length; i++)
	{
		if (text_string [i] != '\t')
			actual_text_string [j++]	= text_string [i];
		else
		{
			for (k = j; k < (j / 8 + 1) * 8; k++)
				actual_text_string [k]	= ' ';
			j	= k;
		}
	}

	strncpy (string_buffer, "\0", actual_text_length);
d295 1
d298 1
a298 2
	i	= 0;
	while (i < actual_text_length)
d300 18
a317 1
		j	= 0;
d319 1
a319 3
		while (i < actual_text_length && actual_text_string [i] != '\n')
		{
			string_buffer [j++]	= actual_text_string [i++];
d322 4
a325 2
		if (i < actual_text_length)
			string_buffer [j++]	= actual_text_string [i++];
d332 3
a334 3
					XTextExtents (font_struct, string_buffer, strlen (string_buffer), 
						&direction_hint, &font_ascent, &font_descent, &overall);
					string_width	= overall.rbearing - overall.lbearing;
d346 24
a369 2
					XDrawString (display, window, gc, xstart, ystart, 
						string_buffer, strlen (string_buffer));
d371 2
d400 2
a401 1
		strncpy (string_buffer, "\0", actual_text_length);
d405 1
a405 1
	XtFree (actual_text_string);
@


1.5
log
@After fixing multiline with null line bug.
@
text
@d1 1
a1 1
/*$Header: /home/petsun4/ty7777/src/xlabel/RCS/utility.c,v 1.4 1992/09/28 16:33:15 ty7777 Exp ty7777 $*/
d3 3
d263 1
a263 4
	static char	*function	= "DrawLabel";
	int		xstart;
	int		ystart;
	int		text_length;
d265 3
a268 1
	int		font_height;
d270 8
a278 1
	i		= 0;
d283 11
a293 1
	string_buffer	= (char *) pkg_malloc (text_length, function, "string_buffer");
d295 17
a311 1
	strncpy (string_buffer, "\0", text_length);
d315 3
d320 2
a321 1
	while (i < text_length)
d325 1
a325 1
		while (i < text_length && text_string [i] != '\n')
d327 1
a327 1
			string_buffer [j++]	= text_string [i++];
d330 2
a331 1
		string_buffer [j++]	= text_string [i++];
d338 3
a340 2
					string_width	= XTextWidth (font_struct, 
								string_buffer, strlen (string_buffer));
d382 1
a382 1
		strncpy (string_buffer, "\0", text_length);
d386 1
@


1.4
log
@After Symbol Menu Worked.
@
text
@d1 5
a5 2
/*$Header$*/
/*$Log$*/
d260 1
a260 1
	static char	*function	= "ButtonDownEventHandler";
d274 1
a274 2
	string_buffer	= (char *) pkg_malloc (text_length, 
					function, "string_buffer");
d286 1
a286 1
		do
d288 2
a289 2
			string_buffer [j++] = text_string [i++];
		} while (i < text_length && text_string [i] != '\n');
d291 1
a291 1
		string_buffer [j++] = text_string [i++];
d295 17
a311 2
			case ORIENT_HORI : 	
				string_width	= XTextWidth (font_struct, 
a312 5

				xstart	= x;
				if (alignment_flag == ALIGNMENT_CENTER)
				{
					xstart	-= string_width / 2;
a313 7
				else if (alignment_flag == ALIGNMENT_RIGHT)
				{
					xstart	-= string_width;
				}

				XDrawString (display, window, gc, xstart, ystart, 
					string_buffer, strlen (string_buffer));
d316 1
a316 1
			case ORIENT_VERT :
@


1.3
log
@After font bug (reported by Julie Fiez) is fixed.
@
text
@d1 3
d486 1
d538 7
d649 11
a659 8
	FILE			*file;
	char			line [MAXLINE];
	char			label [MAXLINE];
	char			value [MAXLINE];
	Widget			widget_buffer;
	int			n;
	Arg			arglist[2];
	char			*font_name;
d907 2
d910 55
d996 6
a1001 4
	FILE	*file;
	int	int_buffer;
	char	value [MAXLINE];
	char	*string;
d1067 9
@


1.2
log
@After Arrow works.
@
text
@d606 1
a606 1
		strcat (font_string, "*medium");
d608 1
a608 1
		strcat (font_string, "*bold");
d611 1
a611 1
		strcat (font_string, "*r*");
d613 1
a613 1
		strcat (font_string, "*i*");
d615 1
a615 1
		strcat (font_string, "*o*");
@


1.1
log
@Initial revision
@
text
@d106 1
a106 1
	double	arrow_length;
d114 1
a114 2
	arrow_width	= pkg_max (line_width, ARROW_THICKNESS);  
	arrow_length	= arrow_width / (tan (THETA * PI / 180) * 2);
d116 2
a117 2
	x1		= x2 - ROUND (arrow_length * cos_phi);
	y1		= y2 - ROUND (arrow_length * sin_phi);
d833 16
d978 6
@
