head	2.38;
access;
symbols;
locks
	tom:2.38; strict;
comment	@ * @;


2.38
date	95.10.26.19.06.34;	author ty7777;	state Exp;
branches;
next	2.37;

2.37
date	95.10.26.19.02.28;	author ty7777;	state Exp;
branches;
next	2.36;

2.36
date	95.09.08.21.40.44;	author ty7777;	state Exp;
branches;
next	2.35;

2.35
date	95.09.07.17.04.13;	author ty7777;	state Exp;
branches;
next	2.34;

2.34
date	95.09.07.16.55.05;	author ty7777;	state Exp;
branches;
next	2.33;

2.33
date	95.08.31.20.18.38;	author ty7777;	state Exp;
branches;
next	2.32;

2.32
date	95.08.29.16.46.37;	author ty7777;	state Exp;
branches;
next	2.31;

2.31
date	95.08.29.15.52.58;	author ty7777;	state Exp;
branches;
next	2.30;

2.30
date	95.08.28.21.09.23;	author ty7777;	state Exp;
branches;
next	2.29;

2.29
date	95.08.28.15.38.46;	author ty7777;	state Exp;
branches;
next	2.28;

2.28
date	95.08.22.16.51.58;	author ty7777;	state Exp;
branches;
next	2.27;

2.27
date	95.08.02.16.49.48;	author ty7777;	state Exp;
branches;
next	2.26;

2.26
date	95.07.31.15.10.38;	author ty7777;	state Exp;
branches;
next	2.25;

2.25
date	95.07.27.19.55.14;	author ty7777;	state Exp;
branches;
next	2.24;

2.24
date	95.07.26.20.41.17;	author ty7777;	state Exp;
branches;
next	2.23;

2.23
date	95.07.25.16.12.08;	author ty7777;	state Exp;
branches;
next	2.22;

2.22
date	95.07.24.20.28.17;	author ty7777;	state Exp;
branches;
next	2.21;

2.21
date	95.07.14.20.53.34;	author ty7777;	state Exp;
branches;
next	2.20;

2.20
date	95.07.07.17.12.30;	author ty7777;	state Exp;
branches;
next	2.19;

2.19
date	95.06.30.15.22.12;	author ty7777;	state Exp;
branches;
next	2.18;

2.18
date	95.06.14.20.12.10;	author ty7777;	state Exp;
branches;
next	2.17;

2.17
date	95.06.13.20.12.47;	author ty7777;	state Exp;
branches;
next	2.16;

2.16
date	95.06.12.19.30.55;	author ty7777;	state Exp;
branches;
next	2.15;

2.15
date	95.06.07.14.36.03;	author ty7777;	state Exp;
branches;
next	2.14;

2.14
date	95.06.05.19.50.57;	author ty7777;	state Exp;
branches;
next	2.13;

2.13
date	95.06.02.14.23.13;	author ty7777;	state Exp;
branches;
next	2.12;

2.12
date	95.01.18.20.11.16;	author ty7777;	state Exp;
branches;
next	2.11;

2.11
date	95.01.17.20.07.49;	author ty7777;	state Exp;
branches;
next	2.10;

2.10
date	94.12.30.21.20.58;	author ty7777;	state Exp;
branches;
next	2.9;

2.9
date	94.12.01.20.09.48;	author ty7777;	state Exp;
branches;
next	2.8;

2.8
date	94.12.01.16.58.44;	author ty7777;	state Exp;
branches;
next	2.7;

2.7
date	94.11.30.20.00.08;	author ty7777;	state Exp;
branches;
next	2.6;

2.6
date	94.11.01.17.36.48;	author ty7777;	state Exp;
branches;
next	2.5;

2.5
date	94.10.28.16.17.43;	author ty7777;	state Exp;
branches;
next	2.4;

2.4
date	94.10.27.20.02.04;	author ty7777;	state Exp;
branches;
next	2.3;

2.3
date	94.10.26.16.15.35;	author ty7777;	state Exp;
branches;
next	2.2;

2.2
date	94.10.19.17.17.38;	author ty7777;	state Exp;
branches;
next	2.1;

2.1
date	94.10.19.17.01.16;	author ty7777;	state Exp;
branches;
next	1.99;

1.99
date	94.10.17.19.53.07;	author ty7777;	state Exp;
branches;
next	1.98;

1.98
date	94.10.14.18.07.42;	author ty7777;	state Exp;
branches;
next	1.97;

1.97
date	94.10.13.18.54.48;	author ty7777;	state Exp;
branches;
next	1.96;

1.96
date	94.08.25.16.40.41;	author ty7777;	state Exp;
branches;
next	1.95;

1.95
date	94.08.25.16.39.00;	author ty7777;	state Exp;
branches;
next	1.94;

1.94
date	94.08.17.21.19.36;	author ty7777;	state Exp;
branches;
next	1.93;

1.93
date	94.08.17.20.26.19;	author ty7777;	state Exp;
branches;
next	1.92;

1.92
date	94.08.17.19.46.01;	author ty7777;	state Exp;
branches;
next	1.91;

1.91
date	94.08.17.16.16.29;	author ty7777;	state Exp;
branches;
next	1.90;

1.90
date	94.08.16.15.45.44;	author ty7777;	state Exp;
branches;
next	1.89;

1.89
date	94.08.12.16.59.19;	author ty7777;	state Exp;
branches;
next	1.88;

1.88
date	94.08.11.21.21.13;	author ty7777;	state Exp;
branches;
next	1.87;

1.87
date	94.06.23.17.12.24;	author ty7777;	state Exp;
branches;
next	1.86;

1.86
date	94.06.23.16.57.11;	author ty7777;	state Exp;
branches;
next	1.85;

1.85
date	94.06.02.20.55.16;	author ty7777;	state Exp;
branches;
next	1.84;

1.84
date	94.05.19.14.11.53;	author ty7777;	state Exp;
branches;
next	1.83;

1.83
date	94.05.09.21.59.17;	author ty7777;	state Exp;
branches;
next	1.82;

1.82
date	94.05.09.16.43.31;	author ty7777;	state Exp;
branches;
next	1.81;

1.81
date	94.05.09.16.07.53;	author ty7777;	state Exp;
branches;
next	1.80;

1.80
date	94.05.06.19.40.45;	author ty7777;	state Exp;
branches;
next	1.79;

1.79
date	94.04.18.17.55.03;	author ty7777;	state Exp;
branches;
next	1.78;

1.78
date	94.04.14.20.38.12;	author ty7777;	state Exp;
branches;
next	1.77;

1.77
date	94.04.13.15.09.59;	author ty7777;	state Exp;
branches;
next	1.76;

1.76
date	94.04.12.20.46.15;	author ty7777;	state Exp;
branches;
next	1.75;

1.75
date	94.04.12.20.08.59;	author ty7777;	state Exp;
branches;
next	1.74;

1.74
date	94.04.12.15.27.41;	author ty7777;	state Exp;
branches;
next	1.73;

1.73
date	94.04.07.16.52.09;	author ty7777;	state Exp;
branches;
next	1.72;

1.72
date	94.02.17.17.27.44;	author ty7777;	state Exp;
branches;
next	1.71;

1.71
date	94.02.11.22.23.15;	author ty7777;	state Exp;
branches;
next	1.70;

1.70
date	94.01.24.20.08.25;	author ty7777;	state Exp;
branches;
next	1.69;

1.69
date	94.01.12.21.37.49;	author ty7777;	state Exp;
branches;
next	1.68;

1.68
date	94.01.11.22.24.18;	author ty7777;	state Exp;
branches;
next	1.67;

1.67
date	94.01.11.17.55.38;	author ty7777;	state Exp;
branches;
next	1.66;

1.66
date	94.01.11.16.15.52;	author ty7777;	state Exp;
branches;
next	1.65;

1.65
date	93.12.16.15.51.27;	author ty7777;	state Exp;
branches;
next	1.64;

1.64
date	93.12.14.20.00.07;	author ty7777;	state Exp;
branches;
next	1.63;

1.63
date	93.12.13.20.21.48;	author ty7777;	state Exp;
branches;
next	1.62;

1.62
date	93.12.13.20.20.22;	author ty7777;	state Exp;
branches;
next	1.61;

1.61
date	93.12.13.19.43.50;	author ty7777;	state Exp;
branches;
next	1.60;

1.60
date	93.12.13.15.19.59;	author ty7777;	state Exp;
branches;
next	1.59;

1.59
date	93.12.08.21.02.40;	author ty7777;	state Exp;
branches;
next	1.58;

1.58
date	93.11.02.16.52.32;	author ty7777;	state Exp;
branches;
next	1.57;

1.57
date	93.11.01.21.57.27;	author ty7777;	state Exp;
branches;
next	1.56;

1.56
date	93.10.28.15.44.36;	author ty7777;	state Exp;
branches;
next	1.55;

1.55
date	93.10.22.20.05.04;	author ty7777;	state Exp;
branches;
next	1.54;

1.54
date	93.09.27.19.00.52;	author ty7777;	state Exp;
branches;
next	1.53;

1.53
date	93.09.23.20.40.58;	author ty7777;	state Exp;
branches;
next	1.52;

1.52
date	93.07.26.22.01.59;	author ty7777;	state Exp;
branches;
next	1.51;

1.51
date	93.07.13.15.06.51;	author ty7777;	state Exp;
branches;
next	1.50;

1.50
date	93.07.06.16.49.49;	author ty7777;	state Exp;
branches;
next	1.49;

1.49
date	93.06.03.19.38.56;	author ty7777;	state Exp;
branches;
next	1.48;

1.48
date	93.06.03.14.33.17;	author ty7777;	state Exp;
branches;
next	1.47;

1.47
date	93.06.02.17.17.14;	author ty7777;	state Exp;
branches;
next	1.46;

1.46
date	93.05.17.17.17.50;	author ty7777;	state Exp;
branches;
next	1.45;

1.45
date	93.05.17.16.23.48;	author ty7777;	state Exp;
branches;
next	1.44;

1.44
date	93.05.07.21.55.53;	author ty7777;	state Exp;
branches;
next	1.43;

1.43
date	93.05.07.16.56.25;	author ty7777;	state Exp;
branches;
next	1.42;

1.42
date	93.04.05.17.32.58;	author ty7777;	state Exp;
branches;
next	1.41;

1.41
date	93.02.23.18.15.15;	author ty7777;	state Exp;
branches;
next	1.40;

1.40
date	93.01.28.15.42.56;	author ty7777;	state Exp;
branches;
next	1.39;

1.39
date	93.01.13.19.32.49;	author ty7777;	state Exp;
branches;
next	1.38;

1.38
date	93.01.11.15.51.00;	author ty7777;	state Exp;
branches;
next	1.37;

1.37
date	92.12.31.21.56.51;	author ty7777;	state Exp;
branches;
next	1.36;

1.36
date	92.12.07.20.34.28;	author ty7777;	state Exp;
branches;
next	1.35;

1.35
date	92.12.07.15.51.57;	author ty7777;	state Exp;
branches;
next	1.34;

1.34
date	92.12.03.20.25.12;	author ty7777;	state Exp;
branches;
next	1.33;

1.33
date	92.11.20.16.35.26;	author ty7777;	state Exp;
branches;
next	1.32;

1.32
date	92.11.19.16.26.24;	author ty7777;	state Exp;
branches;
next	1.31;

1.31
date	92.10.30.21.51.25;	author ty7777;	state Exp;
branches;
next	1.30;

1.30
date	92.09.28.16.47.24;	author ty7777;	state Exp;
branches;
next	1.29;

1.29
date	92.09.23.19.30.26;	author ty7777;	state Exp;
branches;
next	1.28;

1.28
date	92.08.26.21.28.42;	author ty7777;	state Exp;
branches;
next	1.27;

1.27
date	92.08.26.21.26.00;	author ty7777;	state Exp;
branches;
next	1.26;

1.26
date	92.08.04.15.55.06;	author ty7777;	state Exp;
branches;
next	1.25;

1.25
date	92.08.03.18.52.58;	author ty7777;	state Exp;
branches;
next	1.24;

1.24
date	92.08.03.15.01.15;	author ty7777;	state Exp;
branches;
next	1.23;

1.23
date	92.07.31.20.51.38;	author ty7777;	state Exp;
branches;
next	1.22;

1.22
date	92.07.31.14.41.11;	author ty7777;	state Exp;
branches;
next	1.21;

1.21
date	92.07.20.19.30.52;	author ty7777;	state Exp;
branches;
next	1.20;

1.20
date	92.07.20.15.34.06;	author ty7777;	state Exp;
branches;
next	1.19;

1.19
date	92.07.17.18.04.33;	author ty7777;	state Exp;
branches;
next	1.18;

1.18
date	92.07.16.14.32.07;	author ty7777;	state Exp;
branches;
next	1.17;

1.17
date	92.07.14.14.58.11;	author ty7777;	state Exp;
branches;
next	1.16;

1.16
date	92.07.08.18.47.57;	author ty7777;	state Exp;
branches;
next	1.15;

1.15
date	92.07.06.18.18.54;	author ty7777;	state Exp;
branches;
next	1.14;

1.14
date	92.07.02.19.19.00;	author ty7777;	state Exp;
branches;
next	1.13;

1.13
date	92.07.02.18.08.31;	author ty7777;	state Exp;
branches;
next	1.12;

1.12
date	92.07.02.17.08.26;	author ty7777;	state Exp;
branches;
next	1.11;

1.11
date	92.07.02.15.13.05;	author ty7777;	state Exp;
branches;
next	1.10;

1.10
date	92.06.30.21.49.11;	author ty7777;	state Exp;
branches;
next	1.9;

1.9
date	92.06.01.20.33.52;	author ty7777;	state Exp;
branches;
next	1.8;

1.8
date	92.06.01.13.58.09;	author ty7777;	state Exp;
branches;
next	1.7;

1.7
date	92.05.26.21.19.14;	author ty7777;	state Exp;
branches;
next	1.6;

1.6
date	92.05.26.14.47.39;	author ty7777;	state Exp;
branches
	1.6.1.1;
next	1.5;

1.5
date	92.05.21.19.49.03;	author ty7777;	state Exp;
branches;
next	1.4;

1.4
date	92.05.21.17.24.54;	author ty7777;	state Exp;
branches;
next	1.3;

1.3
date	92.05.20.20.02.16;	author ty7777;	state Exp;
branches;
next	1.2;

1.2
date	92.04.28.19.08.59;	author ty7777;	state Exp;
branches;
next	1.1;

1.1
date	92.04.28.17.58.26;	author ty7777;	state Exp;
branches;
next	;

1.6.1.1
date	92.05.27.14.53.49;	author ty7777;	state Exp;
branches;
next	1.6.1.2;

1.6.1.2
date	92.05.27.16.40.59;	author ty7777;	state Exp;
branches;
next	1.6.1.3;

1.6.1.3
date	92.05.27.17.26.10;	author ty7777;	state Exp;
branches;
next	1.6.1.4;

1.6.1.4
date	92.05.27.18.21.56;	author ty7777;	state Exp;
branches;
next	1.6.1.5;

1.6.1.5
date	92.05.27.19.40.50;	author ty7777;	state Exp;
branches;
next	1.6.1.6;

1.6.1.6
date	92.05.27.20.27.35;	author ty7777;	state Exp;
branches;
next	1.6.1.7;

1.6.1.7
date	92.05.28.15.26.48;	author ty7777;	state Exp;
branches;
next	1.6.1.8;

1.6.1.8
date	92.05.28.15.56.06;	author ty7777;	state Exp;
branches;
next	1.6.1.9;

1.6.1.9
date	92.06.01.13.48.14;	author ty7777;	state Exp;
branches;
next	1.6.1.10;

1.6.1.10
date	92.06.01.13.56.24;	author ty7777;	state Exp;
branches;
next	;


desc
@View25d C Source Code First Version.
@


2.38
log
@Display labels.
@
text
@/*$Id: portal.c,v 2.37 1995/10/26 19:02:28 ty7777 Exp ty7777 $*/
/*$Log: portal.c,v $
 * Revision 2.37  1995/10/26  19:02:28  ty7777
 * Fixed the coronal and sagittal offset bug.
 *
 * Revision 2.36  1995/09/08  21:40:44  ty7777
 * Updated to introduce atlas 2.
 *
 * Revision 2.35  1995/09/07  17:04:13  ty7777
 * Deleted error message.
 *
 * Revision 2.34  1995/09/07  16:55:05  ty7777
 * Fixed the crash in RedrawPortals.
 *
 * Revision 2.33  1995/08/31  20:18:38  ty7777
 * Before watch cursor works.
 *
 * Revision 2.32  1995/08/29  16:46:37  ty7777
 * Added mutual tracking.
 *
 * Revision 2.31  1995/08/29  15:52:58  ty7777
 * After z0 works correctly.
 *
 * Revision 2.30  1995/08/28  21:09:23  ty7777
 * After color bar works.
 *
 * Revision 2.29  1995/08/28  15:38:46  ty7777
 * Before adding mutual image1 and image2 point display.
 *
 * Revision 2.28  1995/08/22  16:51:58  ty7777
 * Before doing anything else.
 *
 * Revision 2.27  1995/08/02  16:49:48  ty7777
 * Tracking works.
 *
 * Revision 2.26  1995/07/31  15:10:38  ty7777
 * Before work on tracking.
 *
 * Revision 2.25  1995/07/27  19:55:14  ty7777
 * Draw atlas only for image1 when there is overlay.
 *
 * Revision 2.24  1995/07/26  20:41:17  ty7777
 * Made image overlay work.
 *
 * Revision 2.23  1995/07/25  16:12:08  ty7777
 * Fixed the offset problem for Image 2.
 *
 * Revision 2.22  1995/07/24  20:28:17  ty7777
 * The mask for interfile worked.
 *
 * Revision 2.21  1995/07/14  20:53:34  ty7777
 * Before further changes.
 *
 * Revision 2.20  1995/07/07  17:12:30  ty7777
 * Two data sets works correctly.
 *
 * Revision 2.19  1995/06/30  15:22:12  ty7777
 *  Before making further changes, tow independent color bars worked.
 *
 * Revision 2.18  1995/06/14  20:12:10  ty7777
 * Added processing for analyze .hdr file.
 *
 * Revision 2.17  1995/06/13  20:12:47  ty7777
 * Added processing for reading .hdr files.
 *
 * Revision 2.16  1995/06/12  19:30:55  ty7777
 * Before adding processing for .hdr file.
 *
 * Revision 2.15  1995/06/07  14:36:03  ty7777
 * Relieve the checking for 75 slices.
 *
 * Revision 2.14  1995/06/05  19:50:57  ty7777
 * Before changing the constraint on the number of slices to display.
 *
 * Revision 2.13  1995/06/02  14:23:13  ty7777
 * Added InputInterfileData ().
 *
 * Revision 2.12  1995/01/18  20:11:16  ty7777
 * Added black border for PosNeg_on_White.tbl.
 *
 * Revision 2.11  1995/01/17  20:07:49  ty7777
 * Deleted things that are related to data_stes.
 *
 * Revision 2.10  1994/12/30  21:20:58  ty7777
 * Added processing for big fonts.
 *
 * Revision 2.9  1994/12/01  20:09:48  ty7777
 * Get rid of the path in atl files.
 *
 * Revision 2.8  1994/12/01  16:58:44  ty7777
 * Pass library_path from the main program.
 *
 * Revision 2.7  1994/11/30  20:00:08  ty7777
 * Same as the last version.
 *
 * Revision 2.6  1994/11/01  17:36:48  ty7777
 * Change the mask file if necessary when reading defaults file.
 *
 * Revision 2.5  1994/10/28  16:17:43  ty7777
 * Use winutil.h
 *
 * Revision 2.4  1994/10/27  20:02:04  ty7777
 * Added checking for zorigin.
 *
 * Revision 2.3  1994/10/26  16:15:35  ty7777
 * Added winutil.h
 *
 * Revision 2.2  1994/10/19  17:17:38  ty7777
 * Change IF to if.
 *
 * Revision 2.1  1994/10/19  17:01:16  ty7777
 * The pattern *pattern* works.
 *
 * Revision 1.99  1994/10/17  19:53:07  ty7777
 * Before file patterns work.
 *
 * Revision 1.98  1994/10/14  18:07:42  ty7777
 * Allow maximum distance for single slices.
 *
 * Revision 1.97  1994/10/13  18:54:48  ty7777
 * Uses pett6_n99 as the default t88 mask.
 *
 * Revision 1.96  1994/08/25  16:40:41  ty7777
 * Changed the documentation.
 *
 * Revision 1.95  1994/08/25  16:39:00  ty7777
 * Same as the last one.
 * X11R5 version.
 *
 * Revision 1.94  1994/08/17  21:19:36  ty7777
 * Delected redundant code for getting the zorigin.
 *
 * Revision 1.93  1994/08/17  20:26:19  ty7777
 * Added processing for X, Y, Z values when getting defaults.
 *
 * Revision 1.92  1994/08/17  19:46:01  ty7777
 * Display the bottom slices of the PET iamge.
 *
 * Revision 1.91  1994/08/17  16:16:29  ty7777
 * Apply the zorigin only to the transverse slices.
 *
 * Revision 1.90  1994/08/16  15:45:44  ty7777
 * Added error checking for the first and last slice.
 *
 * Revision 1.89  1994/08/12  16:59:19  ty7777
 * Use the index in BuildQueue ().
 *
 * Revision 1.88  1994/08/11  21:21:13  ty7777
 * Changed the error message.
 *
 * Revision 1.87  1994/06/23  17:12:24  ty7777
 * Delected the debugging messages.
 *
 * Revision 1.86  1994/06/23  16:57:11  ty7777
 * Added checking for the first slice and last slice in GetDefaultParameters ().
 *
 * Revision 1.85  1994/06/02  20:55:16  ty7777
 * Match the PET images correctly with the atlas slices in the right
 * handed coordinate system.
 *
 * Revision 1.84  1994/05/19  14:11:53  ty7777
 * Changed from (z, x, y) to (x, y, z).
 *
 * Revision 1.83  1994/05/09  21:59:17  ty7777
 * Update for mask 75 slice images and read zorigin.
 *
 * Revision 1.82  1994/05/09  16:43:31  ty7777
 * Changed the processing for mask to use zorigin.
 *
 * Revision 1.81  1994/05/09  16:07:53  ty7777
 * Added color table Color43.tbl.
 *
 * Revision 1.80  1994/05/06  19:40:45  ty7777
 * Added processing for zorigin display for coronal and sagittal sections.
 *
 * Revision 1.79  1994/04/18  17:55:03  ty7777
 * Added processing for zorigin.
 *
 * Revision 1.78  1994/04/14  20:38:12  ty7777
 * Uses slice2z () and z2slice ().
 *
 * Revision 1.77  1994/04/13  15:09:59  ty7777
 * Changed the color table names.
 *
 * Revision 1.76  1994/04/12  20:46:15  ty7777
 * Added frames for color bar.
 *
 * Revision 1.75  1994/04/12  20:08:59  ty7777
 * Adding frames to black and white color bar.
 *
 * Revision 1.74  1994/04/12  15:27:41  ty7777
 * Lowered () is changed.
 *
 * Revision 1.73  1994/04/07  16:52:09  ty7777
 * Final checking in.
 *
 * Revision 1.72  1994/02/17  17:27:44  ty7777
 * Fixed show points error for FACING_LEFT slices.
 *
 * Revision 1.71  1994/02/11  22:23:15  ty7777
 * Fixed region display problem.
 *
 * Revision 1.70  1994/01/24  20:08:25  ty7777
 * Added copyright information.
 *
 * Revision 1.69  1994/01/12  21:37:49  ty7777
 * Fix GetLegendDim bug.
 *
 * Revision 1.68  1994/01/11  22:24:18  ty7777
 * Added processing for legend.
 *
 * Revision 1.67  1994/01/11  17:55:38  ty7777
 * Make the Show Coordinates right for Talairach atlases.
 *
 * Revision 1.66  1994/01/11  16:15:52  ty7777
 * Changed the HD6 Brain and T88 Brain to original and hd6tot88.
 *
 * Revision 1.65  1993/12/16  15:51:27  ty7777
 * Modified DrawLabel. Added GetLabelDim.
 *
 * Revision 1.64  1993/12/14  20:00:07  ty7777
 * Added processing for AF3D display in UpdatePortals.
 *
 * Revision 1.63  1993/12/13  20:21:48  ty7777
 * Deleted old DrawLabel.
 *
 * Revision 1.62  1993/12/13  20:20:22  ty7777
 * Modified DrawLabel.
 *
 * Revision 1.61  1993/12/13  19:43:50  ty7777
 * Deleted debugging lines.
 *
 * Revision 1.60  1993/12/13  15:19:59  ty7777
 * After adding view25d.
 *
 * Revision 1.59  1993/12/08  21:02:40  ty7777
 * Fixed problem for reading default symbol type and symbol color.
 *
 * Revision 1.58  1993/11/02  16:52:32  ty7777
 * Changed ErrorMinMax.
 *
 * Revision 1.57  1993/11/01  21:57:27  ty7777
 * Fixed error checking for Fran.
 *
 * Revision 1.56  1993/10/28  15:44:36  ty7777
 * Fixed bug for displaying sagittal slices facing on left with atlas trim on.
 *
 * Revision 1.55  1993/10/22  20:05:04  ty7777
 * Change RegularMinMax.
 *
 * Revision 1.54  1993/09/27  19:00:52  ty7777
 * Added gray color button for atlas color.
 *
 * Revision 1.53  1993/09/23  20:40:58  ty7777
 * View and Log Coordinates File.
 *
 * Revision 1.52  1993/07/26  22:01:59  ty7777
 * Modified mormula for HD6 to T88 conversion.
 *
 * Revision 1.51  1993/07/13  15:06:51  ty7777
 * After adding show point location.
 *
 * Revision 1.50  1993/07/06  16:49:49  ty7777
 * Before working on getting points.
 *
 * Revision 1.49  1993/06/03  19:38:56  ty7777
 * Make coronal and saggital reginos display work.
 *
 * Revision 1.48  1993/06/03  14:33:17  ty7777
 * After coronal and saggital regions show.
 *
 * Revision 1.47  1993/06/02  17:17:14  ty7777
 * After multiple regions display worked.
 *
 * Revision 1.46  1993/05/17  17:17:50  ty7777
 * Move CreateXorGC () to xor.c in libhp.a.
 *
 * Revision 1.45  1993/05/17  16:23:48  ty7777
 * Fixed any scale problem.
 *
 * Revision 1.44  1993/05/07  21:55:53  ty7777
 * Processing for pet mask image.
 *
 * Revision 1.43  1993/05/07  16:56:25  ty7777
 * Before testing number of slices.
 *
 * Revision 1.42  1993/04/05  17:32:58  ty7777
 * After add AF3D points works.
 *
 * Revision 1.41  1993/02/23  18:15:15  ty7777
 * Before fixing ECAT image bug.
 *
 * Revision 1.40  1993/01/28  15:42:56  ty7777
 * Before changing libcti.a
 *
 * Revision 1.39  1993/01/13  19:32:49  ty7777
 * Modified "atlas trim" to make it work correctly.
 *
 * Revision 1.38  1993/01/11  15:51:00  ty7777
 * Add atlas trim.
 *
 * Revision 1.37  1992/12/31  21:56:51  ty7777
 * Before Randy's change.
 *
 * Revision 1.36  1992/12/07  20:34:28  ty7777
 * Adding a message box when the user gives an ascii af3d file.
 *
 * Revision 1.35  1992/12/07  15:51:57  ty7777
 * Same as the last version.
 *
 * Revision 1.34  1992/12/03  20:25:12  ty7777
 * Before testing libcti.a library.
 *
 * Revision 1.33  1992/11/20  16:35:26  ty7777
 * Working and Updated version.
 *
 * Revision 1.31  1992/10/30  21:51:25  ty7777
 * portal.c checking in.
 *
 * Revision 1.30  1992/09/28  16:47:24  ty7777
 * After Add "xlabel" button.
 *
 * Revision 1.29  1992/09/23  19:30:26  ty7777
 * Same as the last version.
 *
 * Revision 1.28  1992/08/26  21:28:42  ty7777
 * Testing RCS checking in.
 **/
/*$Header: /data/petsun4/src/view25d/RCS/portal.c,v 2.37 1995/10/26 19:02:28 ty7777 Exp ty7777 $*/

#ifndef lint
static char sccsid [] = "@@(#)portal.c	10/22/92  Copyright Neural Pet Group, Washington University 1992";
#endif

static char rcsid [] = "$Header: /data/petsun4/src/view25d/RCS/portal.c,v 2.37 1995/10/26 19:02:28 ty7777 Exp ty7777 $";

/*_________________________________________________________________________________
	File Name:
		portal.c

	Description:
		Support functions for program ``view25d''. File includes 
		manipulation functions for Portals, and AtlasSlices. Also,
		the heart of the slice display functions and data structure
		update routines reside here.
	Authors:
		Tom Yang and M. Todd Gamble.
		02/01/91

	Modifications:
		Created a private function Transformation to transform
		regions of PET images.
		Tom Yang (03/18/1991)

		Rewrite public function GetAtlasSliceData to read in pet
		images and region files.
		Tom Yang (03/20/1991)

        	Rewrite private functions MakePortal and UpdatePortals
		so we can display pet images and regions.
		Tom Yang (03/21/1991)

		Created a public function ClearPortals to clear the portals
		drawn on screen.
		Tom Yang (05/01/1991)

		Created private function ResizeSlice and ResizePortals for
		resizing images and displaying negative PET images.
		Tom Yang (05/06/1991)

		Created a public function DrawPortal to draw portals on
		screen.
		Tom Yang (05/07/1991)

	Pending:
		All comments which include the string "FIX" have information
		on current limitation, bugs, or noted problems.

______________________________________________________________________________*/

#include <time.h>
#include <math.h>
#include "portal.h"
#include <unistd.h>
#include <petutil/matrix7.h>
#include <petutil/winutil.h>
#include <petutil/ifh.h>
#include <petutil/ANALYZE.h> 
#include <petutil/AIR.h> 
#include <Xm/Label.h>
#include <Xm/ToggleB.h>
#include <Xm/Text.h>
#include <Xm/SelectioB.h>
#include <X11/StringDefs.h>
#include <X11/Intrinsic.h> 

#define	SMOOTH_LENGTH	10


PRIVATE void		BuildPortals ();
PRIVATE SCALE_HEADER	*BuildQueue ();
PRIVATE void		ClearRegionSets ();
PRIVATE int		DisplayAF3DPoints ();
PRIVATE int		DrawGammaZData ();
PRIVATE int		DrawAsciiGammaZData ();
PRIVATE void		DrawOutlinedRegion ();
PRIVATE void		DrawPortal ();
PRIVATE void		FormatScreen ();
PRIVATE int		GammaZPointCmp ();
PRIVATE float		GetCoordinate ();
PRIVATE SCALE_HEADER	*GetCurrentHeader ();
PRIVATE short		GetDesiredFirst ();
PRIVATE void		GetFileStatus ();
PUBLIC	GC		GetXorGC ();
PRIVATE void		GetPetCenter ();
PRIVATE void		GetPetDimension ();
PRIVATE int		InputInterfileData ();
PRIVATE void		InputImageData ();
PRIVATE int		InputRegionData ();
PRIVATE int		ReadRegion ();
PRIVATE GammaZData	*MakeAsciiGammaZData ();
PRIVATE Portal		*MakePortal (); 
PRIVATE void		ResizePortals ();
PRIVATE SliceData	*ResizeSlice ();


/*______________________________________________________________________________	
	Procedure:
		SetSelectData
	Parameters:
		w:		Widget, widget where callback was triggered.
		status_flag:	BOOLEAN, either on or off.
	Description:
		Set the toggle button to the specified state.
		Author: Tom Yang 
		(05/21/91)
_____________________________________________________________________________*/

PUBLIC void SetSelectData (w, status_flag)
Widget		w;
BOOLEAN		status_flag;
{
	if (status_flag != XmToggleButtonGetState (w))
	{
		XmToggleButtonSetState (w, status_flag, FALSE);
	}
}


/*_____________________________________________________________________________	
	Function:	GammaZPointCmp
	Arguments:	a: pointer to GammaZPoint	
			b: pointer to GammaZPoint	
	Description:	Compare two gammaz data points by their z value.
	Return Value:	-1 if z value of a less than z value of b
 			 0 if z value of a equals z value of b
			 1 if z value of a greater than z value of b
_____________________________________________________________________________*/

PRIVATE int GammaZPointCmp (a, b)
GammaZPoint	*a, *b;
{
	if (a->z < b->z)
		return (-1);
	if (a->z > b->z)
		return (1);
	return (0);
}



/*______________________________________________________________________________	
	Procedure:
		GetCoordinate
	Parameters:
		point:		FLOAT_POINT3D.
		atlas_orient:	atlas orientation.
	Description:
		Get the coordinate of a 3d floating point in the current active
		atlas orientation.
		Author: Tom Yang 
		(07/17/92)
_____________________________________________________________________________*/

PRIVATE float GetCoordinate (point, atlas_orient)
	FLOAT_POINT3D	point;
	char		atlas_orient;
{
	if (atlas_orient == TRANSVERSE)
		return	point.z;
	else if (atlas_orient == CORONAL)
		return	point.y;
	else
		return	point.x;
}


/*___________________________________________________________________________	
	Function:	DrawGammaZData	

	Arguments:	fd: Unix file descriptor, file to read from  
			c: character read to test condition of file 

	Description:	Allocate, read, and display a set of gammaz data 
			consisting of the header of point information from 
			a Sybase application.

	Author:		Tom Yang
			Created January 12, 1995.

	Return Value:	SUCCEED: successful; FAIL: failed.
____________________________________________________________________________*/

PRIVATE int DrawGammaZData (display, window, gc, fd, c, file_index, symbol_type, 
	pixel_color, symbol_size, outline_width, atlas_orient, current_header, 
	draw_portal_data)
Display			*display;
Window			window;
GC			gc;
int			fd;
char			c;
int			file_index;
char			symbol_type;
Pixel			pixel_color;
unsigned short		symbol_size;
int			outline_width;
char			atlas_orient; 
SCALE_HEADER		*current_header;
DRAW_PORTAL_DATA	*draw_portal_data;
{
	Arg		arglist [1];
	FLOAT_POINT3D	point;
	RawGammaZPoint	*rawpoint;	/* raw point read from input file */
	char		*description;	/* pointer to AF3D description */
	char		*path;		/* pointer to path of image file*/
	char		s [2];		/* temp var to use test char and */
	double		coordinate;
	int		af3d_id;	/* AF3D id */
	int		i;		/* counter */
	int		num_points;	/* number of points in dataset */
	int		slice_xyz; 
	int		sx;
	int		sy;
	int		sz;
	int		tempx;		
	int		tempy;		
	long		bytes;
	long		current_bytes;
	short		desc_len;	/* length of AF3D description */
	short		path_len;	/* length of path string */
	short		x;
	short		y;
	static char	*function = "DrawGammaZData"; /* read path len var from file */

	/* 
	 * Keep the test character and read the rest of the path_len var. 
	 */
	s[0] = c;
	pkg_read (fd, &s [1], 1, function, "s[1]");
	memcpy ((char *) &path_len, s, 2);

	current_bytes	= lseek (fd, 0L, 1);
	bytes		= lseek (fd, 0L, 2);
	if (path_len <= 0 || path_len > bytes - sizeof (RawGammaZPoint))
	{
		XtManageChild (errorMessageBox);
		return FAIL;
	}

	lseek (fd, current_bytes, 0);

	/* 
	 * Allocate memory for the path and read it. 
	 */
	path = (char *) pkg_malloc (path_len, function, "path");
	pkg_read (fd, path, path_len, function, "path");
	free (path);

	/* 
	 * Get the length of the description string. 
	 */
	pkg_read (fd, &desc_len, sizeof (desc_len), function, "desc_len");

	/* 
	 * Allocate memory for the description and read it. 
	 */
	description = (char *) pkg_malloc (desc_len, function, "description");
	pkg_read (fd, description, desc_len, function, "description");
	free (description);

	/* 
	 * Read the af3d id. 
	 */
	pkg_read (fd, &af3d_id, sizeof (af3d_id), function, "af3d_id");

	/* 
	 * Read the number of points. 
	 */
	pkg_read (fd, &num_points, sizeof (num_points), function, "num_points");

	/* 
	 * Allocate a buffer for point reading. 
	 */
	rawpoint 	= (RawGammaZPoint *) pkg_malloc (sizeof (RawGammaZPoint), 
				function, "rawpoint");
	x		= draw_portal_data->portal->x;
	y		= draw_portal_data->portal->y;
	slice_xyz	= draw_portal_data->portal->slice->slice_xyz;
	if (num_points > 0)
	{
		XSetForeground (display, gc, pixel_color);
		XSetLineAttributes (display, gc, pkg_min (symbol_size / 2,
		outline_width), LineSolid, CapButt, JoinMiter);
	}

	/* 
	 * Read the gammaz points. 
	 */
	for (i = 0; i < num_points; i++) 
	{
		/* 
		 * Read a raw point. 
		 */
		pkg_read (fd, rawpoint, sizeof (RawGammaZPoint), function, "rawpoint");

		/* 
		 * Dsiplay the point if it inside the current slice.
		 */
		point.x	= -rawpoint->x;
		point.y	= rawpoint->y;
		point.z	= rawpoint->z;

		coordinate	= GetCoordinate (point, atlas_orient);
		if (*draw_portal_data->all_planes ||
		((coordinate >= slice_xyz - draw_portal_data->spacing) && 
		(coordinate < slice_xyz + draw_portal_data->spacing))) 
		{
			draw_portal_data->symbol_displayed [file_index] = TRUE;

			/* 
	 		 * Reverse coordination orientation and scale. 
	 		 */
			sx	= ROUND ((point.x * 1.0) / current_header->pixel_size);
			sy	= ROUND ((point.y * -1.0) / current_header->pixel_size);
			sz	= ROUND ((point.z * -1.0) / current_header->pixel_size);
			if (atlas_orient == TRANSVERSE)
			{
				tempx	= sx;
				tempy	= sy;
			}
			else if (atlas_orient == CORONAL)
			{
				tempx	= sx;
				tempy	= sz;
			}
			else if (atlas_orient == FACING_LEFT)
			{
				tempx	= sy;
				tempy	= sz;
			}
			else
			{
				tempx	= -sy;
				tempy	= sz;
			}

			tempx	+= x + current_header->centerx - symbol_size / 2;
			tempy	+= y + current_header->centery - symbol_size / 2;

			DrawSymbol (display, window, gc, tempx, tempy, 
				symbol_size, symbol_size, symbol_type);
		}
	}

	/* 
	 * Free the raw point buffer and return to the default line width. 
	 */
	free (rawpoint);		
	if (num_points > 0)
		XSetLineAttributes (display, gc, 1, LineSolid, CapButt, JoinMiter);

	return SUCCEED;
}


/*___________________________________________________________________________	
	Function:	DrawAsciiGammaZData	

	Arguments:	

	Description:	Allocate, read, and display a set of gammaz data 
			created from by an ascii editor.

	Author:		Tom Yang
			Created January 12, 1995.

	Return Value:	SUCCEED: successful; FAIL: failed.
____________________________________________________________________________*/

PRIVATE int DrawAsciiGammaZData (display, window, gc, filename, file_index, symbol_type, 
	pixel_color, symbol_size, outline_width, atlas_orient, current_header, 
	draw_portal_data)
Display			*display;
Window			window;
GC			gc;
char			*filename;
int			file_index;
char			symbol_type;
Pixel			pixel_color;
unsigned short		symbol_size;
int			outline_width;
char			atlas_orient; 
SCALE_HEADER		*current_header;
DRAW_PORTAL_DATA	*draw_portal_data;
{
	FILE		*fp;
	FLOAT_POINT3D	point;
	char		line [MAXLINE];
	double		coordinate;
	float		x;
	float		y;
	float		z;
	int		slice_xyz; 
	int		sx;
	int		sy;
	int		sz;
	int		tempx;		
	int		tempy;		
	short		xstart;
	short		ystart;
	static char	*function = "DrawAsciGammaZData";

	fp	= fopen (filename, "r");
	if (fp == (FILE *) NULL) 
	{
		pkg_message (PKG_ERROR, "view25d", function, "fopen",
			"Can't open %s\n", filename);
		return FAIL;
	}

	xstart		= draw_portal_data->portal->x;
	ystart		= draw_portal_data->portal->y;
	slice_xyz	= draw_portal_data->portal->slice->slice_xyz;
	XSetForeground (display, gc, pixel_color);
	XSetLineAttributes (display, gc, pkg_min (symbol_size / 2,
	outline_width), LineSolid, CapButt, JoinMiter);

	while (fgets (line, MAXLINE, fp) != NULL)
	{
		if (sscanf (line, "%f %f %f", &x, &y, &z) == 3) 
		{
			point.x	= x;
			point.y	= y;
			point.z	= z;

			coordinate	= GetCoordinate (point, atlas_orient);
			if (*draw_portal_data->all_planes ||
			((coordinate >= slice_xyz - draw_portal_data->spacing) && 
			(coordinate < slice_xyz + draw_portal_data->spacing))) 
			{
				draw_portal_data->symbol_displayed [file_index] = TRUE;

				/* 
	 		 	 * Reverse coordination orientation and scale. 
	 		 	 */
				sx	= ROUND ((point.x * 1.0) / current_header->pixel_size);
				sy	= ROUND ((point.y * -1.0) / current_header->pixel_size);
				sz	= ROUND ((point.z * -1.0) / current_header->pixel_size);
				if (atlas_orient == TRANSVERSE)
				{
					tempx	= sx;
					tempy	= sy;
				}
				else if (atlas_orient == CORONAL)
				{
					tempx	= sx;
					tempy	= sz;
				}
				else if (atlas_orient == FACING_LEFT)
				{
					tempx	= sy;
					tempy	= sz;
				}
				else
				{
					tempx	= -sy;
					tempy	= sz;
				}

				tempx	+= xstart + current_header->centerx - symbol_size / 2;
				tempy	+= ystart + current_header->centery - symbol_size / 2;

				DrawSymbol (display, window, gc, tempx, tempy, 
					symbol_size, symbol_size, symbol_type);
			}
		}
	}

	fclose (fp);

	return SUCCEED;
}


/*_______________________________________________________________________________	
	Function:	void ReadAtlasHeader (char *atlas_filename, char *library_path)

	Argument:	atlas_filename: pointer to atlas image filename.	

	Description:	Read atlas header and set the rAtlasHeader structure
			of type ATLAS_HEADER.

	Return Value:	none. 

	Author:		Tom Yang, March, 1992.

			(02/03/1992)
_______________________________________________________________________________*/
PUBLIC void ReadAtlasHeader (atlas_filename, library_path)
char	*atlas_filename;
char	*library_path;
{
	ATLAS_HEADER	*atlas_header	= &rAtlasHeader;
	BOOLEAN		*talairach_flag	= &bTalairachFlag;
	FILE		*atlasfp;		/* file pointer to atlas header */
	char		atlasz [MAXLINE];	/* string to hold xyz value */ 
	char		label [MAXLINE];	/* text label in header file */ 
	char		szBuffer [MAXLINE];	/* buffer string */ 
	int		i;
	int		index;
	int		pet_slice_num;
	int		z_value;

	/* 
	 * Open the header file. 
	 */
	atlasfp	= fopen (atlas_filename, "r");
	if (atlasfp == (FILE *) NULL) 
	{
		pkg_message (PKG_ERROR, "view25d", "ReadAtlasHeader", "fopen",
			"Can't open %s\n", atlas_filename);
		exit (FAIL);
	}

	/* 
	 * Read header information. 
	 */
	if (fgets (label, MAXLINE, atlasfp) == NULL )
	{
		pkg_message (PKG_ERROR, "view25d", "ReadAtlasHeader", "fgets",
			"File %s is empty.\n", atlas_filename);
		return;
	}

	/* 
	 * Read Header for Scale 0.25. 
	 */
	fscanf (atlasfp, "%s %d", label, &(atlas_header->scale_025_header.width));
	fscanf (atlasfp, "%s %d", label, &(atlas_header->scale_025_header.height));
	fscanf (atlasfp, "%s %f", label, &(atlas_header->scale_025_header.pixel_size));
	fscanf (atlasfp, "%s %d", label, &(atlas_header->scale_025_header.centerx));
	fscanf (atlasfp, "%s %d", label, &(atlas_header->scale_025_header.centery));
	fscanf (atlasfp, "%s %s", label, szBuffer);
	strcpy (atlas_header->scale_025_header.image_name, library_path);
	strcat (atlas_header->scale_025_header.image_name, szBuffer);
	fscanf (atlasfp, "%s %s", label, szBuffer);
	strcpy (atlas_header->scale_025_header.mask_name, library_path);
	strcat (atlas_header->scale_025_header.mask_name, szBuffer);

	fscanf (atlasfp, "%s %s", label, szBuffer);

	/* 
	 * Read Header for Scale 0.50. 
	 */
	fscanf (atlasfp, "%s %d", label, &(atlas_header->scale_050_header.width));
	fscanf (atlasfp, "%s %d", label, &(atlas_header->scale_050_header.height));
	fscanf (atlasfp, "%s %f", label, &(atlas_header->scale_050_header.pixel_size));
	fscanf (atlasfp, "%s %d", label, &(atlas_header->scale_050_header.centerx));
	fscanf (atlasfp, "%s %d", label, &(atlas_header->scale_050_header.centery));
	fscanf (atlasfp, "%s %s", label, szBuffer);
	strcpy (atlas_header->scale_050_header.image_name, library_path);
	strcat (atlas_header->scale_050_header.image_name, szBuffer);
	fscanf (atlasfp, "%s %s", label, szBuffer);
	strcpy (atlas_header->scale_050_header.mask_name, library_path);
	strcat (atlas_header->scale_050_header.mask_name, szBuffer);

	fscanf (atlasfp, "%s %s", label, szBuffer);

	/* 
	 * Read Header for Scale 1.00. 
	 */
	fscanf (atlasfp, "%s %d", label, &(atlas_header->scale_100_header.width));
	fscanf (atlasfp, "%s %d", label, &(atlas_header->scale_100_header.height));
	fscanf (atlasfp, "%s %f", label, &(atlas_header->scale_100_header.pixel_size));
	fscanf (atlasfp, "%s %d", label, &(atlas_header->scale_100_header.centerx));
	fscanf (atlasfp, "%s %d", label, &(atlas_header->scale_100_header.centery));
	fscanf (atlasfp, "%s %s", label, szBuffer);
	strcpy (atlas_header->scale_100_header.image_name, library_path);
	strcat (atlas_header->scale_100_header.image_name, szBuffer);
	fscanf (atlasfp, "%s %s", label, szBuffer);
	strcpy (atlas_header->scale_100_header.mask_name, library_path);
	strcat (atlas_header->scale_100_header.mask_name, szBuffer);

	fscanf (atlasfp, "%s %s %s", label, szBuffer, atlasz);

	/* 
	 * Read Index Table. 
	 */
	i	= 0;
	while (fscanf (atlasfp, "%d %d %d", &pet_slice_num, &index, &z_value) != EOF) 
	{
		atlas_header->index_table [i++]	= index;
	}
	atlas_header->scale_025_header.any_scale_flag	= FALSE;
	atlas_header->scale_050_header.any_scale_flag	= FALSE;
	atlas_header->scale_100_header.any_scale_flag	= FALSE;

	if (strstr (atlas_filename, "Talairach") == NULL)
		*talairach_flag	= FALSE;
	else
		*talairach_flag	= TRUE;

	fclose (atlasfp);
}


/*_______________________________________________________________________________	
	Function:	GetCurrentHeader
	Arguments:	
	Description:	Get the active header corresponding to the current scale.

	Return Value:	pointer to structure SCALE_HEADER..
	Author:		Tom (Tongzeng) Yang
			(02/03/1992)
_______________________________________________________________________________*/

PRIVATE SCALE_HEADER *GetCurrentHeader (current_mag, atlas_header)
float		*current_mag;
ATLAS_HEADER	*atlas_header;
{
	SCALE_HEADER	*current_header;

	if (pkg_abs (*current_mag - 0.25) < ERROR_BOUND)
		current_header	= &atlas_header->scale_025_header;
	else if (pkg_abs (*current_mag - 0.50) < ERROR_BOUND)
		current_header	= &atlas_header->scale_050_header;
	else if (pkg_abs (*current_mag - 1.00) < ERROR_BOUND)
		current_header	= &atlas_header->scale_100_header;
	else
	{
		current_header	= &rAnyScaleHeader;
		current_header->width	
			= ROUND (atlas_header->scale_100_header.width * *current_mag);
		current_header->height	
			= ROUND (atlas_header->scale_100_header.height * *current_mag);
		current_header->pixel_size		
			= atlas_header->scale_100_header.pixel_size / *current_mag; 
		current_header->centerx	= (current_header->width - 1) / 2;		
		current_header->centery	= (current_header->height - 1) / 2;		
		current_header->any_scale_flag	= TRUE;
		strcpy (current_header->image_name, 
			atlas_header->scale_100_header.image_name);
		current_header->any_atlas_width		
			= atlas_header->scale_100_header.width;
		current_header->any_atlas_height	
			= atlas_header->scale_100_header.height;
	}

	return	current_header;
}


/*_______________________________________________________________________________	
	Function:	BuildQueue
	Arguments:	
			atlas_list1:	linked list for atlas slices in image 1.
			atlas_list2:	linked list for atlas slices in image 2.
			first_slice:	first slice specified by user.
			last_slice:	last slice specified by user.
			spacing:	spacing specified by user.
	Description:	Build linked list for atlas slices.

	Return Value:	none.
	Author:		Tom (Tongzeng) Yang
			(02/03/1992)
_______________________________________________________________________________*/

PRIVATE SCALE_HEADER *BuildQueue (first_slice, last_slice, spacing, atlas_list1, atlas_list2, current_mag)
short		first_slice;
short		last_slice;
short		spacing;
llist		atlas_list1;
llist		atlas_list2;
float		*current_mag;
{
	ATLAS_HEADER	*atlas_header		= &rAtlasHeader;
	SCALE_HEADER	*current_header;
	SliceData	*slice1;
	SliceData	*slice2;
	char		atlas_orient		= cAtlasOrientation;
	char		*image1_filename	= szImage1FileName;
	float		voxel_depth;
	float		voxel_height;
	float		voxel_width;
	int		default_max_index_num;
	int		desired_slice;
	int		image_type;
	int		index_image;
	int		max_index_num;
	int		min_index_num;
	short		height;
	short		num_slices;
	short		width;
	struct Matval	matval;

	/* 
	 * Set comparison function for llinsert. 
	 */
	llcmp	= AtlasSliceCmp;

	/* 
	 * Build the atlas list. 
	 */
	desired_slice	= first_slice;
	current_header	=  GetCurrentHeader (current_mag, atlas_header);

	if (atlas_orient == TRANSVERSE)
	{
		default_max_index_num	= MAX_TRANS_ATLAS_NUM - 1;
	}
	else if (atlas_orient == CORONAL)
	{
		default_max_index_num	= MAX_ATLAS_NUM - 1;
	}
	else
	{
		default_max_index_num	= MAX_ATLAS_NUM - 1;
	}

	if (strlen (image1_filename) > 0)
	{
		matval.frame	= 1;
		matval.plane	= 1;
		matval.gate	= 1;
		matval.data	= 0;
		matval.bed	= 0;

		if (getimagedim (image1_filename, matval, &image_type, &width, &height, 
		&num_slices, &voxel_width, &voxel_height, &voxel_depth) == FAIL)
			return;

		if (atlas_orient == TRANSVERSE)
		{
			max_index_num	= num_slices - 1;
		}
		else if (atlas_orient == CORONAL)
		{
			max_index_num	= height - 1;
		}
		else
		{
			max_index_num	= width - 1;
		}
	}
	else
	{
		max_index_num	= default_max_index_num;
	}
	min_index_num	= 0;

	while (desired_slice <= last_slice)
	{
		/* 
		 * Allocate memory for a slice. 
		 */
		slice1	= (SliceData *) pkg_malloc (sizeof (SliceData), 
						"BuildQueue", "slice1");
		slice2	= (SliceData *) pkg_malloc (sizeof (SliceData), 
						"BuildQueue", "slice2");

		slice1->slice_xyz	= GetSliceCoord (desired_slice, atlas_orient, zorigin_image1);
		slice2->slice_xyz	= slice1->slice_xyz;
		if (atlas_orient == TRANSVERSE)
		{
			index_image	= desired_slice - 1 + (DEFAULT_ZORIGIN - zorigin_image1);

			if ((index_image < min_index_num && desired_slice >= 1) 
			|| (index_image > max_index_num && desired_slice <= MAX_TRANS_ATLAS_NUM))
			{
				index_image	= max_index_num;
			}
		}
		else
		{
			index_image	= desired_slice - 1;
		}

		if (index_image < min_index_num || index_image > max_index_num)
		{
			fprintf (stderr, 
			"The image index %d is outside the range [%d, %d].\n", 
				index_image, min_index_num, max_index_num);
			exit (0);
		}

		if (index_image < default_max_index_num)
		{
			slice1->atlas_index	= atlas_header->index_table [index_image];
		}
		else
		{
			slice1->atlas_index	= -1;
		}
		slice2->atlas_index	= slice1->atlas_index;

		slice1->pet_exist	= FALSE;
		slice2->pet_exist	= FALSE;
		llinsert (atlas_list1, slice1);
		llinsert (atlas_list2, slice2);
		desired_slice		+= abs (spacing);
	}

	return current_header;
}
 

/*_______________________________________________________________________________	
	Function:	InputImageData
	Arguments:	imgfile: pointer to pet image file
	Description:	Read pet images into atlas list.

	Return Value:	void.
	Author:		Tom Yang
			(06/12/1991)
_______________________________________________________________________________*/

PRIVATE void InputImageData (current_header, imgfile, atlas_list, first_slice, last_slice, 
	spacing, image_zorigin, apply_mask, auto_min_image_value, auto_max_image_value)
SCALE_HEADER	*current_header;
char		*imgfile;
llist		atlas_list;
int		first_slice;
int		last_slice;
int		spacing;
int		image_zorigin;
BOOLEAN		apply_mask;	
short		*auto_min_image_value;
short		*auto_max_image_value;
{
	BOOLEAN		encoded;
	BOOLEAN		err_value 	= SUCCEED;
	BOOLEAN		mask_encoded;
	BOOLEAN		minmax_changed	= FALSE;
	BOOLEAN		pettvi_14	= FALSE;
	BOOLEAN		sagittal_flag;
	COMMENT_INFO	comment_info_data;
	HorizontalSlice	*horizontal_slice;
	MatrixFile	*fptr;
	SliceData	*slice;				/* slice pointer to new slice */
	XPoint		ptBottomRight;
	XPoint		ptUpperLeft;
	char		atlas_orient		= cAtlasOrientation;
	char		*image_mask_file_name	= szImageMaskFileName;
	float		voxel_depth;
	float		voxel_width;
	int		i;				/* counter */
	int		imgfd;
	int		j;				/* counter */
	int		mskfd;
	int		mask_pett_num;
	int		mask_zorigin;
	int		pett_num;
	int		rows;
	int		slice_height;
	int		slice_width;
	int		tempx;			
	int		tempy;			
	int		zorigin_offset;
	llist		slice3d_list;
	long		slice_dim;			/* dimension of the slice image */
	short		global_max	= -MAXSHORT;
	short		global_min	= MAXSHORT;
	short		*header;
	short		height;
	short		mask_num_slices;
	short		*mask_slice_image;
	short		mask_slice_index;
	short		num_slices;
	short		*pet_slice_image;
	short		slice_index;
	short		temp_pet_value;
	short		width;
	static char	*function = "InputImageData";
	struct Matval	matval;

	matval.frame	= 1;
	matval.plane	= 1;
	matval.gate	= 1;
	matval.data	= 0;
	matval.bed	= 0;

	/* 
	 * Find the encoding, number of slices, the pett number.
	 */
	header = (short *) calloc (HEADER_SIZE / sizeof (short), sizeof (short));
	if (header == (short *) NULL)
	{
		pkg_message (PKG_ERROR, "view25d", function, "calloc",
		"Error: Can't allocate header.\n");
	}

	imgfd	= open (imgfile, O_RDONLY, 0);
	if (imgfd == -1)
	{
		fprintf (stderr, "Can't open image file %s\n", imgfile); 
		return;
	}

	pett_num	= getimage_type (imgfd, imgfile, &encoded, &num_slices);

	if (pett_num == ERROR_SCANNER)
		return;
	close (imgfd);

	if ((pett_num == PETT6_SCANNER) && (num_slices <= PETT6_14))
		pettvi_14	= TRUE;

	if (pett_num == INTERFILE)
	{

		InputInterfileData (current_header, imgfile, atlas_list, 
			first_slice, last_slice, spacing, apply_mask,
			image_mask_file_name, auto_min_image_value, 
			auto_max_image_value);
		return;
	}

	/* 
	 * Find the encoding, number of slices, the pett number, and the 
	 * zorigin for the mask file if it exists.
	 */
	if (apply_mask)
	{
		mskfd	= open (image_mask_file_name, O_RDONLY, 0);
		if (mskfd == -1)
		{
			fprintf (stderr, "Can't open mask file%s\n", image_mask_file_name); 
			return;
		}

		mask_pett_num	= getimage_type (mskfd, image_mask_file_name, 
				&mask_encoded, &mask_num_slices);

		if (mask_pett_num == ERROR_SCANNER)
			return;
		close (mskfd);

		mask_zorigin	= DEFAULT_ZORIGIN;
		if (mask_pett_num == ECAT_SCANNER)
		{
			fptr	= OpenEcat (image_mask_file_name, &mask_num_slices, 
				&width, &height, &voxel_width, &voxel_depth, matval);
			if (fptr == (MatrixFile *) NULL)
			{
				fprintf (stderr, "Cannnot open mask image %s.\n", image_mask_file_name);
				return;
			}

			comment_info (fptr->mhptr->study_description, &comment_info_data);

			mask_zorigin	= comment_info_data.zorigin;
			matrix_close (fptr);

			if (mask_zorigin == 0)
			{
				fprintf (stderr, 
				"Error: There is no z0 information in your mask image %s.\n",
				image_mask_file_name);
				fprintf (stderr,
		"       You can use the program setz0 to add the z0 slice to your image.\n");

				exit (FAIL);
			}
		}
	}

	/*
	 * Read the image and mask it if it is necessory.
	 */
	slice3d_list	= llinit ();
	slice_dim	= ENCODED_SLICE_DIM;
	zorigin_offset	= mask_zorigin - image_zorigin;
	for (slice_index = 1; slice_index <= num_slices; slice_index++)
	{
		horizontal_slice	= (HorizontalSlice *) pkg_malloc (sizeof (HorizontalSlice), 
						function, "horizontal_slice");
		horizontal_slice->slice_index	= slice_index;
		horizontal_slice->slice_data	= (short *) calloc (slice_dim, sizeof (short));
		imgfd	= open (imgfile, O_RDONLY, 0);
		if (imgfd == -1)
			fprintf (stderr, "Can't open %d\n", imgfile); 
		getimage (horizontal_slice->slice_data, header, imgfd, imgfile, slice_index, 
				encoded, num_slices, pett_num, &err_value);
		close (imgfd);	

		if (apply_mask)
		{
			mskfd	= open (image_mask_file_name, O_RDONLY, 0);
			if (mskfd == -1)
			{
				fprintf (stderr, "Can't open mask file %s\n", image_mask_file_name);
				return;
			}

			mask_slice_image	= (short *) calloc (slice_dim, sizeof (short));
			mask_slice_index	= slice_index + zorigin_offset;

			if (mask_slice_index <= mask_num_slices && mask_slice_index >= 1)
			{
				getimage (mask_slice_image, header, mskfd, image_mask_file_name, 
					mask_slice_index, mask_encoded, mask_num_slices, 
						mask_pett_num, &err_value);
				for (i = 0; i < slice_dim; i++)
				{
					if (mask_slice_image [i] <= 0)
						horizontal_slice->slice_data [i] = 0;
				}
			}
			close (mskfd);
			free (mask_slice_image);
		}

		lladd (slice3d_list, horizontal_slice);
	}

	if (llsize (atlas_list) > 0)
	{
		/*
		 * The coordinate system is right handed. The slice number and
		 * the x value either increase or decrase at the same time.
		 */
		if (atlas_orient == FACING_LEFT || atlas_orient == FACING_RIGHT)
		{
			sagittal_flag	= TRUE;
			llhead (atlas_list);
		}
		else
		{
			sagittal_flag	= FALSE;
			lltail (atlas_list);
		}
		slice_index	= first_slice;

		GetPetDimension (atlas_orient, num_slices, &slice_width, &slice_height);
		slice_dim	= slice_width * slice_height; 

		do
		{
			/* 
			 * Allocate and Zero the image array. 
			 */
			pet_slice_image	= (short *) calloc (slice_dim, sizeof (short));
			llhead (slice3d_list);			
			slice = llretrieve (atlas_list);
			if (atlas_orient == TRANSVERSE)
			{
				if (slice_index > num_slices)
				{
					slice->pet_exist	= FALSE;
					free (pet_slice_image);
					slice_index	+= abs (spacing);
					continue;
				}

				for (i = 1; i < slice_index; i++)
				{
					llnext (slice3d_list);
				}
				horizontal_slice	= (HorizontalSlice *) llretrieve (slice3d_list);
				for (i = 0; i < slice_dim; i++)
				{
					pet_slice_image [i] = horizontal_slice->slice_data [i];
				}
			}
			else if (atlas_orient == CORONAL)
			{
				for (j = 0; j < slice_height; j++)
				{
					horizontal_slice	
						= (HorizontalSlice *) llretrieve (slice3d_list);
					rows	= j * slice_width;
					for (i = 0; i < slice_width; i++)
					{
						pet_slice_image [rows + i] 
							= horizontal_slice->slice_data [(slice_index - 1) 
							* ENCODED_SLICE_WIDTH + i];
					}
					llnext (slice3d_list);
				}
			}
			else if (atlas_orient == FACING_LEFT)
			{
				for (j = 0; j < slice_height; j++)
				{
					horizontal_slice	
						= (HorizontalSlice *) llretrieve (slice3d_list);
					rows	= j * slice_width;
					for (i = 0; i < slice_width; i++)
					{
						pet_slice_image [rows + i] 
							= horizontal_slice->slice_data [i 
							* ENCODED_SLICE_WIDTH + slice_index - 1];
					}
					llnext (slice3d_list);
				}
			}
			else
			{
				for (j = 0; j < slice_height; j++)
				{
					horizontal_slice	
						= (HorizontalSlice *) llretrieve (slice3d_list);
					rows	= j * slice_width;
					for (i = 0; i < slice_width; i++)
					{
						pet_slice_image [rows + (slice_width - 1 - i)] 
							= horizontal_slice->slice_data [i 
							* ENCODED_SLICE_WIDTH + slice_index - 1];
					}
					llnext (slice3d_list);
				}
			}

			if (slice->pet_exist)
				XtFree (slice->pet_input);
			for (i = 0; i < slice_dim && 
				pet_slice_image [i] == PET_BACK_VALUE; i++)
			;
			if (i >= slice_dim)
			{
				slice->pet_exist	= FALSE;
				free (pet_slice_image);
				slice_index	+= abs (spacing);
				continue;
			}
			else
				slice->pet_exist	= TRUE;

			i	/= slice_width;
			if (i >= slice_height)
			{
				i	= slice_height - 1;
			}

			ptUpperLeft.y	= i;

			for (i = slice_dim - 1;  i >= 0 && 
				pet_slice_image [i] == PET_BACK_VALUE; i--)
			;
			i	/= slice_width;
			if (i < 0)
				i	= 0;
			ptBottomRight.y	= i;

			tempx	= slice_width - 1;
			tempy	= 0;
			for (j = ptUpperLeft.y; j <= ptBottomRight.y; j++)
			{
				rows = j * slice_width;
				for (i = 0; i < slice_width && 
				pet_slice_image [rows + i] == PET_BACK_VALUE; i++)
					;
				if (i < tempx)
					tempx = i;

				for (i = slice_width - 1; i >= 0 &&
				pet_slice_image [rows + i] == PET_BACK_VALUE; i--)
					;
				if (i > tempy)
					tempy = i;
			}
			ptUpperLeft.x	= tempx;
			ptBottomRight.x	= tempy;

			slice->pet_xstart		= ptUpperLeft.x;
			slice->pet_ystart		= ptUpperLeft.y; 
			slice->pet_width		= (ptBottomRight.x - ptUpperLeft.x + 1); 
			slice->pet_height		= (ptBottomRight.y - ptUpperLeft.y + 1); 
			if (slice->pet_exist && pettvi_14)
			{
				slice->rgn_pet_pixelwidth	
					= (PETT6_PIXEL_SIZE  * MMS_PER_CM) 
					/ current_header->pixel_size;
				slice->rgn_pet_pixelheight	
					= (PETT6_PIXEL_SIZE  * MMS_PER_CM) 
					/ current_header->pixel_size;
			}
			else
			{
				slice->rgn_pet_pixelwidth	
					= RGN_PIXEL_WIDTH / current_header->pixel_size;
				slice->rgn_pet_pixelheight	
					= RGN_PIXEL_HEIGHT / current_header->pixel_size;
			}

			if (atlas_orient != TRANSVERSE)
			{
				slice->pet_ystart	+= DEFAULT_ZORIGIN - image_zorigin;
			}

			slice->pet_input	= (short *) pkg_malloc (slice->pet_width 
						* slice->pet_height * sizeof (short), 
						function, "slice->pet_input");

			tempx	= 0;
			for (j = ptUpperLeft.y; j <= ptBottomRight.y; j++)
			{
				rows	= j * slice_width;
				for (i = ptUpperLeft.x; i <= ptBottomRight.x; i++)
				{
					temp_pet_value	= pet_slice_image [rows + i];
					slice->pet_input [tempx++] = temp_pet_value;

					if (temp_pet_value > global_max)
						global_max	= temp_pet_value;
					if (temp_pet_value < global_min)
						global_min	= temp_pet_value;
				}
			}
			minmax_changed	= TRUE;
			free (pet_slice_image);
			slice_index += abs (spacing);
		}
		while (((!sagittal_flag && llprevious (atlas_list) != FAIL) 
		|| (sagittal_flag && llnext (atlas_list) != FAIL))
		&& slice_index <= last_slice);

		if (minmax_changed)
		{
			*auto_min_image_value	= global_min;
			*auto_max_image_value	= global_max;
		}
	}
	free (header);

	/* 
	 * Clear slice3d_list data. 
	 */
	llhead (slice3d_list);			
	while (llsize (slice3d_list) > 0) 
	{
		horizontal_slice	= (HorizontalSlice *) llretrieve (slice3d_list);
		XtFree (horizontal_slice->slice_data);
		XtFree (horizontal_slice);

		lldelete (slice3d_list);
	} 
}


/*_______________________________________________________________________________	
	Function:	InputInterfileData
	Arguments:	imgfile: pointer to pet image file
	Description:	Read pet images into atlas list.

	Return Value:	SUCCEED: successful; FAIL: fail.
	Author:		Tom Yang
			(05/19/1995)
_______________________________________________________________________________*/

PRIVATE int InputInterfileData (current_header, imgfile, atlas_list, first_slice, last_slice, 
		spacing, apply_mask, mskfile, auto_min_image_value, auto_max_image_value)
SCALE_HEADER	*current_header;
char		*imgfile;
llist		atlas_list;
int		first_slice;
int		last_slice;
BOOLEAN		apply_mask;
char		*mskfile;
int		spacing;
short		*auto_min_image_value;
short		*auto_max_image_value;
{
	BOOLEAN		minmax_changed	= FALSE;
	BOOLEAN		sagittal_flag;
	IFH		ifhdr;
	IFH		ifhdr_mask;
	SliceData	*slice;				/* slice pointer to new slice */
	XPoint		ptBottomRight;
	XPoint		ptUpperLeft;
	char		atlas_orient		= cAtlasOrientation;
	char		*extension;
	char		ifhdr_file [MAXLINE];
	char		ifhdr_mskfile [MAXLINE];
	char		ifmskfile [MAXLINE];
	char		imgroot [MAXLINE];
	char		*lines [IFH_MAXLEN];
	float		*mask_slice_data;
	float		rgn_mask_pixelheight;
	float		rgn_mask_pixelwidth;
	float		rgn_pet_pixelheight;
	float		rgn_pet_pixelwidth;
	float		*slice_data;
	int		i;				/* counter */
	int		j;				/* counter */
	int		mask_slice_height;
	int		mask_slice_width;
	int		nlines;
	int		offset;
	int		rows;
	int		slice_height;
	int		slice_width;
	int		tempx;			
	int		tempy;			
	long		mask_slice_dim;			/* dimension of the slice image */
	long		slice_dim;			/* dimension of the slice image */
	short		global_max	= -MAXSHORT;
	short		global_min	= MAXSHORT;
	short		height;
	short		mask_index;
	short		num_slices;
	short		*pet_slice_image;
	short		slice_index;
	short		temp_pet_value;
	short		width;
	static char	*function = "InputInterfileData";

	/* 
 	 * Create the interfile header file.
 	 */
	memset (imgroot, 0, MAXLINE); 
	extension	= strrchr (imgfile, '.');
	if (extension != NULL)
		strncpy (imgroot, imgfile, strlen (imgfile)  - strlen (extension));
	else
		strcpy (imgroot, imgfile);
	strcpy (ifhdr_file, imgroot);
	strcat (ifhdr_file, IFH_EXT);

	if (readifhdr (ifhdr_file, FALSE, IFH_MAXLEN, &nlines, lines) == FAIL 
	|| getifhdr (ifhdr_file, FALSE, nlines, lines, &ifhdr) == FAIL)
	{
		strcpy (ifhdr_file, imgroot);
		strcat (ifhdr_file, HDR_EXT);

		if (hdr2ifh (ifhdr_file, &ifhdr) == FAIL)
			return;
	}

	if (atlas_orient == TRANSVERSE)
	{
		i	= 0;
		j	= 1;
	}
	else if (atlas_orient == CORONAL)
	{
		i	= 0;
		j	= 2;
	}
	else if (atlas_orient == FACING_LEFT || atlas_orient == FACING_RIGHT)
	{
		i	= 1;
		j	= 2;
	}
	slice_dim		= ifhdr.matrix_size [i] * ifhdr.matrix_size [j]; 
	slice_width		= ifhdr.matrix_size [i];
	slice_height		= ifhdr.matrix_size [j];
	rgn_pet_pixelwidth	= ifhdr.scaling_factor [i] / current_header->pixel_size;
	rgn_pet_pixelheight	= ifhdr.scaling_factor [j] / current_header->pixel_size;

	if (apply_mask)
	{
		memset (imgroot, 0, MAXLINE); 
		extension	= strrchr (mskfile, '.');
		if (extension != NULL)
			strncpy (imgroot, mskfile, strlen (mskfile)  - strlen (extension));
		else
			strcpy (imgroot, mskfile);
		strcat (imgroot, "_ifimg");
		strcpy (ifhdr_mskfile, imgroot);
		strcat (ifhdr_mskfile, IFH_EXT);

		strcpy (ifmskfile, imgroot);
		strcat (ifmskfile, ".mask");

		if (readifhdr (ifhdr_mskfile, FALSE, IFH_MAXLEN, &nlines, lines) == FAIL 
		|| getifhdr (ifhdr_mskfile, FALSE, nlines, lines, &ifhdr_mask) == FAIL)
		{
			strcpy (ifhdr_mskfile, imgroot);
			strcat (ifhdr_mskfile, HDR_EXT);

			if (hdr2ifh (ifhdr_mskfile, &ifhdr_mask) == FAIL)
				return;
		}

		mask_slice_dim		= ifhdr_mask.matrix_size [i] * ifhdr_mask.matrix_size [j]; 
		mask_slice_width	= ifhdr_mask.matrix_size [i];
		mask_slice_height	= ifhdr_mask.matrix_size [j];
		if (pkg_abs (ifhdr.scaling_factor [i] - ifhdr_mask.scaling_factor [i]) >= ERROR_BOUND
		|| pkg_abs (ifhdr.scaling_factor [j] - ifhdr_mask.scaling_factor [j]) >= ERROR_BOUND)
		{
			fprintf (stderr, "Error: the image %s and the mask %s have different voxel size\n",
				imgfile, ifmskfile);
			return;
		}
	}

	/*
	 * Read the image.
	 */
	if (llsize (atlas_list) > 0)
	{
		/*
		 * The coordinate system is right handed. The slice number and
		 * the x value either increase or decrase at the same time.
		 */
		if (atlas_orient == FACING_LEFT || atlas_orient == FACING_RIGHT)
		{
			sagittal_flag	= TRUE;
			llhead (atlas_list);
		}
		else
		{
			sagittal_flag	= FALSE;
			lltail (atlas_list);
		}
		slice_index	= first_slice;

		do
		{
			slice = llretrieve (atlas_list);

			/* 
			 * Allocate and Zero the image array. 
			 */
			slice_data	= (float *) calloc (slice_dim, sizeof (float));
			if (readifimg (imgfile, atlas_orient, slice_index, slice_dim, 
			ifhdr, slice_data) == FAIL)
			{
					slice->pet_exist	= FALSE;
					free (slice_data);
					slice_index	+= abs (spacing);
					continue;
			}

			pet_slice_image	= (short *) calloc (slice_dim, sizeof (short));
			for (i = 0; i < slice_dim; i++)
			{
				pet_slice_image [i]	= ROUND (slice_data [i]);
			}

			free (slice_data);

			if (apply_mask)
			{
				mask_slice_data	= (float *) calloc (mask_slice_dim, sizeof (float));
				offset	= ROUND (ifhdr_mask.atlas_origin [2] - ifhdr.atlas_origin [2]);

				if (atlas_orient == TRANSVERSE)
				{
					mask_index	= slice_index + offset;
				}
				else
					mask_index	= slice_index;
				if (readifimg (ifmskfile, atlas_orient, mask_index, mask_slice_dim, 
				ifhdr_mask, mask_slice_data) == FAIL)
				{
					free (mask_slice_data);
					slice_index	+= abs (spacing);
					continue;
				}

				if (atlas_orient == TRANSVERSE)
				{
					for (i = 0; i < slice_dim; i++)
					{
						if (pkg_abs (mask_slice_data [i]) < ERROR_BOUND)
							pet_slice_image [i]	= 0;
					}
				}
				else 
				{
					for (j = 0; j < slice_height; j++)
					{
						rows	= j * slice_width;
						for (i = 0; i < slice_width; i++)
						{
							if (pkg_abs (mask_slice_data [(j + offset)
							* slice_width + i]) < ERROR_BOUND)
								pet_slice_image [rows + i]	= 0;
						}
					}
				}

				free (mask_slice_data);
			}

			if (slice->pet_exist)
				XtFree (slice->pet_input);
			for (i = 0; i < slice_dim && 
				pet_slice_image [i] == PET_BACK_VALUE; i++)
			;
			if (i >= slice_dim)
			{
				slice->pet_exist	= FALSE;
				free (pet_slice_image);
				slice_index	+= abs (spacing);
				continue;
			}
			else
				slice->pet_exist	= TRUE;

			i	/= slice_width;
			if (i >= slice_height)
			{
				i	= slice_height - 1;
			}

			ptUpperLeft.y	= i;

			for (i = slice_dim - 1;  i >= 0 && 
				pet_slice_image [i] == PET_BACK_VALUE; i--)
			;
			i	/= slice_width;
			if (i < 0)
				i	= 0;
			ptBottomRight.y	= i;

			tempx	= slice_width - 1;
			tempy	= 0;
			for (j = ptUpperLeft.y; j <= ptBottomRight.y; j++)
			{
				rows = j * slice_width;
				for (i = 0; i < slice_width && 
				pet_slice_image [rows + i] == PET_BACK_VALUE; i++)
					;
				if (i < tempx)
					tempx = i;

				for (i = slice_width - 1; i >= 0 &&
				pet_slice_image [rows + i] == PET_BACK_VALUE; i--)
					;
				if (i > tempy)
					tempy = i;
			}
			ptUpperLeft.x	= tempx;
			ptBottomRight.x	= tempy;

			slice->pet_xstart	= ptUpperLeft.x;
			slice->pet_ystart	= ptUpperLeft.y; 
			slice->pet_width	= (ptBottomRight.x - ptUpperLeft.x + 1); 
			slice->pet_height	= (ptBottomRight.y - ptUpperLeft.y + 1); 
			slice->rgn_pet_pixelwidth	= rgn_pet_pixelwidth;
			slice->rgn_pet_pixelheight	= rgn_pet_pixelheight;

			slice->pet_input	= (short *) pkg_malloc (slice->pet_width 
						* slice->pet_height * sizeof (short), 
						function, "slice->pet_input");

			tempx	= 0;
			for (j = ptUpperLeft.y; j <= ptBottomRight.y; j++)
			{
				rows	= j * slice_width;
				for (i = ptUpperLeft.x; i <= ptBottomRight.x; i++)
				{
					temp_pet_value	= pet_slice_image [rows + i];
					slice->pet_input[tempx++] = temp_pet_value;

					if (temp_pet_value > global_max)
						global_max	= temp_pet_value;
					if (temp_pet_value < global_min)
						global_min	= temp_pet_value;
				}
			}
			minmax_changed	= TRUE;
			free (pet_slice_image);
			slice_index += abs (spacing);
		}
		while (((!sagittal_flag && llprevious (atlas_list) != FAIL) 
		|| (sagittal_flag && llnext (atlas_list) != FAIL))
		&& slice_index <= last_slice);

		if (minmax_changed)
		{
			*auto_min_image_value	= global_min;
			*auto_max_image_value	= global_max;
		}
	}
}


/*_______________________________________________________________________________	
	Function:	InputRegionData
	Arguments:	
	Description:	Read region data set into region_sets list.

	Return Value:	SUCCEED: successful; FAIL: failed.
	Author:		Tom Yang
			(05/22/1992)
_______________________________________________________________________________*/

PRIVATE int InputRegionData (filenames, display_region, filling_type, region_color, region_sets)
char		filenames [][MAXLINE];
BOOLEAN		*display_region;
char		*filling_type;
Pixel		*region_color;
llist		region_sets;
{
	int		fd;
	int		i;
	BOOLEAN		talairach_region_flag	= bTalairachRegionFlag;

	/*
	 * Clear old data sets.
	 */
	ClearRegionSets (region_sets);

	for (i = 0; i < MAX_REGIONSET_NUM; i++)
	{
		if (*(display_region + i))
		{
			if (strlen (filenames [i]) == 0 ||
				(fd	= open (filenames [i], O_RDONLY, 0)) == -1)
			{
				continue;
			}
			close (fd);

			/* 
		 	 * Read data from file.
		 	 */
			if (ReadRegion (filenames [i], filling_type [i], region_color [i], 
					region_sets, talairach_region_flag) == FAIL)
			{
				fprintf (stderr, "Error in ReadRegion for file %s\n", filenames [i]);
			}
		}
	}
}


/*_______________________________________________________________________________	
	Function:	ReadRegion
	Arguments:	rgn_filename:	region filename.	
			filling_type:	region filling type.
			region_color:	region color.
			region_sets:	region linked list.
	Description:	Read region slices into atlas list.

	Return Value:	int.
			SUCCEED: successful; FAIL: failed.
	Author:		Tom Yang
			(06/10/1991)
_______________________________________________________________________________*/

PRIVATE int ReadRegion (rgn_filename, filling_type, region_color, region_sets, talairach_region_flag)
char	*rgn_filename;
char	filling_type;
Pixel	region_color;
llist	region_sets;
BOOLEAN	talairach_region_flag;
{
	FILE		*rgnfp; 			/* input file pointer */
	RegionListData	*region_data;
	char		filename [MAXLINE];
	char		filetype [MAXLINE];
	char		line [MAXLINE];          	/* line buffer */
	double		x, y, z;	
	int		first_rgn_slice;
	int		i;				/* counter */
	int		j;				/* counter */
	int		last_rgn_slice;
	int		num_slices;
	int		pixel_num;
	int		slice_index;
	int		tempx, tempy;
	static char	*function = "ReadRegion";

	/* 
	 * Open the region file. 
	 */
  	rgnfp = fopen (rgn_filename, "r");
  	if (rgnfp == (FILE *) NULL) 
	{
		fprintf (stderr, "Error in opening region file %s\n", rgn_filename);
		return FAIL;
  	}

	/* 
	 * Ignore the first HEADER lines in the region file. 
	 */
	if (fgets (line, MAXLINE, rgnfp) == NULL)
	{
		fprintf (stderr, "Error: region file %s is empty.\n", rgn_filename); 
		return FAIL;
	}
	if (sscanf (line, "%s %d %s", filetype, &i, filename) == 3 &&
	strncmp (filetype, "filetype:", 9) == 0 && (i == 1 || i == 2)) 
	{
		fgets (line, MAXLINE, rgnfp);
	}

	fscanf (rgnfp, "%d %d %f %f %f %d %d", 
		&num_slices, &tempy, &x, &y, &z, &i, &slice_index);
	fscanf (rgnfp, "%d %d %d %d %d %d", &i, &slice_index, 
		&first_rgn_slice, &last_rgn_slice, &tempx, &tempy);

	j	= 0;
	while (fscanf (rgnfp, "%d %d", &slice_index, &pixel_num) != EOF && j < num_slices)
	{
		/* 
	 	 * Allocate the region set header. 
	 	 */
		region_data			= (RegionListData *) pkg_malloc (sizeof (RegionListData), 
							function, "region_data");
		region_data->region_input	= (XPoint *) pkg_malloc (pixel_num * sizeof (XPoint), 
							function, "region_data->region_input");
		for (i = 0; i < pixel_num; i++)
		{
			/*
			 * Convert pixels in image space to HD6 atlas space
			 * Units are in mm.
			 */
			fscanf (rgnfp, "%2x %2x", &tempx, &tempy);
    			region_data->region_input [i].x	= (tempx - REGION_SLICE_CX)
								* RGN_PIXEL_WIDTH;
    			region_data->region_input [i].y	= (REGION_SLICE_CY - tempy)
								* RGN_PIXEL_HEIGHT;
		}

		region_data->filling_type	= filling_type;
		region_data->region_color	= region_color;
		region_data->z			= (int) slice2z (slice_index, zorigin_image1);
		region_data->region_pixel_num	= pixel_num;

		if (talairach_region_flag)
		{
			region_data->z	= ROUND (1.07 * region_data->z);

			for (i = 0; i < pixel_num; i++)
			{
				region_data->region_input [i].x
					= ROUND (0.900 * region_data->region_input [i].x);
				region_data->region_input [i].y
					= ROUND (1.06 * (region_data->region_input [i].y - 14.0));
			}
		}

		/* 
 	 	 * Add data set to global list. 
 	 	 */
		lladd (region_sets, region_data);			

		j++;
	} 

	fclose (rgnfp);
}


/*_______________________________________________________________________________	
	Function:	DisplayAF3DPoints
	Arguments:	filenames:	AF3D file names, up to 10 sets.
	Description:	Read and display AF3D points for a specific slice. 

	Return Value:	SUCCEED: successful; FAIL: failed.
	Author:		Tom Yang
			Created January 12, 1995.
_______________________________________________________________________________*/

PRIVATE int DisplayAF3DPoints (display, window, gc, filenames, atlas_orient, 
	display_symbol, symbol_type, pixel_color, symbol_size, outline_width, 
	current_header, draw_portal_data)
Display			*display;
Window			window;
GC			gc;
char			filenames [][MAXLINE];
char			atlas_orient;
BOOLEAN			*display_symbol;
char			*symbol_type;
Pixel			*pixel_color;
unsigned short		*symbol_size;
int			*outline_width;
SCALE_HEADER		*current_header;
DRAW_PORTAL_DATA	*draw_portal_data;
{
	char		c;			/* test char */
	int		fd;
	int		file_type;
	int		i;

	for (i = 0; i < MAX_AF3DSET_NUM; i++)
	{
		if (*(display_symbol + i))
		{
			if (strlen (filenames [i]) == 0 ||
			(fd = open (filenames [i], O_RDONLY, 0)) == -1)
			{
				continue;
			}

			/* 
		 	 * Read either in Binary or Ascii format.
		 	 */
			file_type	= getfile_type (filenames [i]);
			if (file_type == BINARY)
			{
				if (read (fd, &c, 1) == 1)		
					DrawGammaZData (display, window, gc,
						fd, 
						c, 
						i,
						*(symbol_type + i), 
						*(pixel_color + i), 
						*(symbol_size + i), 
						*outline_width, 
						atlas_orient, 
						current_header,
						draw_portal_data);	
				close (fd);
			}
			else if (file_type == ASCII)
			{
				close (fd);
				DrawAsciiGammaZData (display, window, gc,
					filenames [i],
					i,
					*(symbol_type + i), 
					*(pixel_color + i), 
					*(symbol_size + i), 
					*outline_width, 
					atlas_orient, 
					current_header,
					draw_portal_data);	
			}
		}
	}
	return SUCCEED;
}


/*________________________________________________________________________________	
	Function:	ResizeSlice
	Arguments:	slice: pointer to slice.	
			minimum: minimum pixel value of the pet image slice.
			minimum: maximum pixel value of the pet image slice.
	Description:
			Resize and process a slice. 

	Return Value:	Pointer to new slice.

	Author:		Tom (Tongzeng) Yang
			(05/03/1991)
________________________________________________________________________________*/
PRIVATE SliceData *ResizeSlice (current_header, slice, minimum, maximum, pet_cx, pet_cy, 
		image1_flag, auto_image_value_flag, image_value_flag)
SCALE_HEADER	*current_header;
SliceData	*slice;		/* slice pointer to new slice */
short		*minimum;
short		*maximum;
float		pet_cx;
float		pet_cy;
BOOLEAN		image1_flag;
BOOLEAN		auto_image_value_flag;
char		image_value_flag;
{
	static char	*function	= "ResizeSlice";
	long		slice_size;		/* size of the slice image */
	short		*databuf;		/* buffer for interpolated pet image */
	char		*pet_coord_databuf;	/* temp buffer for coord. pet image */
	int		i, j;			/* loop control integer */
	int		tempx, tempy;
	int		xoffset, yoffset;	/* Offset for pet image */
	SliceData	*portalSlice;
	int		temp_coord_num;
	int		temp_back_num;
	int		rows;

	/* 
	 * Allocate memory for portal slice. 
	 */
	portalSlice = (SliceData *) pkg_malloc (sizeof (SliceData), function, "portalSlice");

	portalSlice->slice_xyz			= slice->slice_xyz;
	portalSlice->atlas_index		= slice->atlas_index;
	portalSlice->pet_exist			= slice->pet_exist;
	portalSlice->rgn_pet_pixelwidth		= slice->rgn_pet_pixelwidth;
	portalSlice->rgn_pet_pixelheight	= slice->rgn_pet_pixelheight;

	/* 
	 * Memory allocation for pet image. 
	 */
	if (portalSlice->pet_exist)
	{
		portalSlice->pet_width	= ROUND (slice->pet_width * slice->rgn_pet_pixelwidth);
		portalSlice->pet_height	= ROUND (slice->pet_height * slice->rgn_pet_pixelheight);
		slice_size		= portalSlice->pet_width * portalSlice->pet_height;
		databuf			= (short *) pkg_malloc (slice_size * sizeof (short), 
									function, "databuf");
		pet_coord_databuf	= (char *) pkg_malloc (slice_size, 
						function, "pet_coord_databuf");

		/* 
		 * Compute pet image offset. 
		 */
		Transformation (portalSlice->rgn_pet_pixelwidth, 
				portalSlice->rgn_pet_pixelheight, 
		    		pet_cx, 
				pet_cy,
		    		slice->pet_xstart, 
				slice->pet_ystart,
				current_header->centerx, 
				current_header->centery, 
				&xoffset, 
				&yoffset);

		/* 
		 * The pixel has different size.
		 */
		xoffset			-= ROUND (portalSlice->rgn_pet_pixelwidth / 2);
		yoffset			-= ROUND (portalSlice->rgn_pet_pixelheight / 2);
		portalSlice->pet_xstart	= xoffset;
		portalSlice->pet_ystart	= yoffset;

		/* 
		 * Resize and convert pet image. 
		 */
		interp (slice->pet_input, slice->pet_width, slice->pet_height, 
			databuf, portalSlice->pet_width, portalSlice->pet_height);

		Convert16to8 (databuf, portalSlice->pet_width, portalSlice->pet_height, 
				pet_coord_databuf, minimum, maximum, 
				auto_image_value_flag, image_value_flag);
		XtFree (databuf);

		temp_coord_num = 0;
		for (j = 0; j < portalSlice->pet_height; j++) 
		{
	    		rows = j * portalSlice->pet_width;

			for (i = 0; i < portalSlice->pet_width && 
				pet_coord_databuf [rows + i] == PET_BACK_VALUE; i++)
				;
			tempx = i;

			for (i = portalSlice->pet_width - 1; i >= 0 && 
				pet_coord_databuf [rows + i] == PET_BACK_VALUE; i--)
				;
			tempy = i;

			if (tempy >= tempx)
			{
				temp_coord_num += tempy - tempx + 1;
			}
		}
		portalSlice->pet_point_num = temp_coord_num;

		portalSlice->pet_point_pixel = (unsigned char *) pkg_malloc (portalSlice->pet_point_num, 
							function, "portalSlice->pet_point_pixel");
		portalSlice->pet_point_coord 
			= (XPoint *) pkg_malloc (portalSlice->pet_point_num * sizeof (XPoint), 
							function, "portalSlice->pet_point_coord");

		/* 
		 * Compute PET pixels and coordinates. 
		 */
		temp_coord_num = 0;
		for (j = 0; j < portalSlice->pet_height; j++) 
		{
	    		rows = j * portalSlice->pet_width;

			for (i = 0; i < portalSlice->pet_width && 
				pet_coord_databuf [rows + i] == PET_BACK_VALUE; i++)
				;
			tempx = i;

			for (i = portalSlice->pet_width - 1; i >= 0 && 
				pet_coord_databuf [rows + i] == PET_BACK_VALUE; i--)
				;
			tempy = i;

	    		for (i = tempx; i <= tempy; i++)
	    		{
				if (image1_flag)
	 				portalSlice->pet_point_pixel [temp_coord_num] 
					= pet_coord_databuf [rows + i] + PET_COLOR_START;
				else
	 				portalSlice->pet_point_pixel [temp_coord_num] 
					= pet_coord_databuf [rows + i] + PET_COLOR_START - 20;
				portalSlice->pet_point_coord [temp_coord_num].x = i + xoffset;
				portalSlice->pet_point_coord [temp_coord_num].y = j + yoffset;
				temp_coord_num++;
	    		}
		}
		XtFree (pet_coord_databuf);
	}

	return (portalSlice);
}


/*________________________________________________________________________________	
	Function:	MakePortal
	Arguments:	display: pointer to X Display 
			window: Window to which this portal will be drawn.
			slice: pointer SliceData to display in window 
			x,y: int representing upper left coord. of window
	Description: 	Allocate, create, and display portal with atlas slice.

	Return Value:	A pointer to the new Portal.
_________________________________________________________________________________*/

PRIVATE Portal	*MakePortal (slice) 
SliceData	*slice; 
{ 
	Portal	*p;			/* pointer to Portal */

	/* 
	 * Allocate mem for the Portal header. 
	 */
	p	= (Portal *) pkg_malloc (sizeof (Portal), "MakePortal", "p");

	/* 
	 * Assign portal header. 
	 */
	p->slice = slice;

	/* 
	 * Return the new portal. 
	 */
	return (p);
}


/*_________________________________________________________________________________	
	Function:	UpdatePortals	
	Arguments:	display: pointer to X Display 
			portal_list: linked list of Portals for image 1 or 2.
	Description: 	Redraw slice images and point data in slices.
	Return Value:	None.
_________________________________________________________________________________*/

PUBLIC void UpdatePortals (display, window, gc, current_header, portal_list, 
		atlas_orient, display_atlas_flag, display_image_flag, xstart, ystart, 
		auto_image_value_flag, image_value_flag, colorbar_xstart, colorbar_ystart, 
		colorbar_width, colorbar_length, hori_colorbar, colorbar_onoff, color_table_name,
		color_bar_exist, color_bar_min, color_bar_middle, color_bar_max,
		image1_flag, image_zorigin, overlay)
Display		*display; 
Window		window;		/* window to display to */
GC		gc;		/* graphics context */
SCALE_HEADER	*current_header;
llist		portal_list;
char		atlas_orient;
BOOLEAN		*display_atlas_flag;
BOOLEAN		*display_image_flag;
short		xstart;		/* portal x start */
short		ystart;		/* portal y start */
BOOLEAN		auto_image_value_flag;
BOOLEAN		image_value_flag;
short		colorbar_xstart;
short		colorbar_ystart;
short		colorbar_width;
short		colorbar_length;
BOOLEAN		hori_colorbar;
BOOLEAN		colorbar_onoff;
char		*color_table_name;
BOOLEAN		*color_bar_exist;
XRectangle	*color_bar_min;
XRectangle	*color_bar_middle;
XRectangle	*color_bar_max;
BOOLEAN		image1_flag;
int		image_zorigin;
BOOLEAN		overlay;
{ 
	BOOLEAN			low2high;
	BOOLEAN			pet_exist	= FALSE;
	BOOLEAN			slice_num_flag;
	DRAW_PORTAL_DATA	draw_portal_data;
	FILE			*atlasfp;
	FILE			*maskfp;
	Portal			*portal;	/* current portal */
	SliceData		*slice;		/* current slice */
	XCharStruct		overall;
	XFontStruct		*font_struct;
	char			stringbuf [MAXLINE];	/* buffer for label */
	float			slice_scale	= dSliceMagnification;
	int			direction_hint;	
	int			font_ascent;
	int			font_descent;
	int			i;		/* counter */
	int			j;		/* counter */
	int			k;		/* counter */
	int			mask_bottom;		
	int			mask_top;		
	int			rows_index;
	int			temp_bottom;
	int			temp_top;
	short			*atlas_slice;
	short			*abs_mask_slice;
	short			bottom;
	short			*databuf;		/* buffer for interpolated atlas image */
	short			label_xorigin;		
	short			label_yorigin;		
	short			left;
	short			list_size;
	short			*mask_slice;
	short			minimum;
	short			maximum;
	short			right;
	short			top;
	short			xinc;		/* portal x increment in millimeter */
	short			yinc;		/* portal y increment in millimeter */
	short			xinc_mm;	/* portal x increment in millimeter */
	short			yinc_mm;	/* portal y increment in millimeter */
	short			xlabel_mm;
	short			ylabel_mm;
	short			xoffset;	/* portal x offset */
	short			yoffset;	/* portal y offset */
	short			xrow_mm;	/* row x increment in millimeter */
	short			yrow_mm;	/* row y increment in millimeter */
	unsigned int		any_slice_size;
	unsigned int		mask_size;
	unsigned int		slice_size;

	list_size	= llsize (portal_list);
	if (list_size > 0) 
	{
		draw_portal_data.display_atlas_flag	= display_atlas_flag;
		draw_portal_data.display_pet_flag	= display_image_flag;
		draw_portal_data.display_region_flag	= bDisplayRegion;
		draw_portal_data.display_label_flag	= &bDisplayLabel;
		if (list_size == 1)
			draw_portal_data.spacing	= dMaximumDistance;
		else
			draw_portal_data.spacing	= pkg_min (nSpacing, dMaximumDistance);
		draw_portal_data.atlas_trim		= &bAtlasTrim;
		draw_portal_data.all_planes		= &bAllPlanes;
		draw_portal_data.symbol_displayed	= bAF3DSymbolDisplayed;
		for (i = 0; i < MAX_AF3DSET_NUM; i++)
		{
			draw_portal_data.symbol_displayed [i]	= FALSE;
		}

		xoffset			= xstart;
		yoffset			= ystart;
		xinc_mm			= nxOffsetMillimeter;
		yinc_mm			= nyOffsetMillimeter;
		xrow_mm			= nxRowRowMillimeter;
		yrow_mm			= nyRowRowMillimeter;
		xlabel_mm		= nxLabelStart;
		ylabel_mm		= nyLabelStart;
		left			= nxFormatedScreen;
		top			= nyFormatedScreen;
		right			= left + nFormatedScreenWidth;
		bottom			= top + nFormatedScreenHeight;
		low2high		= bLow2High;
		font_struct		= FontStruct;
		slice_num_flag		= bSliceNumberFlag;

		/* 
		 * Move to head of portal list. 
		 */
		if (low2high)
			llhead (portal_list);
		else
			lltail (portal_list);

		if (!current_header->any_scale_flag)
		{
			maskfp	= fopen (current_header->mask_name, "rb");
			if (maskfp == (FILE *) NULL) 
			{
				fprintf (stderr, "UpdatePortals: Can't open %s\n", 
						current_header->mask_name);
				exit (-1);
			}
		}
		mask_size	= sizeof (short) * 2 * current_header->height;

		if (*draw_portal_data.display_atlas_flag || current_header->any_scale_flag)
		{
			atlasfp	= fopen (current_header->image_name, "rb");
			if (atlasfp == (FILE *) NULL) 
			{
				fprintf (stderr, "UpdatePortals: Can't open %s\n", 
						current_header->image_name);
				exit (-1);
			}

			slice_size	= sizeof (short) * current_header->width 
						* current_header->height;
			if (current_header->any_scale_flag)
			{
				any_slice_size	= slice_size;
				slice_size	= sizeof (short) * current_header->any_atlas_width 
						* current_header->any_atlas_height;
			}
		}

		/* 
		 * For each portal. 
		 */
		k	= 0;
		while (k < list_size)
		{
			/* 
			 * Get a portal. 
			 */
			portal		= (Portal *) llretrieve (portal_list);
			slice		= portal->slice;
			xinc		= ROUND (xinc_mm / current_header->pixel_size);
			yinc		= ROUND (yinc_mm / current_header->pixel_size);
			pet_exist	= pet_exist || slice->pet_exist; 

			if (list_size > 1)
				FormatScreen (current_header->pixel_size, xinc, yinc, xrow_mm, 
						yrow_mm, &xoffset, &yoffset, &xstart, 
						&ystart, left, top, right, bottom);

			portal->x	= xoffset - current_header->centerx;
			portal->y	= yoffset - current_header->centery;

			if (slice_num_flag)
			{
				sprintf (stringbuf, "%d", 
					GetSliceNumber (slice->slice_xyz, atlas_orient, image_zorigin)); 
			}
			else
			{
				if (atlas_orient == TRANSVERSE)
					sprintf (stringbuf, "Z = %d", slice->slice_xyz); 
				else if (atlas_orient == CORONAL)
					sprintf (stringbuf, "Y = %d", slice->slice_xyz); 
				else
					sprintf (stringbuf, "X = %d", slice->slice_xyz); 
			}

			XTextExtents (font_struct, stringbuf, strlen (stringbuf), 
				&direction_hint, &font_ascent, &font_descent, &overall);
			label_xorigin		= xoffset + ROUND (xlabel_mm 
							/ current_header->pixel_size);
			label_yorigin		= yoffset + ROUND (ylabel_mm 
							/ current_header->pixel_size);
			slice->xlabel_start	= label_xorigin + overall.lbearing;
			slice->ylabel_start	= label_yorigin - overall.ascent;
			slice->label_width	= overall.rbearing - overall.lbearing;
			slice->label_height	= overall.ascent + overall.descent;

			if (slice->atlas_index >= 0 && (*draw_portal_data.display_atlas_flag
				|| current_header->any_scale_flag))
			{
				atlas_slice = (short *) malloc (slice_size);

				if (fseek (atlasfp, slice->atlas_index 
							* slice_size, SEEK_SET) != 0)
				{
					fprintf (stderr, 
						"UpdatePortals (portal.c): Seeking Error\n");
					exit (-1);
				}

				if (fread (atlas_slice, slice_size, 1, atlasfp) != 1)
				{
					fprintf(stderr,"%d fread error\n");
					perror ("view25d");
					exit(-1);
				}

				if (!current_header->any_scale_flag)
				{
					draw_portal_data.atlas_slice	= atlas_slice;
				}
				else
				{
					databuf = (short *) malloc (any_slice_size);
					interp (atlas_slice, 
						current_header->any_atlas_width, 
						current_header->any_atlas_height, 
						databuf, 
						current_header->width, 
						current_header->height);
					draw_portal_data.atlas_slice	= databuf;
					XtFree (atlas_slice);
				}
			}

			mask_slice	= (short *) malloc (mask_size);
			if (!current_header->any_scale_flag && slice->atlas_index >= 0)
			{
				if (fseek (maskfp, slice->atlas_index 
							* mask_size, SEEK_SET) != 0)
				{
					fprintf (stderr, 
						"UpdatePortals (portal.c): Seeking Error\n");
					exit (-1);
				}

				if (fread (mask_slice, mask_size, 1, maskfp) != 1)
				{
					fprintf (stderr,"%d fread error\n");
					perror ("view25d");
					exit(-1);
				}
			}
			else if (slice->atlas_index >= 0)
			{
				for (j = 0; j < current_header->height; j++) 
				{
					rows_index = j * current_header->width;
					for (i = 0; i < current_header->width && 
						draw_portal_data.atlas_slice [rows_index + i] 
							< ATLAS_THRESHOLD; i++)
						;
					mask_slice [2 * j]	= i;

					for (i = current_header->width - 1; i >= 0 && 
	     					draw_portal_data.atlas_slice [rows_index + i] 
							< ATLAS_THRESHOLD; i--)
						;
					mask_slice [2 * j + 1]	= i;
				}
			}

			/* 
			 * Fix broken outline if there is any.
			 */
			if (current_header->any_scale_flag && slice_scale <= 0.2 && slice->atlas_index >= 0)
			{
				abs_mask_slice	= (short *) malloc (mask_size);

				for (j = 1; j < current_header->height; j++)
				{
					rows_index	= 2 * j;
					abs_mask_slice [rows_index - 2]	= abs (mask_slice [rows_index]
									- mask_slice [rows_index - 2]); 
					abs_mask_slice [rows_index - 1]	= abs (mask_slice [rows_index + 1]
									- mask_slice [rows_index - 1]); 
				}

				for (j = 0; j < current_header->height 
					&& mask_slice [2 * j] > mask_slice [2 * j + 1]; j++);
				mask_top	= j;

				for (j = current_header->height - 1; j >= 0 && 
					mask_slice [2 * j] > mask_slice [2 * j + 1]; j--);
				mask_bottom	= j;

				for (j = mask_top + 1; j < mask_bottom; j++)
				{
					rows_index	= 2 * (j - 1);
					if (abs(mask_slice [rows_index + 2] - mask_slice [rows_index]) 
						>= SMOOTH_LENGTH) 
					{
						mask_slice [rows_index + 2]	
							= pkg_min (mask_slice [rows_index], 
								mask_slice [rows_index + 2]); 
						draw_portal_data.atlas_slice [j * current_header->width 
							+ mask_slice [rows_index + 2]] 	= 1;
					}

					if (abs(mask_slice [rows_index + 3] - mask_slice [rows_index + 1]) 
						>= SMOOTH_LENGTH)
					{
						mask_slice [rows_index + 3]	
							= pkg_max (mask_slice [rows_index + 1], 
								mask_slice [rows_index + 3]); 
						draw_portal_data.atlas_slice [j * current_header->width 
							+ mask_slice [rows_index + 3]] 	= 1;
					}
				}
				free (abs_mask_slice);
			}

			draw_portal_data.mask_slice	= mask_slice;

			draw_portal_data.portal		= portal;
			draw_portal_data.zlabel		= stringbuf;
			draw_portal_data.label_xorigin	= &label_xorigin;
			draw_portal_data.label_yorigin	= &label_yorigin;

			DrawPortal (display, window, gc, current_header, 
				&draw_portal_data, atlas_orient, image1_flag, overlay);

			portal->xold	= portal->x;
			portal->yold	= portal->y;
			if (atlas_orient == FACING_RIGHT)
			{
				portal->xold	+= current_header->centerx 
						+ (current_header->centerx - current_header->width + 1);
			}

			if (slice->atlas_index >= 0)
				XtFree (mask_slice);

			if (slice->atlas_index >= 0 && (*draw_portal_data.display_atlas_flag
				|| current_header->any_scale_flag))
				XtFree (draw_portal_data.atlas_slice);

			xoffset += xinc;
			yoffset += yinc;
			k++;
			if (low2high)
				llnext (portal_list);
			else
				llprevious (portal_list);
		}

		if (!current_header->any_scale_flag)
			fclose (maskfp);

		if (*draw_portal_data.display_atlas_flag)
			fclose (atlasfp);

		if (*draw_portal_data.display_pet_flag && pet_exist && colorbar_onoff)
		{
			DrawColorBar (display, window, gc, colorbar_xstart, colorbar_ystart, 
				colorbar_length, colorbar_width, hori_colorbar, 
				image_value_flag, color_table_name, image1_flag); 

			XSetForeground (display, gc, LABEL_CELL);
			GetImageMinMax (image1_flag, auto_image_value_flag, &minimum, &maximum);
			DrawColorBarText (display, window, gc, &minimum, &maximum, font_struct, 
				hori_colorbar, colorbar_xstart, colorbar_ystart, 
				colorbar_length, colorbar_width, FALSE, auto_image_value_flag, 
				image_value_flag, color_bar_exist, color_bar_min,
				color_bar_middle, color_bar_max);
		}
	}
}


/*________________________________________________________________________	
	Function:	DrawPortal	
	Arguments:	display: pointer to X Display 
			portal: Portal to be drawn on screen
	Description: 	Redraw portal on screen.
	Return Value:	None.

	Author:		Tom Yang
			(05/07/1991)
________________________________________________________________________*/

PRIVATE void DrawPortal (display, window, gc, current_header, draw_portal_data, atlas_orient, 
			image1_flag, overlay)
Display			*display;
Window			window;
GC			gc;
SCALE_HEADER		*current_header;
DRAW_PORTAL_DATA	*draw_portal_data;
char			atlas_orient;
BOOLEAN			image1_flag;
BOOLEAN			overlay;
{ 
	FLOAT_POINT3D	*region_input;
	FLOAT_POINT3D	point;
	GammaZData	*data_set;
	GammaZPoint	*gammaz_point;			/* point to plot */
	Pixel		BackgroundPixel;
	Pixel		ColorPixel;
	RegionListData	*region_set;
	SliceData	*slice;			/* current slice */
	XPoint		*region_draw;	
	double		coordinate;
	int		i;			/* counter */
	int		j;			/* counter */
	int		region_input_num;
	int		rgn_pet_pixelheight;
	int		rgn_pet_pixelwidth;
	int		rows;
	int		tempx;		
	int		tempy;		
	int		sx;
	int		sy;
	int		sz;
	short		x; 
	short		y; 

	/* 
	 * Get header variables. 
	 */
	slice			= draw_portal_data->portal->slice;
	rgn_pet_pixelwidth	= ROUND (slice->rgn_pet_pixelwidth);
	rgn_pet_pixelheight	= ROUND (slice->rgn_pet_pixelheight);
	x			= draw_portal_data->portal->x;
	y			= draw_portal_data->portal->y;

	/*
	 * Draw mask
	 */
	/*
	XSetForeground (display, gc, BACKGROUND_CELL);
	if (slice->atlas_index >= 0 && (!overlay || !image1_flag))
	{
		if (atlas_orient != FACING_RIGHT)
		{
			for (j = 0; j < current_header->height; j++) 
			{
				tempx	= draw_portal_data->mask_slice [2 * j];
				tempy	= draw_portal_data->mask_slice [2 * j + 1];

				if (tempx <= tempy)
					XDrawLine (display, window, gc, 
					x + tempx, y + j, x + tempy, y + j);
			}
		}
		else
		{
			for (j = 0; j < current_header->height; j++) 
			{
				tempx	= draw_portal_data->mask_slice [2 * j];
				tempy	= draw_portal_data->mask_slice [2 * j + 1];

				tempx	= current_header->centerx + (current_header->centerx - tempy);
				tempy	= current_header->centerx + (current_header->centerx - tempx); 

				if (tempx <= tempy)
					XDrawLine (display, window, gc, 
					x + tempx, y + j, x + tempy, y + j);
			}
		}
	}
	*/

	/* 
	 * Put the PET image on the screen. 
	 */
	if (*draw_portal_data->display_pet_flag && slice->pet_exist)
	{
		if (*draw_portal_data->atlas_trim)
		{
			i = 0;
			while (i < slice->pet_point_num)
			{
				sx	= slice->pet_point_coord [i].x;
				sy	= slice->pet_point_coord [i].y;

				if (sy >= 0 && sy < current_header->height)
				{
					tempx	= draw_portal_data->mask_slice [2 * sy];
					tempy	= draw_portal_data->mask_slice [2 * sy + 1];

					if (atlas_orient == FACING_RIGHT)
					{
						tempx	= current_header->centerx 
							+ (current_header->centerx - tempy);
						tempy	= current_header->centerx 
							+ (current_header->centerx - tempx); 
					}

					if (sx >= tempx && sx <= tempy)
					{
						XSetForeground (display, gc, slice->pet_point_pixel [i]);
						XDrawPoint (display, window, gc, x + sx, y + sy);
					}
				}
				i++;
			}
		}
		else
		{
			i = 0;
			BackgroundPixel	= PET_BACK_VALUE + PET_COLOR_START;
			while (i < slice->pet_point_num)
			{
				ColorPixel = slice->pet_point_pixel [i];

				XSetForeground (display, gc, ColorPixel);
				do
				{
					if (ColorPixel != BackgroundPixel)
						XDrawPoint (display, window, gc, 
							x + slice->pet_point_coord [i].x,
							y + slice->pet_point_coord [i].y);
					i++;
				} while (i < slice->pet_point_num &&
				slice->pet_point_pixel [i] == ColorPixel);
			}
		}
	}

	/* 
	 * Draw atlas. 
	 */
	if (*draw_portal_data->display_atlas_flag && slice->atlas_index >= 0 
	&& (!overlay || overlay && image1_flag))
	{
		if (image1_flag)
	    		XSetForeground (display, gc, ATLAS1_CELL);
		else
	    		XSetForeground (display, gc, ATLAS2_CELL);
		if (atlas_orient != FACING_RIGHT)
		{
			for (i = 0; i < current_header->height; i++)
			{
				for (j = 0; j < current_header->width; j++)
				{
					if (draw_portal_data->atlas_slice 
						[i * current_header->width + j] > 0)
					{
						XDrawPoint (display, window, gc, j + x, i + y);
					}
				}
			}
		}
		else
		{
			for (i = 0; i < current_header->height; i++)
			{
				for (j = 0; j < current_header->width; j++)
				{
					if (draw_portal_data->atlas_slice 
						[i * current_header->width + j] > 0)
					{
						XDrawPoint (display, window, gc, 
						x + current_header->centerx 
						+ (current_header->centerx - j), 
						y + i);
					}
				}
			}
		}
	}

	/* 
	 * Draw region. 
	 */
	if (llsize (region_sets) > 0 
	&& (!overlay || overlay && image1_flag))
	{
		llhead (region_sets);
	    	do 
	    	{
			region_set	= (RegionListData *) llretrieve (region_sets);
			region_input	= (FLOAT_POINT3D *) pkg_malloc (region_set->region_pixel_num 
						* sizeof (FLOAT_POINT3D), "DrawPortal", "region_input");
			j	= 0;
			point.z	= region_set->z;
			for (i = 0; i < region_set->region_pixel_num; i++)
			{
				point.x		= region_set->region_input [i].x;
				point.y		= region_set->region_input [i].y;
				coordinate	= GetCoordinate (point, atlas_orient);
				if (coordinate >= slice->slice_xyz - 1 && 
					coordinate < slice->slice_xyz + 1)
				{
					region_input [j].x	= point.x;
					region_input [j].y	= point.y;
					region_input [j].z	= point.z;
					j++;
				}
			}
			region_input_num	= j;

			if (region_input_num > 0)
			{
				region_draw = (XPoint *) pkg_malloc (region_input_num 
						* sizeof (XPoint), "DrawPortal", "region_draw");
				for (i = 0; i < region_input_num; i++)
				{
					/* 
			 		 * Reverse coordination orientation and scale. 
			 		 */
					sx	= ROUND ((region_input [i].x * 1.0) 
							/ current_header->pixel_size);
					sy	= ROUND (region_input [i].y * -1.0 
							/ current_header->pixel_size);
					sz	= ROUND (region_input [i].z * -1.0 
							/ current_header->pixel_size);

					if (atlas_orient == TRANSVERSE)
					{
						tempx	= sx;
						tempy	= sy;
					}
					else if (atlas_orient == CORONAL)
					{
						tempx	= sx;
						tempy	= sz;
					}
					else if (atlas_orient == FACING_LEFT)
					{
						tempx	= sy;
						tempy	= sz;
					}
					else
					{
						tempx	= -sy;
						tempy	= sz;
					}
					region_draw [i].x	= x + tempx + current_header->centerx
								- rgn_pet_pixelwidth / 2;
					region_draw [i].y	= y + tempy + current_header->centery
								- rgn_pet_pixelheight / 2;
				}

				XSetForeground (display, gc, region_set->region_color);

				if (region_set->filling_type == SOLID_RECT_INDEX)
				{
					for (i = 0; i < region_input_num; i++)
					{
						XFillRectangle (display, window, gc, 
							region_draw [i].x - rgn_pet_pixelwidth / 2,
							region_draw [i].y - rgn_pet_pixelheight / 2,
							rgn_pet_pixelwidth, rgn_pet_pixelheight);
					}
				}
				else if (region_set->filling_type < SOLID_RECT_INDEX)
				{
					XSetLineAttributes (display, gc, 5, LineSolid, 
								CapButt, JoinMiter);
					DrawOutlinedRegion (display, window, gc, rgn_pet_pixelwidth, 
							region_input_num, region_draw);
					XSetLineAttributes (display, gc, 1, LineSolid, CapButt, JoinMiter);
				}
				else
				{
					for (i = 0; i < region_input_num; i++)
					{
						XDrawRectangle (display, window, gc, 
							region_draw [i].x - rgn_pet_pixelwidth / 2,
							region_draw [i].y - rgn_pet_pixelheight / 2,
							rgn_pet_pixelwidth, rgn_pet_pixelheight);
					}
				}
				free (region_draw);
			}
			free (region_input);
		} while (llnext (region_sets) != FAIL);
	}

	/* 
	 * Draw AF3D points. 
	 */
	if (!overlay || overlay && image1_flag)
		DisplayAF3DPoints (display, window, gc, szAF3DFileNames, atlas_orient, 
		bDisplaySymbol, cSymbolType, pixelAF3DColor, nSymbolSize, &nOutlineWidth, 
		current_header, draw_portal_data);

	/* 
	 * Compute the z-coord label dimension and put the label on image. 
	 */
	if (*draw_portal_data->display_label_flag)
	{
		XSetForeground (display, gc, LABEL_CELL);
		XDrawString (display, window, gc, *draw_portal_data->label_xorigin, 
			*draw_portal_data->label_yorigin, draw_portal_data->zlabel, 
			strlen (draw_portal_data->zlabel));
	}

}


/*________________________________________________________________________________	
	Function:	ResizePortals	
	Arguments:	display: pointer to X Display 
			portal_list: linked list of Portals on screen
	Description: 	Resize portals.
	Return Value:	None.

	Author:		Tom (Tongzeng) Yang
			05/06/91.
__________________________________________________________________________________*/

PRIVATE void ResizePortals (current_header, portal_list, atlas_list, minimum, maximum, 
		pet_cx, pet_cy, image1_flag, auto_image_value_flag, image_value_flag) 
SCALE_HEADER	*current_header;
llist		portal_list;
llist		atlas_list;
short		*minimum;
short		*maximum;
float		pet_cx;
float		pet_cy;
BOOLEAN		image1_flag;
BOOLEAN		auto_image_value_flag;
char		image_value_flag;
{ 
	Portal		*portal;	/* current portal */
	SliceData	*slice;		/* current slice */
	int		size;		/* size of portal list */

	size	= llsize (atlas_list);
	if (size > 0) 
	{
		llhead (atlas_list);

		do
		{
			/* 
			 * Move to head of portal list. 
			 */
			llhead (portal_list);

			/* 
			 * Get slice and portal. 
			 */
			portal	= (Portal *) llretrieve (portal_list);
			slice	= portal->slice;

			/* 
			 * Free memory that will change for portal->slice. 
			 */
			if (slice->pet_exist)
			{
				XtFree (slice->pet_point_pixel);
				XtFree (slice->pet_point_coord);
			}

			/* 
			 * Resize slices. 
			 */
			slice = (SliceData *) llretrieve (atlas_list);
			portal->slice	= ResizeSlice (current_header, slice, minimum, maximum, 
					pet_cx, pet_cy, image1_flag, auto_image_value_flag,
					image_value_flag);

			/* 
			 * Make new portal. 
			 */
			portal	= MakePortal (portal->slice);
			lldelete (portal_list);
			lladdtail (portal_list, portal);
		} while (llnext (atlas_list) != FAIL); 
	}
}


/*_________________________________________________________________________________	
	Function:
		Swap	
	Arguments:
		int *: first integet pointer
		int *: second integet pointer
	Description:
		Swap two integer pointers.

	Author:
		Tom (Tongzeng) Yang
		(05/14/1991)
________________________________________________________________________________*/

PUBLIC void Swap (pnFirst, pnSecond)
int	*pnFirst;
int	*pnSecond;
{
	int	temp;		/* temp int buffer */

	temp		= *pnFirst;
	*pnFirst	= *pnSecond;
	*pnSecond	= temp;
}


/*________________________________________________________________________________	
	Function:
		SwapShort	
	Arguments:
		short *: first integet pointer
		short *: second integet pointer
	Description:
		Swap two short integer pointers.

	Author:
		Tom (Tongzeng) Yang
		(11/14/1991)
________________________________________________________________________________*/

PUBLIC void SwapShort (pnFirst, pnSecond)
short	*pnFirst;
short	*pnSecond;
{
	short	temp;		/* temp int buffer */

	temp = *pnFirst;
	*pnFirst = *pnSecond;
	*pnSecond = temp;
}


/*____________________________________________________________________________	
	Procedure:	ClearData.	
	Arguments:	portal_list:		portal linked list.
			atlas_list1:		atlas linked list.
	Description:	Clear portal data from memory. Remove all points from 
			screen and data structures.
	Author:		Tom Yang
			(06/05/1991)
____________________________________________________________________________*/

PUBLIC void ClearData (portal_list, atlas_list)
llist		atlas_list;
llist		portal_list;
{
	Portal		*portal;
	SliceData	*slice;

	/* 
	 * Clear portal_list data. 
	 */
	llhead (portal_list);			/* step through portal list */
	while (llsize (portal_list) > 0) 
	{
		portal	= (Portal *) llretrieve (portal_list);
		slice	= portal->slice;

		if (slice->pet_exist)
		{
			XtFree (slice->pet_point_pixel);
			XtFree (slice->pet_point_coord);
		}

		XtFree (slice);
		XtFree (portal);

		lldelete (portal_list);
	} 

	/* 
	 * Clear memory corresponding to points in slice. 
	 */
	llhead (atlas_list);			/* step through the atlas list */
	while (llsize (atlas_list) > 0)
	{
		/* 
		 * Get a slice. 
		 */
		slice = (SliceData *) llretrieve (atlas_list);

		if (slice->pet_exist)
			XtFree (slice->pet_input);

		XtFree (slice);
		lldelete (atlas_list);
	}
}


/*____________________________________________________________________________	
	Procedure:	ClearRegionSets.	
	Arguments:	region_sets:	linked list for region data.
	Description:	Clear region sets linked list from memory. 
	Author:		Tom Yang
			(05/22/1993)
____________________________________________________________________________*/

PRIVATE void ClearRegionSets (region_sets)
llist	region_sets;
{
	RegionListData	*region_set;

	llhead (region_sets);
	while (llsize (region_sets) > 0)		/* step through data sets */
	{
		/* 
		 * Get a region set. 
		 */
		region_set = (RegionListData *) llretrieve (region_sets);

		/* 
		 * Free memory for region_input. 
		 */
		XtFree (region_set->region_input);

		lldelete (region_sets);		/* delete region set from list */
		XtFree (region_set);		/* free memory for region set header */
	} 
}


/*____________________________________________________________________________	
	Procedure:	GetFileStatus.	
			atlas_list:	lineked atlas list for image1.
			first_slice:	first slice id.
			last_slice:	last slice id.
			spacing:	spacing.
			input_node:	input node returned.
			image_zorigin:	zorigin of image.
	Description:	Determine if file is new, updated, or same.
	Author:		Tom (Tongzeng) Yang
			(06/26/1991)
_____________________________________________________________________________*/

PRIVATE void GetFileStatus (atlas_list, first_slice, last_slice, spacing, image_zorigin, input_node)
llist	atlas_list;
short	first_slice;
short	*last_slice;
short	spacing;
int	image_zorigin;
char	*input_node;
{
	int		size;
	SliceData	*slice;
	int		desired_slice;
	char		atlas_orient		= cAtlasOrientation;

	size = llsize (atlas_list);
	if (size > 0) 
	{ 
		if (size == 1 + (*last_slice - first_slice) / spacing)
		{
			llhead (atlas_list);
			slice = llretrieve (atlas_list);			
			for (desired_slice = first_slice; desired_slice <= *last_slice; 
								desired_slice += spacing)
			;
			if (desired_slice > *last_slice)
				desired_slice -= spacing;
			*last_slice = desired_slice;
			if (slice->slice_xyz != GetSliceCoord (*last_slice, atlas_orient, image_zorigin))
			{
				*input_node = INPUT_UPDATE;
			}
			else 
			{
				lltail (atlas_list);
				slice = llretrieve (atlas_list);			
				if (slice->slice_xyz != GetSliceCoord (first_slice, 
				atlas_orient, image_zorigin))
				{
					*input_node = INPUT_UPDATE;
				}
				else
				{
					*input_node = INPUT_SAME;
				}
			}
		}
		else
		{
			*input_node = INPUT_UPDATE;
		}
	}
	else
		*input_node = INPUT_NEW;
}


/*__________________________________________________________________________	
	Function:
		AtlasSliceCmp	
	Arguments:
		s1: atlas slice structure.
		s2: atlas slice structure.
	Description:
		Function for llcmp assignment which compares two atlas slices
		by their z coord. Returns:

			-1: is z of s1 < z of s2
			 0: is z of s1 = z of s2
			 1: is z of s1 > z of s2
__________________________________________________________________________*/

PUBLIC int AtlasSliceCmp (s1, s2)
SliceData	*s1;
SliceData	*s2;
{
	if (s1->slice_xyz < s2->slice_xyz)
		return (-1);
	if (s1->slice_xyz > s2->slice_xyz)
		return (1);
	return (0);
}


/*______________________________________________________________________________________	
	Function:
		FormatScreen	
	Arguments:
		xincrement:	increment in x direction.
		yincrement:	increment in y direction.
		slice:		current slice.
		xoffset:	offset in x direction.
		yoffset:	offset in y direction.
		xstart:		starting point in x direction.
		ystart:		starting point in y direction.
	Description:
		Compute the offsets of the next slice for making a portal.
	Author:		Tom (Tongzeng) Yang
			(06/26/1991)
______________________________________________________________________________________*/

PRIVATE void FormatScreen (pixel_size, xincrement, yincrement, xrow_mm, yrow_mm, 
		xoffset, yoffset, xstart, ystart, left, top, right, bottom)
float		pixel_size;
short		xincrement;
short		yincrement;
short		xrow_mm;
short		yrow_mm;
short		*xoffset;
short		*yoffset;
short		*xstart;
short		*ystart;
short		left;
short		top;
short		right;
short		bottom;
{
	if (*xoffset + xincrement > right || *xoffset + xincrement < left ||
		*yoffset + yincrement > bottom || *yoffset + yincrement < top)
	{
		*xstart += ROUND (xrow_mm / pixel_size);
		*ystart += ROUND (yrow_mm / pixel_size);
		*xoffset = *xstart;
		*yoffset = *ystart;
	}
}


/*_____________________________________________________________________________	
	Function:
		RedrawPortals	
	Arguments:
	Description:
		Redraw slices.
	Author:	Tom (Tongzeng) Yang
		(07/05/1991)
_____________________________________________________________________________*/

PUBLIC void RedrawPortals (draw_data, atlas_list1, portal_list1, atlas_list2, portal_list2) 
DRAW_DATA	*draw_data;
llist		atlas_list1;
llist		portal_list1;
llist		atlas_list2;
llist		portal_list2;
{
	BOOLEAN		*atlas_changed	= &bAtlasChanged;
	BOOLEAN		*mag_changed	= &bMagChanged;
	BOOLEAN		overlay;
	BOOLEAN		*z0_changed	= &bImage1ZoriginChanged;
	Display		*display	= draw_data->display; 	
	GC		gc		= draw_data->gc;
	Portal		*portal;
	SCALE_HEADER	*current_header;
	SliceData	*portal_slice;
	SliceData	*slice;
	Window		window		= draw_data->window;
	char		atlas_orient	= cAtlasOrientation;
	char		input_node	= INPUT_NEW;
	float		*current_mag	= &dSliceMagnification;
	float		pet_cx;
	float		pet_cy;
	int		image2_slice_offset;
	short		first_slice	= nFirstSlice;
	short		last_slice	= nLastSlice;
	short		maximum;
	short		minimum;
	short		spacing		= nSpacing;

	if (bClearSliceArea)
		XClearArea (display, window, 0, 0, DRAW_AREA_WIDTH, DRAW_AREA_HEIGHT, FALSE);

	if (*mag_changed || *atlas_changed || *z0_changed)
	{
		input_node	= INPUT_UPDATE;
		*mag_changed	= FALSE;
		*atlas_changed	= FALSE;
		*z0_changed	= FALSE;
	}
	else
		GetFileStatus (atlas_list1, first_slice, &last_slice, spacing, zorigin_image1, &input_node);

	first_slice	= GetDesiredFirst (first_slice, last_slice, spacing);

	if (input_node != INPUT_SAME)
	{
		if (input_node == INPUT_UPDATE)
		{
			ClearData (portal_list1, atlas_list1);
			ClearData (portal_list2, atlas_list2);
		}
		rCurrentScaleHeader	= BuildQueue (first_slice, last_slice, spacing, 
					atlas_list1, atlas_list2, current_mag);
	}
	current_header	= rCurrentScaleHeader;

	if (bImage1Selected)
	{
		InputImageData (current_header, szImage1FileName, atlas_list1, first_slice, 
			last_slice, spacing, zorigin_image1, bApplyMask1, &nAutoMinImage1Value, 
			&nAutoMaxImage1Value);
	}

	if (bImage2Selected)
	{
		if (atlas_orient == TRANSVERSE)
			image2_slice_offset	= zorigin_image2 - zorigin_image1;
		else
			image2_slice_offset	= 0;
		InputImageData (current_header, szImage2FileName, atlas_list2, 
			first_slice + image2_slice_offset, last_slice + image2_slice_offset, 
			spacing, zorigin_image2, bApplyMask2, &nAutoMinImage2Value, 
			&nAutoMaxImage2Value);
	}

	if (InputRegionData (szRegionFileNames, bDisplayRegion, cRegionType, 
		pixelRegionColor, region_sets) == FAIL)
	{
		fprintf (stderr, "Error: in InputRegionData ()\n");
		return;
	}

	GetPetCenter (atlas_orient, &pet_cx, &pet_cy); 

	if (nxImage1Start == nxImage2Start && nyImage1Start == nyImage2Start)
		overlay	= TRUE;
	else
		overlay	= FALSE;

	/*
	 * Process data for image 2
	 */
	if (bDisplayImage2 && bImage2Selected && strlen (szImage2FileName) > 0)
	{
		GetImageMinMax (FALSE, bAutoImage2ValueFlag, &minimum, &maximum);

		if (input_node != INPUT_SAME || llsize (portal_list2) == 0)
		{
			BuildPortals (current_header, atlas_list2, portal_list2, 
				&minimum, &maximum, pet_cx, pet_cy, FALSE,
				bAutoImage2ValueFlag, cImage2ValueFlag);
		}
		else if (input_node == INPUT_SAME) 
		{
			ResizePortals (current_header, portal_list2, atlas_list2, 
				&minimum, &maximum, pet_cx, pet_cy, FALSE,
				bAutoImage2ValueFlag, cImage2ValueFlag);
		}

		UpdatePortals (display, window, gc, current_header, portal_list2, 
			atlas_orient, &bDisplayAtlas2, &bDisplayImage2, nxImage2Start, 
			nyImage2Start, bAutoImage2ValueFlag, cImage2ValueFlag, nxImage2ColorBarStart,
			nyImage2ColorBarStart, nImage2ColorBarWidth, nImage2ColorBarLength,
			bImage2HorizontalColorBar, bImage2ColorBarOnOff, szImage2ColorTableName,
			&bImage2ColorBarExist, &rectImage2ColorBarMin, &rectImage2ColorBarMiddle,
			&rectImage2ColorBarMax, FALSE, zorigin_image2, overlay);

		nxImage2OldColorBar		= nxImage2ColorBarStart;
		nyImage2OldColorBar		= nyImage2ColorBarStart;
		nImage2OldColorBarLength	= nImage2ColorBarLength;
		nImage2OldColorBarWidth		= nImage2ColorBarWidth;
		bImage2OldHoriColorBar		= bImage2HorizontalColorBar;
	}

	/*
	 * Process data for image 1
	 */
	if (bDisplayImage1 && bImage1Selected && strlen (szImage1FileName) > 0)
	{
		GetImageMinMax (TRUE, bAutoImage1ValueFlag, &minimum, &maximum);

		if (input_node != INPUT_SAME || llsize (portal_list1) == 0)
			BuildPortals (current_header, atlas_list1, portal_list1, 
				&minimum, &maximum, pet_cx, pet_cy, TRUE,
				bAutoImage1ValueFlag, cImage1ValueFlag);
		else if (input_node == INPUT_SAME) 
			ResizePortals (current_header, portal_list1, atlas_list1, 
				&minimum, &maximum, pet_cx, pet_cy, TRUE,
				bAutoImage1ValueFlag, cImage1ValueFlag);

		UpdatePortals (display, window, gc, current_header, portal_list1, 
			atlas_orient, &bDisplayAtlas1, &bDisplayImage1, nxImage1Start, 
			nyImage1Start, bAutoImage1ValueFlag, cImage1ValueFlag, nxImage1ColorBarStart,
			nyImage1ColorBarStart, nImage1ColorBarWidth, nImage1ColorBarLength,
			bImage1HorizontalColorBar, bImage1ColorBarOnOff, szImage1ColorTableName,
			&bImage1ColorBarExist, &rectImage1ColorBarMin, &rectImage1ColorBarMiddle,
			&rectImage1ColorBarMax, TRUE, zorigin_image1, overlay);

		nxImage1OldColorBar		= nxImage1ColorBarStart;
		nyImage1OldColorBar		= nyImage1ColorBarStart;
		nImage1OldColorBarLength	= nImage1ColorBarLength;
		nImage1OldColorBarWidth		= nImage1ColorBarWidth;
		bImage1OldHoriColorBar		= bImage1HorizontalColorBar;
	}
}


/*______________________________________________________________________________________	
	Function:
		BuildPortals	
	Arguments:
	Description:
		Build portal slices.
	Author:	Tom (Tongzeng) Yang
		(07/05/1991)
______________________________________________________________________________________*/

PRIVATE void BuildPortals (current_header, atlas_list, portal_list, minimum, maximum, 
		pet_cx, pet_cy, image1_flag, auto_image_value_flag, image_value_flag) 
SCALE_HEADER	*current_header;
llist		atlas_list;
llist		portal_list;
short		*minimum;
short		*maximum;
float		pet_cx;
float		pet_cy;
BOOLEAN		image1_flag;
BOOLEAN		auto_image_value_flag;
char		image_value_flag;
{
	SliceData	*slice;
	SliceData	*portal_slice;
	Portal		*portal;

	if (llsize (atlas_list) > 0)
	{
		llhead (atlas_list);

		do
		{
			slice		= (SliceData *) llretrieve (atlas_list);
			portal_slice	= ResizeSlice (current_header, slice, minimum, maximum, 
					pet_cx, pet_cy, image1_flag, auto_image_value_flag, 
					image_value_flag);
			portal		= MakePortal (portal_slice);
			lladd (portal_list, portal);
		} while (llnext (atlas_list) != FAIL);
	}
}


/*______________________________________________________________________________________	
	Function:
		DrawColorBar	
	Arguments:
	Description:
		Draw a color bar on screen.
	Author:	Tom (Tongzeng) Yang
		(07/08/1991)
______________________________________________________________________________________*/

PUBLIC void DrawColorBar (display, window, gc, x, y, length, width, 
		horizontal_flag, pet_value_flag, color_table_name, image1_flag) 
Display		*display;
Window		window;
GC		gc;
short		x;
short		y;
short		length;
short		width;
BOOLEAN		horizontal_flag;
char		pet_value_flag;
char		*color_table_name;
BOOLEAN		image1_flag;
{
	BOOLEAN		direction_flag;
	BOOLEAN		show_border;
	Pixel		color_pixel;
	char		*extension;
	char		*short_color_table_name;
	int		border_height;
	int		border_width;
	int		screen;
	short		h;
	char		i;
	short		increment;
	short		w;
	short		xstart;
	short		ystart;
	unsigned long	border_foreground;

	extension	= strrchr (color_table_name, '/');
	if (extension != NULL && strncmp (extension, "/", 1) == 0)
		short_color_table_name	= extension + 1;
	else
		short_color_table_name	= color_table_name;

	if (strncmp (short_color_table_name, "Black_on_White.tbl", 18) == 0
	|| strncmp (short_color_table_name, "White_on_Black.tbl", 18) == 0
	|| strncmp (short_color_table_name, "PosNeg_on_White.tbl", 19) == 0
	|| strncmp (short_color_table_name, "Color43.tbl", 11) == 0)
	{
		show_border	= TRUE;
	}
	else
		show_border	= FALSE;

	increment	= length / NCOLORS;

	if (horizontal_flag)
	{
		w		= increment;
		h		= width;
		border_width	= length;
		border_height	= width;
	}
	else
	{
		w		= width;
		h		= increment;
		border_width	= width;
		border_height	= length;
	}

	if (!show_border)
	{
		XSetForeground (display, gc, BACKGROUND_CELL);
		XDrawRectangle (display, window, gc, x, y, border_width, border_height);
	}

	xstart		= x;
	ystart		= y;
	direction_flag	= ((pet_value_flag != PETVALUE_NEGATIVE && horizontal_flag)  
		|| (pet_value_flag == PETVALUE_NEGATIVE && !horizontal_flag));  
	if (image1_flag)
		color_pixel	= (direction_flag)? PET_COLOR_START: 
				PET_COLOR_START + NCOLORS - 1;
	else
		color_pixel	= (direction_flag)? PET_COLOR_START - 20: 
				PET_COLOR_START - 1;

	for (i = 0; i < NCOLORS; i++)
	{
		XSetForeground (display, gc, color_pixel);
		XFillRectangle (display, window, gc, xstart, ystart, w, h); 

		if (horizontal_flag)
			xstart	+= increment;
		else
			ystart	+= increment;

		if (direction_flag)
			color_pixel++;
		else
			color_pixel--;
	}

	if (show_border)
	{
		screen			= DefaultScreen (display);
		border_foreground	= BlackPixel (display, screen);
		XSetForeground (display, gc, border_foreground);
		XDrawRectangle (display, window, gc, x, y, border_width, border_height);
	}
}


/*______________________________________________________________________________________	
	Function:
		GetDesiredFirst
	Arguments:
	Description:
		Get the desired first slice number in a list configuration. 
	Author:	Tom (Tongzeng) Yang
		(07/11/1991)
______________________________________________________________________________________*/

PRIVATE short GetDesiredFirst (first_slice, last_slice, spacing)
short	first_slice;
short	last_slice;
short	spacing;
{
	short	desired_slice;

	if (spacing < 0)
	{
		for (desired_slice = last_slice; desired_slice > first_slice;
						desired_slice += spacing)
		;
		if (desired_slice < first_slice)
			desired_slice	+= -spacing;
	}
	else
	{
		desired_slice	= first_slice;
	}

	return desired_slice;
}


/*______________________________________________________________________________________	
	Function:
		DrawColorBarText	
	Arguments:
	Description:
		Draw or Clear Color Bar Text.
	Author:	Tom (Tongzeng) Yang
		(07/15/1991)
______________________________________________________________________________________*/

PUBLIC void DrawColorBarText (display, window, gc, min_image_value, max_image_value, 
	font_struct, hori_colorbar, colorbar_xstart, colorbar_ystart, colorbar_length, 
	colorbar_width, clear_flag, auto_image_value_flag, image_value_flag,
	color_bar_exist, color_bar_min, color_bar_middle, color_bar_max)
Display		*display;
Window		window;
GC		gc;
short		*min_image_value;
short		*max_image_value;
XFontStruct	*font_struct;
BOOLEAN		hori_colorbar;
short		colorbar_xstart;
short		colorbar_ystart;
short		colorbar_length;
short		colorbar_width;
BOOLEAN		clear_flag;
BOOLEAN		auto_image_value_flag;		
BOOLEAN		image_value_flag;		
BOOLEAN		*color_bar_exist;
XRectangle	*color_bar_min;
XRectangle	*color_bar_middle;
XRectangle	*color_bar_max;
{
	XCharStruct	overall;
	char		stringbuf [MAXLINE];	/* buffer for label */
	int		direction_hint;	
	int		font_ascent;
	int		font_descent;
	short		xstart;
	short		ystart;
	short		width;
	short		height;

	RegularMinMax (auto_image_value_flag, image_value_flag, min_image_value, max_image_value);

	sprintf (stringbuf, "%d", *min_image_value);
	XTextExtents (font_struct, stringbuf, strlen (stringbuf), &direction_hint,
			&font_ascent, &font_descent, &overall);

	xstart	= colorbar_xstart;
	ystart	= colorbar_ystart;
	width	= overall.rbearing - overall.lbearing;  
	height	= overall.ascent + overall.descent;

	if (hori_colorbar)
	{
		ystart	+= colorbar_width;
	}
	else
	{
		xstart	+= colorbar_width;
		ystart	+= colorbar_length - overall.ascent;
	}

	if (clear_flag && *color_bar_exist)
	{
		XClearArea (display, window, color_bar_min->x, color_bar_min->y, 
				color_bar_min->width, color_bar_min->height, FALSE);
	}
	else
	{
		XDrawString (display, window, gc, xstart - overall.lbearing, 
				ystart + overall.ascent, stringbuf, strlen (stringbuf));
	}
	color_bar_min->x	= xstart;
	color_bar_min->y	= ystart;
	color_bar_min->width	= width;
	color_bar_min->height	= height;

	sprintf (stringbuf, "%d", (*min_image_value + *max_image_value) / 2);
	XTextExtents (font_struct, stringbuf, strlen (stringbuf), &direction_hint,
			&font_ascent, &font_descent, &overall);
	width	= overall.rbearing - overall.lbearing;  
	height	= overall.ascent + overall.descent;
	if (hori_colorbar)
	{
		xstart	= colorbar_xstart + colorbar_length / 2 - width / 2;
		if (!clear_flag)
			xstart	-= overall.lbearing;
	}
	else
	{
		ystart	= colorbar_ystart + colorbar_length / 2 - height / 2;
	}

	if (clear_flag && *color_bar_exist)
	{
		XClearArea (display, window, color_bar_middle->x, color_bar_middle->y, 
				color_bar_middle->width, color_bar_middle->height, FALSE);
	}
	else
	{
		XDrawString (display, window, gc, xstart - overall.lbearing, 
			ystart + overall.ascent, stringbuf, strlen (stringbuf));
	}
	color_bar_middle->x		= xstart;
	color_bar_middle->y		= ystart;
	color_bar_middle->width		= width;
	color_bar_middle->height	= height;

	sprintf (stringbuf, "%d", *max_image_value);
	XTextExtents (font_struct, stringbuf, strlen (stringbuf), &direction_hint,
			&font_ascent, &font_descent, &overall);
	width	= overall.rbearing - overall.lbearing;  
	height	= overall.ascent + overall.descent;
	if (hori_colorbar)
	{
		xstart	= colorbar_xstart + colorbar_length - width;
		if (!clear_flag)
			xstart	-= overall.lbearing;
	}
	else
	{
		ystart	= colorbar_ystart;
	}

	if (clear_flag)
	{
		XClearArea (display, window, color_bar_max->x, color_bar_max->y, 
				color_bar_max->width, color_bar_max->height, FALSE);
	}
	else
	{
		XDrawString (display, window, gc, xstart - overall.lbearing, 
			ystart + overall.ascent, stringbuf, strlen (stringbuf));
	}
	color_bar_max->x	= xstart;
	color_bar_max->y	= ystart;
	color_bar_max->width	= width;
	color_bar_max->height	= height;

	if (!(*color_bar_exist))
		*color_bar_exist	= TRUE;
}


/*____________________________________________________________________	
	Function::
		DrawOutlinedRegion	
	Parameters:
		display:	X Display pointer.
		window:		X window to draw into.
		gc:		graphics context.
		pixel_width:	pixel width.
		num_pixels:	number of pixels to be drawn for region.
		pixel_points:	pixel coordinates.
	Description:
		Draw outlined region.
	Author:	Tom (Tongzeng) Yang
		(08/29/1991)
____________________________________________________________________*/

PRIVATE void DrawOutlinedRegion (display, window, gc, pixel_width, num_pixels, pixel_points)
Display		*display;
Window		window;
GC		gc;
unsigned short	pixel_width;
int		num_pixels;
XPoint		*pixel_points;
{
	static char	*function = "DrawOutlinedRegion";
	int		i;
	int		j;
	short		xmin	= MAXSHORT;
	short		xmax	= -MAXSHORT;
	short		ymin	= MAXSHORT;
	short		ymax	= -MAXSHORT;
	char		*character_matrix;
	unsigned short	width;
	unsigned short	height;

	for (i = 0; i < num_pixels; i++)
	{
		xmin	= pkg_min (xmin, pixel_points [i].x);
		xmax	= pkg_max (xmax, pixel_points [i].x);
		ymin	= pkg_min (ymin, pixel_points [i].y);
		ymax	= pkg_max (ymax, pixel_points [i].y);
	}

	width			= xmax - xmin + 1;
	height			= ymax - ymin + 1;
	character_matrix	= (char *) pkg_malloc (width * height, function, "character_matrix");

	for (j = 0; j < height; j++)
	{
		for (i = 0; i < width; i++)
		{
			character_matrix [ j * width + i] = FALSE;
		}
	}

	for (i = 0; i < num_pixels; i++)
	{
		j	= (pixel_points[i].y - ymin) * width + (pixel_points [i].x - xmin);
		character_matrix [j]	= TRUE;
	}

	for (j = 0; j < height; j++)
	{
		for (i = 0; i < width; i++)
		{
			if (character_matrix [j * width + i])
			{
				if (i == 0 || !character_matrix [j * width + (i - pixel_width)])
					XDrawLine (display, window, gc, 
							xmin + i - pixel_width / 2,
							ymin + j - pixel_width / 2, 
							xmin + i - pixel_width / 2,
							ymin + j + pixel_width / 2);
				if (i == width - 1 || !character_matrix [j * width + (i + pixel_width)])
					XDrawLine (display, window, gc, 
							xmin + i + pixel_width / 2,
							ymin + j - pixel_width / 2, 
							xmin + i + pixel_width / 2,
							ymin + j + pixel_width / 2);
				if (j == 0 || !character_matrix [(j - pixel_width) * width + i])
					XDrawLine (display, window, gc, 
							xmin + i - pixel_width / 2,
							ymin + j - pixel_width / 2, 
							xmin + i + pixel_width / 2,
							ymin + j - pixel_width / 2);
				if (j == height - 1 || !character_matrix [(j + pixel_width) * width + i])
					XDrawLine (display, window, gc, 
							xmin + i - pixel_width / 2,
							ymin + j - pixel_width / 2, 
							xmin + i + pixel_width / 2,
							ymin + j - pixel_width / 2);
			}
		}
	}

	XtFree (character_matrix);
}

PUBLIC void DrawRectangle (display, window, gc, x, y, x2, y2)
	Display	*display;
	Window	window;
	GC	gc;
	int	x, y, x2, y2;
{
	CheckPoints (&x, &y, &x2, &y2);
	XDrawRectangle (display, window, gc,  x, y, x2 - x, y2 - y);
}

PUBLIC void CheckPoints (x, y, x2, y2)
	int	*x, *y, *x2, *y2;
{
	if (*x2 < *x)
		Swap (x2, x);
	if (*y2 < *y)
		Swap (y2, y);
}

PUBLIC void GetLegendDim (display, files, nfiles, legend_font, 
	legend_width, legend_height, font_height)
	Display	*display;
	char	files [][MAXLINE];
	int	nfiles;
	char	*legend_font;
	short	*legend_width;
	short	*legend_height;
	short	*font_height;
{
	BOOLEAN		*symbol_displayed	= bAF3DSymbolDisplayed;
	XFontStruct	*font_struct;
	char		*extension;
	char		*short_name;
	int		actual_list_size;
	int		i;
	short		height;
	short		string_width;
	short		width;

	font_struct	= XLoadQueryFont (display, legend_font);
	if (font_struct == 0)
	{
		fprintf (stderr, "Can Not Find Font %s\n", legend_font);
		return;
	}

	*font_height	= font_struct->ascent + font_struct->descent;

	width			= 0;
	actual_list_size	= 0;
	for (i = 0; i < nfiles; i++)
	{
		if (strlen (files [i]) > 0 && symbol_displayed [i])
		{
			actual_list_size++;
			extension	= strrchr (files [i], '/');
			if (extension != NULL && strncmp (extension, "/", 1) == 0)
				short_name	= extension + 1;
			else
				short_name	= files [i];
			string_width	= XTextWidth (font_struct, short_name, strlen (short_name));
			if (string_width > width)
				width	= string_width;
		}
	}

	XFreeFont (display, font_struct);

	*legend_width	= width + *font_height * 2 + *font_height / 2;
	*legend_height	= *font_height * (actual_list_size - 1) * 1.2 + *font_height; 
}

PUBLIC void DrawLegend (display, window, gc, xstart, ystart, files, nfiles, legend_font, 
	text_color, symbol_color, symbol_type)
	Display	*display;
	Window	window;
	GC	gc;
	int	xstart;
	int	ystart;
	char	files [][MAXLINE];
	int	nfiles;
	char	*legend_font;
	Pixel	text_color;
	Pixel	*symbol_color;
	char	*symbol_type;	
{
	BOOLEAN		*symbol_displayed	= bAF3DSymbolDisplayed;
	XFontStruct	*font_struct;
	char		*extension;
	char		*short_name;
	int		i;
	int		x;
	int		y;
	short		font_height;

	font_struct	= XLoadQueryFont (display, legend_font);
	if (font_struct == 0)
	{
		fprintf (stderr, "Can Not Find Font %s\n", legend_font);
		return;
	}
	XSetFont (display, gc, font_struct->fid);

	font_height	= font_struct->ascent + font_struct->descent;
	x		= xstart + font_height * 2;
	y		= ystart + font_height / 4;

	for (i = 0; i < nfiles; i++)
	{
		if (strlen (files [i]) > 0 && symbol_displayed [i])
		{
			XSetForeground (display, gc, *(symbol_color + i));
			DrawSymbol (display, window, gc, xstart - font_height / 2, 
			y - 3 * font_height / 4, font_height, font_height, *(symbol_type + i));

			extension	= strrchr (files [i], '/');
			if (extension != NULL && strncmp (extension, "/", 1) == 0)
				short_name	= extension + 1;
			else
				short_name	= files [i];
			XSetForeground (display, gc, text_color);
			XDrawString (display, window, gc, x, y, short_name, strlen (short_name));
			y	+= 1.2 * font_height;
		}
	}

	XFreeFont (display, font_struct);
}

PUBLIC void GetLabelDim (font_struct, text_string, line_spacing, text_orient, label_width, label_height)
	XFontStruct	*font_struct;
	char		*text_string;
	int		line_spacing;
	char		text_orient;
	short		*label_width;
	short		*label_height;
{
	XCharStruct	overall;
	char		*pure_string;
	char		*string_buffer;
	int		direction_hint;	
	int		font_ascent;
	int		font_descent;
	int		font_height;
	int		font_width;
	int		i, j, k, m;
	int		string_width;
	int		tabspaces;
	int		tabspaces_per_line;
	int		text_length;
	short		num_lines;
	short		width;
	short		height;
	static char	*function	= "GetLabelDim";

	text_length	= strlen (text_string);
	font_struct	= FontStruct;
	font_height	= font_struct->ascent + font_struct->descent;

	string_buffer	= (char *) pkg_malloc (text_length, function, "string_buffer");
	pure_string	= (char *) pkg_malloc (text_length, function, "pure_string");

	strncpy (string_buffer, "\0", text_length);
	strncpy (pure_string, "\0", text_length);

	XTextExtents (font_struct, "x", 1, &direction_hint, &font_ascent, &font_descent, &overall);
	font_width	= overall.rbearing - overall.lbearing;

	i		= 0;
	width		= 0;
	height		= 0;
	num_lines	= 0;

	while (i < text_length)
	{
		j			= 0;
		k			= 0;
		m			= 0;
		tabspaces_per_line	= 0;
		while (i < text_length && text_string [i] != '\n')
		{
			if (text_string [i] != '\t')
			{
				pure_string [k++]	= text_string [i];
				m++;
			}
			else
			{
				tabspaces_per_line	+= (m / 8 + 1) * 8 - m;
				m	+= tabspaces_per_line;
			}
			string_buffer [j++]	= text_string [i];

			i++;
		} 

		string_buffer [j++]	= text_string [i];
		pure_string [j++]	= text_string [i];
		i++;

		switch (text_orient) 
		{
			case ORIENT_HORI: 	
				if (strlen (string_buffer) > 0)
				{
					string_width	= XTextWidth (font_struct, pure_string, 
								strlen (pure_string)) 
								+ tabspaces_per_line * font_width;
					if (string_width > width)
						width	= string_width;
				}

				num_lines++;
				break;
			case ORIENT_VERT:
				string_width	= font_height * strlen (string_buffer);
				if (height > string_width)
					height	= string_width;

				num_lines++;
				break;
		}

		strncpy (string_buffer, "\0", text_length);
		strncpy (pure_string, "\0", text_length);
	}
	XtFree (string_buffer);
	XtFree (pure_string);

	if (text_orient == ORIENT_HORI)
	{
		*label_width	= width;
		*label_height	= ((num_lines - 1) * font_height * line_spacing) 
				/ LINE_SPACING_FACTOR + font_height;
	}
	else if (text_orient == ORIENT_VERT)
	{
		*label_width	= ((num_lines - 1) * font_width * line_spacing) 
				/ LINE_SPACING_FACTOR + font_width;
		*label_height	= height;
	}
}

PUBLIC void DrawLabel (display, window, gc, x, y, x2, y2, color_pixel, font_struct, 
			text_string, alignment_flag, line_spacing, text_orient)
	Display		*display;
	Window		window;
	GC		gc;
	int		x, y, x2, y2;
	Pixel		color_pixel;
	XFontStruct	*font_struct;
	char		*text_string;
	char		alignment_flag;
	int		line_spacing;
	char		text_orient;
{
	char		*pure_string;
	char		*string_buffer;
	int		font_height;
	int		font_width;
	int		i, j, k, m;
	int		tabspaces;
	int		tabspaces_per_line;
	int		string_width;
	int		text_length;
	int		xinitial;
	int		yinitial;
	int		xstart;
	int		ystart;
	int		direction_hint;	
	int		font_ascent;
	int		font_descent;
	XCharStruct	overall;
	static char	*function	= "DrawLabel";

	text_length	= strlen (text_string);
	font_struct	= FontStruct;
	font_height	= font_struct->ascent + font_struct->descent;

	string_buffer	= (char *) pkg_malloc (text_length, function, "string_buffer");
	pure_string	= (char *) pkg_malloc (text_length, function, "pure_string");

	strncpy (string_buffer, "\0", text_length);
	strncpy (pure_string, "\0", text_length);
	XSetFont (display, gc, font_struct->fid);
	XSetForeground (display, gc, color_pixel);

	XTextExtents (font_struct, "x", 1, &direction_hint, &font_ascent, &font_descent, &overall);
	font_width	= overall.rbearing - overall.lbearing;

	i	= 0;
	xstart	= x;
	ystart	= y;
	while (i < text_length)
	{
		j			= 0;
		k			= 0;
		m			= 0;
		tabspaces_per_line	= 0;
		while (i < text_length && text_string [i] != '\n')
		{
			if (text_string [i] != '\t')
			{
				pure_string [k++]	= text_string [i];
				m++;
			}
			else
			{
				tabspaces_per_line	+= (m / 8 + 1) * 8 - m;
				m	+= tabspaces_per_line;
			}
			string_buffer [j++]	= text_string [i];

			i++;
		} 

		string_buffer [j++]	= text_string [i];
		pure_string [j++]	= text_string [i];
		i++;

		switch (text_orient) 
		{
			case ORIENT_HORI: 	
				if (strlen (string_buffer) > 0)
				{
					string_width	= XTextWidth (font_struct, pure_string, 
								strlen (pure_string)) 
								+ tabspaces_per_line * font_width;

					xstart	= x;

					/*
					 * Only xstart is changed.
					 */
					GetTextStart (text_orient, alignment_flag, string_width, 
					font_height, &xstart, &ystart);

					xinitial	= xstart;

					strncpy (pure_string, "\0", text_length);
					j	= 0;
					k	= 0;
					m	= 0;
					while (j <= strlen (string_buffer))
					{
						if (j < strlen (string_buffer) && string_buffer [j] != '\t')
						{
							pure_string [k++]	= string_buffer [j];
							m++;
						}
						else
						{
							XDrawString (display, window, gc, xstart, ystart, 
								pure_string, k);

							m	= (m / 8 + 1) * 8;
							xstart	= xinitial + m * font_width;
							strncpy (pure_string, "\0", text_length);
							k	= 0;
						}

						j++;
					}
				}

				ystart	+= (font_height * line_spacing) / LINE_SPACING_FACTOR;
				break;
			case ORIENT_VERT:
				ystart	= y;
				string_width	= font_height * strlen (string_buffer);

				/*
				 * Only ystart is changed.
				 */
				GetTextStart (text_orient, alignment_flag, font_width, 
				string_width, &xstart, &ystart);

				for (k = 0; k < strlen (string_buffer); k++) 
				{
					XDrawString (display, window, gc, 
						xstart, ystart + (font_height * k), 
						string_buffer + k, 1);
				}

				xstart	+= (font_width * line_spacing) / LINE_SPACING_FACTOR;
				break;
		}

		strncpy (string_buffer, "\0", text_length);
		strncpy (pure_string, "\0", text_length);
	}

	XtFree (string_buffer);
	XtFree (pure_string);
}

PUBLIC void GetImageMinMax (image1_flag, auto_flag, minimum, maximum)
	BOOLEAN		image1_flag;
	BOOLEAN		auto_flag;
	short		*minimum;
	short		*maximum;
{
	if (image1_flag)
	{
		if (auto_flag)
		{
			*minimum	= nAutoMinImage1Value;
			*maximum	= nAutoMaxImage1Value;
		}
		else
		{
			*minimum	= nMinImage1Value;
			*maximum	= nMaxImage1Value;
		}
	}
	else
	{
		if (auto_flag)
		{
			*minimum	= nAutoMinImage2Value;
			*maximum	= nAutoMaxImage2Value;
		}
		else
		{
			*minimum	= nMinImage2Value;
			*maximum	= nMaxImage2Value;
		}
	}
}

PUBLIC void ErrorCheckMinMax (image_value_flag, minimum, maximum)
	BOOLEAN		image_value_flag;
	short		*minimum;
	short		*maximum;
{
	if (*minimum > *maximum)
		SwapShort (minimum, maximum);
	else if (*minimum == *maximum)
		(*maximum)++;

	if ((image_value_flag == PETVALUE_POSITIVE && *maximum <= 0)
	|| (image_value_flag == PETVALUE_NEGATIVE && *minimum >= 0))
	{
		*maximum	*= -1;
		*minimum	*= -1;
		SwapShort (minimum, maximum);
	}
}

PUBLIC void RegularMinMax (auto_image_value_flag, image_value_flag, minimum, maximum)
	BOOLEAN		auto_image_value_flag;
	BOOLEAN		image_value_flag;
	short		*minimum;
	short		*maximum;
{
	if (image_value_flag == PETVALUE_POSITIVE && (auto_image_value_flag || *minimum < 0))
	{
		*minimum	= 0;
	}
	else if (image_value_flag == PETVALUE_NEGATIVE && (auto_image_value_flag || *maximum > 0))
	{
		*maximum	= 0;
	}
	else if (image_value_flag == PETVALUE_DUAL)
	{
		*minimum	= - pkg_max (abs (*minimum), abs (*maximum));
		*maximum	= - *minimum;
	}
}


/*___________________________________________________________________________________	
	Function:
		GetActiveWidget	
	Arguments:
	Description:
		Get the current select widget from a group of widgets.

	Author:
		Tom (Tongzeng) Yang
		(12/05/1991)
_____________________________________________________________________________________*/

PUBLIC Widget GetActiveWidget (widget_set, num_widget)
	Widget	*widget_set;
	int	num_widget;
{
	int	index;

	index	= GetActiveIndex (widget_set, num_widget);
	return *(widget_set + index);
}


/*____________________________________________________________________________________	
	Function:
		GetActiveIndex	
	Arguments:
	Description:
		Get the index of the current selected widget from a group of widgets.

	Author:
		Tom (Tongzeng) Yang
		(12/09/1991)
_____________________________________________________________________________________*/

PUBLIC int GetActiveIndex (widget_set, num_widget)
	Widget	*widget_set;
	int	num_widget;
{
	int	i;
	int	index;

	for (i = 0; i < num_widget; i++)
	{
		if (XmToggleButtonGetState (widget_set[i]))
		{
			index	= i;
			break;
		}
	}

	return	index;
}


/*________________________________________________________________________________________________	
	Function:
		GetNameFromWidget	
	Arguments:
	Description:
		Get the color name form the current selected widget.

	Author:
		Tom (Tongzeng) Yang
		(12/05/1991)
_______________________________________________________________________________________________*/

PUBLIC void GetNameFromWidget (widget_set, num_widget, mode, name)
	Widget	*widget_set;
	int	num_widget;
	char	mode;
	char	*name;
{
	int	index;

	index	= GetActiveIndex (widget_set, num_widget);
	switch (mode)
	{
		case TOGGLE_COLOR: 
			strcpy (name, nonImageColorList [index]);
			break;
		case TOGGLE_ALIGN: 
			strcpy (name, alignmentList [index]);
			break;
		case TOGGLE_SLANT: 
			strcpy (name, slantList [index]);
			break;
		case TOGGLE_WEIGHT: 
			strcpy (name, weightList [index]);
			break;
		case TOGGLE_ORIENT: 
			strcpy (name, orientList [index]);
			break;
		case TOGGLE_SCALE: 
			strcpy (name, scaleList [index]);
			break;
		case TOGGLE_ATLAS_ORIENT: 
			strcpy (name, atlasOrientList [index]);
			break;
	}
}


/*________________________________________________________________________________________________	
	Function:
		GetIndexFromName	
	Arguments:
	Description:
		Get the index from the name of a widget.

	Author:
		Tom (Tongzeng) Yang
		(12/09/1991)
_______________________________________________________________________________________________*/

PUBLIC int GetIndexFromName (name, mode)
	char	*name;
	char	mode;
{
	char	lower_name [MAXLINE];
	int	index;
	float	mag_value;
	char	**symbol_names	= symbolNames;

	strcpy (lower_name, name);
	Lowered (lower_name, strlen (lower_name));

	switch (mode)
	{
		case TOGGLE_COLOR:
			if (strncmp (lower_name, "black", 5) == 0)
				index	= BLACK;
			else if (strncmp (lower_name, "blue", 4) == 0)
				index	= BLUE;
			else if (strncmp (lower_name, "cyan", 4) == 0)
				index	= CYAN;
			else if (strncmp (lower_name, "green", 5) == 0)
				index	= GREEN;
			else if (strncmp (lower_name, "yellow", 6) == 0)
				index	= YELLOW;
			else if (strncmp (lower_name, "magenta", 7) == 0)
				index	= MAGENTA;
			else if (strncmp (lower_name, "red", 3) == 0)
				index	= RED;
			else if (strncmp (lower_name, "white", 5) == 0)
				index	= WHITE;
			else
				index	= GRAY;
			break;
		case TOGGLE_ALIGN:
			if (strncmp (lower_name, "left", 4) == 0)
				index	= ALIGNMENT_LEFT;
			else if (strncmp (lower_name, "center", 5) == 0)
				index	= ALIGNMENT_CENTER;
			else 
				index	= ALIGNMENT_RIGHT;
			break;
		case TOGGLE_SLANT:
			if (strncmp (lower_name, "roman", 5) == 0)
				index	= SLANT_ROMAN;
			else if (strncmp (lower_name, "italic", 6) == 0)
				index	= SLANT_ITALIC;
			else 
				index	= SLANT_OBLIQUE;
			break;
		case TOGGLE_WEIGHT:
			if (strncmp (lower_name, "medium", 6) == 0)
				index	= WEIGHT_MEDIUM;
			else 
				index	= WEIGHT_BOLD;
			break;
		case TOGGLE_ORIENT:
			if (strncmp (lower_name, "horizontal", 10) == 0)
				index	= ORIENT_HORI;
			else 
				index	= ORIENT_VERT;
			break;
		case TOGGLE_MAG:
			mag_value	= atof (name);
			for (index = 0; index < MAG_NUM - 1; index++)
			{
				if (mag_value == magnify_table [index])
					break;
			}
			break;
		case TOGGLE_SCALE:
			if (strncmp (lower_name, "positive", 8) == 0)
				index	= PETVALUE_POSITIVE;
			else if (strncmp (lower_name, "negative", 8) == 0)
				index	= PETVALUE_NEGATIVE;
			else 
				index	= PETVALUE_DUAL;
			break;
		case TOGGLE_ATLAS_ORIENT:
			if (strncmp (lower_name, "transverse", 10) == 0)
				index	= TRANSVERSE;
			else if (strncmp (lower_name, "coronal", 7) == 0)
				index	= CORONAL;
			else if (strncmp (lower_name, "facingleft", 10) == 0)
				index	= FACING_LEFT;
			else
				index	= FACING_RIGHT;
			break;
		case TOGGLE_SYMBOL_SHAPE:
			for (index = 0; index < NUM_SYMBOL_NAMES; index++)
			{
				if (strcmp (lower_name, symbol_names [index]) == 0)
					break;
			}
			break;
	}

	free (lower_name);

	return	index;
}


/*______________________________________________________________________________________	
	Function:
		GetWidgetFormName	
	Arguments:
	Description:
		Get the current select widget from a group of widgets.

	Author:
		Tom (Tongzeng) Yang
		(12/05/1991)
_____________________________________________________________________________________*/

PUBLIC Widget GetWidgetFromName (widget_set, name, mode, index)
	Widget	*widget_set;
	char	*name;
	char	mode;
	int	*index;
{
	*index	= GetIndexFromName (name, mode);

	return	*(widget_set + *index);
}


/*_________________________________________________________________________________	
	Function:
		GetFontName	
	Arguments:
	Description:
		Get the font name from the settings in the Font menu.

	Author:
		Tom (Tongzeng) Yang
		(12/09/1991)
_________________________________________________________________________________*/
PUBLIC char *GetFontName (font_list, font_name, weight_set, 
			slant_set, size_list, size_name)
	Widget	*font_list;
	Widget	*font_name;
	Widget	*weight_set;
	Widget	*slant_set;
	Widget	*size_list;
	Widget	*size_name;
{
	char		*buffer;
	char		*font_string;
	char		*lower_name;
	char		size_string [MAXLINE];
	int		i;
	int		point_size;

	font_string	= (char *) pkg_malloc (MAXLINE, "GetFontName", "font_string");

	strcpy (font_string, "-*-");
	buffer	= XmTextGetString (*font_name);
	nFontNameIndex	= XmListItemPos (*font_list,
				XmStringCreate (buffer, XmSTRING_DEFAULT_CHARSET));
	strcat (font_string, buffer);
	XtFree (buffer);

	if (XmToggleButtonGetState (weight_set[0]))
		strcat (font_string, "-medium");
	else 
		strcat (font_string, "-bold");

	if (XmToggleButtonGetState (slant_set[0]))
		strcat (font_string, "-r");
	else if (XmToggleButtonGetState (slant_set[1]))
		strcat (font_string, "-i");
	else 
		strcat (font_string, "-o");
	strcat (font_string, "-*-*-");

	buffer	= XmTextGetString (*size_name);
	nFontSizeIndex	= XmListItemPos (*size_list,
				XmStringCreate (buffer, XmSTRING_DEFAULT_CHARSET));
	strcat (font_string, buffer);
	point_size	= PIXEL_POINT_FACTOR * atoi (buffer);
	sprintf (size_string, "-%d", point_size);
	strcat (font_string, size_string);
	XtFree (buffer);

	if (strstr (font_string, "symbol") == NULL)
		strcat (font_string, "-75-75-*-*-iso8859-1");
	else
		strcat (font_string, "-75-75-*-*-*-*");

	return font_string;
}

PUBLIC void GetDefaultParameters (display, root_window, gc, file_name, default_parameters,
				xmsize_symbol)
	Display			*display;
	Window			root_window;
	GC			gc;
	char			*file_name;
	PARAMETERS_DATA		*default_parameters;
	XmString		xmsize_symbol [];
{
	Arg			arglist [2];
	BOOLEAN			*auto_image1_value_flag	= &bAutoImage1ValueFlag;        
	BOOLEAN			*auto_image2_value_flag	= &bAutoImage2ValueFlag;        
	BOOLEAN			bool_buffer;
	BOOLEAN			*color_bar_orient_image1	= &bImage1HorizontalColorBar;
	BOOLEAN			*color_bar_orient_image2	= &bImage2HorizontalColorBar;
	BOOLEAN			filled;
	BOOLEAN			*image1_colorbar_onoff	= &bImage1ColorBarOnOff;
	BOOLEAN			*image2_colorbar_onoff	= &bImage2ColorBarOnOff;
	BOOLEAN			*image1_value_flag	= &cImage1ValueFlag;        
	BOOLEAN			*image2_value_flag	= &cImage2ValueFlag;        
	BOOLEAN			*region_onoff		= bDisplayRegion;
	BOOLEAN			*slice_number_flag	= &bSliceNumberFlag;
	BOOLEAN			*symbol_onoff		= bDisplaySymbol;
	COLOR_BAR_MENU		*color_bar_menu		= default_parameters->color_bar_menu;
	DATA_TYPE_MENU		*data_type_menu		= default_parameters->data_type_menu;
	FILE			*file;
	FONT_MENU		*font_menu		= default_parameters->font_menu;
	FORMAT_SCREEN_MENU	*format_screen_menu	= default_parameters->format_screen_menu;
	MAG_SCALE_MENU		*mag_scale_menu		= default_parameters->mag_scale_menu;
	Pixel			background;
	Pixel			foreground;
	Pixmap			pixmap_symbol;
	REGION_MENU		*region_menu		= default_parameters->region_menu;
	SYMBOL_MENU		*symbol_menu		= default_parameters->symbol_menu;
	Screen			*screen;
	Widget			widget_buffer;
	XFontStruct		*font_struct;
	XmString		item;
	char			*atlas_orient		= &cAtlasOrientation;
	char			*color_table_image1	= szImage1ColorTableName;
	char			*color_table_image2	= szImage2ColorTableName;
	char			*complete_atlas_name	= szAtlasFileName;
	char			*dynamic_symbol_color	= cDynamicSymbolColor;
	char			*dynamic_symbol_type	= cDynamicSymbolType;
	char			*extension;
	char			*font_name;
	char			label [MAXLINE];
	char			line [MAXLINE];
	char			lowered_value [MAXLINE];
	char			mask_name [MAXLINE];
	char			*region_alter_set	= &cActiveRegionSet;
	char			*region_color		= cRegionColor;
	char			*region_type	 	= cRegionType; 
	char			*short_atlas_name;
	char			*symbol_alter_set	= &cActiveAF3DSet;
	char			*symbol_color		= cSymbolColor;
	char			**symbol_names		= symbolNames;
	char			*symbol_type	 	= cSymbolType; 
	char			value [MAXLINE];
	float			*slice_scale		= &dSliceMagnification;
	float			new_scale		= *slice_scale;
	int			i;
	int			n;
	short			*color_bar_length_image1	= &nImage1ColorBarLength;
	short			*color_bar_length_image2	= &nImage2ColorBarLength;
	short			*color_bar_width_image1		= &nImage1ColorBarWidth;
	short			*color_bar_width_image2		= &nImage2ColorBarWidth;
	short			*first_slice		= &nFirstSlice;
	short			*last_slice		= &nLastSlice;
	short			*max_value_image1	= &nMaxImage1Value;
	short			*max_value_image2	= &nMaxImage2Value;
	short			max_slice_num;
	short			*min_value_image1	= &nMinImage1Value;
	short			*min_value_image2	= &nMinImage2Value;
	short			min_slice_num;
	short			*xcolor_bar_image1	= &nxImage1ColorBarStart;
	short			*xcolor_bar_image2	= &nxImage2ColorBarStart;
	short			*ycolor_bar_image1	= &nyImage1ColorBarStart;
	short			*ycolor_bar_image2	= &nyImage2ColorBarStart;
	unsigned short		*symbol_size		= nSymbolSize;

	file	= fopen (file_name, "r");
	if (file == NULL)
	{
		fprintf (stderr, "Error: Cannot Open file %s\n", file_name);
		return;
	}

	while ( fgets (line, MAXLINE, file) != NULL)
	{
		if (sscanf (line, "%s %s", label, value) == 2) 
		{
			strcpy (lowered_value, value);
			Lowered (lowered_value, strlen (lowered_value));

			if (strcmp (label, "AtlasFileName:") == 0)
			{
				extension	= strrchr (value, '/');
				if (extension != NULL && strncmp (extension, "/", 1) == 0)
					short_atlas_name	= extension + 1;
				else
					short_atlas_name	= value;

				strcpy (complete_atlas_name, default_parameters->library_path);
				strcat (complete_atlas_name, short_atlas_name);
				ReadAtlasHeader (complete_atlas_name, default_parameters->library_path);

				strcpy (mask_name, default_parameters->library_path);
				if (strstr (short_atlas_name, "Talairach") == NULL)
				{
					strcat (mask_name, "HD6.mask");
				}
				else
				{
					strcat (mask_name, "pett6_n99_t88.mask");
				}
				strcpy (szImageMaskFileName, mask_name);

				continue;
			}

			if (strcmp (label, "DisplayImage1AtlasFlag:") == 0
			|| strcmp (label, "DisplayAtlasFlag:") == 0)
			{
				if (strcmp (lowered_value, "true") == 0)
					bool_buffer	= TRUE;
				else
					bool_buffer	= FALSE;

				SetSelectData (*data_type_menu->atlas1, bool_buffer);
				bDisplayAtlas1	= bool_buffer;

				continue;
			}

			if (strcmp (label, "DisplayImage2AtlasFlag:") == 0)
			{
				if (strcmp (lowered_value, "true") == 0)
					bool_buffer	= TRUE;
				else
					bool_buffer	= FALSE;

				SetSelectData (*data_type_menu->atlas2, bool_buffer);
				bDisplayAtlas2	= bool_buffer;

				continue;
			}

			if (strcmp (label, "AtlasTrim:") == 0)
			{
				if (strcmp (lowered_value, "true") == 0)
					bool_buffer	= TRUE;
				else
					bool_buffer	= FALSE;

				SetSelectData (*data_type_menu->atlas_trim, bool_buffer);
				bAtlasTrim	= bool_buffer;

				continue;
			}

			if (strcmp (label, "DisplayPetFlag:") == 0
			|| strcmp (label, "DisplayImage1Flag:") == 0)
			{
				if (strcmp (lowered_value, "true") == 0)
					bool_buffer	= TRUE;
				else
					bool_buffer	= FALSE;

				SetSelectData (*data_type_menu->image1, bool_buffer);
				bDisplayImage1	= bool_buffer;

				continue;
			}

			if (strcmp (label, "ApplyMaskFlag:") == 0
			|| strcmp (label, "ApplyImage1MaskFlag:") == 0)
			{
				if (strcmp (lowered_value, "true") == 0)
					bool_buffer	= TRUE;
				else
					bool_buffer	= FALSE;

				SetSelectData (*data_type_menu->mask1, bool_buffer);
				bApplyMask1	= bool_buffer;

				continue;
			}

			if (strcmp (label, "DisplayImage2Flag:") == 0)
			{
				if (strcmp (lowered_value, "true") == 0)
					bool_buffer	= TRUE;
				else
					bool_buffer	= FALSE;

				SetSelectData (*data_type_menu->image2, bool_buffer);
				bDisplayImage2	= bool_buffer;

				continue;
			}

			if (strcmp (label, "ApplyImage2MaskFlag:") == 0)
			{
				if (strcmp (lowered_value, "true") == 0)
					bool_buffer	= TRUE;
				else
					bool_buffer	= FALSE;

				SetSelectData (*data_type_menu->mask2, bool_buffer);
				bApplyMask2	= bool_buffer;

				continue;
			}

			if (strcmp (label, "DisplayLabelFlag:") == 0)
			{
				if (strcmp (lowered_value, "true") == 0)
					bool_buffer	= TRUE;
				else
					bool_buffer	= FALSE;

				SetSelectData (*data_type_menu->label, bool_buffer);
				bDisplayLabel	= bool_buffer;

				continue;
			}

			if (strcmp (label, "SliceNumZValueFlag:") == 0)
			{
				if (strcmp (lowered_value, "true") == 0)
					bool_buffer	= TRUE;
				else
					bool_buffer	= FALSE;

				n	= 0;
				XtSetArg (arglist [n], XmNlabelString,
					XmStringCreate (bool_buffer? "Slice Numbers":
					"Z Values", XmSTRING_DEFAULT_CHARSET)); n++;
				XtSetValues (*data_type_menu->slice_num_flag, arglist, n);

				SetSelectData (*data_type_menu->slice_num_flag, bool_buffer);
				*slice_number_flag	= bool_buffer;

				continue;
			}

			if (strcmp (label, "AtlasOrientation:") == 0)
			{
				n	= 0;
				XtSetArg (arglist [n], XmNset, False); n++;
				XtSetValues (GetActiveWidget (data_type_menu->orientation_set, 
					ORIENTATION_NUM), arglist, n);

				widget_buffer	
				= GetWidgetFromName (data_type_menu->orientation_set,
							value, TOGGLE_ATLAS_ORIENT, &n);
				*atlas_orient	= (char) n;
				SetDefaultAtlas (*atlas_orient, default_parameters->library_path);

				n	= 0;
				XtSetArg (arglist [n], XmNset, True); n++;
				XtSetValues (widget_buffer, arglist, n);

				continue;
			}

			if (strcmp (label, "FirstSlice:") == 0)
			{
				*first_slice	= atoi (value);
				if (!(*slice_number_flag))
				{
					*first_slice	= GetSliceNumber (*first_slice, 
							*atlas_orient, zorigin_image1);
				}
				XmTextSetString (*data_type_menu->first_slice, value); 

				continue;
			}

			if (strcmp (label, "LastSlice:") == 0)
			{
				*last_slice	= atoi (value);
				if (!(*slice_number_flag))
				{
					*last_slice	= GetSliceNumber (*last_slice, 
							*atlas_orient, zorigin_image1);
				}
				XmTextSetString (*data_type_menu->last_slice, value); 

				continue;
			}

			if (strcmp (label, "Spacing:") == 0)
			{
				nSpacing	= *slice_number_flag? atoi (value):
							atoi (value) / 2;
				XmTextSetString (*data_type_menu->spacing, value); 


				continue;
			}

			if (strcmp (label, "MagnificationFactor:") == 0)
			{
				n	= 0;
				XtSetArg (arglist [n], XmNset, False); n++;
				XtSetValues (GetActiveWidget (mag_scale_menu->mag_set, 
						MAG_NUM), arglist, n);

				widget_buffer	= GetWidgetFromName (mag_scale_menu->mag_set,
							value, TOGGLE_MAG, &n);
				new_scale	= atof (value);
				if (pkg_abs (*slice_scale - new_scale) >= ERROR_BOUND)
				{
					*slice_scale	= new_scale;
					bMagChanged	= TRUE;
				}
				cMagnifyIndex	= (char) n;

				n	= 0;
				XtSetArg (arglist [n], XmNset, True); n++;
				XtSetValues (widget_buffer, arglist, n);

				XmTextSetString (*mag_scale_menu->text_mag_any, value);

				continue;
			}

			if (strcmp (label, "Image1Scale:") == 0
			|| strcmp (label, "PetImageScale:") == 0)
			{
				n	= 0;
				XtSetArg (arglist [n], XmNset, False); n++;
				XtSetValues (GetActiveWidget 
				(mag_scale_menu->scale_set_image1, 
						SCALE_NUM), arglist, n);

				widget_buffer	
				= GetWidgetFromName (mag_scale_menu->scale_set_image1,
							value, TOGGLE_SCALE, &n);
				*image1_value_flag	= (char) n;

				n	= 0;
				XtSetArg (arglist [n], XmNset, True); n++;
				XtSetValues (widget_buffer, arglist, n);

				continue;
			}

			if (strcmp (label, "AutoImage1MinMaxFlag:") == 0
			|| strcmp (label, "AutoPetMinMaxFlag:") == 0)
			{
				if (strcmp (lowered_value, "true") == 0)
					bool_buffer	= TRUE;
				else
					bool_buffer	= FALSE;

				SetSelectData (*mag_scale_menu->auto_minmax_image1, bool_buffer);
				*auto_image1_value_flag	= bool_buffer;

				continue;
			}

			if (strcmp (label, "Image1Minimum:") == 0
			|| strcmp (label, "PetMinimum:") == 0)
			{
				*min_value_image1	= atoi (value);
				if (!(*auto_image1_value_flag))
					XmTextSetString (*mag_scale_menu->min_text_image1, value); 

				continue;
			}

			if (strcmp (label, "Image1Maximum:") == 0
			|| strcmp (label, "PetMaximum:") == 0)
			{
				*max_value_image1	= atoi (value);
				if (!(*auto_image1_value_flag))
					XmTextSetString (*mag_scale_menu->max_text_image1, value); 

				continue;
			}

			if (strcmp (label, "Image2Scale:") == 0)
			{
				n	= 0;
				XtSetArg (arglist [n], XmNset, False); n++;
				XtSetValues (GetActiveWidget 
				(mag_scale_menu->scale_set_image2, 
						SCALE_NUM), arglist, n);

				widget_buffer	
				= GetWidgetFromName (mag_scale_menu->scale_set_image2,
							value, TOGGLE_SCALE, &n);
				*image2_value_flag	= (char) n;

				n	= 0;
				XtSetArg (arglist [n], XmNset, True); n++;
				XtSetValues (widget_buffer, arglist, n);

				continue;
			}

			if (strcmp (label, "AutoImage2MinMaxFlag:") == 0)
			{
				if (strcmp (lowered_value, "true") == 0)
					bool_buffer	= TRUE;
				else
					bool_buffer	= FALSE;

				SetSelectData (*mag_scale_menu->auto_minmax_image2, bool_buffer);
				*auto_image2_value_flag	= bool_buffer;

				continue;
			}

			if (strcmp (label, "Image2Minimum:") == 0)
			{
				*min_value_image2	= atoi (value);
				if (!(*auto_image2_value_flag))
					XmTextSetString (*mag_scale_menu->min_text_image2, value); 

				continue;
			}

			if (strcmp (label, "Image2Maximum:") == 0)
			{
				*max_value_image2	= atoi (value);
				if (!(*auto_image2_value_flag))
					XmTextSetString (*mag_scale_menu->max_text_image2, value); 

				continue;
			}

			if (strcmp (label, "AlterRegionSet:") == 0)
			{
				*region_alter_set	= atoi (value) - 1;

				SetSelectData (GetActiveWidget (region_menu->toggle_alter_set, 
						MAX_REGIONSET_NUM), False);
				SetSelectData (region_menu->toggle_alter_set [*region_alter_set], True);

				continue;
			}

			if (strcmp (label, "DisplayRegionSet:") == 0)
			{
				for (i = 0; i < MAX_REGIONSET_NUM; i++)
				{
					fgets (line, MAXLINE, file);
					sscanf (line, "%s %s", label, value);
					Lowered (value, strlen (value));

					if (strcmp (value, "true") == 0)
						bool_buffer	= TRUE;
					else
						bool_buffer	= FALSE;

					*(region_onoff + i)	= bool_buffer;
				}

				continue;
			}

			if (strcmp (label, "RegionColorSet:") == 0)
			{
				for (i = 0; i < MAX_REGIONSET_NUM; i++)
				{
					fgets (line, MAXLINE, file);
					sscanf (line, "%s %s", label, value);

					*(region_color + i)	
						= GetIndexFromName (value, TOGGLE_COLOR);
				}

				continue;
			}

			if (strcmp (label, "RegionFillingTypeSet:") == 0)
			{
				for (i = 0; i < MAX_REGIONSET_NUM; i++)
				{
					fgets (line, MAXLINE, file);
					sscanf (line, "%s %s", label, value);

					*(region_type + i)	
						= GetIndexFromName (value, TOGGLE_SYMBOL_SHAPE);
				}

				continue;
			}

			if (strcmp (label, "TalairachRegionFlag:") == 0)
			{
				if (strcmp (lowered_value, "true") == 0)
					bool_buffer	= TRUE;
				else
					bool_buffer	= FALSE;

				n	= 0;
				XtSetArg (arglist [n], XmNset, bool_buffer); n++;
				XtSetArg (arglist [n], XmNlabelString,
					XmStringCreate (bool_buffer? "hd6tot88":
					"original", XmSTRING_DEFAULT_CHARSET)); n++;
				XtSetValues (*region_menu->toggle_talairach_region, arglist, n);

				bTalairachRegionFlag	= bool_buffer;

				continue;
			}

			if (strcmp (label, "AlterSymbolSet:") == 0)
			{
				*symbol_alter_set	= atoi (value) - 1;

				SetSelectData (GetActiveWidget (symbol_menu->toggle_alter_set, 
						MAX_AF3DSET_NUM), False);
				SetSelectData (symbol_menu->toggle_alter_set [*symbol_alter_set], True);

				continue;
			}

			if (strcmp (label, "DisplaySymbolSet:") == 0)
			{
				for (i = 0; i < MAX_AF3DSET_NUM; i++)
				{
					fgets (line, MAXLINE, file);
					sscanf (line, "%s %s", label, value);
					Lowered (value, strlen (value));

					if (strcmp (value, "true") == 0)
						bool_buffer	= TRUE;
					else
						bool_buffer	= FALSE;

					*(symbol_onoff + i)	= bool_buffer;
				}

				continue;
			}

			if (strcmp (label, "AF3DColorSet:") == 0)
			{
				for (i = 0; i < MAX_AF3DSET_NUM; i++)
				{
					fgets (line, MAXLINE, file);
					sscanf (line, "%s %s", label, value);

					*(symbol_color + i)	
						= GetIndexFromName (value, TOGGLE_COLOR);
					*(dynamic_symbol_color + i)	
						= *(symbol_color + i);
				}

				continue;
			}

			if (strcmp (label, "AF3DSymbolShapeSet:") == 0)
			{
				for (i = 0; i < MAX_AF3DSET_NUM; i++)
				{
					fgets (line, MAXLINE, file);
					sscanf (line, "%s %s", label, value);

					*(symbol_type + i)	
						= GetIndexFromName (value, TOGGLE_SYMBOL_SHAPE);
					*(dynamic_symbol_type + i)	= *(symbol_type + i);
				}

				continue;
			}

			if (strcmp (label, "AF3DSymbolSizeSet:") == 0)
			{
				for (i = 0; i < MAX_AF3DSET_NUM; i++)
				{
					fgets (line, MAXLINE, file);
					sscanf (line, "%s %s", label, value);

					*(symbol_size + i)	= atoi (value);
				}
			}

			if (strcmp (label, "AF3DSymbolOutlineWidth:") == 0)
			{
				n	= atoi (value);
				nOutlineWidth	= n;
				XmScaleSetValue (*symbol_menu->outline_width, n);
			}

			if (strcmp (label, "AF3DSymMaximumDistance:") == 0)
			{
				dMaximumDistance	= atof (value);
				XmTextSetString (*symbol_menu->text_maximum_distance, value);
			}

			if (strcmp (label, "xFormatedScreen:") == 0)
			{
				nxFormatedScreen	= atoi (value);
				XmTextSetString (*format_screen_menu->format_x, value); 

				continue;
			}

			if (strcmp (label, "yFormatedScreen:") == 0)
			{
				nyFormatedScreen	= atoi (value);
				XmTextSetString (*format_screen_menu->format_y, value); 

				continue;
			}

			if (strcmp (label, "FormatedScreenWidth:") == 0)
			{
				nFormatedScreenWidth	= atoi (value);
				XmTextSetString (*format_screen_menu->format_width, value); 

				continue;
			}

			if (strcmp (label, "FormatedScreenHeight:") == 0)
			{
				nFormatedScreenHeight	= atoi (value);
				XmTextSetString (*format_screen_menu->format_height, value); 

				continue;
			}

			if (strcmp (label, "xStartFormatedSlices:") == 0
			|| strcmp (label, "xImage1StartFormatedSlices:") == 0)
			{
				nxImage1Start	= atoi (value);
				XmTextSetString (*format_screen_menu->xstart_text_image1, value); 

				continue;
			}

			if (strcmp (label, "yStartFormatedSlices:") == 0
			|| strcmp (label, "yImage1StartFormatedSlices:") == 0)
			{
				nyImage1Start	= atoi (value);
				XmTextSetString (*format_screen_menu->ystart_text_image1, value); 

				continue;
			}

			if (strcmp (label, "xImage2StartFormatedSlices:") == 0)
			{
				nxImage2Start	= atoi (value);
				XmTextSetString (*format_screen_menu->xstart_text_image2, value); 

				continue;
			}

			if (strcmp (label, "yImage2StartFormatedSlices:") == 0)
			{
				nyImage2Start	= atoi (value);
				XmTextSetString (*format_screen_menu->ystart_text_image2, value); 

				continue;
			}

			if (strcmp (label, "xOffsetFormatedSlices:") == 0)
			{
				nxOffsetMillimeter	= atoi (value);
				XmTextSetString (*format_screen_menu->xoffset_text, value); 

				continue;
			}

			if (strcmp (label, "yOffsetFormatedSlices:") == 0)
			{
				nyOffsetMillimeter	= atoi (value);
				XmTextSetString (*format_screen_menu->yoffset_text, value); 

				continue;
			}

			if (strcmp (label, "xRowRowOffsetFormatedSlices:") == 0)
			{
				nxRowRowMillimeter	= atoi (value);
				XmTextSetString (*format_screen_menu->rowxoffset_text, value); 

				continue;
			}

			if (strcmp (label, "yRowRowOffsetFormatedSlices:") == 0)
			{
				nyRowRowMillimeter	= atoi (value);
				XmTextSetString (*format_screen_menu->rowyoffset_text, value); 

				continue;
			}

			if (strcmp (label, "xLabelStartFormatedSlices:") == 0)
			{
				nxLabelStart	= atoi (value);
				XmTextSetString (*format_screen_menu->label_xstart, value); 

				continue;
			}

			if (strcmp (label, "yLabelStartFormatedSlices:") == 0)
			{
				nyLabelStart	= atoi (value);
				XmTextSetString (*format_screen_menu->label_ystart, value); 

				continue;
			}

			if (strcmp (label, "ZLowToHighOrder:") == 0)
			{
				if (strcmp (lowered_value, "true") == 0)
					bool_buffer	= TRUE;
				else
					bool_buffer	= FALSE;

				SetSelectData (*format_screen_menu->display_order, bool_buffer);
				bLow2High	= bool_buffer;

				continue;
			}

			if (strcmp (label, "xImage1ColorBarStart:") == 0
			|| strcmp (label, "xColorBarStart:") == 0)
			{
				*xcolor_bar_image1	= atoi (value);
				XmTextSetString (*color_bar_menu->image1_xstart, value); 

				continue;
			}

			if (strcmp (label, "yImage1ColorBarStart:") == 0
			|| strcmp (label, "yColorBarStart:") == 0)
			{
				*ycolor_bar_image1	= atoi (value);
				XmTextSetString (*color_bar_menu->image1_ystart, value); 

				continue;
			}

			if (strcmp (label, "Image1ColorBarWidth:") == 0
			|| strcmp (label, "ColorBarWidth:") == 0)
			{
				*color_bar_width_image1	= atoi (value);
				XmTextSetString (*color_bar_menu->image1_height, value); 

				continue;
			}

			if (strcmp (label, "Image1ColorBarLength:") == 0
			|| strcmp (label, "ColorBarLength:") == 0)
			{
				*color_bar_length_image1	= atoi (value);
				XmTextSetString (*color_bar_menu->image1_width, value); 

				continue;
			}

			if (strcmp (label, "Image1ColorBarOrientation:") == 0
			|| strcmp (label, "ColorBarOrientation:") == 0)
			{
				if (strcmp (lowered_value, "true") == 0)
					bool_buffer	= TRUE;
				else
					bool_buffer	= FALSE;

				SetSelectData (*color_bar_menu->image1_orientation, bool_buffer);
				*color_bar_orient_image1	= bool_buffer;

				continue;
			}

			if (strcmp (label, "Image1ColorBarOnOff:") == 0)
			{
				if (strcmp (lowered_value, "true") == 0)
					bool_buffer	= TRUE;
				else
					bool_buffer	= FALSE;

				SetSelectData (*color_bar_menu->image1_onoff, bool_buffer);
				*image1_colorbar_onoff	= bool_buffer;

				continue;
			}

			if (strcmp (label, "xImage2ColorBarStart:") == 0)
			{
				*xcolor_bar_image2	= atoi (value);
				XmTextSetString (*color_bar_menu->image2_xstart, value); 

				continue;
			}

			if (strcmp (label, "yImage2ColorBarStart:") == 0)
			{
				*ycolor_bar_image2	= atoi (value);
				XmTextSetString (*color_bar_menu->image2_ystart, value); 

				continue;
			}

			if (strcmp (label, "Image2ColorBarWidth:") == 0)
			{
				*color_bar_width_image2	= atoi (value);
				XmTextSetString (*color_bar_menu->image2_height, value); 

				continue;
			}

			if (strcmp (label, "Image2ColorBarLength:") == 0)
			{
				*color_bar_length_image2	= atoi (value);
				XmTextSetString (*color_bar_menu->image2_width, value); 

				continue;
			}

			if (strcmp (label, "Image2ColorBarOrientation:") == 0)
			{
				if (strcmp (lowered_value, "true") == 0)
					bool_buffer	= TRUE;
				else
					bool_buffer	= FALSE;

				SetSelectData (*color_bar_menu->image2_orientation, bool_buffer);
				*color_bar_orient_image2	= bool_buffer;

				continue;
			}

			if (strcmp (label, "Image2ColorBarOnOff:") == 0)
			{
				if (strcmp (lowered_value, "true") == 0)
					bool_buffer	= TRUE;
				else
					bool_buffer	= FALSE;

				SetSelectData (*color_bar_menu->image2_onoff, bool_buffer);
				*image2_colorbar_onoff	= bool_buffer;

				continue;
			}

			if (strcmp (label, "BackgroundColor:") == 0)
			{
				n	= 0;
				XtSetArg (arglist [n], XmNset, False); n++;
				XtSetValues (GetActiveWidget (default_parameters->back_color_set, 
						MAX_NONIMAGE_COLOR), arglist, n);

				widget_buffer	
				= GetWidgetFromName (default_parameters->back_color_set,
							value, TOGGLE_COLOR, &n);

				n	= 0;
				XtSetArg (arglist [n], XmNset, True); n++;
				XtSetValues (widget_buffer, arglist, n);

				continue;
			}

			if (strcmp (label, "Atlas1Color:") == 0
			|| strcmp (label, "AtlasColor:") == 0)
			{
				n	= 0;
				XtSetArg (arglist [n], XmNset, False); n++;
				XtSetValues (GetActiveWidget (default_parameters->atlas1_color_set, 
						MAX_NONIMAGE_COLOR + 1), arglist, n);

				widget_buffer	
				= GetWidgetFromName (default_parameters->atlas1_color_set,
							value, TOGGLE_COLOR, &n);

				n	= 0;
				XtSetArg (arglist [n], XmNset, True); n++;
				XtSetValues (widget_buffer, arglist, n);

				continue;
			}

			if (strcmp (label, "Atlas2Color:") == 0)
			{
				n	= 0;
				XtSetArg (arglist [n], XmNset, False); n++;
				XtSetValues (GetActiveWidget (default_parameters->atlas2_color_set, 
						MAX_NONIMAGE_COLOR + 1), arglist, n);

				widget_buffer	
				= GetWidgetFromName (default_parameters->atlas2_color_set,
							value, TOGGLE_COLOR, &n);

				n	= 0;
				XtSetArg (arglist [n], XmNset, True); n++;
				XtSetValues (widget_buffer, arglist, n);

				continue;
			}

			if (strcmp (label, "Image1ColorTable:") == 0
			|| strcmp (label, "PetColorTable:") == 0)
			{
				item	= XmStringCreate (value, XmSTRING_DEFAULT_CHARSET);
				widget_buffer	
				= XmSelectionBoxGetChild (*default_parameters->image1_color_box, 
										XmDIALOG_LIST);
				XmListSelectItem (widget_buffer, item, True);
				XtFree (item);

				strcpy (color_table_image1, default_parameters->library_path);
				strcat (color_table_image1, value);

				continue;
			}

			if (strcmp (label, "Image2ColorTable:") == 0)
			{
				item	= XmStringCreate (value, XmSTRING_DEFAULT_CHARSET);
				widget_buffer	
				= XmSelectionBoxGetChild (*default_parameters->image2_color_box, 
										XmDIALOG_LIST);
				XmListSelectItem (widget_buffer, item, True);
				XtFree (item);

				strcpy (color_table_image2, default_parameters->library_path);
				strcat (color_table_image2, value);

				continue;
			}

			if (strcmp (label, "LabelColor:") == 0)
			{
				n	= 0;
				XtSetArg (arglist [n], XmNset, False); n++;
				XtSetValues (GetActiveWidget (default_parameters->label_color_set, 
						MAX_NONIMAGE_COLOR), arglist, n);

				widget_buffer	
				= GetWidgetFromName (default_parameters->label_color_set,
							value, TOGGLE_COLOR, &n);

				n	= 0;
				XtSetArg (arglist [n], XmNset, True); n++;
				XtSetValues (widget_buffer, arglist, n);

				continue;
			}

			if (strcmp (label, "FontColor:") == 0)
			{
				n	= 0;
				XtSetArg (arglist [n], XmNset, False); n++;
				XtSetValues (GetActiveWidget (font_menu->font_color_set, 
						MAX_NONIMAGE_COLOR), arglist, n);

				widget_buffer	
				= GetWidgetFromName (font_menu->font_color_set,
							value, TOGGLE_COLOR, &n);
				cTextColorIndex	= n;	

				n	= 0;
				XtSetArg (arglist [n], XmNset, True); n++;
				XtSetValues (widget_buffer, arglist, n);

				continue;
			}

			if (strcmp (label, "FontName:") == 0)
			{
				n	= XmListItemPos (*font_menu->font_list,
					XmStringCreate (value, XmSTRING_DEFAULT_CHARSET));
				nFontNameIndex	= n; 

				XmListSelectPos (*font_menu->font_list, n, True);
				XmTextSetString (*font_menu->font_name, value);

				continue;
			}

			if (strcmp (label, "FontSize:") == 0)
			{
				n	= XmListItemPos (*font_menu->size_list,
					XmStringCreate (value, XmSTRING_DEFAULT_CHARSET));
				nFontSizeIndex	= n; 

				XmListSelectPos (*font_menu->size_list, n, True);
				XmTextSetString (*font_menu->size_name, value);

				continue;
			}

			if (strcmp (label, "FontSlant:") == 0)
			{
				n	= 0;
				XtSetArg (arglist [n], XmNset, False); n++;
				XtSetValues (GetActiveWidget (font_menu->slant_set, 
						SLANT_NUM), arglist, n);

				widget_buffer	
				= GetWidgetFromName (font_menu->slant_set,
							value, TOGGLE_SLANT, &n);
				cFontSlantIndex	= (char) n;	

				n	= 0;
				XtSetArg (arglist [n], XmNset, True); n++;
				XtSetValues (widget_buffer, arglist, n);

				continue;
			}

			if (strcmp (label, "FontWeight:") == 0)
			{
				n	= 0;
				XtSetArg (arglist [n], XmNset, False); n++;
				XtSetValues (GetActiveWidget (font_menu->weight_set, 
						WEIGHT_NUM), arglist, n);

				widget_buffer	
				= GetWidgetFromName (font_menu->weight_set,
						value, TOGGLE_WEIGHT, &n);
				cFontWeightIndex	= (char) n;	

				n	= 0;
				XtSetArg (arglist [n], XmNset, True); n++;
				XtSetValues (widget_buffer, arglist, n);

				continue;
			}

			if (strcmp (label, "FontOrientation:") == 0)
			{
				n	= 0;
				XtSetArg (arglist [n], XmNset, False); n++;
				XtSetValues (GetActiveWidget (font_menu->orient_set, 
						ORIENT_NUM), arglist, n);

				widget_buffer	
				= GetWidgetFromName (font_menu->orient_set,
						value, TOGGLE_ORIENT, &n);
				cFontOrientIndex	= (char) n;	

				n	= 0;
				XtSetArg (arglist [n], XmNset, True); n++;
				XtSetValues (widget_buffer, arglist, n);

				continue;
			}

			if (strcmp (label, "TextInterLineSpace:") == 0)
			{
				XmScaleSetValue (*font_menu->line_spacing, 
						atoi (value));
				nLineSpacing	= atoi (value);
				continue;
			}

			if (strcmp (label, "TextAlignment:") == 0)
			{
				n	= 0;
				XtSetArg (arglist [n], XmNset, False); n++;
				XtSetValues (GetActiveWidget (font_menu->alignment_set, 
						ALIGNMENT_NUM), arglist, n);

				widget_buffer	
				= GetWidgetFromName (font_menu->alignment_set,
							value, TOGGLE_ALIGN, &n);
				cAlignment	= (char) n;	

				n	= 0;
				XtSetArg (arglist [n], XmNset, True); n++;
				XtSetValues (widget_buffer, arglist, n);

				continue;
			}

			if (strcmp (label, "SaveFileFormat:") == 0)
			{
				n	= 0;
				if (strcmp (value, "PostScript") == 0)
				{
					XtSetArg (arglist[n], XmNset, False); n++;
					XtSetArg (arglist[n], XmNlabelString,
						XmStringCreate ("File Format: PostScript ", 
						XmSTRING_DEFAULT_CHARSET)); n++;
					bWinDumpFile	= FALSE;
				}
				else
				{
					XtSetArg (arglist[n], XmNset, True); n++;
					XtSetArg (arglist[n], XmNlabelString,
						XmStringCreate ("File Format: Window Dump ", 
						XmSTRING_DEFAULT_CHARSET)); n++;
					bWinDumpFile	= TRUE;
				}
				XtSetValues (*default_parameters->save_format, arglist, n);

				continue;
			}

			if (strcmp (label, "SaveArea:") == 0)
			{
				n	= 0;
				if (strcmp (value, "UserDefined") == 0)
				{
					XtSetArg (arglist[n], XmNset, False); n++;
					XtSetArg (arglist[n], XmNlabelString,
						XmStringCreate ("Area Saved: User Defined ", 
						XmSTRING_DEFAULT_CHARSET)); n++;
					bSaveWholeScreen	= FALSE;
				}
				else
				{
					XtSetArg (arglist[n], XmNset, True); n++;
					XtSetArg (arglist[n], XmNlabelString,
						XmStringCreate ("Area Saved: Entire Window", 
						XmSTRING_DEFAULT_CHARSET)); n++;
					bSaveWholeScreen	= TRUE;
				}
				XtSetValues (*default_parameters->save_area, arglist, n);
			}
		}
		else
		{
			fprintf (stderr, "Error: GetDefaultParameters %s\n", line);
		}
	}

	if (*slice_number_flag)
		strcpy (value, "Slice Numbers");
	else if (*atlas_orient == TRANSVERSE)
		strcpy (value, "Z Values");
	else if (*atlas_orient == CORONAL)
		strcpy (value, "Y Values");
	else 
		strcpy (value, "X Values");

	n	= 0;
	item	= XmStringCreate (value, XmSTRING_DEFAULT_CHARSET);
	XtSetArg (arglist [n], XmNlabelString, item); n++;
	XtSetValues (*data_type_menu->slice_num_flag, arglist, n);
	XtFree (item);

	ErrorCheckMinMax (*image1_value_flag, min_value_image1, max_value_image1);
	ErrorCheckMinMax (*image2_value_flag, min_value_image2, max_value_image2);

	/*
	 * Check if the first and last slice are within the allowed range
	 * and change the boundary slices if necessary.
	 */
	if (*atlas_orient == TRANSVERSE)
	{
		max_slice_num	= MAX_TRANS_ATLAS_NUM;
	}
	else
	{
		max_slice_num	= MAX_ATLAS_NUM;
	}
	min_slice_num	= 1;

	if (*first_slice < min_slice_num || *first_slice > max_slice_num)
	{
		fprintf (stderr, 
		"Your first slice %d is outside the allowed range of [%d, %d].\n",
			*first_slice, min_slice_num, max_slice_num);

		if (*first_slice < min_slice_num)
			*first_slice	= min_slice_num;
		else if (*first_slice > max_slice_num)
			*first_slice	= max_slice_num;

		fprintf (stderr, 
		"The number %d is assigned as the new first slice.\n", 
		*first_slice);
	}

	if (*last_slice < min_slice_num || *last_slice > max_slice_num)
	{
		fprintf (stderr, 
		"Your last slice %d is outside the allowed range of [%d, %d].\n",
		*last_slice, min_slice_num, max_slice_num);

		if (*last_slice < min_slice_num)
			*last_slice	= min_slice_num;
		else if (*last_slice > max_slice_num)
			*last_slice	= max_slice_num;

		fprintf (stderr, 
		"The number %d is assigned as the new last slice.\n", 
		*last_slice);
	}

	if (*first_slice > *last_slice)
		Swap (first_slice, last_slice);

	nxImage1OldColorBar		= *xcolor_bar_image1; 
	nyImage1OldColorBar		= *ycolor_bar_image1; 
	nImage1OldColorBarLength	= *color_bar_length_image1; 
	nImage1OldColorBarWidth		= *color_bar_width_image1; 
	bImage1OldHoriColorBar		= *color_bar_orient_image1;

	nxImage2OldColorBar		= *xcolor_bar_image2; 
	nyImage2OldColorBar		= *ycolor_bar_image2; 
	nImage2OldColorBarLength	= *color_bar_length_image2; 
	nImage2OldColorBarWidth		= *color_bar_width_image2; 
	bImage2OldHoriColorBar		= *color_bar_orient_image2;

	n = 0;
	XtSetArg (arglist [n], XtNbackground, &background); n++;
	XtGetValues (symbol_menu->toggle_symbol_set [0], arglist, n);

	screen	= XtScreen (symbol_menu->label_symbol_set [0]);

	for (i = 0; i < MAX_REGIONSET_NUM; i++)
	{
		SetSelectData (region_menu->display_onoff_set [i], *(region_onoff + i));

		n = 0;
		XtSetArg (arglist [n], XtNforeground, &foreground); n++;
		XtGetValues (region_menu->toggle_color_set [*(region_color + i)], arglist, n);

		pixmap_symbol	= XmGetPixmap (screen,  
					symbol_names [*(region_type + i)], 
					foreground, background);

		n = 0;
		XtSetArg (arglist [n], XmNlabelType, XmPIXMAP); n++;
		XtSetArg (arglist [n], XmNlabelPixmap, pixmap_symbol); n++;
		XtSetValues (region_menu->label_pattern_set [i], arglist, n);
	}

	SetSelectData (GetActiveWidget (region_menu->toggle_color_set, MAX_NONIMAGE_COLOR), False);
	SetSelectData (region_menu->toggle_color_set [*(region_color + *region_alter_set)], True);

	if (*(region_type + *region_alter_set) == SOLID_RECT_INDEX)
		i	= REGION_FILLED;
	else if (*(region_type + *region_alter_set) < SOLID_RECT_INDEX)
		i	= REGION_OUTLINE;
	else
		i	= REGION_PIXEL;

	SetSelectData (GetActiveWidget (region_menu->toggle_pattern_set, REGION_STYLE_NUM), False);
	SetSelectData (region_menu->toggle_pattern_set [i], True);

	for (i = 0; i < MAX_AF3DSET_NUM; i++)
	{
		SetSelectData (symbol_menu->display_onoff_set [i], *(symbol_onoff + i));

		n = 0;
		XtSetArg (arglist [n], XtNforeground, &foreground); n++;
		XtGetValues (symbol_menu->toggle_color_set [*(symbol_color + i)], arglist, n);

		pixmap_symbol	= XmGetPixmap (screen,  
					symbol_names [*(symbol_type + i)], 
					foreground, background);

		n = 0;
		XtSetArg (arglist [n], XmNlabelType, XmPIXMAP); n++;
		XtSetArg (arglist [n], XmNlabelPixmap, pixmap_symbol); n++;
		XtSetValues (symbol_menu->label_symbol_set [i], arglist, n);

		XtFree (xmsize_symbol [i]);
		itoa (*(symbol_size + i), value);
		xmsize_symbol [i]	= XmStringCreate (value, XmSTRING_DEFAULT_CHARSET); 

		n = 0;
		XtSetArg (arglist [n], XmNlabelString, *(xmsize_symbol + i)); n++;
		XtSetValues (symbol_menu->label_symbol_size_set [i], arglist, n);
	}

	SetSelectData (GetActiveWidget (symbol_menu->toggle_color_set, MAX_NONIMAGE_COLOR), False);
	SetSelectData (symbol_menu->toggle_color_set [*(symbol_color + *symbol_alter_set)], True);

	if (*(symbol_type + *symbol_alter_set) >= MAX_SYMBOL_NUM)
	{
		i	= *(symbol_type + *symbol_alter_set) - MAX_SYMBOL_NUM;
		filled	= TRUE;
	}
	else
	{
		i	= *(symbol_type + *symbol_alter_set);
		filled	= FALSE;
	}

	SetSelectData (GetActiveWidget (symbol_menu->toggle_symbol_set, MAX_SYMBOL_NUM), False);
	SetSelectData (symbol_menu->toggle_symbol_set [i], True);

	SetSelectData (*symbol_menu->filled, filled);

	XmScaleSetValue (*symbol_menu->size_scale, *(symbol_size + *symbol_alter_set));

	SetColorParameters (display, root_window, DefaultScreen (display), default_parameters);

	font_name	= GetFontName (*font_menu->font_list,
					*font_menu->font_name,
					font_menu->weight_set,
					font_menu->slant_set,
					*font_menu->size_list,
					*font_menu->size_name);
	font_struct	= XLoadQueryFont (display, font_name);
	if (font_struct == 0)
		fprintf (stderr, "Can Not Find Font %s\n", font_name);
	else
	{
		XSetFont (display, gc, font_struct->fid);
	}
	XtFree (font_name);
	FontStruct	= font_struct;

	fclose (file);
}

PUBLIC void SaveDefaultParameters (file_name, default_parameters)
	char		*file_name;
	PARAMETERS_DATA	*default_parameters;
{
	BOOLEAN			bool_buffer;
	BOOLEAN			*slice_number_flag	= &bSliceNumberFlag;
	BOOLEAN			*region_onoff		= bDisplayRegion;
	BOOLEAN			*symbol_onoff		= bDisplaySymbol;
	COLOR_BAR_MENU		*color_bar_menu		= default_parameters->color_bar_menu;
	DATA_TYPE_MENU		*data_type_menu		= default_parameters->data_type_menu;
	FILE			*file;
	FONT_MENU		*font_menu		= default_parameters->font_menu;
	FORMAT_SCREEN_MENU	*format_screen_menu	= default_parameters->format_screen_menu;
	SYMBOL_MENU		*symbol_menu		= default_parameters->symbol_menu;
	char			atlas_orient		= cAtlasOrientation;
	char			**color_list	 	= nonImageColorList; 
	char			*complete_atlas_name	= szAtlasFileName;
	char			*extension;
	char			*region_color		= cRegionColor;
	char			*region_type	 	= cRegionType; 
	char			*short_atlas_name;
	char			*string;
	char			*symbol_color		= cSymbolColor;
	char			*symbol_shape	 	= cSymbolType; 
	char			**symbol_names		= symbolNames;
	char			value [MAXLINE];
	short			first_slice		= nFirstSlice;
	int			i;
	int			int_buffer;
	short			last_slice		= nLastSlice;
	short			spacing			= nSpacing;
	unsigned short		*symbol_size		= nSymbolSize;

	file	= fopen (file_name, "w");
	if (file == NULL)
	{
		fprintf (stderr, "Error: Cannot Open file %s\n", file_name);
		return;
	}

	extension	= strrchr (complete_atlas_name, '/');
	if (extension != NULL && strncmp (extension, "/", 1) == 0)
		short_atlas_name	= extension + 1;
	else
		short_atlas_name	= complete_atlas_name;
	fprintf (file, "AtlasFileName:		%s\n", short_atlas_name);

	bool_buffer	
	= XmToggleButtonGetState (*data_type_menu->atlas_trim);
	fprintf (file, "AtlasTrim:		%s\n", bool_buffer? "True": "False");

	bool_buffer	= XmToggleButtonGetState (*data_type_menu->atlas1);
	fprintf (file, "DisplayImage1AtlasFlag:	%s\n", bool_buffer? "True": "False");

	bool_buffer	= XmToggleButtonGetState (*data_type_menu->image1);
	fprintf (file, "DisplayImage1Flag:	%s\n", bool_buffer? "True": "False");

	bool_buffer	= XmToggleButtonGetState (*data_type_menu->mask1);
	fprintf (file, "ApplyImage1MaskFlag:	%s\n", bool_buffer? "True": "False");

	bool_buffer	= XmToggleButtonGetState (*data_type_menu->atlas2);
	fprintf (file, "DisplayImage2AtlasFlag:	%s\n", bool_buffer? "True": "False");

	bool_buffer	= XmToggleButtonGetState (*data_type_menu->image2);
	fprintf (file, "DisplayImage2Flag:	%s\n", bool_buffer? "True": "False");

	bool_buffer	= XmToggleButtonGetState (*data_type_menu->mask2);
	fprintf (file, "ApplyImage2MaskFlag:	%s\n", bool_buffer? "True": "False");

	bool_buffer	= XmToggleButtonGetState (*data_type_menu->label);
	fprintf (file, "DisplayLabelFlag:	%s\n", bool_buffer? "True": "False");

	bool_buffer	= XmToggleButtonGetState (*data_type_menu->slice_num_flag);
	fprintf (file, "SliceNumZValueFlag:	%s\n", bool_buffer? "True": "False");

	GetNameFromWidget (data_type_menu->orientation_set, 
				ORIENTATION_NUM, TOGGLE_ATLAS_ORIENT, value); 
	fprintf (file, "AtlasOrientation:	%s\n", value);

	if (!(*slice_number_flag))
	{
		spacing		*= 2; 
		first_slice	= GetSliceCoord (first_slice, atlas_orient, zorigin_image1);
		last_slice	= GetSliceCoord (last_slice, atlas_orient, zorigin_image1);
	}
	fprintf (file, "FirstSlice:		%d\n", first_slice);
	fprintf (file, "LastSlice:		%d\n", last_slice);
	fprintf (file, "Spacing:		%d\n", spacing);

	int_buffer	= GetActiveIndex (default_parameters->mag_scale_menu->mag_set, 
				MAG_NUM);
	if (int_buffer < MAG_NUM - 1)
	{
		sprintf (value, "%.3f", magnify_table [int_buffer]);
	}
	else
	{
		string	= XmTextGetString (*default_parameters->mag_scale_menu->text_mag_any);
		strcpy (value, string);
		XtFree (string);
	}
	fprintf (file, "MagnificationFactor:	%s\n", value);

	GetNameFromWidget (default_parameters->mag_scale_menu->scale_set_image1, 
				SCALE_NUM, TOGGLE_SCALE, value); 
	fprintf (file, "Image1Scale:		%s\n", value);

	bool_buffer	
	= XmToggleButtonGetState (*default_parameters->mag_scale_menu->auto_minmax_image1);
	fprintf (file, "AutoImage1MinMaxFlag:	%s\n", bool_buffer? "True": "False");

	string	= XmTextGetString (*default_parameters->mag_scale_menu->min_text_image1);
	fprintf (file, "Image1Minimum:		%s\n", string);
	XtFree (string);
	string	= XmTextGetString (*default_parameters->mag_scale_menu->max_text_image1);
	fprintf (file, "Image1Maximum:		%s\n", string);
	XtFree (string);

	GetNameFromWidget (default_parameters->mag_scale_menu->scale_set_image2, 
				SCALE_NUM, TOGGLE_SCALE, value); 
	fprintf (file, "Image2Scale:		%s\n", value);

	bool_buffer	
	= XmToggleButtonGetState (*default_parameters->mag_scale_menu->auto_minmax_image2);
	fprintf (file, "AutoImage2MinMaxFlag:	%s\n", bool_buffer? "True": "False");

	string	= XmTextGetString (*default_parameters->mag_scale_menu->min_text_image2);
	fprintf (file, "Image2Minimum:		%s\n", string);
	XtFree (string);
	string	= XmTextGetString (*default_parameters->mag_scale_menu->max_text_image2);
	fprintf (file, "Image2Maximum:		%s\n", string);
	XtFree (string);

	fprintf (file, "AlterRegionSet:		%d\n", cActiveRegionSet + 1);
	fprintf (file, "DisplayRegionSet:	On\n");
	for (i = 0; i < MAX_REGIONSET_NUM; i++)
	{
		fprintf (file, "	%d		%s\n", 
			i + 1, *(region_onoff + i)? "True": "False");
	}

	fprintf (file, "RegionColorSet:		Color\n");
	for (i = 0; i < MAX_REGIONSET_NUM; i++)
	{
		fprintf (file, "	%d		%s\n", 
			i + 1, color_list [*(region_color + i)]);
	}

	fprintf (file, "RegionFillingTypeSet:	Shape\n");
	for (i = 0; i < MAX_REGIONSET_NUM; i++)
	{
		fprintf (file, "	%d		%s\n", 
			i + 1, symbol_names [*(region_type + i)]);
	}

	bool_buffer	= XmToggleButtonGetState (*default_parameters->region_menu->toggle_talairach_region);
	fprintf (file, "TalairachRegionFlag:	%s\n", bool_buffer? "True": "False");

	fprintf (file, "AlterSymbolSet:		%d\n", cActiveAF3DSet + 1);
	fprintf (file, "DisplaySymbolSet:	On\n");
	for (i = 0; i < MAX_AF3DSET_NUM; i++)
	{
		fprintf (file, "	%d		%s\n", 
			i + 1, *(symbol_onoff + i)? "True": "False");
	}

	fprintf (file, "AF3DColorSet:		Color\n");
	for (i = 0; i < MAX_AF3DSET_NUM; i++)
	{
		fprintf (file, "	%d		%s\n", 
			i + 1, color_list [*(symbol_color + i)]);
	}

	fprintf (file, "AF3DSymbolShapeSet:	Shape\n");
	for (i = 0; i < MAX_AF3DSET_NUM; i++)
	{
		fprintf (file, "	%d		%s\n", 
			i + 1, symbol_names [*(symbol_shape + i)]);
	}

	fprintf (file, "AF3DSymbolSizeSet:	Size\n");
	for (i = 0; i < MAX_AF3DSET_NUM; i++)
	{
		fprintf (file, "	%d		%d\n", 
			i + 1, *(symbol_size + i));
	}

	XmScaleGetValue (*symbol_menu->outline_width, &int_buffer);
	fprintf (file, "AF3DSymbolOutlineWidth:	%d\n", int_buffer);

	string	= XmTextGetString (*symbol_menu->text_maximum_distance);
	fprintf (file, "AF3DSymMaximumDistance:	%s\n", string);
	XtFree (string);

	string	= XmTextGetString (*format_screen_menu->format_x);
	fprintf (file, "xFormatedScreen:	%s\n", string); 
	XtFree (string);

	string	= XmTextGetString (*format_screen_menu->format_y);
	fprintf (file, "yFormatedScreen:	%s\n", string); 
	XtFree (string);

	string	= XmTextGetString (*format_screen_menu->format_width);
	fprintf (file, "FormatedScreenWidth:	%s\n", string); 
	XtFree (string);

	string	= XmTextGetString (*format_screen_menu->format_height);
	fprintf (file, "FormatedScreenHeight:	%s\n", string); 
	XtFree (string);

	string	= XmTextGetString (*format_screen_menu->xstart_text_image1);
	fprintf (file, "xImage1StartFormatedSlices:	%s\n", string); 
	XtFree (string);

	string	= XmTextGetString (*format_screen_menu->ystart_text_image1);
	fprintf (file, "yImage1StartFormatedSlices:	%s\n", string); 
	XtFree (string);

	string	= XmTextGetString (*format_screen_menu->xstart_text_image2);
	fprintf (file, "xImage2StartFormatedSlices:	%s\n", string); 
	XtFree (string);

	string	= XmTextGetString (*format_screen_menu->ystart_text_image2);
	fprintf (file, "yImage2StartFormatedSlices:	%s\n", string); 
	XtFree (string);

	string	= XmTextGetString (*format_screen_menu->xoffset_text);
	fprintf (file, "xOffsetFormatedSlices:		%s\n", string); 
	XtFree (string);

	string	= XmTextGetString (*format_screen_menu->yoffset_text);
	fprintf (file, "yOffsetFormatedSlices:		%s\n", string); 
	XtFree (string);

	string	= XmTextGetString (*format_screen_menu->rowxoffset_text);
	fprintf (file, "xRowRowOffsetFormatedSlices:	%s\n", string); 
	XtFree (string);

	string	= XmTextGetString (*format_screen_menu->rowyoffset_text);
	fprintf (file, "yRowRowOffsetFormatedSlices:	%s\n", string); 
	XtFree (string);

	string	= XmTextGetString (*format_screen_menu->label_xstart);
	fprintf (file, "xLabelStartFormatedSlices:	%s\n", string); 
	XtFree (string);

	string	= XmTextGetString (*format_screen_menu->label_ystart);
	fprintf (file, "yLabelStartFormatedSlices:	%s\n", string); 
	XtFree (string);

	bool_buffer	
	= XmToggleButtonGetState (*format_screen_menu->display_order);
	fprintf (file, "ZLowToHighOrder:		%s\n", bool_buffer? "True": "False");

	string	= XmTextGetString (*color_bar_menu->image1_xstart);
	fprintf (file, "xImage1ColorBarStart:		%s\n", string); 
	XtFree (string);

	string	= XmTextGetString (*color_bar_menu->image1_ystart);
	fprintf (file, "yImage1ColorBarStart:		%s\n", string); 
	XtFree (string);

	string	= XmTextGetString (*color_bar_menu->image1_width);
	fprintf (file, "Image1ColorBarLength:		%s\n", string); 
	XtFree (string);

	string	= XmTextGetString (*color_bar_menu->image1_height);
	fprintf (file, "Image1ColorBarWidth:		%s\n", string); 
	XtFree (string);

	bool_buffer	
	= XmToggleButtonGetState (*color_bar_menu->image1_orientation);
	fprintf (file, "Image1ColorBarOrientation:	%s\n", bool_buffer? "True": "False");

	bool_buffer	
	= XmToggleButtonGetState (*color_bar_menu->image1_onoff);
	fprintf (file, "Image1ColorBarOnOff:		%s\n", bool_buffer? "True": "False");

	string	= XmTextGetString (*color_bar_menu->image2_xstart);
	fprintf (file, "xImage2ColorBarStart:		%s\n", string); 
	XtFree (string);

	string	= XmTextGetString (*color_bar_menu->image2_ystart);
	fprintf (file, "yImage2ColorBarStart:		%s\n", string); 
	XtFree (string);

	string	= XmTextGetString (*color_bar_menu->image2_width);
	fprintf (file, "Image2ColorBarLength:		%s\n", string); 
	XtFree (string);

	string	= XmTextGetString (*color_bar_menu->image2_height);
	fprintf (file, "Image2ColorBarWidth:		%s\n", string); 
	XtFree (string);

	bool_buffer	
	= XmToggleButtonGetState (*color_bar_menu->image2_orientation);
	fprintf (file, "Image2ColorBarOrientation:	%s\n", bool_buffer? "True": "False");

	bool_buffer	
	= XmToggleButtonGetState (*color_bar_menu->image2_onoff);
	fprintf (file, "Image2ColorBarOnOff:		%s\n", bool_buffer? "True": "False");

	GetNameFromWidget (default_parameters->back_color_set, 
				MAX_NONIMAGE_COLOR, TOGGLE_COLOR, value); 
	fprintf (file, "BackgroundColor:	%s\n", value);

	GetNameFromWidget (default_parameters->atlas1_color_set, 
				MAX_NONIMAGE_COLOR + 1, TOGGLE_COLOR, value); 
	fprintf (file, "Atlas1Color:		%s\n", value);

	GetNameFromWidget (default_parameters->atlas2_color_set, 
				MAX_NONIMAGE_COLOR + 1, TOGGLE_COLOR, value); 
	fprintf (file, "Atlas2Color:		%s\n", value);

	string	= XmTextGetString (XmSelectionBoxGetChild 
		(*default_parameters->image1_color_box, XmDIALOG_TEXT));
	fprintf (file, "Image1ColorTable:	%s\n", string);
	XtFree (string);

	string	= XmTextGetString (XmSelectionBoxGetChild 
		(*default_parameters->image2_color_box, XmDIALOG_TEXT));
	fprintf (file, "Image2ColorTable:	%s\n", string);
	XtFree (string);

	GetNameFromWidget (default_parameters->label_color_set, 
				MAX_NONIMAGE_COLOR, TOGGLE_COLOR, value); 
	fprintf (file, "LabelColor:		%s\n", value);

	GetNameFromWidget (font_menu->font_color_set, 
				MAX_NONIMAGE_COLOR, TOGGLE_COLOR, value); 
	fprintf (file, "FontColor:		%s\n", value);

	string	= XmTextGetString (*font_menu->font_name);
	fprintf (file, "FontName:		%s\n", string);
	XtFree (string);

	string	= XmTextGetString (*font_menu->size_name);
	fprintf (file, "FontSize:		%s\n", string);
	XtFree (string);

	GetNameFromWidget (font_menu->slant_set, 
				SLANT_NUM, TOGGLE_SLANT, value); 
	fprintf (file, "FontSlant:		%s\n", value);

	GetNameFromWidget (font_menu->weight_set, 
				WEIGHT_NUM, TOGGLE_WEIGHT, value); 
	fprintf (file, "FontWeight:		%s\n", value);

	GetNameFromWidget (font_menu->orient_set, 
				ORIENT_NUM, TOGGLE_ORIENT, value); 
	fprintf (file, "FontOrientation:	%s\n", value);

	XmScaleGetValue (*font_menu->line_spacing, &int_buffer);
	fprintf (file, "TextInterLineSpace:	%d\n", int_buffer);

	GetNameFromWidget (font_menu->alignment_set, 
				ALIGNMENT_NUM, TOGGLE_ALIGN, value); 
	fprintf (file, "TextAlignment:		%s\n", value);

	if (XmToggleButtonGetState (*default_parameters->save_format))
		fprintf (file, "SaveFileFormat:		WindowDump\n");
	else
		fprintf (file, "SaveFileFormat:		PostScript\n");

	if (XmToggleButtonGetState (*default_parameters->save_area))
		fprintf (file, "SaveArea:		EntireWindow\n");
	else
		fprintf (file, "SaveArea:		UserDefined\n");

	fclose (file);
}


/*____________________________________________________________________________	
	Procedure:	GetSliceCoord.	
			slice_num:		slice number.
			atlas_orientation:	atlas orientation, transverse,
						coronal, or sagittal.
			image_zorigin,		zorigin of image.
	Description:	Get the slice coordinate (x, y, or z value) for a slice.
	Return:		slice coordinate.
	Author:		Tom (Tongzeng) Yang
			(05/21/1992)
_____________________________________________________________________________*/

PUBLIC int GetSliceCoord (slice_num, atlas_orientation, image_zorigin)
	short	slice_num;
	char	atlas_orientation;
	int	image_zorigin;
{
	int	atlas_coord;

	if (atlas_orientation == TRANSVERSE)
	{
		atlas_coord	= (int) slice2z (slice_num, image_zorigin);
	}
	else if (atlas_orientation == CORONAL)
	{
		atlas_coord	= SliceY (slice_num);
	}
	else
	{
		atlas_coord	= SliceX (slice_num);
	}

	return	atlas_coord;
}


/*____________________________________________________________________________	
	Procedure:	GetSliceNumber.	
			slice_coord:		slice coordinate, x, y, or z.
			atlas_orientation:	atlas orientation, transverse,
						coronal, or sagittal.
			iamge_zorigin:		zorigin of image.
	Description:	Get the slice number for a slice.
	Return:		slice number.
	Author:		Tom (Tongzeng) Yang
			(05/22/1992)
_____________________________________________________________________________*/

PUBLIC int GetSliceNumber (slice_coord, atlas_orientation, image_zorigin)
	short	slice_coord;
	char	atlas_orientation;
	int	image_zorigin;
{
	int	slice_number;

	if (atlas_orientation == TRANSVERSE)
	{
		slice_number	= z2slice ((float)slice_coord, image_zorigin);
	}
	else if (atlas_orientation == CORONAL)
	{
		slice_number	= YtoSlice (slice_coord);
	}
	else
	{
		slice_number	= XtoSlice (slice_coord);
	}

	return	slice_number;
}


/*____________________________________________________________________________	
	Procedure:	GetPetDimension.	
			atlas_orientation:	atlas orientation, transverse,
						coronal, or sagittal.
			num_slices:		total number of slices.
			slice_width:		pointer to slice width.
			slice_height:		pointer to slice height.
	Description:	Get the image dimension of a pet image.
	Return:		none. 
	Author:		Tom (Tongzeng) Yang
			(05/28/1992)
_____________________________________________________________________________*/

PRIVATE void GetPetDimension (atlas_orient, num_slices, slice_width, slice_height)
	char	atlas_orient;
	short	num_slices;
	int	*slice_width;
	int	*slice_height;
{
	if (atlas_orient == TRANSVERSE)
	{
		*slice_width	= ENCODED_SLICE_WIDTH;
		*slice_height	= ENCODED_SLICE_HEIGHT;
	}
	else if (atlas_orient == CORONAL)
	{
		*slice_width	= ENCODED_SLICE_WIDTH;
		*slice_height	= num_slices;
	}
	else
	{
		*slice_width	= ENCODED_SLICE_HEIGHT;
		*slice_height	= num_slices;
	}
}


/*____________________________________________________________________________	
	Procedure:	GetPetCenter.	
			atlas_orient:	atlas orientation, transverse,
					coronal, or sagittal.
			slice_cx:	pointer to slice center x.
			slice_cy:	pointer to slice center y.
	Description:	Get the image center of a pet image.
	Return:		none. 
	Author:		Tom (Tongzeng) Yang
			(05/28/1992)
_____________________________________________________________________________*/

PRIVATE void GetPetCenter (atlas_orient, slice_cx, slice_cy)
	char	atlas_orient;
	float	*slice_cx;
	float	*slice_cy;
{
	if (atlas_orient == TRANSVERSE)
	{
		*slice_cx	= CX_IMAGE;
		*slice_cy	= CY_IMAGE;
	}
	else if (atlas_orient == CORONAL)
	{
		*slice_cx	= CX_IMAGE;
		*slice_cy	= CZ_IMAGE;
	}
	else
	{
		*slice_cx	= CY_IMAGE;
		*slice_cy	= CZ_IMAGE;
	}
}


/*____________________________________________________________________________	
	Procedure:	SetDefaultAtlas.	
			atlas_orient:	atlas orientation, transverse,
					coronal, or sagittal.
	Description:	Set the default atlas image file as the current atlas image file.
	Return:		None. 
	Author:		Tom (Tongzeng) Yang
			(06/02/1992)
_____________________________________________________________________________*/

PUBLIC void SetDefaultAtlas (atlas_orient, library_path)
	char	atlas_orient;
	char	*library_path;
{
	char	szBuffer [MAXLINE];
	char	atlas_name [MAXLINE];
	char	mask_name [MAXLINE];

	strcpy (szBuffer, szAtlasFileName);
	strcpy (atlas_name, szBuffer);

	if (atlas_orient == TRANSVERSE && strstr (szBuffer, "transverse") == NULL)
	{
		strcpy (atlas_name, library_path);
		if (strstr (szBuffer, "Talairach") == NULL)
		{
			strcat (atlas_name, "HD6");
		}
		else
		{
			strcat (atlas_name, "Talairach");
		}
		strcat (atlas_name, "_transverse.atl");
	}
	else if (atlas_orient == CORONAL && strstr (szBuffer, "coronal") == NULL)
	{
		strcpy (atlas_name, library_path);
		strcat (atlas_name, "Talairach_coronal.atl");
	}
	else if ((atlas_orient == FACING_LEFT || 
			atlas_orient == FACING_RIGHT) 
		&& (strstr (szBuffer, "coronal") != NULL || 
			strstr (szBuffer, "trans") != NULL))
	{
		strcpy (atlas_name, library_path);
		strcat (atlas_name, "Talairach_sagittal.atl");
	}

	if (strcmp (szBuffer, atlas_name) != 0)
	{
		strcpy (szAtlasFileName, atlas_name);
		bAtlasChanged	= TRUE;
		ReadAtlasHeader (atlas_name, library_path);

		strcpy (mask_name, library_path);
		if (strstr (atlas_name, "Talairach") == NULL)
		{
			strcat (mask_name, "HD6.mask");
		}
		else
		{
			strcat (mask_name, "pett6_n99_t88.mask");
		}
		strcpy (szImageMaskFileName, mask_name);
	}
}


/*____________________________________________________________________________	
	Procedure:	ShowCoordinates
			atlas_orient:	atlas orientation, transverse,
					coronal, or sagittal.
	Description:	Show coordinates in the HD6 or Talairach 88 space.
	Return:		None. 
	Author:		Tom (Tongzeng) Yang
			(06/08/1993)
_____________________________________________________________________________*/

PUBLIC void ShowCoordinates (display, window, gc, x, y, current_header, portal_list1, 
	portal_list2, atlas_orient, widget, save)
	Display		*display;
	Window		window;
	GC		gc;
	int		x;
	int		y;
	SCALE_HEADER	*current_header;
	llist		portal_list1;
	llist		portal_list2;
	char		atlas_orient;
	Widget		widget;
	BOOLEAN		save;
{
	Arg		arglist [1];
	FILE		*logfp;
	GC		mygc;
	Portal		*best_portal;
	Portal		*best_portal1;
	Portal		*best_portal2;
	Portal		*portal;
	SliceData	*slice;
	XmString	xmstring_buffer;
	char		*coordinates_file = szCoordinatesFileName;
	char		*image1_filename = szImage1FileName;
	char		*image2_filename = szImage2FileName;
	char		short_filename1 [MAXLINE];
	char		short_filename2 [MAXLINE];
	char		*string;
	char		szBuffer [MAXLINE];
	double		best_distance;
	double		best_distance1;
	double		best_distance2;
	double		distance;
	double		product;
	int		ax;
	int		ay;
	int		az;
	int		cx;
	int		cy;
	int		n;
	int		screen;
	int		tempx;
	int		tempy;
	int		xyz;
	llist		tracking_list;
	unsigned long	border_foreground;

	best_distance1	= (float) MAXSHORT;
	if (llsize (portal_list1) > 0)
	{
		llhead (portal_list1);
	    	do 
	    	{
			portal	= (Portal *) llretrieve (portal_list1);
			slice	= portal->slice;
			if (slice->atlas_index >= 0)
			{
				cx		= portal->xold + current_header->centerx;
				cy		= portal->yold + current_header->centery;
				product		= ((double)x - cx) * (x - cx) 
						+ ((double)y - cy) * (y - cy);
				distance	= sqrt (product);
				if (distance < best_distance1)
				{
					best_distance1	= distance;
					best_portal1	= portal;
				}
			}
		} while (llnext (portal_list1) != FAIL);
	}

	best_distance2	= (float) MAXSHORT;
	if (llsize (portal_list2) > 0)
	{
		llhead (portal_list2);
	    	do 
	    	{
			portal	= (Portal *) llretrieve (portal_list2);
			slice	= portal->slice;
			if (slice->atlas_index >= 0)
			{
				cx		= portal->xold + current_header->centerx;
				cy		= portal->yold + current_header->centery;
				product		= ((double)x - cx) * (x - cx) 
						+ ((double)y - cy) * (y - cy);
				distance	= sqrt (product);
				if (distance < best_distance2)
				{
					best_distance2	= distance;
					best_portal2	= portal;
				}
			}
		} while (llnext (portal_list2) != FAIL);
	}

	if (best_distance2 < best_distance1)
	{
		best_distance	= best_distance2;
		best_portal	= best_portal2;
		tracking_list	= portal_list1;
	}
	else
	{
		best_distance	= best_distance1;
		best_portal	= best_portal1;
		tracking_list	= portal_list2;
	}

	if (best_distance < (float) MAXSHORT)
	{
		tempx	= best_portal->xold;
		if (atlas_orient == FACING_RIGHT)
		{
			tempx	-= current_header->centerx 
				+ (current_header->centerx - current_header->width + 1);
		}
		cx	= tempx + current_header->centerx;
		cy	= best_portal->yold + current_header->centery;
		slice	= best_portal->slice;

		tempx	= ROUND ((x - cx) * current_header->pixel_size * (-1.0));
		tempy	= ROUND ((y - cy) * current_header->pixel_size * (-1.0));
		xyz	= slice->slice_xyz;

		if (atlas_orient == TRANSVERSE)
		{
			ax	= tempx;
			ay	= tempy;
			az	= xyz;
		}
		else if (atlas_orient == CORONAL)
		{
			ax	= tempx;
			ay	= xyz;
			az	= tempy;
		}
		else if (atlas_orient == FACING_LEFT)
		{
			ax	= xyz;
			ay	= tempx;
			az	= tempy;
		}
		else
		{
			ax	= xyz;
			ay	= -tempx;
			az	= tempy;
		}
	}
	else
	{
		ax	= x;
		ay	= y;
		az	= 0;
	}

	tempx	= x - cx;
	tempy	= y - cy;

	if (llsize (tracking_list) > 0)
	{
		llhead (tracking_list);
    		do 
    		{
			portal	= (Portal *) llretrieve (tracking_list);
			slice	= portal->slice;
			if (slice->slice_xyz == xyz)
			{
				cx	= portal->xold + current_header->centerx;
				cy	= portal->yold + current_header->centery;
				tempx	+= cx;
				tempy	+= cy;

				/*
				XSetForeground (display, mygc, 0xffffffff);
				mygc	= GetXorGC (display, window);
				DrawSymbol (display, window, gc, 
					tempx - 25, tempy - 25, 50, 50, FILLED_DIAMOND);

				XSetForeground (display, mygc, 0);
				*/
				DrawSymbol (display, window, gc, tempx, tempy, 50, 50, CROSSHAIR);
				DrawSymbol (display, window, gc, 
					tempx - 25, tempy - 25, 50, 50, DIAMOND);
				/*
				XSetForeground (display, mygc, 0xffffffff);
				*/
			}
		} while (llnext (tracking_list) != FAIL);

		if (save)
		{
			DrawSymbol (display, window, gc, x, y, 50, 50, CROSSHAIR);
			DrawSymbol (display, window, gc, x - 25, y - 25, 50, 50, DIAMOND);
		}
	}

	if (atlas_orient == TRANSVERSE || atlas_orient == CORONAL)
	{
		ax	*= -1;
	}

	/*
	 * If atlas is in Talairach 88 space, do transformation.
	 */
	/*
	if (bTalairachFlag)
	{
		hd6tot88 (&ax, &ay, &az);
	}
	*/

	/*
	 * Create string and Motif string.
	 */
	string		= strrchr (image1_filename, '/');
	if (string != NULL)
		strcpy (short_filename1, string + 1);
	else if (strlen (image1_filename) > 0)
		strcpy (short_filename1, image1_filename);
	else
		strcpy (short_filename1, "NULL");

	string		= strrchr (image2_filename, '/');
	if (string != NULL)
		strcpy (short_filename2, string + 1);
	else if (strlen (image2_filename) > 0)
		strcpy (short_filename2, image2_filename);
	else
		strcpy (short_filename2, "NULL");

	bzero (szBuffer, MAXLINE);
	sprintf (szBuffer, "(%d, %d, %d)     ", ax, ay, az);
	strcpy (szAtlasCoordinate, szBuffer);
	strcat (szBuffer, "          Image 1:  ");
	strcat (szBuffer, short_filename1);
	strcat (szBuffer, "    Image 2:  ");
	strcat (szBuffer, short_filename2);
	xmstring_buffer	= XmStringCreate (szBuffer, XmSTRING_DEFAULT_CHARSET); 

	/*
	 * Display Motif string on menu bar.
	 */
	n	= 0;
	XtSetArg (arglist [n], XmNlabelString, xmstring_buffer); n++;
	XtSetValues (widget, arglist, n);
	free (xmstring_buffer);

	if (save && strlen (coordinates_file) > 0)
	{
		logfp	= fopen (coordinates_file, "a");
		if (logfp == (FILE *) NULL)
		{
			fprintf (stderr, "Error in opening log file %s\n", coordinates_file);
			return;
		}
		fprintf (logfp, "%d      %d      %d\n", ax, ay, az);
		fprintf (logfp, "Atlas File:     %s\n", szAtlasFileName);
		if (strlen (image1_filename) > 0)
			fprintf (logfp, "Image 1: %s\n", image1_filename);
		if (strlen (image2_filename) > 0)
			fprintf (logfp, "Image 2: %s\n", image2_filename);
		fprintf (logfp, "\n");

		fclose (logfp);
	}
}


PUBLIC GC GetXorGC (display, window)
	Display	*display;
	Window	window;
{
	GC		gc;
	int		screen;
	unsigned long	mask;

	screen	= DefaultScreen (display);
	mask	= BlackPixel (display, screen) ^ WhitePixel (display, screen);	

	gc	= XCreateGC (display, window, 0, 0);
	XSetForeground (display, gc, 0xffffffff);
	XSetBackground (display, gc, 0);
	XSetFunction (display, gc, GXxor);
	XSetPlaneMask (display, gc, mask);

	return gc;
}
@


2.37
log
@Fixed the coronal and sagittal offset bug.
@
text
@d1 1
a1 1
/*$Id: portal.c,v 2.36 1995/09/08 21:40:44 ty7777 Exp ty7777 $*/
d3 3
d329 1
a329 1
/*$Header: /data/petsun4/src/view25d/RCS/portal.c,v 2.36 1995/09/08 21:40:44 ty7777 Exp ty7777 $*/
d335 1
a335 1
static char rcsid [] = "$Header: /data/petsun4/src/view25d/RCS/portal.c,v 2.36 1995/09/08 21:40:44 ty7777 Exp ty7777 $";
d3044 1
a3044 2
	if (*draw_portal_data->display_label_flag
	&& (!overlay || overlay && (image1_flag || image2_flag)))
@


2.36
log
@Updated to introduce atlas 2.
@
text
@d1 1
a1 1
/*$Id: portal.c,v 2.35 1995/09/07 17:04:13 ty7777 Exp ty7777 $*/
d3 3
d326 1
a326 1
/*$Header: /data/petsun4/src/view25d/RCS/portal.c,v 2.35 1995/09/07 17:04:13 ty7777 Exp ty7777 $*/
d332 1
a332 1
static char rcsid [] = "$Header: /data/petsun4/src/view25d/RCS/portal.c,v 2.35 1995/09/07 17:04:13 ty7777 Exp ty7777 $";
d382 1
a382 1
#include <petutil/matrix.h>
d3042 1
a3042 1
	&& (!overlay || overlay && image1_flag))
d3484 4
a3487 1
		image2_slice_offset	= zorigin_image2 - zorigin_image1;
@


2.35
log
@Deleted error message.
@
text
@d1 1
a1 1
/*$Id: portal.c,v 2.34 1995/09/07 16:55:05 ty7777 Exp ty7777 $*/
d3 3
d323 1
a323 1
/*$Header: /data/petsun4/src/view25d/RCS/portal.c,v 2.34 1995/09/07 16:55:05 ty7777 Exp ty7777 $*/
d329 1
a329 1
static char rcsid [] = "$Header: /data/petsun4/src/view25d/RCS/portal.c,v 2.34 1995/09/07 16:55:05 ty7777 Exp ty7777 $";
d2882 4
a2885 1
	    	XSetForeground (display, gc, ATLAS_CELL);
d5650 2
a5651 1
			if (strcmp (label, "AtlasColor:") == 0)
d5655 1
a5655 1
				XtSetValues (GetActiveWidget (default_parameters->atlas_color_set, 
d5659 1
a5659 1
				= GetWidgetFromName (default_parameters->atlas_color_set,
d5669 18
d6405 1
a6405 1
	GetNameFromWidget (default_parameters->atlas_color_set, 
d6407 5
a6411 1
	fprintf (file, "AtlasColor:		%s\n", value);
@


2.34
log
@Fixed the crash in RedrawPortals.
@
text
@d1 1
a1 1
/*$Id: portal.c,v 2.33 1995/08/31 20:18:38 ty7777 Exp ty7777 $*/
d3 3
d320 1
a320 1
/*$Header: /data/petsun4/src/view25d/RCS/portal.c,v 2.33 1995/08/31 20:18:38 ty7777 Exp ty7777 $*/
d326 1
a326 1
static char rcsid [] = "$Header: /data/petsun4/src/view25d/RCS/portal.c,v 2.33 1995/08/31 20:18:38 ty7777 Exp ty7777 $";
a3475 2
printf ("zorigin 1 = %d zorigin 2 = %d offset = %d\n", 
	zorigin_image1, zorigin_image2, image2_slice_offset); 
@


2.33
log
@Before watch cursor works.
@
text
@d1 1
a1 1
/*$Id: portal.c,v 2.32 1995/08/29 16:46:37 ty7777 Exp ty7777 $*/
d3 3
d317 1
a317 1
/*$Header: /data/petsun4/src/view25d/RCS/portal.c,v 2.32 1995/08/29 16:46:37 ty7777 Exp ty7777 $*/
d323 1
a323 1
static char rcsid [] = "$Header: /data/petsun4/src/view25d/RCS/portal.c,v 2.32 1995/08/29 16:46:37 ty7777 Exp ty7777 $";
d3169 1
a3169 1
	Arguments:	portal_list1:		portal linked list.
d3177 3
a3179 3
PUBLIC void ClearData (portal_list1, atlas_list1)
llist		atlas_list1;
llist		portal_list1;
d3185 1
a3185 1
	 * Clear portal_list1 data. 
d3187 2
a3188 2
	llhead (portal_list1);			/* step through portal list */
	while (llsize (portal_list1) > 0) 
d3190 1
a3190 1
		portal	= (Portal *) llretrieve (portal_list1);
d3202 1
a3202 1
		lldelete (portal_list1);
d3208 2
a3209 2
	llhead (atlas_list1);			/* step through the atlas list */
	while (llsize (atlas_list1) > 0)
d3214 1
a3214 1
		slice = (SliceData *) llretrieve (atlas_list1);
d3220 1
a3220 1
		lldelete (atlas_list1);
d3473 2
d3502 2
a3503 1
		if (input_node != INPUT_SAME)
d3507 1
d3509 1
d3513 1
d3537 1
a3537 1
		if (input_node != INPUT_SAME)
a5163 2
			ErrorCheckMinMax (*image1_value_flag, min_value_image1, max_value_image1);

a5214 2
			ErrorCheckMinMax (*image2_value_flag, min_value_image2, max_value_image2);

d5904 3
d6188 1
a6188 1
	fprintf (file, "Image2Maximum:		%s\n", string);
@


2.32
log
@Added mutual tracking.
@
text
@d1 1
a1 1
/*$Id: portal.c,v 2.31 1995/08/29 15:52:58 ty7777 Exp ty7777 $*/
d3 3
d314 1
a314 1
/*$Header: /data/petsun4/src/view25d/RCS/portal.c,v 2.31 1995/08/29 15:52:58 ty7777 Exp ty7777 $*/
d320 1
a320 1
static char rcsid [] = "$Header: /data/petsun4/src/view25d/RCS/portal.c,v 2.31 1995/08/29 15:52:58 ty7777 Exp ty7777 $";
d399 1
d2329 3
a2331 3
		atlas_orient, display_image_flag, xstart, ystart, auto_image_value_flag,
		image_value_flag, colorbar_xstart, colorbar_ystart, colorbar_width,
		colorbar_length, hori_colorbar, colorbar_onoff, color_table_name,
d2340 1
d2414 1
a2414 1
		draw_portal_data.display_atlas_flag	= &bDisplayAtlas;
d3507 2
a3508 2
			atlas_orient, &bDisplayImage2, nxImage2Start, nyImage2Start,
			bAutoImage2ValueFlag, cImage2ValueFlag, nxImage2ColorBarStart,
d3538 2
a3539 2
			atlas_orient, &bDisplayImage1, nxImage1Start, nyImage1Start,
			bAutoImage1ValueFlag, cImage1ValueFlag, nxImage1ColorBarStart,
d4892 2
a4893 1
			if (strcmp (label, "DisplayAtlasFlag:") == 0)
d4900 2
a4901 2
				SetSelectData (*data_type_menu->atlas, bool_buffer);
				bDisplayAtlas	= bool_buffer;
d4906 13
a6111 3
	bool_buffer	= XmToggleButtonGetState (*data_type_menu->atlas);
	fprintf (file, "DisplayAtlasFlag:	%s\n", bool_buffer? "True": "False");

d6116 3
d6125 3
d6672 1
d6697 1
d6702 1
d6829 9
d6841 3
d6923 21
@


2.31
log
@After z0 works correctly.
@
text
@d1 1
a1 1
/*$Id: portal.c,v 2.30 1995/08/28 21:09:23 ty7777 Exp ty7777 $*/
d3 3
d311 1
a311 1
/*$Header: /data/petsun4/src/view25d/RCS/portal.c,v 2.30 1995/08/28 21:09:23 ty7777 Exp ty7777 $*/
d317 1
a317 1
static char rcsid [] = "$Header: /data/petsun4/src/view25d/RCS/portal.c,v 2.30 1995/08/28 21:09:23 ty7777 Exp ty7777 $";
d6651 2
d6658 1
d6664 2
a6674 1
	int		tempx1;
a6675 1
	int		tempy1;
d6677 1
a6677 1
	int		xyz1;
d6679 1
a6681 1
		best_distance	= (float) MAXSHORT;
d6694 1
a6694 1
				if (distance < best_distance)
d6696 2
a6697 2
					best_distance	= distance;
					best_portal	= portal;
d6701 1
d6703 9
a6711 4
		if (best_distance < (float) MAXSHORT)
		{
			tempx	= best_portal->xold;
			if (atlas_orient == FACING_RIGHT)
d6713 10
a6722 2
				tempx	-= current_header->centerx 
					+ (current_header->centerx - current_header->width + 1);
d6724 2
a6725 3
			cx	= tempx + current_header->centerx;
			cy	= best_portal->yold + current_header->centery;
			slice	= best_portal->slice;
d6727 12
a6738 3
			tempx	= ROUND ((x - cx) * current_header->pixel_size * (-1.0));
			tempy	= ROUND ((y - cy) * current_header->pixel_size * (-1.0));
			xyz	= slice->slice_xyz;
d6740 7
a6746 24
			if (atlas_orient == TRANSVERSE)
			{
				ax	= tempx;
				ay	= tempy;
				az	= xyz;
			}
			else if (atlas_orient == CORONAL)
			{
				ax	= tempx;
				ay	= xyz;
				az	= tempy;
			}
			else if (atlas_orient == FACING_LEFT)
			{
				ax	= xyz;
				ay	= tempx;
				az	= tempy;
			}
			else
			{
				ax	= xyz;
				ay	= -tempx;
				az	= tempy;
			}
d6748 3
d6752 3
a6754 2
		tempx	= x - cx;
		tempy	= y - cy;
d6756 1
a6756 1
		if (llsize (portal_list2) > 0)
d6758 3
a6760 22
			llhead (portal_list2);
	    		do 
	    		{
				portal	= (Portal *) llretrieve (portal_list2);
				slice	= portal->slice;
				if (slice->slice_xyz == xyz)
				{
					cx	= portal->xold + current_header->centerx;
					cy	= portal->yold + current_header->centery;
					tempx	+= cx;
					tempy	+= cy;
					DrawSymbol (display, window, gc, tempx, tempy, 50, 50, CROSSHAIR);
					DrawSymbol (display, window, gc, 
						tempx - 25, tempy - 25, 50, 50, DIAMOND);
				}
			} while (llnext (portal_list2) != FAIL);

			if (save)
			{
				DrawSymbol (display, window, gc, x, y, 50, 50, CROSSHAIR);
				DrawSymbol (display, window, gc, x - 25, y - 25, 50, 50, DIAMOND);
			}
d6762 18
d6788 29
d6835 1
a6835 1
	string		= strrchr (szImage1FileName, '/');
d6838 2
a6839 2
	else if (strlen (szImage1FileName) > 0)
		strcpy (short_filename1, szImage1FileName);
d6843 1
a6843 1
	string		= strrchr (szImage2FileName, '/');
d6846 2
a6847 2
	else if (strlen (szImage2FileName) > 0)
		strcpy (short_filename2, szImage2FileName);
d6879 3
a6881 1
			fprintf (logfp, "Pet Image File: %s\n", szImage1FileName);
@


2.30
log
@After color bar works.
@
text
@d1 1
a1 1
/*$Id: portal.c,v 2.29 1995/08/28 15:38:46 ty7777 Exp ty7777 $*/
d3 3
d308 1
a308 1
/*$Header: /data/petsun4/src/view25d/RCS/portal.c,v 2.29 1995/08/28 15:38:46 ty7777 Exp ty7777 $*/
d314 1
a314 1
static char rcsid [] = "$Header: /data/petsun4/src/view25d/RCS/portal.c,v 2.29 1995/08/28 15:38:46 ty7777 Exp ty7777 $";
a979 1
	char		*image2_filename	= szImage2FileName;
d986 1
a986 2
	int		index_image1;
	int		index_image2;
d1060 1
a1060 1
		slice2->slice_xyz	= GetSliceCoord (desired_slice, atlas_orient, zorigin_image2);
d1063 1
a1063 2
			index_image1	= desired_slice - 1 + (DEFAULT_ZORIGIN - zorigin_image1);
			index_image2	= desired_slice - 1 + (DEFAULT_ZORIGIN - zorigin_image2);
d1065 2
a1066 8
			if ((index_image1 < min_index_num && desired_slice >= 1) 
			|| (index_image1 > max_index_num && desired_slice <= MAX_TRANS_ATLAS_NUM))
			{
				index_image1	= max_index_num;
			}

			if ((index_image2 < min_index_num && desired_slice >= 1) 
			|| (index_image2 > max_index_num && desired_slice <= MAX_TRANS_ATLAS_NUM))
d1068 1
a1068 1
				index_image2	= max_index_num;
d1073 1
a1073 2
			index_image1	= desired_slice - 1;
			index_image2	= desired_slice - 1;
d1076 1
a1076 1
		if (index_image1 < min_index_num || index_image1 > max_index_num)
d1079 2
a1080 2
			"The image 1 index %d is outside the range [%d, %d].\n", 
				index_image1, min_index_num, max_index_num);
d1084 1
a1084 1
		if (index_image2 < min_index_num || index_image2 > max_index_num)
d1086 1
a1086 4
			fprintf (stderr, 
			"The image 2 index %d is outside the range [%d, %d].\n", 
				index_image2, min_index_num, max_index_num);
			exit (0);
a1087 5

		if (index_image1 < default_max_index_num)
		{
			slice1->atlas_index	= atlas_header->index_table [index_image1];
		}
d1092 1
a1093 9
		if (index_image2 < default_max_index_num)
		{
			slice2->atlas_index	= atlas_header->index_table [index_image2];
		}
		else
		{
			slice2->atlas_index	= -1;
		}

d3418 1
d3461 4
a3464 2
		InputImageData (current_header, szImage2FileName, atlas_list2, first_slice, 
			last_slice, spacing, zorigin_image2, bApplyMask2, &nAutoMinImage2Value, 
@


2.29
log
@Before adding mutual image1 and image2 point display.
@
text
@d1 1
a1 1
/*$Id: portal.c,v 2.28 1995/08/22 16:51:58 ty7777 Exp ty7777 $*/
d3 3
d305 1
a305 1
/*$Header: /data/petsun4/src/view25d/RCS/portal.c,v 2.28 1995/08/22 16:51:58 ty7777 Exp ty7777 $*/
d311 1
a311 1
static char rcsid [] = "$Header: /data/petsun4/src/view25d/RCS/portal.c,v 2.28 1995/08/22 16:51:58 ty7777 Exp ty7777 $";
d2347 3
a2349 1
		colorbar_length, hori_colorbar, colorbar_onoff, image1_flag, image_zorigin, overlay)
d2367 5
d2719 1
a2719 1
				image_value_flag, szImage1ColorTableName, image1_flag); 
d2726 2
a2727 1
				image_value_flag);
d3522 3
a3524 2
			bImage2HorizontalColorBar, bImage2ColorBarOnOff, FALSE, 
			zorigin_image2, overlay);
d3553 3
a3555 2
			bImage1HorizontalColorBar, bImage1ColorBarOnOff, TRUE, 
			zorigin_image1, overlay);
d3770 1
a3770 1
PUBLIC void DrawColorBarText (display, window, gc, min_pet_value, max_pet_value, 
d3772 2
a3773 1
	colorbar_width, clear_flag, auto_image_value_flag, image_value_flag)
d3777 2
a3778 2
short		*min_pet_value;
short		*max_pet_value;
d3788 4
d3793 1
a3797 1
	XCharStruct	overall;
a3801 6
	short		min_value;
	short		max_value;
	BOOLEAN		*color_bar_exist;
	XRectangle	*color_bar_min;
	XRectangle	*color_bar_middle;
	XRectangle	*color_bar_max;
d3803 1
a3803 4
	color_bar_exist		= &bColorBarExist;
	color_bar_min		= &rectColorBarMin;
	color_bar_middle	= &rectColorBarMiddle;
	color_bar_max		= &rectColorBarMax;
d3805 1
a3805 5
	RegularMinMax (auto_image_value_flag, image_value_flag, min_pet_value, max_pet_value);
	min_value	= *min_pet_value;
	max_value	= *max_pet_value;

	sprintf (stringbuf, "%d", min_value);
d3839 1
a3839 1
	sprintf (stringbuf, "%d", (min_value + max_value) / 2);
d3870 1
a3870 1
	sprintf (stringbuf, "%d", max_value);
@


2.28
log
@Before doing anything else.
@
text
@d1 1
a1 1
/*$Id: portal.c,v 2.27 1995/08/02 16:49:48 ty7777 Exp ty7777 $*/
d3 3
d302 1
a302 1
/*$Header: /data/petsun4/src/view25d/RCS/portal.c,v 2.27 1995/08/02 16:49:48 ty7777 Exp ty7777 $*/
d308 1
a308 1
static char rcsid [] = "$Header: /data/petsun4/src/view25d/RCS/portal.c,v 2.27 1995/08/02 16:49:48 ty7777 Exp ty7777 $";
d386 1
d981 2
a982 1
	int		index;
d1055 2
a1056 2
		slice1->slice_xyz	= GetSliceCoord (desired_slice, atlas_orient);
		slice2->slice_xyz	= slice1->slice_xyz;
d1059 14
a1072 4
			index	= desired_slice - 1 + (DEFAULT_ZORIGIN - zorigin);
			if ((index < min_index_num && desired_slice >= 1) 
			|| (index > max_index_num && desired_slice <= MAX_TRANS_ATLAS_NUM))
				index	= max_index_num;
d1076 2
a1077 1
			index	= desired_slice - 1;
d1079 2
a1080 1
		if (index < min_index_num || index > max_index_num)
d1083 2
a1084 2
			"The index %d is outside the range [%d, %d].\n", 
				index, min_index_num, max_index_num);
d1088 1
a1088 1
		if (index < default_max_index_num)
d1090 4
a1093 2
			slice1->atlas_index	= atlas_header->index_table [index];
			slice2->atlas_index	= atlas_header->index_table [index];
d1095 5
d1103 8
d1113 1
d1136 1
a1136 1
	spacing, apply_mask, auto_min_image_value, auto_max_image_value)
d1143 1
a1170 1
	int		*pzorigin	= &zorigin;
d1290 1
a1290 1
	zorigin_offset	= mask_zorigin - *pzorigin;
d1506 1
a1506 1
				slice->pet_ystart	+= DEFAULT_ZORIGIN - zorigin;
d2031 1
a2031 1
		region_data->z			= (int) slice2z (slice_index, zorigin);
d2344 1
a2344 1
		colorbar_length, hori_colorbar, image1_flag, overlay)
d2361 1
d2363 1
d2517 1
a2517 1
					GetSliceNumber (slice->slice_xyz, atlas_orient)); 
d2705 1
a2705 1
		if (*draw_portal_data.display_pet_flag && pet_exist)
d3260 1
a3260 1
			atlas_list1:	lineked atlas list for image1.
d3265 1
d3271 2
a3272 2
PUBLIC void GetFileStatus (atlas_list1, first_slice, last_slice, spacing, input_node)
llist	atlas_list1;
d3276 1
d3284 1
a3284 1
	size = llsize (atlas_list1);
d3289 2
a3290 2
			llhead (atlas_list1);
			slice = llretrieve (atlas_list1);			
d3297 1
a3297 1
			if (slice->slice_xyz != GetSliceCoord (*last_slice, atlas_orient))
d3303 4
a3306 3
				lltail (atlas_list1);
				slice = llretrieve (atlas_list1);			
				if (slice->slice_xyz != GetSliceCoord (first_slice, atlas_orient))
d3417 1
a3417 1
	BOOLEAN		*z0_changed	= &bZoriginChanged;
d3447 1
a3447 2
		GetFileStatus (atlas_list1, first_slice, &last_slice, 
						spacing, &input_node);
d3466 2
a3467 1
			last_slice, spacing, bApplyMask1, &nAutoMinImage1Value, &nAutoMaxImage1Value);
d3473 2
a3474 1
			last_slice, spacing, bApplyMask2, &nAutoMinImage2Value, &nAutoMaxImage2Value);
d3511 2
a3512 1
			bImage2HorizontalColorBar, FALSE, overlay);
d3541 2
a3542 1
			bImage1HorizontalColorBar, TRUE, overlay);
d4791 2
a4792 1
	BOOLEAN			*color_bar_orient	= &bImage1HorizontalColorBar;
d4794 2
d4817 2
a4818 1
	char			*color_table_name	= szImage1ColorTableName;
d4841 4
a4844 2
	short			*color_bar_length	= &nImage1ColorBarLength;
	short			*color_bar_width	= &nImage1ColorBarWidth;
d4853 4
a4856 2
	short			*xcolor_bar		= &nxImage1ColorBarStart;
	short			*ycolor_bar		= &nyImage1ColorBarStart;
d5036 2
a5037 1
					*first_slice	= GetSliceNumber (*first_slice, *atlas_orient);
d5049 2
a5050 1
					*last_slice	= GetSliceNumber (*last_slice, *atlas_orient);
d5495 1
a5495 1
				*xcolor_bar	= atoi (value);
d5504 1
a5504 1
				*ycolor_bar	= atoi (value);
d5513 1
a5513 1
				*color_bar_width	= atoi (value);
d5522 1
a5522 1
				*color_bar_length	= atoi (value);
d5537 1
a5537 1
				*color_bar_orient	= bool_buffer;
d5542 71
d5654 1
a5654 1
				= XmSelectionBoxGetChild (*default_parameters->pet_color_box, 
d5659 2
a5660 2
				strcpy (color_table_name, default_parameters->library_path);
				strcat (color_table_name, value);
d5665 15
d5941 5
a5945 5
	nxImage1OldColorBar		= *xcolor_bar; 
	nyImage1OldColorBar		= *ycolor_bar; 
	nImage1OldColorBarLength	= *color_bar_length; 
	nImage1OldColorBarWidth		= *color_bar_width; 
	bImage1OldHoriColorBar		= *color_bar_orient;
d5947 6
d6113 1
a6113 1
	fprintf (file, "DisplayImage1Flag:		%s\n", bool_buffer? "True": "False");
d6116 1
a6116 1
	fprintf (file, "ApplyImage1MaskFlag:		%s\n", bool_buffer? "True": "False");
d6119 1
a6119 1
	fprintf (file, "DisplayImage2Flag:		%s\n", bool_buffer? "True": "False");
d6122 1
a6122 1
	fprintf (file, "ApplyImage2MaskFlag:		%s\n", bool_buffer? "True": "False");
d6137 2
a6138 2
		first_slice	= GetSliceCoord (first_slice, atlas_orient);
		last_slice	= GetSliceCoord (last_slice, atlas_orient);
d6282 1
a6282 1
	fprintf (file, "xOffsetFormatedSlices:	%s\n", string); 
d6286 1
a6286 1
	fprintf (file, "yOffsetFormatedSlices:	%s\n", string); 
d6307 1
a6307 1
	fprintf (file, "ZLowToHighOrder:	%s\n", bool_buffer? "True": "False");
d6329 28
d6366 2
a6367 2
		(*default_parameters->pet_color_box, XmDIALOG_TEXT));
	fprintf (file, "Image1ColorTable:		%s\n", string);
d6370 5
d6429 1
d6436 1
a6436 1
PUBLIC int GetSliceCoord (slice_num, atlas_orientation)
d6439 1
d6445 1
a6445 1
		atlas_coord	= (int) slice2z (slice_num, zorigin);
d6465 1
d6472 1
a6472 1
PUBLIC int GetSliceNumber (slice_coord, atlas_orientation)
d6475 1
d6481 1
a6481 1
		slice_number	= z2slice ((float)slice_coord, zorigin);
@


2.27
log
@Tracking works.
@
text
@d1 1
a1 1
/*$Id: portal.c,v 2.26 1995/07/31 15:10:38 ty7777 Exp ty7777 $*/
d3 3
d299 1
a299 1
/*$Header: /data/petsun4/src/view25d/RCS/portal.c,v 2.26 1995/07/31 15:10:38 ty7777 Exp ty7777 $*/
d305 1
a305 1
static char rcsid [] = "$Header: /data/petsun4/src/view25d/RCS/portal.c,v 2.26 1995/07/31 15:10:38 ty7777 Exp ty7777 $";
d911 1
a911 1
	if (*current_mag == 0.25)
d913 1
a913 1
	else if (*current_mag == 0.50)
d915 1
a915 1
	else if (*current_mag == 1.00)
d1051 1
a1051 1
		slice2->slice_xyz	= GetSliceCoord (desired_slice, atlas_orient);
d1664 2
a1665 2
		if (pkg_abs (ifhdr.scaling_factor [i] - ifhdr_mask.scaling_factor [i]) > ERROR_BOUND
		|| pkg_abs (ifhdr.scaling_factor [j] - ifhdr_mask.scaling_factor [j]) > ERROR_BOUND)
d1742 1
a1742 1
						if (pkg_abs (mask_slice_data [i]) <= ERROR_BOUND)
d1754 1
a1754 1
							* slice_width + i]) <= ERROR_BOUND)
d4792 2
d5025 6
a5030 1
				dSliceMagnification	= atof (value);
@


2.26
log
@Before work on tracking.
@
text
@d1 1
a1 1
/*$Id: portal.c,v 2.25 1995/07/27 19:55:14 ty7777 Exp ty7777 $*/
d3 3
d296 1
a296 1
/*$Header: /data/petsun4/src/view25d/RCS/portal.c,v 2.25 1995/07/27 19:55:14 ty7777 Exp ty7777 $*/
d302 1
a302 1
static char rcsid [] = "$Header: /data/petsun4/src/view25d/RCS/portal.c,v 2.25 1995/07/27 19:55:14 ty7777 Exp ty7777 $";
d6451 1
a6451 1
	Return:		none. 
d6456 5
a6460 1
PUBLIC void ShowCoordinates (x, y, current_header, portal_list1, atlas_orient, widget, save)
d6465 1
d6492 1
d6494 1
d6496 1
d6560 29
@


2.25
log
@Draw atlas only for image1 when there is overlay.
@
text
@d1 1
a1 1
/*$Id: portal.c,v 2.24 1995/07/26 20:41:17 ty7777 Exp ty7777 $*/
d3 3
d293 1
a293 1
/*$Header: /data/petsun4/src/view25d/RCS/portal.c,v 2.24 1995/07/26 20:41:17 ty7777 Exp ty7777 $*/
d299 1
a299 1
static char rcsid [] = "$Header: /data/petsun4/src/view25d/RCS/portal.c,v 2.24 1995/07/26 20:41:17 ty7777 Exp ty7777 $";
a6467 1
	char		szBuffer [MAXLINE];
d6470 4
d6577 16
d6596 4
a6599 1
	strcat (szBuffer, szImage1FileName);
@


2.24
log
@Made image overlay work.
@
text
@d1 1
a1 1
/*$Id: portal.c,v 2.23 1995/07/25 16:12:08 ty7777 Exp ty7777 $*/
d3 3
d290 1
a290 1
/*$Header: /data/petsun4/src/view25d/RCS/portal.c,v 2.23 1995/07/25 16:12:08 ty7777 Exp ty7777 $*/
d296 1
a296 1
static char rcsid [] = "$Header: /data/petsun4/src/view25d/RCS/portal.c,v 2.23 1995/07/25 16:12:08 ty7777 Exp ty7777 $";
d2704 1
d2808 1
d2816 1
a2816 1
					if (ColorPixel != PET_BACK_VALUE + PET_COLOR_START)
d3438 5
d3463 1
a3463 1
			bImage2HorizontalColorBar, FALSE, FALSE);
a3487 4
		if (nxImage1Start == nxImage2Start && nyImage1Start == nyImage2Start)
			overlay	= TRUE;
		else
			overlay	= FALSE;
@


2.23
log
@Fixed the offset problem for Image 2.
@
text
@d1 1
a1 1
/*$Id: portal.c,v 2.22 1995/07/24 20:28:17 ty7777 Exp ty7777 $*/
d3 3
d287 1
a287 1
/*$Header: /data/petsun4/src/view25d/RCS/portal.c,v 2.22 1995/07/24 20:28:17 ty7777 Exp ty7777 $*/
d293 1
a293 1
static char rcsid [] = "$Header: /data/petsun4/src/view25d/RCS/portal.c,v 2.22 1995/07/24 20:28:17 ty7777 Exp ty7777 $";
d2211 1
a2211 1
		portalSlice->pet_point_pixel = (char *) pkg_malloc (portalSlice->pet_point_num, 
d2299 1
a2299 1
		colorbar_length, hori_colorbar, image1_flag)
d2317 1
d2625 2
a2626 1
			DrawPortal (display, window, gc, current_header, &draw_portal_data, atlas_orient);
d2686 2
a2687 1
PRIVATE void DrawPortal (display, window, gc, current_header, draw_portal_data, atlas_orient)
d2694 2
d2732 1
a2732 1
/*
d2734 1
a2734 1
	if (slice->atlas_index >= 0)
a2735 1
printf ("Draw Mask\n");
d2764 1
a2764 1
*/
d2812 3
a2814 3
					XDrawPoint (display, window, gc, 
						x + slice->pet_point_coord [i].x,
						y + slice->pet_point_coord [i].y);
d2825 2
a2826 1
	if (*draw_portal_data->display_atlas_flag && slice->atlas_index >= 0)
d2865 2
a2866 1
	if (llsize (region_sets) > 0)
d2973 4
a2976 3
	DisplayAF3DPoints (display, window, gc, szAF3DFileNames, atlas_orient, 
	bDisplaySymbol, cSymbolType, pixelAF3DColor, nSymbolSize, &nOutlineWidth, 
	current_header, draw_portal_data);
d2981 2
a2982 1
	if (*draw_portal_data->display_label_flag)
d3364 1
d3434 29
d3478 4
d3486 1
a3486 1
			bImage1HorizontalColorBar, TRUE);
a3492 29
	}

	/*
	 * Process data for image 2
	 */
	if (bDisplayImage2 && bImage2Selected && strlen (szImage2FileName) > 0)
	{
		GetImageMinMax (FALSE, bAutoImage2ValueFlag, &minimum, &maximum);

		if (input_node != INPUT_SAME)
			BuildPortals (current_header, atlas_list2, portal_list2, 
				&minimum, &maximum, pet_cx, pet_cy, FALSE,
				bAutoImage2ValueFlag, cImage2ValueFlag);
		else if (input_node == INPUT_SAME) 
			ResizePortals (current_header, portal_list2, atlas_list2, 
				&minimum, &maximum, pet_cx, pet_cy, FALSE,
				bAutoImage2ValueFlag, cImage2ValueFlag);

		UpdatePortals (display, window, gc, current_header, portal_list2, 
			atlas_orient, &bDisplayImage2, nxImage2Start, nyImage2Start,
			bAutoImage2ValueFlag, cImage2ValueFlag, nxImage2ColorBarStart,
			nyImage2ColorBarStart, nImage2ColorBarWidth, nImage2ColorBarLength,
			bImage2HorizontalColorBar, FALSE);

		nxImage2OldColorBar		= nxImage2ColorBarStart;
		nyImage2OldColorBar		= nyImage2ColorBarStart;
		nImage2OldColorBarLength	= nImage2ColorBarLength;
		nImage2OldColorBarWidth		= nImage2ColorBarWidth;
		bImage2OldHoriColorBar		= bImage2HorizontalColorBar;
@


2.22
log
@The mask for interfile worked.
@
text
@d1 1
a1 1
/*$Id: portal.c,v 2.21 1995/07/14 20:53:34 ty7777 Exp ty7777 $*/
d3 3
d284 1
a284 1
/*$Header: /data/petsun4/src/view25d/RCS/portal.c,v 2.21 1995/07/14 20:53:34 ty7777 Exp ty7777 $*/
d290 1
a290 1
static char rcsid [] = "$Header: /data/petsun4/src/view25d/RCS/portal.c,v 2.21 1995/07/14 20:53:34 ty7777 Exp ty7777 $";
d3419 2
d3424 3
a3426 1
	GetImageMinMax (TRUE, bAutoImage1ValueFlag, &minimum, &maximum);
d3428 2
a3429 7
	GetPetCenter (atlas_orient, &pet_cx, &pet_cy); 
	if (input_node != INPUT_SAME)
		BuildPortals (current_header, atlas_list1, portal_list1, 
			&minimum, &maximum, pet_cx, pet_cy, TRUE,
			bAutoImage1ValueFlag, cImage1ValueFlag);
	else if (input_node == INPUT_SAME) 
		ResizePortals (current_header, portal_list1, atlas_list1, 
d3432 4
d3437 5
a3441 5
	UpdatePortals (display, window, gc, current_header, portal_list1, 
		atlas_orient, &bDisplayImage1, nxImage1Start, nyImage1Start,
		bAutoImage1ValueFlag, cImage1ValueFlag, nxImage1ColorBarStart,
		nyImage1ColorBarStart, nImage1ColorBarWidth, nImage1ColorBarLength,
		bImage1HorizontalColorBar, TRUE);
d3443 6
a3448 5
	nxImage1OldColorBar		= nxImage1ColorBarStart;
	nyImage1OldColorBar		= nyImage1ColorBarStart;
	nImage1OldColorBarLength	= nImage1ColorBarLength;
	nImage1OldColorBarWidth		= nImage1ColorBarWidth;
	bImage1OldHoriColorBar		= bImage1HorizontalColorBar;
d3453 3
a3455 1
	GetImageMinMax (FALSE, bAutoImage2ValueFlag, &minimum, &maximum);
d3457 2
a3458 2
	if (input_node != INPUT_SAME)
		BuildPortals (current_header, atlas_list2, portal_list2, 
d3461 2
a3462 2
	else if (input_node == INPUT_SAME) 
		ResizePortals (current_header, portal_list2, atlas_list2, 
d3466 5
a3470 5
	UpdatePortals (display, window, gc, current_header, portal_list2, 
		atlas_orient, &bDisplayImage2, nxImage2Start, nyImage2Start,
		bAutoImage2ValueFlag, cImage2ValueFlag, nxImage2ColorBarStart,
		nyImage2ColorBarStart, nImage2ColorBarWidth, nImage2ColorBarLength,
		bImage2HorizontalColorBar, FALSE);
d3472 6
a3477 5
	nxImage2OldColorBar		= nxImage2ColorBarStart;
	nyImage2OldColorBar		= nyImage2ColorBarStart;
	nImage2OldColorBarLength	= nImage2ColorBarLength;
	nImage2OldColorBarWidth		= nImage2ColorBarWidth;
	bImage2OldHoriColorBar		= bImage2HorizontalColorBar;
d6354 2
a6355 3
	Description:	Set the default atlas image file as the current atlas
			image file.
	Return:		none. 
@


2.21
log
@Before further changes.
@
text
@d1 1
a1 1
/*$Id: portal.c,v 2.20 1995/07/07 17:12:30 ty7777 Exp ty7777 $*/
d3 3
d281 1
a281 1
/*$Header: /data/petsun4/src/view25d/RCS/portal.c,v 2.20 1995/07/07 17:12:30 ty7777 Exp ty7777 $*/
d287 1
a287 1
static char rcsid [] = "$Header: /data/petsun4/src/view25d/RCS/portal.c,v 2.20 1995/07/07 17:12:30 ty7777 Exp ty7777 $";
d1177 1
d1179 2
a1180 1
			first_slice, last_slice, spacing, auto_min_image_value,
d1519 1
a1519 1
		spacing, auto_min_image_value, auto_max_image_value)
d1525 2
d1534 1
d1541 2
d1545 3
d1553 2
d1556 1
d1562 1
d1567 1
d1618 37
d1701 44
d4800 1
a4800 1
					strcat (mask_name, "pett6_n99.t88.mask");
d6402 1
a6402 1
			strcat (mask_name, "pett6_n99.t88.mask");
@


2.20
log
@Two data sets works correctly.
@
text
@d1 1
a1 1
/*$Id: portal.c,v 2.19 1995/06/30 15:22:12 ty7777 Exp ty7777 $*/
d3 3
d278 1
a278 1
/*$Header: /data/petsun4/src/view25d/RCS/portal.c,v 2.19 1995/06/30 15:22:12 ty7777 Exp ty7777 $*/
d284 1
a284 1
static char rcsid [] = "$Header: /data/petsun4/src/view25d/RCS/portal.c,v 2.19 1995/06/30 15:22:12 ty7777 Exp ty7777 $";
d1175 2
a1176 1
					first_slice, last_slice, spacing);
d1513 2
a1514 1
PRIVATE int InputInterfileData (current_header, imgfile, atlas_list, first_slice, last_slice, spacing)
d1521 2
d1733 2
a1734 2
			nAutoMinImage1Value	= global_min;
			nAutoMaxImage1Value	= global_max;
@


2.19
log
@ Before making further changes, tow independent color bars worked.
@
text
@d1 1
a1 1
/*$Id: portal.c,v 2.18 1995/06/14 20:12:10 ty7777 Exp ty7777 $*/
d3 3
d275 1
a275 1
/*$Header: /data/petsun4/src/view25d/RCS/portal.c,v 2.18 1995/06/14 20:12:10 ty7777 Exp ty7777 $*/
d281 1
a281 1
static char rcsid [] = "$Header: /data/petsun4/src/view25d/RCS/portal.c,v 2.18 1995/06/14 20:12:10 ty7777 Exp ty7777 $";
d1996 2
a1997 2
PRIVATE SliceData *ResizeSlice (current_header, slice, minimum, 
				maximum, pet_cx, pet_cy)
d2004 3
d2073 2
a2074 1
				pet_coord_databuf, minimum, maximum, cImage1ValueFlag);
d2125 1
a2125 1
				if (bInterfile)
d2127 1
a2127 1
					= pet_coord_databuf [rows + i] + PET_COLOR_START - 20;
d2130 1
a2130 1
					= pet_coord_databuf [rows + i] + PET_COLOR_START;
d2179 1
a2179 1
			portal_list1: linked list of Portals for image 1.
d2184 4
a2187 1
PUBLIC void	UpdatePortals (display, window, gc, current_header, portal_list1, atlas_orient)
d2192 1
a2192 1
llist		portal_list1;
d2194 11
a2205 1
	BOOLEAN			hori_colorbar;
a2215 1
	char			pet_value_flag;
a2231 4
	short			colorbar_length;
	short			colorbar_width;
	short			colorbar_xstart;
	short			colorbar_ystart;
a2251 2
	short			xstart;		/* portal x start */
	short			ystart;		/* portal y start */
d2256 1
a2256 1
	list_size	= llsize (portal_list1);
d2260 1
a2260 1
		draw_portal_data.display_pet_flag	= &bDisplayPet;
a2274 2
		xstart			= nxImage1Start;
		ystart			= nyImage1Start;
a2289 1
		pet_value_flag		= cImage1ValueFlag;
d2295 1
a2295 1
			llhead (portal_list1);
d2297 1
a2297 1
			lltail (portal_list1);
d2340 1
a2340 1
			portal		= (Portal *) llretrieve (portal_list1);
d2533 1
a2533 1
				llnext (portal_list1);
d2535 1
a2535 1
				llprevious (portal_list1);
a2545 6
			colorbar_xstart	= nxImage1ColorBarStart;
			colorbar_ystart	= nyImage1ColorBarStart;
			colorbar_length	= nImage1ColorBarLength;
			colorbar_width	= nImage1ColorBarWidth;
			hori_colorbar	= bImage1HorizontalColorBar;

d2548 1
a2548 1
				pet_value_flag, szImage1ColorTableName, TRUE); 
a2549 6
			nxImage1OldColorBar		= colorbar_xstart; 
			nyImage1OldColorBar		= colorbar_ystart; 
			nImage1OldColorBarLength	= colorbar_length; 
			nImage1OldColorBarWidth		= colorbar_width; 
			bImage1OldHoriColorBar		= hori_colorbar;

d2551 2
a2552 2
			GetImageMinMax (TRUE, bAutoImage1ValueFlag, &minimum, &maximum);
			ColorBarText (display, window, gc, &minimum, &maximum, font_struct, 
d2554 2
a2555 23
				colorbar_length, colorbar_width, FALSE, pet_value_flag);

			colorbar_xstart	= nxImage2ColorBarStart;
			colorbar_ystart	= nyImage2ColorBarStart;
			colorbar_length	= nImage2ColorBarLength;
			colorbar_width	= nImage2ColorBarWidth;
			hori_colorbar	= bImage2HorizontalColorBar;

			DrawColorBar (display, window, gc, colorbar_xstart, colorbar_ystart, 
				colorbar_length, colorbar_width, hori_colorbar, 
				pet_value_flag, szImage2ColorTableName, FALSE); 

			nxImage2OldColorBar		= colorbar_xstart; 
			nyImage2OldColorBar		= colorbar_ystart; 
			nImage2OldColorBarLength	= colorbar_length; 
			nImage2OldColorBarWidth		= colorbar_width; 
			bImage2OldHoriColorBar		= hori_colorbar;

			XSetForeground (display, gc, LABEL_CELL);
			GetImageMinMax (FALSE, bAutoImage1ValueFlag, &minimum, &maximum);
			ColorBarText (display, window, gc, &minimum, &maximum, font_struct, 
				hori_colorbar, colorbar_xstart, colorbar_ystart, 
				colorbar_length, colorbar_width, FALSE, pet_value_flag);
d2876 1
a2876 1
			portal_list1: linked list of Portals on screen
d2884 2
a2885 2
PRIVATE void ResizePortals (current_header, portal_list, atlas_list, 
			minimum, maximum, pet_cx, pet_cy) 
d2893 3
d2932 3
a2934 2
			portal->slice	= ResizeSlice (current_header, slice, 
						minimum, maximum, pet_cx, pet_cy);
d3294 1
a3294 1
			last_slice, spacing, bApplyMask, &nAutoMinImage1Value, &nAutoMaxImage1Value);
d3300 1
a3300 1
			last_slice, spacing, bApplyMask, &nAutoMinImage2Value, &nAutoMaxImage2Value);
d3318 2
a3319 1
				&minimum, &maximum, pet_cx, pet_cy);
d3322 2
a3323 1
				&minimum, &maximum, pet_cx, pet_cy);
d3325 5
a3329 1
	UpdatePortals (display, window, gc, current_header, portal_list1, atlas_orient);
d3331 6
d3344 2
a3345 1
				&minimum, &maximum, pet_cx, pet_cy);
d3348 2
a3349 1
				&minimum, &maximum, pet_cx, pet_cy);
d3351 11
a3361 3
/*
	UpdatePortals (display, window, gc, current_header, portal_list2, atlas_orient);
*/
d3375 2
a3376 2
PRIVATE void BuildPortals (current_header, atlas_list, portal_list, 
			minimum, maximum, pet_cx, pet_cy) 
d3384 3
d3399 3
a3401 2
			portal_slice	= ResizeSlice (current_header, slice, 
						minimum, maximum, pet_cx, pet_cy);
d3561 1
a3561 1
		ColorBarText	
d3569 3
a3571 3
PUBLIC void ColorBarText (display, window, gc, min_pet_value, max_pet_value, 
	font_struct, hori_colorbar, colorbar_xstart, colorbar_ystart, 
	colorbar_length, colorbar_width, clear_flag, pet_value_flag)
d3584 2
a3585 1
char		pet_value_flag;		
d3608 1
a3608 1
	RegularMinMax (pet_value_flag, min_pet_value, max_pet_value);
d4241 2
a4242 2
PUBLIC void ErrorCheckMinMax (pet_value_flag, minimum, maximum)
	BOOLEAN		pet_value_flag;
d4251 2
a4252 2
	if ((pet_value_flag == PETVALUE_POSITIVE && *maximum <= 0)
	|| (pet_value_flag == PETVALUE_NEGATIVE && *minimum >= 0))
d4260 3
a4262 2
PUBLIC void RegularMinMax (pet_value_flag, minimum, maximum)
	BOOLEAN		pet_value_flag;
d4266 1
a4266 5
	BOOLEAN auto_flag;

	auto_flag	= bAutoImage1ValueFlag;

	if (pet_value_flag == PETVALUE_POSITIVE && (auto_flag || *minimum < 0))
d4270 1
a4270 1
	else if (pet_value_flag == PETVALUE_NEGATIVE && (auto_flag || *maximum > 0))
d4274 1
a4274 1
	else if (pet_value_flag == PETVALUE_DUAL)
d4600 2
a4601 1
	BOOLEAN			*auto_pet_value_flag	= &bAutoImage1ValueFlag;        
d4605 2
a4606 1
	BOOLEAN			*pet_value_flag		= &cImage1ValueFlag;        
d4651 2
a4652 1
	short			*max_pet_value		= &nMaxImage1Value;
d4654 2
a4655 1
	short			*min_pet_value		= &nMinImage1Value;
d4727 2
a4728 1
			if (strcmp (label, "DisplayPetFlag:") == 0)
d4735 2
a4736 2
				SetSelectData (*data_type_menu->pet, bool_buffer);
				bDisplayPet	= bool_buffer;
d4741 2
a4742 1
			if (strcmp (label, "ApplyMaskFlag:") == 0)
d4749 2
a4750 2
				SetSelectData (*data_type_menu->mask, bool_buffer);
				bApplyMask	= bool_buffer;
d4755 26
d4888 2
a4889 1
			if (strcmp (label, "PetImageScale:") == 0)
d4894 1
a4894 1
				(mag_scale_menu->scale_set, 
d4898 1
a4898 1
				= GetWidgetFromName (mag_scale_menu->scale_set,
d4900 1
a4900 1
				*pet_value_flag	= (char) n;
d4909 2
a4910 1
			if (strcmp (label, "AutoPetMinMaxFlag:") == 0)
d4917 2
a4918 2
				SetSelectData (*mag_scale_menu->auto_pet_minmax, bool_buffer);
				*auto_pet_value_flag	= bool_buffer;
d4923 2
a4924 1
			if (strcmp (label, "PetMinimum:") == 0)
d4926 3
a4928 3
				*min_pet_value	= atoi (value);
				if (!(*auto_pet_value_flag))
					XmTextSetString (*mag_scale_menu->min_text, value); 
d4933 2
a4934 1
			if (strcmp (label, "PetMaximum:") == 0)
d4936 3
a4938 3
				*max_pet_value	= atoi (value);
				if (!(*auto_pet_value_flag))
					XmTextSetString (*mag_scale_menu->max_text, value); 
d4943 1
a4943 1
			ErrorCheckMinMax (*pet_value_flag, min_pet_value, max_pet_value);
d4945 53
d5192 2
a5193 1
			if (strcmp (label, "xStartFormatedSlices:") == 0)
d5196 1
a5196 1
				XmTextSetString (*format_screen_menu->xstart_text, value); 
d5201 2
a5202 1
			if (strcmp (label, "yStartFormatedSlices:") == 0)
d5205 1
a5205 1
				XmTextSetString (*format_screen_menu->ystart_text, value); 
d5210 16
d5815 2
a5816 2
	bool_buffer	= XmToggleButtonGetState (*data_type_menu->pet);
	fprintf (file, "DisplayPetFlag:		%s\n", bool_buffer? "True": "False");
d5818 2
a5819 2
	bool_buffer	= XmToggleButtonGetState (*data_type_menu->mask);
	fprintf (file, "ApplyMaskFlag:		%s\n", bool_buffer? "True": "False");
d5821 6
d5861 1
a5861 1
	GetNameFromWidget (default_parameters->mag_scale_menu->scale_set, 
d5863 1
a5863 1
	fprintf (file, "PetImageScale:		%s\n", value);
d5866 2
a5867 2
	= XmToggleButtonGetState (*default_parameters->mag_scale_menu->auto_pet_minmax);
	fprintf (file, "AutoPetMinMaxFlag:	%s\n", bool_buffer? "True": "False");
d5869 2
a5870 2
	string	= XmTextGetString (*default_parameters->mag_scale_menu->min_text);
	fprintf (file, "PetMinimum:		%s\n", string);
d5872 2
a5873 2
	string	= XmTextGetString (*default_parameters->mag_scale_menu->max_text);
	fprintf (file, "PetMaximum:		%s\n", string);
d5876 15
d5968 2
a5969 2
	string	= XmTextGetString (*format_screen_menu->xstart_text);
	fprintf (file, "xStartFormatedSlices:	%s\n", string); 
d5972 10
a5981 2
	string	= XmTextGetString (*format_screen_menu->ystart_text);
	fprintf (file, "yStartFormatedSlices:	%s\n", string); 
@


2.18
log
@Added processing for analyze .hdr file.
@
text
@d1 1
a1 1
/*$Id: portal.c,v 2.17 1995/06/13 20:12:47 ty7777 Exp ty7777 $*/
d3 3
d272 1
a272 1
/*$Header: /data/petsun4/src/view25d/RCS/portal.c,v 2.17 1995/06/13 20:12:47 ty7777 Exp ty7777 $*/
d278 1
a278 1
static char rcsid [] = "$Header: /data/petsun4/src/view25d/RCS/portal.c,v 2.17 1995/06/13 20:12:47 ty7777 Exp ty7777 $";
d359 1
a359 1
PRIVATE void		InputPetData ();
d917 2
a918 1
			atlas:		linked list for atlas slices.
d929 1
a929 2
PRIVATE SCALE_HEADER *BuildQueue (first_slice, last_slice, 
			spacing, atlas_list, current_mag)
d933 2
a934 1
llist		atlas_list;
d937 1
a937 1
	ATLAS_HEADER	*atlas_header	= &rAtlasHeader;
d939 5
a943 3
	SliceData	*slice;
	char		atlas_orient	= cAtlasOrientation;
	char		*pet_filename	= szPetFileName;
d982 1
a982 1
	if (strlen (pet_filename) > 0)
d990 1
a990 1
		if (getimagedim (pet_filename, matval, &image_type, &width, &height, 
d1018 4
a1021 2
		slice	= (SliceData *) pkg_malloc (sizeof (SliceData), 
						"BuildQueue", "slice");
d1023 2
a1024 1
		slice->slice_xyz	= GetSliceCoord (desired_slice, atlas_orient);
d1045 4
a1048 1
			slice->atlas_index	= atlas_header->index_table [index];
d1050 8
a1057 3
			slice->atlas_index	= -1;
		slice->pet_exist	= FALSE;
		llinsert (atlas_list, slice);
d1066 2
a1067 2
	Function:	InputPetData
	Arguments:	pet_filename: pointer to pet image file
d1075 2
a1076 1
PRIVATE void InputPetData (current_header, pet_filename, atlas_list, first_slice, last_slice, spacing)
d1078 1
a1078 1
char		*pet_filename;
d1083 3
a1086 1
	BOOLEAN		apply_mask	= bApplyMask;
d1100 1
a1100 1
	char		*pet_mask_file_name	= szPetMaskFileName;
d1131 1
a1131 1
	static char	*function = "InputPetData";
d1150 1
a1150 1
	imgfd	= open (pet_filename, O_RDONLY, 0);
d1153 1
a1153 1
		fprintf (stderr, "Can't open image file %s\n", pet_filename); 
d1157 1
a1157 1
	pett_num	= getimage_type (imgfd, pet_filename, &encoded, &num_slices);
a1164 1
	bPettVI14	= pettvi_14;
d1168 1
a1168 1
		InputInterfileData (current_header, pet_filename, atlas_list, 
d1179 1
a1179 1
		mskfd	= open (pet_mask_file_name, O_RDONLY, 0);
d1182 1
a1182 1
			fprintf (stderr, "Can't open mask file%s\n", pet_mask_file_name); 
d1186 1
a1186 1
		mask_pett_num	= getimage_type (mskfd, pet_mask_file_name, 
d1196 1
a1196 1
			fptr	= OpenEcat (pet_mask_file_name, &mask_num_slices, 
d1200 1
a1200 1
				fprintf (stderr, "Cannnot open mask image %s.\n", pet_mask_file_name);
d1213 1
a1213 1
				pet_mask_file_name);
d1234 1
a1234 1
		imgfd	= open (pet_filename, O_RDONLY, 0);
d1236 2
a1237 2
			fprintf (stderr, "Can't open %d\n", pet_filename); 
		getimage (horizontal_slice->slice_data, header, imgfd, pet_filename, slice_index, 
d1243 1
a1243 1
			mskfd	= open (pet_mask_file_name, O_RDONLY, 0);
d1246 1
a1246 1
				fprintf (stderr, "Can't open mask file %s\n", pet_mask_file_name);
d1255 1
a1255 1
				getimage (mask_slice_image, header, mskfd, pet_mask_file_name, 
d1457 1
a1457 1
					slice->pet_input[tempx++] = temp_pet_value;
d1475 2
a1476 2
			nAutoMinPetValue	= global_min;
			nAutoMaxPetValue	= global_max;
d1498 1
a1498 1
	Arguments:	pet_filename: pointer to pet image file
d1506 1
a1506 1
PRIVATE int InputInterfileData (current_header, pet_filename, atlas_list, first_slice, last_slice, spacing)
d1508 1
a1508 1
char		*pet_filename;
d1551 1
a1551 1
	extension	= strrchr (pet_filename, '.');
d1553 1
a1553 1
		strncpy (imgroot, pet_filename, strlen (pet_filename)  - strlen (extension));
d1555 1
a1555 1
		strcpy (imgroot, pet_filename);
d1619 1
a1619 1
			if (readifimg (pet_filename, atlas_orient, slice_index, slice_dim, 
d1723 2
a1724 2
			nAutoMinPetValue	= global_min;
			nAutoMaxPetValue	= global_max;
d2067 1
a2067 1
				pet_coord_databuf, minimum, maximum, cPetValueFlag);
d2118 5
a2122 1
	 			portalSlice->pet_point_pixel [temp_coord_num] 
d2172 1
a2172 1
			plist: linked list of Portals on screen
d2177 1
a2177 1
PUBLIC void	UpdatePortals (display, window, gc, current_header, plist, atlas_orient)
d2182 1
a2182 1
llist		plist;
d2243 1
a2243 1
	list_size	= llsize (plist);
d2262 2
a2263 2
		xstart			= nxImageStart;
		ystart			= nyImageStart;
d2279 1
a2279 1
		pet_value_flag		= cPetValueFlag;
d2285 1
a2285 1
			llhead (plist);
d2287 1
a2287 1
			lltail (plist);
d2330 1
a2330 1
			portal		= (Portal *) llretrieve (plist);
d2523 1
a2523 1
				llnext (plist);
d2525 1
a2525 1
				llprevious (plist);
d2536 5
a2540 5
			colorbar_xstart	= nxColorBarStart;
			colorbar_ystart	= nyColorBarStart;
			colorbar_length	= nColorBarLength;
			colorbar_width	= nColorBarWidth;
			hori_colorbar	= bHorizontalColorBar;
d2543 2
a2544 1
				colorbar_length, colorbar_width, hori_colorbar, pet_value_flag); 
d2546 5
a2550 5
			nxOldColorBar		= colorbar_xstart; 
			nyOldColorBar		= colorbar_ystart; 
			nOldColorBarLength	= colorbar_length; 
			nOldColorBarWidth	= colorbar_width; 
			bOldHoriColorBar	= hori_colorbar;
d2553 1
a2553 1
			GetPetMinMax (bAutoPetValueFlag, &minimum, &maximum);
d2557 22
d2638 1
d2642 1
d2671 1
d2718 1
a2895 96
/*___________________________________________________________________________	
	Function:	ClearPortals	
	Arguments:	display: pointer to X Display 
			plist: linked list of Portals on screen
	Description: 	Clear atlas, PET, region images and AF3D points.
	Return Value:	None.

	Author:		
			Tom (Tongzeng) Yang
			05/01/91.
____________________________________________________________________________*/

PUBLIC void	ClearPortals (display, window, gc, plist) 
Display		*display; 
Window		window;
GC		gc;
llist		plist;
{ 
	Portal			*portal;	/* current portal */
	SliceData		*slice;
	BOOLEAN			pet_exist	= FALSE;
	BOOLEAN			hori_colorbar;
	short			x;
	short			y;
	short			length;
	short			width;
	int			w;
	int			h;
	short			minimum;
	short			maximum;
	SCALE_HEADER		*current_header	= rCurrentScaleHeader;
	int			oatlas_width	= nOldAtlasWidth;
	int			oatlas_height	= nOldAtlasHeight;
	char			atlas_orient	= cAtlasOrientation;

	if (llsize (plist) > 0) 
	{
		/* 
		 * Move to head of portal list. 
		 */
		llhead (plist);

		do
		{
			/* 
			 * Get a portal. 
			 */
			portal		= (Portal *) llretrieve (plist);
			x		= portal->x;
			y		= portal->y;
			slice		= portal->slice;
			pet_exist	= pet_exist || slice->pet_exist; 

			XClearArea (display, window, portal->xold, portal->yold, 
					oatlas_width, oatlas_height, FALSE);

			if (slice->pet_exist)
			{
				XClearArea (display, window, 
					x + slice->pet_xstart,
					y + slice->pet_ystart,
					slice->pet_width,
					slice->pet_height,
					FALSE);
			}

			XClearArea (display, window, slice->xlabel_start, slice->ylabel_start,
					slice->label_width, slice->label_height, FALSE);
		} while (llnext (plist) != FAIL);

		/* 
		 * Clear color bar. 
		 */
		x		= nxOldColorBar;
		y		= nyOldColorBar;
		length		= nOldColorBarLength;
		width		= nOldColorBarWidth;
		hori_colorbar	= bOldHoriColorBar;
		w		= length;
		h		= width;

		if (!hori_colorbar)
			Swap (&w, &h);

		if (pet_exist)	
		{
			XClearArea (display, window, x, y, w, h, FALSE); 
			GetPetMinMax (bAutoPetValueFlag, &minimum, &maximum);
			ColorBarText (display, window, gc, &minimum, &maximum, FontStruct, 
					hori_colorbar, x, y, length, width, TRUE);
		}
	}
}



d2899 1
a2899 1
			plist: linked list of Portals on screen
d2907 1
a2907 1
PRIVATE void ResizePortals (current_header, plist, atlas, 
d2910 2
a2911 2
llist		plist;
llist		atlas;
d2921 1
a2921 1
	size	= llsize (atlas);
d2924 1
a2924 1
		llhead (atlas);
d2931 1
a2931 1
			llhead (plist);
d2936 1
a2936 1
			portal	= (Portal *) llretrieve (plist);
d2951 1
a2951 1
			slice = (SliceData *) llretrieve (atlas);
d2959 3
a2961 3
			lldelete (plist);
			lladdtail (plist, portal);
		} while (llnext (atlas) != FAIL); 
d3020 2
a3021 2
	Arguments:	plist:		portal linked list.
			atlas:		atlas linked list.
d3028 3
a3030 3
PUBLIC void ClearData (plist, atlas)
llist		atlas;
llist		plist;
d3036 1
a3036 1
	 * Clear plist data. 
d3038 2
a3039 2
	llhead (plist);			/* step through portal list */
	while (llsize (plist) > 0) 
d3041 1
a3041 1
		portal	= (Portal *) llretrieve (plist);
d3053 1
a3053 1
		lldelete (plist);
d3059 2
a3060 2
	llhead (atlas);			/* step through the atlas */
	while (llsize (atlas) > 0)
d3065 1
a3065 1
		slice = (SliceData *) llretrieve (atlas);
d3071 1
a3071 1
		lldelete (atlas);
d3110 1
a3110 1
			atlas:		atlas linked list.
d3120 2
a3121 2
PUBLIC void GetFileStatus (atlas_slice, first_slice, last_slice, spacing, input_node)
llist	atlas_slice;
d3132 1
a3132 1
	size = llsize (atlas_slice);
d3137 2
a3138 2
			llhead (atlas_slice);
			slice = llretrieve (atlas_slice);			
d3151 2
a3152 2
				lltail (atlas_slice);
				slice = llretrieve (atlas_slice);			
d3254 1
a3254 1
PUBLIC void RedrawPortals (draw_data, atlas_list, portal_list) 
d3256 4
a3259 2
llist		atlas_list;
llist		portal_list;
a3280 2
	int		*old_atlas_h	= &nOldAtlasHeight;  
	int		*old_atlas_w	= &nOldAtlasWidth;  
a3281 6
/*
	time_t		time1, time2, time3;

	time1	= time (NULL);
*/

d3293 1
a3293 1
		GetFileStatus (atlas_list, first_slice, &last_slice, 
d3300 1
a3300 2
		if (llsize (portal_list) > 0 && 
			(llsize (portal_list) == llsize (atlas_list)))
d3302 2
a3303 2
			*old_atlas_w	= rCurrentScaleHeader->width;
			*old_atlas_h	= rCurrentScaleHeader->height;
a3304 2
		if (input_node == INPUT_UPDATE)
			ClearData (portal_list, atlas_list);
d3306 1
a3306 6
					atlas_list, current_mag);
		if (llsize (portal_list) != llsize (atlas_list))
		{
			*old_atlas_w	= rCurrentScaleHeader->width;
			*old_atlas_h	= rCurrentScaleHeader->height;
		}
d3310 1
a3310 1
	if (bPetImageSelected)
d3312 2
a3313 1
		InputPetData (current_header, szPetFileName, atlas_list, first_slice, last_slice, spacing);
d3316 6
d3329 4
a3332 1
	GetPetMinMax (bAutoPetValueFlag, &minimum, &maximum);
d3336 1
a3336 1
		BuildPortals (current_header, atlas_list, portal_list, 
d3339 1
a3339 1
		ResizePortals (current_header, portal_list, atlas_list, 
d3342 1
a3342 4
/*
time2	= time (NULL);
*/
	UpdatePortals (display, window, gc, current_header, portal_list, atlas_orient);
d3344 12
d3357 1
a3357 2
time3	= time (NULL);
printf ("Time1 = %d Time2 = %d sum = %d\n", time2 - time1, time3 - time2, time3 - time1);
d3413 1
a3413 1
			horizontal_flag, pet_value_flag) 
d3423 2
a3428 1
	char		*color_table_name	= szColorTableName;
d3458 1
a3458 1
	increment		= length / NCOLORS;
d3485 2
a3486 1
	color_pixel	= (direction_flag)? PET_COLOR_START: 
d3488 3
d4199 2
a4200 1
PUBLIC void GetPetMinMax (auto_flag, minimum, maximum)
d4205 1
a4205 1
	if (auto_flag)
d4207 10
a4216 2
		*minimum	= nAutoMinPetValue;
		*maximum	= nAutoMaxPetValue;
d4220 10
a4229 2
		*minimum	= nMinPetValue;
		*maximum	= nMaxPetValue;
d4259 1
a4259 1
	auto_flag	= bAutoPetValueFlag;
d4595 1
a4595 1
	BOOLEAN			*auto_pet_value_flag	= &bAutoPetValueFlag;        
d4597 1
a4597 1
	BOOLEAN			*color_bar_orient	= &bHorizontalColorBar;
d4599 1
a4599 1
	BOOLEAN			*pet_value_flag		= &cPetValueFlag;        
d4619 1
a4619 1
	char			*color_table_name	= szColorTableName;
d4640 2
a4641 2
	short			*color_bar_length	= &nColorBarLength;
	short			*color_bar_width	= &nColorBarWidth;
d4644 1
a4644 1
	short			*max_pet_value		= &nMaxPetValue;
d4646 1
a4646 1
	short			*min_pet_value		= &nMinPetValue;
d4648 2
a4649 2
	short			*xcolor_bar		= &nxColorBarStart;
	short			*ycolor_bar		= &nyColorBarStart;
d4687 1
a4687 1
				strcpy (szPetMaskFileName, mask_name);
d4705 13
d5100 1
a5100 1
				nxImageStart	= atoi (value);
d5108 1
a5108 1
				nyImageStart	= atoi (value);
d5175 2
a5176 1
			if (strcmp (label, "AtlasTrim:") == 0)
a5177 13
				if (strcmp (lowered_value, "true") == 0)
					bool_buffer	= TRUE;
				else
					bool_buffer	= FALSE;

				SetSelectData (*format_screen_menu->atlas_trim, bool_buffer);
				bAtlasTrim	= bool_buffer;

				continue;
			}

			if (strcmp (label, "xColorBarStart:") == 0)
			{
d5179 1
a5179 1
				XmTextSetString (*color_bar_menu->xstart, value); 
d5184 2
a5185 1
			if (strcmp (label, "yColorBarStart:") == 0)
d5188 1
a5188 1
				XmTextSetString (*color_bar_menu->ystart, value); 
d5193 2
a5194 1
			if (strcmp (label, "ColorBarWidth:") == 0)
d5197 1
a5197 1
				XmTextSetString (*color_bar_menu->height, value); 
d5202 2
a5203 1
			if (strcmp (label, "ColorBarLength:") == 0)
d5206 1
a5206 1
				XmTextSetString (*color_bar_menu->width, value); 
d5211 2
a5212 1
			if (strcmp (label, "ColorBarOrientation:") == 0)
d5219 1
a5219 1
				SetSelectData (*color_bar_menu->orientation, bool_buffer);
d5261 2
a5262 1
			if (strcmp (label, "PetColorTable:") == 0)
d5538 5
a5542 5
	nxOldColorBar		= *xcolor_bar; 
	nyOldColorBar		= *ycolor_bar; 
	nOldColorBarLength	= *color_bar_length; 
	nOldColorBarWidth	= *color_bar_width; 
	bOldHoriColorBar	= *color_bar_orient;
d5699 4
d5871 2
a5872 6
	bool_buffer	
	= XmToggleButtonGetState (*format_screen_menu->atlas_trim);
	fprintf (file, "AtlasTrim:		%s\n", bool_buffer? "True": "False");

	string	= XmTextGetString (*color_bar_menu->xstart);
	fprintf (file, "xColorBarStart:		%s\n", string); 
d5875 2
a5876 2
	string	= XmTextGetString (*color_bar_menu->ystart);
	fprintf (file, "yColorBarStart:		%s\n", string); 
d5879 2
a5880 2
	string	= XmTextGetString (*color_bar_menu->width);
	fprintf (file, "ColorBarLength:		%s\n", string); 
d5883 2
a5884 2
	string	= XmTextGetString (*color_bar_menu->height);
	fprintf (file, "ColorBarWidth:		%s\n", string); 
d5888 2
a5889 2
	= XmToggleButtonGetState (*color_bar_menu->orientation);
	fprintf (file, "ColorBarOrientation:	%s\n", bool_buffer? "True": "False");
d5901 1
a5901 1
	fprintf (file, "PetColorTable:		%s\n", string);
d6157 1
a6157 1
		strcpy (szPetMaskFileName, mask_name);
d6172 1
a6172 1
PUBLIC void ShowCoordinates (x, y, current_header, plist, atlas_orient, widget, save)
d6176 1
a6176 1
	llist		plist;
d6189 1
a6189 1
	char		*petfilename = szPetFileName;
d6203 1
a6203 1
	if (llsize (plist) > 0)
d6206 1
a6206 1
		llhead (plist);
d6209 1
a6209 1
			portal	= (Portal *) llretrieve (plist);
d6224 1
a6224 1
		} while (llnext (plist) != FAIL);
d6296 1
a6296 1
	strcat (szBuffer, szPetFileName);
d6317 2
a6318 2
		if (strlen (petfilename) > 0)
			fprintf (logfp, "Pet Image File: %s\n", szPetFileName);
@


2.17
log
@Added processing for reading .hdr files.
@
text
@d1 1
a1 1
/*$Id: portal.c,v 2.16 1995/06/12 19:30:55 ty7777 Exp ty7777 $*/
d3 3
d269 1
a269 1
/*$Header: /data/petsun4/src/view25d/RCS/portal.c,v 2.16 1995/06/12 19:30:55 ty7777 Exp ty7777 $*/
d275 1
a275 1
static char rcsid [] = "$Header: /data/petsun4/src/view25d/RCS/portal.c,v 2.16 1995/06/12 19:30:55 ty7777 Exp ty7777 $";
d1547 1
a1547 1
			return FAIL;
@


2.16
log
@Before adding processing for .hdr file.
@
text
@d1 1
a1 1
/*$Id$*/
d3 3
d266 1
a266 1
/*$Header: /data/petsun4/src/view25d/RCS/portal.c,v 2.15 1995/06/07 14:36:03 ty7777 Exp ty7777 $*/
d272 1
a272 1
static char rcsid [] = "$Header: /data/petsun4/src/view25d/RCS/portal.c,v 2.15 1995/06/07 14:36:03 ty7777 Exp ty7777 $";
d325 2
d1501 1
d1528 1
a1528 1
	memset (ifhdr_file, 0, MAXLINE); 
d1531 1
a1531 1
		strncpy (ifhdr_file, pet_filename, strlen (pet_filename)  - strlen (extension));
d1533 2
a1534 1
		strcpy (ifhdr_file, pet_filename);
d1537 2
a1538 2

	if (readifhdr (ifhdr_file, TRUE, IFH_MAXLEN, &nlines, lines) == FAIL)
d1540 2
a1541 2
		return FAIL;
	}
d1543 2
a1544 3
	if (getifhdr (ifhdr_file, TRUE, nlines, lines, &ifhdr) == FAIL)
	{
		return FAIL;
@


2.15
log
@Relieve the checking for 75 slices.
@
text
@d1 1
d3 3
d263 1
a263 1
/*$Header: /data/petsun4/src/view25d/RCS/portal.c,v 2.14 1995/06/05 19:50:57 ty7777 Exp ty7777 $*/
d269 1
a269 1
static char rcsid [] = "$Header: /data/petsun4/src/view25d/RCS/portal.c,v 2.14 1995/06/05 19:50:57 ty7777 Exp ty7777 $";
d842 1
a842 1
		atlas_header->index_table[i++]	= index;
d933 1
d955 13
d995 1
a995 12
		if (atlas_orient == TRANSVERSE)
		{
			max_index_num	= MAX_TRANS_ATLAS_NUM - 1;
		}
		else if (atlas_orient == CORONAL)
		{
			max_index_num	= MAX_ATLAS_NUM - 1;
		}
		else
		{
			max_index_num	= MAX_ATLAS_NUM - 1;
		}
d1027 4
a1030 1
		slice->atlas_index	= atlas_header->index_table [index];
d3319 1
a3319 1
	/*
d3323 1
a3323 1
	*/
@


2.14
log
@Before changing the constraint on the number of slices to display.
@
text
@d2 3
d259 1
a259 1
/*$Header: /data/petsun4/src/view25d/RCS/portal.c,v 2.13 1995/06/02 14:23:13 ty7777 Exp ty7777 $*/
d265 1
a265 1
static char rcsid [] = "$Header: /data/petsun4/src/view25d/RCS/portal.c,v 2.13 1995/06/02 14:23:13 ty7777 Exp ty7777 $";
d925 4
d930 1
d934 4
d949 2
a950 1
	if (atlas_orient == TRANSVERSE)
d952 22
a973 1
		max_index_num	= MAX_TRANS_ATLAS_NUM - 1;
d977 12
a988 1
		max_index_num	= MAX_ATLAS_NUM - 1;
@


2.13
log
@Added InputInterfileData ().
@
text
@d2 3
d256 1
a256 1
/*$Header: /data/petsun4/src/view25d/RCS/portal.c,v 2.12 1995/01/18 20:11:16 ty7777 Exp ty7777 $*/
d262 1
a262 1
static char rcsid [] = "$Header: /data/petsun4/src/view25d/RCS/portal.c,v 2.12 1995/01/18 20:11:16 ty7777 Exp ty7777 $";
d995 7
a1001 6
PRIVATE void InputPetData (pet_filename, atlas_list, first_slice, last_slice, spacing)
char	*pet_filename;
llist	atlas_list;
int	first_slice;
int	last_slice;
int	spacing;
d1086 2
a1087 1
		InputInterfileData (pet_filename, atlas_list, first_slice, last_slice, spacing);
d1338 20
a1357 4
			slice->pet_xstart	= ptUpperLeft.x;
			slice->pet_ystart	= ptUpperLeft.y; 
			slice->pet_width	= (ptBottomRight.x - ptUpperLeft.x + 1); 
			slice->pet_height	= (ptBottomRight.y - ptUpperLeft.y + 1); 
d1424 7
a1430 6
PRIVATE int InputInterfileData (pet_filename, atlas_list, first_slice, last_slice, spacing)
char	*pet_filename;
llist	atlas_list;
int	first_slice;
int	last_slice;
int	spacing;
d1442 2
d1488 2
a1489 3
		slice_dim	= ifhdr.matrix_size [0] * ifhdr.matrix_size [1]; 
		slice_width	= ifhdr.matrix_size [0];
		slice_height	= ifhdr.matrix_size [1];
d1493 2
a1494 3
		slice_dim	= ifhdr.matrix_size [0] * ifhdr.matrix_size [2]; 
		slice_width	= ifhdr.matrix_size [0];
		slice_height	= ifhdr.matrix_size [2];
d1498 2
a1499 3
		slice_dim	= ifhdr.matrix_size [1] * ifhdr.matrix_size [2]; 
		slice_width	= ifhdr.matrix_size [1];
		slice_height	= ifhdr.matrix_size [2];
d1501 5
d1608 2
a1924 1
	int		rgn_pet_pixelsize;
d1936 5
a1940 3
	portalSlice->slice_xyz		= slice->slice_xyz;
	portalSlice->atlas_index	= slice->atlas_index;
	portalSlice->pet_exist		= slice->pet_exist;
a1942 6
	 * Compute resized region pixel size. 
	 */
	rgn_pet_pixelsize = ROUND (RGN_PIXEL_WIDTH / current_header->pixel_size);
	portalSlice->rgn_pet_pixelsize = rgn_pet_pixelsize;

	/* 
d1947 2
a1948 7
		if (bPettVI14)
		{
			rgn_pet_pixelsize	= ROUND (PETT6_PIXEL_SIZE  * MMS_PER_CM
							/ current_header->pixel_size);
		}
		portalSlice->pet_width	= slice->pet_width * rgn_pet_pixelsize;
		portalSlice->pet_height	= slice->pet_height * rgn_pet_pixelsize;
d1958 2
a1959 1
		Transformation ((float) rgn_pet_pixelsize, 
d1972 2
a1973 2
		xoffset			-= rgn_pet_pixelsize / 2;
		yoffset			-= rgn_pet_pixelsize / 2;
d2505 2
a2506 1
	int		rgn_pet_pixelsize;
d2520 2
a2521 1
	rgn_pet_pixelsize	= slice->rgn_pet_pixelsize;
d2720 1
a2720 1
								- slice->rgn_pet_pixelsize / 2;
d2722 1
a2722 1
								- slice->rgn_pet_pixelsize / 2;
a2725 1
				tempx	= slice->rgn_pet_pixelsize;
d2732 3
a2734 3
							region_draw [i].x - tempx / 2,
							region_draw [i].y - tempx / 2,
							tempx, tempx);
d2741 1
a2741 1
					DrawOutlinedRegion (display, window, gc, tempx, 
d2750 3
a2752 3
							region_draw [i].x - tempx / 2,
							region_draw [i].y - tempx / 2,
							tempx, tempx);
d3308 1
a3308 1
		InputPetData (szPetFileName, atlas_list, first_slice, last_slice, spacing);
@


2.12
log
@Added black border for PosNeg_on_White.tbl.
@
text
@d2 3
d253 1
a253 1
/*$Header: /home/petsun4/ty7777/src/view25d/RCS/portal.c,v 2.11 1995/01/17 20:07:49 ty7777 Exp ty7777 $*/
d259 1
a259 1
static char rcsid [] = "$Header: /home/petsun4/ty7777/src/view25d/RCS/portal.c,v 2.11 1995/01/17 20:07:49 ty7777 Exp ty7777 $";
d311 1
d337 1
d1080 6
d1394 226
a1968 1

@


2.11
log
@Deleted things that are related to data_stes.
@
text
@d2 3
d250 1
a250 1
/*$Header: /home/petsun4/ty7777/src/view25d/RCS/portal.c,v 2.10 1994/12/30 21:20:58 ty7777 Exp ty7777 $*/
d256 1
a256 1
static char rcsid [] = "$Header: /home/petsun4/ty7777/src/view25d/RCS/portal.c,v 2.10 1994/12/30 21:20:58 ty7777 Exp ty7777 $";
d3171 1
@


2.10
log
@Added processing for big fonts.
@
text
@d2 3
d247 1
a247 1
/*$Header: /home/petsun4/ty7777/src/view25d/RCS/portal.c,v 2.9 1994/12/01 20:09:48 ty7777 Exp ty7777 $*/
d253 1
a253 1
static char rcsid [] = "$Header: /home/petsun4/ty7777/src/view25d/RCS/portal.c,v 2.9 1994/12/01 20:09:48 ty7777 Exp ty7777 $";
a316 1
PRIVATE void		ClearDataSets ();
d318 3
a329 1
PRIVATE void		InputAF3DData ();
a332 1
PRIVATE GammaZData	*MakeGammaZData ();
d411 2
a412 1
	Function:	MakeGammaZData	
d415 5
a419 4
	Description:
			Allocate and read a set of gammaz data consisting
			of the header of point information from a Sybase
			application.
d421 1
d423 1
a423 1
	Return Value:	Pointer to allocated dataset.
d426 6
a431 1
PRIVATE GammaZData	*MakeGammaZData (fd, c)
d434 8
d444 1
a444 2
	GammaZData	*data;		/* new data */
	GammaZPoint	*point;		/* new point to make structure */
d448 2
a449 1
	char		s[2];		/* temp var to use test char and */
d453 6
a458 1
	llist		points;		/* list of points */
d463 3
a465 2
	static char	*function = "MakeGammaZData";
					/* read path len var from file */
a467 5
	 * Allocate the data set header. 
	 */
	data	= (GammaZData *) pkg_malloc (sizeof (GammaZData), function, "data");

	/* 
d479 1
a479 1
		return (GammaZData *) NULL;
d489 1
d501 1
a513 10
	 * Initialize the point list. 
	 */
	points = llinit ();

	/* 
	 * Set the comparison function for llinsert. 
	 */
	llcmp = GammaZPointCmp;

	/* 
d516 11
a526 1
	rawpoint = (RawGammaZPoint *) pkg_malloc (sizeof (RawGammaZPoint), function, "rawpoint");
d539 1
a539 1
		 * Allocate mem for internal point representation. 
d541 3
a543 1
		point = (GammaZPoint *) pkg_malloc (sizeof(GammaZPoint), function, "point");
d545 6
a550 10
		/* 
		 * Fill the internal point structure. 
		 */
		point->x	= -rawpoint->x;
		point->y	= rawpoint->y;
		point->z	= rawpoint->z;
		point->sig	= rawpoint->sig;
		point->mag	= rawpoint->mag;
		point->z_score	= rawpoint->z_score;
		point->data_set	= data;
d552 33
a584 4
		/* 
		 * Insert the point into the point list. 
		 */
		llinsert (points, point);
d588 1
a588 1
	 * Free the raw point buffer. 
d590 3
a592 1
	XtFree(rawpoint);		
d594 1
a594 12
	/* 
	 * Fill the dataset header. 
	 */
	data->path_len		= path_len;
	data->path		= path;
	data->desc_len		= desc_len;
	data->description	= description;
	data->af3d_id		= af3d_id;
	data->num_points	= num_points;
	data->points		= points;

	return (data);
d599 1
a599 5
	Function:	MakeAsciiGammaZData	
	Arguments:	filename:	file containing ascii AF3D coordinates
					in the order of z, x, y.
	Description:	Allocate and read a set of AF3D points from an ascii 
			file. The coordinates should be arraged in z, x, y order.
d601 5
d607 1
a607 1
			Created on Sep. 21, 1993.
d609 1
a609 1
	Return Value:	Pointer to allocated dataset.
d612 15
a626 2
PRIVATE GammaZData *MakeAsciiGammaZData (filename)
	char	*filename;
d629 1
a629 2
	GammaZData	*data;		/* new data */
	GammaZPoint	*point;		/* new point to make structure */
d631 1
d635 9
a643 3
	int		num_points;	/* number of points in dataset */
	llist		points;		/* list of points */
	static char	*function = "MakeAsciGammaZData";
a644 21
	float		max;
	float		zscore;
	float		sig;
	short		path_len;
	char		path [MAXLINE];
	short		desc_len;
	char		description [MAXLINE];
	int		af3d_id;

	Arg		arglist [1];
	RawGammaZPoint	*rawpoint;	/* raw point read from input file */
	char		s[2];		/* temp var to use test char and */
	int		i;		/* counter */
	long		bytes;
	long		current_bytes;
					/* read path len var from file */
	/* 
	 * Allocate the data set header. 
	 */
	data	= (GammaZData *) pkg_malloc (sizeof (GammaZData), function, "data");

d650 1
a650 1
		return (GammaZData *) NULL;
d653 6
a658 3
	/* 
	 * Initialize the point list and set the comparison function for llinsert. 
	 */
a659 7
	points	= llinit ();
	llcmp	= GammaZPointCmp;

	num_points	= 0;
	max		= 0.0;
	zscore		= 0.0;
	sig		= 0.0;
d664 3
a666 4
			/* 
		 	 * Allocate memory for internal point representation. 
		 	 */
			point	= (GammaZPoint *) pkg_malloc (sizeof (GammaZPoint), function, "point");
d668 6
a673 10
			/* 
			 * Fill the internal point structure. 
			 */
			point->x	= x;
			point->y	= y;
			point->z	= z;
			point->sig	= sig;
			point->mag	= max;
			point->z_score	= zscore;
			point->data_set	= data;
d675 26
a700 4
			/* 
			 * Insert the point into the point list. 
			 */
			llinsert (points, point);
d702 6
a707 1
			num_points++;
d713 1
a713 21
	/* 
	 * Define the default parameters.
	 */
	strcpy (path, "Path is not known");
	path_len	= strlen (path);

	sprintf (description, "Created from ascii file %s", filename);
	desc_len	= strlen (description);

	/* 
	 * Fill the dataset header. 
	 */
	data->path_len		= path_len;
	data->path		= path;
	data->desc_len		= desc_len;
	data->description	= description;
	data->af3d_id		= 6;
	data->num_points	= num_points;
	data->points		= points;

	return (data);
d1549 3
a1551 3
	Function:	InputAF3DData
	Arguments:	AF3D_filename: pointer to AF3D loci points file name	
	Description:	Read AF3D data set into data_sets list.
d1553 1
a1553 1
	Return Value:	void.
d1555 1
a1555 1
			(06/26/1991)
d1558 15
a1572 9
PRIVATE void InputAF3DData (filenames, display_symbol, symbol_type, pixel_color, 
			symbol_size, outline_width, data_sets)
char		filenames [][MAXLINE];
BOOLEAN		*display_symbol;
char		*symbol_type;
Pixel		*pixel_color;
unsigned short	*symbol_size;
int		*outline_width;
llist		data_sets;
a1573 1
	GammaZData	*d;			/* new data set */
a1578 5
	/*
	 * Clear old data sets.
	 */
	ClearDataSets (data_sets);

d1584 1
a1584 1
				(fd = open (filenames [i], O_RDONLY, 0)) == -1)
d1589 5
a1593 1
			while (read (fd, &c, 1) == 1)		
d1595 13
a1607 24
				/* 
			 	 * Make new data set from input. 
			 	 */
				file_type	= getfile_type (filenames [i]);
				if (file_type == BINARY)
					d	= MakeGammaZData (fd, c);	
				else if (file_type == ASCII)
					d	= MakeAsciiGammaZData (filenames [i]);	
				else
					continue;

				if (d != (GammaZData *) NULL)
				{
					d->symbol_shape		= *(symbol_type + i);
					d->pixel_color		= *(pixel_color + i);
					d->symbol_size		= *(symbol_size + i);
					d->outline_width	= *outline_width;
					d->file_index		= i;

					/* 
			 	 	 * Add data set to global list. 
			 	 	 */
					lladd (data_sets, d);			
				}
d1609 14
a1622 2

			close (fd);
d1625 1
d2505 3
a2507 9
	if (llsize (data_sets) > 0)
	{
		llhead (data_sets);
	    	do 
	    	{
			data_set = (GammaZData *) llretrieve (data_sets);
			XSetForeground (display, gc, data_set->pixel_color);
			XSetLineAttributes (display, gc, pkg_min (data_set->symbol_size / 2,
				data_set->outline_width), LineSolid, CapButt, JoinMiter);
a2508 59
			llhead (data_set->points);
			do 
			{
				gammaz_point = (GammaZPoint *) llretrieve (data_set->points);
				point.x	= gammaz_point->x;
				point.y	= gammaz_point->y;
				point.z	= gammaz_point->z;
				coordinate	= GetCoordinate (point, atlas_orient);
				if (*draw_portal_data->all_planes ||
					((coordinate >= slice->slice_xyz - draw_portal_data->spacing) && 
					(coordinate < slice->slice_xyz + draw_portal_data->spacing))) 
				{
					draw_portal_data->symbol_displayed [data_set->file_index] = TRUE;

					/* 
			 		 * Reverse coordination orientation and scale. 
			 		 */
					sx	= ROUND ((point.x * 1.0) 
							/ current_header->pixel_size);
					sy	= ROUND ((point.y * -1.0) 
							/ current_header->pixel_size);
					sz	= ROUND ((point.z * -1.0)
							/ current_header->pixel_size);
					if (atlas_orient == TRANSVERSE)
					{
						tempx	= sx;
						tempy	= sy;
					}
					else if (atlas_orient == CORONAL)
					{
						tempx	= sx;
						tempy	= sz;
					}
					else if (atlas_orient == FACING_LEFT)
					{
						tempx	= sy;
						tempy	= sz;
					}
					else
					{
						tempx	= -sy;
						tempy	= sz;
					}

					tempx	+= x + current_header->centerx
							- data_set->symbol_size / 2;
					tempy	+= y + current_header->centery
							- data_set->symbol_size / 2;

					DrawSymbol (display, window, gc, tempx, tempy, 
							data_set->symbol_size, 
							data_set->symbol_size, 
							data_set->symbol_shape);
				}
			} while (llnext (data_set->points) != FAIL);
		} while (llnext (data_sets) != FAIL);
	}
	XSetLineAttributes (display, gc, 1, LineSolid, CapButt, JoinMiter);

a2744 1
			data_sets:	linked list for AF3D data.
d2751 1
a2751 1
PUBLIC void ClearData (plist, atlas, data_sets)
a2753 1
llist		data_sets;
d2780 1
a2780 1
	 * Clear memory corresponding to points and data_sets in slice. 
a2795 5

	/* 
	 * Clear data_sets. 
	 */
	ClearDataSets (data_sets);
a2831 49
	Procedure:	ClearDataSets.	
	Arguments:	data_sets:	linked list for AF3D data.
	Description:	Clear data sets linked list from memory. 
	Author:		Tom Yang
			(07/10/1992)
____________________________________________________________________________*/

PRIVATE void ClearDataSets (data_sets)
llist		data_sets;
{
	GammaZPoint	*point;
	GammaZData	*data_set;

	llhead (data_sets);
	while (llsize (data_sets) > 0)		/* step through data sets */
	{
		/* 
		 * Get a data set. 
		 */
		data_set = (GammaZData *) llretrieve (data_sets);

		/* 
		 * Remove all points in data set. 
		 */
		if (llsize (data_set->points) > 0) 
		{
			llhead (data_set->points);
			do 
			{
				point = (GammaZPoint *) llretrieve (data_set->points);
				lldelete (data_set->points);
				XtFree (point);
			} while (llsize (data_set->points) > 0);
		}

		/* 
		 * Free memory for header strings. 
		 */
		XtFree (data_set->path);
		XtFree (data_set->description);
		free (data_set->points);

		lldelete (data_sets);		/* delete data set from list */
		XtFree (data_set);		/* free mem for data set header */
	} 
}


/*____________________________________________________________________________	
d2977 1
a2977 1
PUBLIC void RedrawPortals (draw_data, atlas_list, portal_list, data_sets_list) 
a2980 1
llist		data_sets_list;
d3036 1
a3036 1
			ClearData (portal_list, atlas_list, data_sets_list);
a3057 3

	InputAF3DData (szAF3DFileNames, bDisplaySymbol, cSymbolType, 
		pixelAF3DColor, nSymbolSize, &nOutlineWidth, data_sets_list);
@


2.9
log
@Get rid of the path in atl files.
@
text
@d2 3
d244 1
a244 1
/*$Header: /home/petsun4/ty7777/src/view25d/RCS/portal.c,v 2.8 1994/12/01 16:58:44 ty7777 Exp ty7777 $*/
d250 1
a250 1
static char rcsid [] = "$Header: /home/petsun4/ty7777/src/view25d/RCS/portal.c,v 2.8 1994/12/01 16:58:44 ty7777 Exp ty7777 $";
a4307 1

d4317 1
d4319 1
a4319 2
	char		*buffer;
	int		point_size;
d4322 1
d4326 1
a4326 1
	strcpy (font_string, "*");
d4339 1
a4339 1
		strcat (font_string, "-r*");
d4341 1
a4341 1
		strcat (font_string, "-i*");
d4343 2
a4344 1
		strcat (font_string, "-o*");
d4351 1
a4351 1
	sprintf (size_string, "*%d", point_size);
d4355 4
a4358 1
	strcat (font_string, "*75-75*");
@


2.8
log
@Pass library_path from the main program.
@
text
@d2 3
d241 1
a241 1
/*$Header: /home/petsun4/ty7777/src/view25d/RCS/portal.c,v 2.7 1994/11/30 20:00:08 ty7777 Exp ty7777 $*/
d247 1
a247 1
static char rcsid [] = "$Header: /home/petsun4/ty7777/src/view25d/RCS/portal.c,v 2.7 1994/11/30 20:00:08 ty7777 Exp ty7777 $";
d678 1
a678 1
	Function:	void ReadAtlasHeader (char *atlas_filename)
d691 1
a691 1
PUBLIC void ReadAtlasHeader (atlas_filename)
d693 1
d698 3
a700 3
	char		label[MAXLINE];		/* text label in header file */ 
	char		temp_str[MAXLINE];	/* text label in header file */ 
	char		atlasz[MAXLINE];	/* text label in header file */ 
d720 1
a720 1
	if ( fgets (label, MAXLINE, atlasfp) == NULL )
d735 6
a740 2
	fscanf (atlasfp, "%s %s", label, atlas_header->scale_025_header.image_name);
	fscanf (atlasfp, "%s %s", label, atlas_header->scale_025_header.mask_name);
d742 1
a742 1
	fscanf (atlasfp, "%s %s", label, temp_str);
d752 6
a757 2
	fscanf (atlasfp, "%s %s", label, atlas_header->scale_050_header.image_name);
	fscanf (atlasfp, "%s %s", label, atlas_header->scale_050_header.mask_name);
d759 1
a759 1
	fscanf (atlasfp, "%s %s", label, temp_str);
d769 6
a774 2
	fscanf (atlasfp, "%s %s", label, atlas_header->scale_100_header.image_name);
	fscanf (atlasfp, "%s %s", label, atlas_header->scale_100_header.mask_name);
d776 1
a776 1
	fscanf (atlasfp, "%s %s %s", label, temp_str, atlasz);
d4391 1
d4394 1
d4403 1
d4439 5
a4443 2
				strcpy (szAtlasFileName, value);
				ReadAtlasHeader (value);
d4445 4
d4450 1
a4450 1
				if (strstr (value, "Talairach") == NULL)
d5430 2
d5434 1
d5454 6
a5459 1
	fprintf (file, "AtlasFileName:		%s\n", szAtlasFileName);
d5911 1
a5911 1
		ReadAtlasHeader (atlas_name);
@


2.7
log
@Same as the last version.
@
text
@d2 3
d238 1
a238 1
/*$Header: /home/petsun4/ty7777/src/view25d/RCS/portal.c,v 2.6 1994/11/01 17:36:48 ty7777 Exp ty7777 $*/
d244 1
a244 1
static char rcsid [] = "$Header: /home/petsun4/ty7777/src/view25d/RCS/portal.c,v 2.6 1994/11/01 17:36:48 ty7777 Exp ty7777 $";
d4423 1
a4423 1
				strcpy (mask_name, szLibraryPathName);
d4519 1
a4519 1
				SetDefaultAtlas (*atlas_orient);
d5010 1
a5010 1
				strcpy (color_table_name, szLibraryPathName);
d5835 1
a5835 1
PUBLIC void SetDefaultAtlas (atlas_orient)
d5837 1
a5841 1
	char	*library_path	= szLibraryPathName;
@


2.6
log
@Change the mask file if necessary when reading defaults file.
@
text
@d2 3
d235 1
a235 1
/*$Header: /home/petsun4/ty7777/src/view25d/RCS/portal.c,v 2.5 1994/10/28 16:17:43 ty7777 Exp ty7777 $*/
d241 1
a241 1
static char rcsid [] = "$Header: /home/petsun4/ty7777/src/view25d/RCS/portal.c,v 2.5 1994/10/28 16:17:43 ty7777 Exp ty7777 $";
@


2.5
log
@Use winutil.h
@
text
@d2 3
d232 1
a232 1
/*$Header: /home/petsun4/ty7777/src/view25d/RCS/portal.c,v 2.4 1994/10/27 20:02:04 ty7777 Exp ty7777 $*/
d238 1
a238 1
static char rcsid [] = "$Header: /home/petsun4/ty7777/src/view25d/RCS/portal.c,v 2.4 1994/10/27 20:02:04 ty7777 Exp ty7777 $";
d4375 1
d4416 11
@


2.4
log
@Added checking for zorigin.
@
text
@d2 3
d229 1
a229 1
/*$Header: /home/petsun4/ty7777/src/view25d/RCS/portal.c,v 2.3 1994/10/26 16:15:35 ty7777 Exp ty7777 $*/
d235 1
a235 1
static char rcsid [] = "$Header: /home/petsun4/ty7777/src/view25d/RCS/portal.c,v 2.3 1994/10/26 16:15:35 ty7777 Exp ty7777 $";
d1049 1
a1049 1
				"You can use the program setz0 to add the z0 slice to your image.\n");
@


2.3
log
@Added winutil.h
@
text
@d2 3
d226 1
a226 1
/*$Header: /home/petsun4/ty7777/src/view25d/RCS/portal.c,v 2.2 1994/10/19 17:17:38 ty7777 Exp ty7777 $*/
d232 1
a232 1
static char rcsid [] = "$Header: /home/petsun4/ty7777/src/view25d/RCS/portal.c,v 2.2 1994/10/19 17:17:38 ty7777 Exp ty7777 $";
d1039 11
@


2.2
log
@Change IF to if.
@
text
@d2 3
d223 1
a223 1
/*$Header: /home/petsun4/ty7777/src/view25d/RCS/portal.c,v 2.1 1994/10/19 17:01:16 ty7777 Exp ty7777 $*/
d229 1
a229 1
static char rcsid [] = "$Header: /home/petsun4/ty7777/src/view25d/RCS/portal.c,v 2.1 1994/10/19 17:01:16 ty7777 Exp ty7777 $";
d280 1
@


2.1
log
@The pattern *pattern* works.
@
text
@d2 3
d220 1
a220 1
/*$Header: /home/petsun4/ty7777/src/view25d/RCS/portal.c,v 1.99 1994/10/17 19:53:07 ty7777 Exp ty7777 $*/
d226 1
a226 1
static char rcsid [] = "$Header: /home/petsun4/ty7777/src/view25d/RCS/portal.c,v 1.99 1994/10/17 19:53:07 ty7777 Exp ty7777 $";
d5831 1
a5831 1
	IF (strcmp (szBuffer, atlas_name) != 0)
@


1.99
log
@Before file patterns work.
@
text
@d2 3
d217 1
a217 1
/*$Header: /home/petsun4/ty7777/src/view25d/RCS/portal.c,v 1.98 1994/10/14 18:07:42 ty7777 Exp ty7777 $*/
d223 1
a223 1
static char rcsid [] = "$Header: /home/petsun4/ty7777/src/view25d/RCS/portal.c,v 1.98 1994/10/14 18:07:42 ty7777 Exp ty7777 $";
d4467 2
a4468 3
				XtSetValues (GetActiveWidget 
				(data_type_menu->orientation_set, 
						ORIENTATION_NUM), arglist, n);
d5828 1
a5828 1
	if (strcmp (szBuffer, atlas_name) != 0)
a5832 1
	}
d5834 10
a5843 4
	strcpy (mask_name, library_path);
	if (strstr (atlas_name, "Talairach") == NULL)
	{
		strcat (mask_name, "HD6.mask");
a5844 5
	else
	{
		strcat (mask_name, "pett6_n99.t88.mask");
	}
	strcpy (szPetMaskFileName, mask_name);
@


1.98
log
@Allow maximum distance for single slices.
@
text
@d2 3
d214 1
a214 1
/*$Header: /home/petsun4/ty7777/src/view25d/RCS/portal.c,v 1.97 1994/10/13 18:54:48 ty7777 Exp ty7777 $*/
d220 1
a220 1
static char rcsid [] = "$Header: /home/petsun4/ty7777/src/view25d/RCS/portal.c,v 1.97 1994/10/13 18:54:48 ty7777 Exp ty7777 $";
d5870 1
d5981 1
a5981 2
	XtFree (xmStrImageName);
	xmStrImageName	= XmStringCreate (szBuffer, XmSTRING_DEFAULT_CHARSET); 
d5987 1
a5987 1
	XtSetArg (arglist [n], XmNlabelString, xmStrImageName); n++;
d5989 1
@


1.97
log
@Uses pett6_n99 as the default t88 mask.
@
text
@d2 3
d211 1
a211 1
/*$Header: /home/petsun4/ty7777/src/view25d/RCS/portal.c,v 1.96 1994/08/25 16:40:41 ty7777 Exp ty7777 $*/
d217 1
a217 1
static char rcsid [] = "$Header: /home/petsun4/ty7777/src/view25d/RCS/portal.c,v 1.96 1994/08/25 16:40:41 ty7777 Exp ty7777 $";
d1804 4
a1807 1
		draw_portal_data.spacing		= pkg_min (nSpacing, dMaximumDistance);
@


1.96
log
@Changed the documentation.
@
text
@d2 3
d208 1
a208 1
/*$Header: /home/petsun4/ty7777/src/view25d/RCS/portal.c,v 1.95 1994/08/25 16:39:00 ty7777 Exp ty7777 $*/
d214 1
a214 1
static char rcsid [] = "$Header: /home/petsun4/ty7777/src/view25d/RCS/portal.c,v 1.95 1994/08/25 16:39:00 ty7777 Exp ty7777 $";
d5831 1
a5831 1
		strcat (mask_name, "Talairach.mask");
@


1.95
log
@Same as the last one.
X11R5 version.
@
text
@d2 4
d205 1
a205 1
/*$Header: /home/petsun4/ty7777/src/view25d/RCS/portal.c,v 1.94 1994/08/17 21:19:36 ty7777 Exp ty7777 $*/
d211 1
a211 1
static char rcsid [] = "$Header: /home/petsun4/ty7777/src/view25d/RCS/portal.c,v 1.94 1994/08/17 21:19:36 ty7777 Exp ty7777 $";
d222 1
a222 1
	Author:
d224 1
a224 1
		02/01/90
@


1.94
log
@Delected redundant code for getting the zorigin.
@
text
@d2 3
d201 1
a201 1
/*$Header: /home/petsun4/ty7777/src/view25d/RCS/portal.c,v 1.93 1994/08/17 20:26:19 ty7777 Exp ty7777 $*/
d207 1
a207 1
static char rcsid [] = "$Header: /home/petsun4/ty7777/src/view25d/RCS/portal.c,v 1.93 1994/08/17 20:26:19 ty7777 Exp ty7777 $";
@


1.93
log
@Added processing for X, Y, Z values when getting defaults.
@
text
@d2 3
d198 1
a198 1
/*$Header: /home/petsun4/ty7777/src/view25d/RCS/portal.c,v 1.92 1994/08/17 19:46:01 ty7777 Exp ty7777 $*/
d204 1
a204 1
static char rcsid [] = "$Header: /home/petsun4/ty7777/src/view25d/RCS/portal.c,v 1.92 1994/08/17 19:46:01 ty7777 Exp ty7777 $";
d949 1
a949 2
	 * Find the encoding, number of slices, the pett number, and the 
	 * zorigin for the image file.
a973 19

	*pzorigin	= DEFAULT_ZORIGIN;
	if (pett_num == ECAT_SCANNER)
	{
		fptr	= OpenEcat (pet_filename, &num_slices, &width, &height, 
				&voxel_width, &voxel_depth, matval);
		if (fptr == (MatrixFile *) NULL)
		{
			fprintf (stderr, "Cannnot open image %s.\n", pet_filename);
			return;
		}

		comment_info (fptr->mhptr->study_description, &comment_info_data);

		*pzorigin	= comment_info_data.zorigin;
		bZoriginChanged	= TRUE;

		matrix_close (fptr);
	}
@


1.92
log
@Display the bottom slices of the PET iamge.
@
text
@d2 3
d195 1
a195 1
/*$Header: /home/petsun4/ty7777/src/view25d/RCS/portal.c,v 1.91 1994/08/17 16:16:29 ty7777 Exp ty7777 $*/
d201 1
a201 1
static char rcsid [] = "$Header: /home/petsun4/ty7777/src/view25d/RCS/portal.c,v 1.91 1994/08/17 16:16:29 ty7777 Exp ty7777 $";
a4310 8
	FILE			*file;
	char			line [MAXLINE];
	char			label [MAXLINE];
	char			value [MAXLINE];
	char			lowered_value [MAXLINE];
	Widget			widget_buffer;
	int			n;
	int			i;
d4312 1
a4312 3
	char			*font_name;
	XmString		item;
	char			*color_table_name	= szColorTableName;
d4314 4
a4317 1
	char			*atlas_orient		= &cAtlasOrientation;
d4319 6
a4324 11
	short			*first_slice		= &nFirstSlice;
	short			*last_slice		= &nLastSlice;
	BOOLEAN			*auto_pet_value_flag	= &bAutoPetValueFlag;        
	BOOLEAN			*pet_value_flag		= &cPetValueFlag;        
	short			*min_pet_value		= &nMinPetValue;
	short			*max_pet_value		= &nMaxPetValue;
	short			*xcolor_bar		= &nxColorBarStart;
	short			*ycolor_bar		= &nyColorBarStart;
	short			*color_bar_length	= &nColorBarLength;
	short			*color_bar_width	= &nColorBarWidth;
	BOOLEAN			*color_bar_orient	= &bHorizontalColorBar;
d4326 3
a4328 1
	DATA_TYPE_MENU		*data_type_menu		= default_parameters->data_type_menu;
d4331 2
a4332 3
	FORMAT_SCREEN_MENU	*format_screen_menu	= default_parameters->format_screen_menu;
	COLOR_BAR_MENU		*color_bar_menu		= default_parameters->color_bar_menu;
	FONT_MENU		*font_menu		= default_parameters->font_menu;
d4334 9
a4342 1

a4343 1
	BOOLEAN			*region_onoff		= bDisplayRegion;
a4345 1

a4346 2
	BOOLEAN			*symbol_onoff		= bDisplaySymbol;
	char			*dynamic_symbol_color	= cDynamicSymbolColor;
d4348 1
a4348 1
	char			*dynamic_symbol_type	= cDynamicSymbolType;
d4350 13
a4362 1
	char			**symbol_names		= symbolNames;
a4363 5
	Screen			*screen;
	Pixel			foreground;
	Pixel			background;
	Pixmap			pixmap_symbol;
	BOOLEAN			filled;
d5162 61
@


1.91
log
@Apply the zorigin only to the transverse slices.
@
text
@d2 3
d192 1
a192 1
/*$Header: /home/petsun4/ty7777/src/view25d/RCS/portal.c,v 1.90 1994/08/16 15:45:44 ty7777 Exp ty7777 $*/
d198 1
a198 1
static char rcsid [] = "$Header: /home/petsun4/ty7777/src/view25d/RCS/portal.c,v 1.90 1994/08/16 15:45:44 ty7777 Exp ty7777 $";
d843 1
d845 4
d850 1
d852 1
@


1.90
log
@Added error checking for the first and last slice.
@
text
@d2 3
d189 1
a189 1
/*$Header: /amd/home/petsun4/ty7777/src/view25d/RCS/portal.c,v 1.89 1994/08/12 16:59:19 ty7777 Exp ty7777 $*/
d195 1
a195 1
static char rcsid [] = "$Header: /amd/home/petsun4/ty7777/src/view25d/RCS/portal.c,v 1.89 1994/08/12 16:59:19 ty7777 Exp ty7777 $";
d839 4
a842 1
		index			= desired_slice - 1 + (DEFAULT_ZORIGIN - zorigin);
@


1.89
log
@Use the index in BuildQueue ().
@
text
@d2 3
d186 1
a186 1
/*$Header: /home/petsun4/ty7777/src/view25d/RCS/portal.c,v 1.88 1994/08/11 21:21:13 ty7777 Exp ty7777 $*/
d192 1
a192 1
static char rcsid [] = "$Header: /home/petsun4/ty7777/src/view25d/RCS/portal.c,v 1.88 1994/08/11 21:21:13 ty7777 Exp ty7777 $";
d1088 1
a1157 1
			slice = llretrieve (atlas_list);
@


1.88
log
@Changed the error message.
@
text
@d2 3
d183 1
a183 1
/*$Header: /home/petsun4/ty7777/src/view25d/RCS/portal.c,v 1.87 1994/06/23 17:12:24 ty7777 Exp ty7777 $*/
d189 1
a189 1
static char rcsid [] = "$Header: /home/petsun4/ty7777/src/view25d/RCS/portal.c,v 1.87 1994/06/23 17:12:24 ty7777 Exp ty7777 $";
a816 1
		min_index_num	= DEFAULT_ZORIGIN - zorigin;
a820 1
		min_index_num	= 0;
d822 1
d833 1
a833 1
		index			= min_index_num + desired_slice - 1;
d837 2
a838 2
			"The slice number %d is outside the range [%d, %d].\n", 
				index + 1, min_index_num + 1, max_index_num + 1);
d841 1
a841 2
		else if (index < 0)
			index	= max_index_num;
@


1.87
log
@Delected the debugging messages.
@
text
@d2 3
d180 1
a180 1
/*$Header: /home/petsun4/ty7777/src/view25d/RCS/portal.c,v 1.86 1994/06/23 16:57:11 ty7777 Exp ty7777 $*/
d186 1
a186 1
static char rcsid [] = "$Header: /home/petsun4/ty7777/src/view25d/RCS/portal.c,v 1.86 1994/06/23 16:57:11 ty7777 Exp ty7777 $";
d834 3
a836 2
			fprintf (stderr, "The index %d is outside the range [%d, %d].\n", 
				index, min_index_num, max_index_num);
@


1.86
log
@Added checking for the first slice and last slice in GetDefaultParameters ().
@
text
@d2 3
d177 1
a177 1
/*$Header: /amd/home/petsun4/ty7777/src/view25d/RCS/portal.c,v 1.85 1994/06/02 20:55:16 ty7777 Exp ty7777 $*/
d183 1
a183 1
static char rcsid [] = "$Header: /amd/home/petsun4/ty7777/src/view25d/RCS/portal.c,v 1.85 1994/06/02 20:55:16 ty7777 Exp ty7777 $";
a3020 1
printf ("first slice = %d last_slice = %d spacing = %d\n", first_slice, last_slice, spacing);
@


1.85
log
@Match the PET images correctly with the atlas slices in the right
handed coordinate system.
@
text
@d2 4
d174 1
a174 1
/*$Header: /amd/home/petsun4/ty7777/src/view25d/RCS/portal.c,v 1.84 1994/05/19 14:11:53 ty7777 Exp ty7777 $*/
d180 1
a180 1
static char rcsid [] = "$Header: /amd/home/petsun4/ty7777/src/view25d/RCS/portal.c,v 1.84 1994/05/19 14:11:53 ty7777 Exp ty7777 $";
d3018 1
d4575 1
d4577 1
a4577 1
					if (strcmp (lowered_value, "true") == 0)
d4652 1
d4654 1
a4654 1
					if (strcmp (lowered_value, "true") == 0)
d5134 3
@


1.84
log
@Changed from (z, x, y) to (x, y, z).
@
text
@d2 3
d170 1
a170 1
/*$Header: /amd/home/petsun4/ty7777/src/view25d/RCS/portal.c,v 1.83 1994/05/09 21:59:17 ty7777 Exp ty7777 $*/
d176 1
a176 1
static char rcsid [] = "$Header: /amd/home/petsun4/ty7777/src/view25d/RCS/portal.c,v 1.83 1994/05/09 21:59:17 ty7777 Exp ty7777 $";
d863 1
d1047 14
a1060 1
		lltail (atlas_list);
a1061 1
		llhead (slice3d_list);			
d1227 3
a1229 1
		while (llprevious (atlas_list) != FAIL && slice_index <= last_slice);
@


1.83
log
@Update for mask 75 slice images and read zorigin.
@
text
@d2 3
d167 1
a167 1
/*$Header: /home/petsun4/ty7777/src/view25d/RCS/portal.c,v 1.82 1994/05/09 16:43:31 ty7777 Exp ty7777 $*/
d173 1
a173 1
static char rcsid [] = "$Header: /home/petsun4/ty7777/src/view25d/RCS/portal.c,v 1.82 1994/05/09 16:43:31 ty7777 Exp ty7777 $";
d446 1
a446 1
		point->x	= rawpoint->x;
a464 1

d549 1
a549 1
		if (sscanf (line, "%f %f %f", &z, &x, &y) == 3) 
d1369 1
a1369 1
    			region_data->region_input [i].x	= (REGION_SLICE_CX - tempx)
d2280 1
a2280 1
					sx	= ROUND ((region_input [i].x * -1.0) 
d2380 1
a2380 1
					sx	= ROUND ((point.x * -1.0) 
d5538 4
d5544 1
a5544 1
		atlas_coord	= SliceXY (slice_num);
d5572 4
d5578 1
a5578 1
		slice_number	= XYtoSlice (slice_coord);
d5838 5
d5857 1
a5857 1
	sprintf (szBuffer, "(%d, %d, %d)     ", az, ax, ay);
d5878 1
a5878 1
		fprintf (logfp, "%d      %d      %d\n", az, ax, ay);
@


1.82
log
@Changed the processing for mask to use zorigin.
@
text
@d2 3
d164 1
a164 1
/*$Header: /home/petsun4/ty7777/src/view25d/RCS/portal.c,v 1.81 1994/05/09 16:07:53 ty7777 Exp ty7777 $*/
d170 1
a170 1
static char rcsid [] = "$Header: /home/petsun4/ty7777/src/view25d/RCS/portal.c,v 1.81 1994/05/09 16:07:53 ty7777 Exp ty7777 $";
d855 1
d872 2
d888 1
d890 1
d899 6
d906 2
a907 1
	 * Allocate header 
d918 4
a921 1
		fprintf (stderr, "Can't open %d\n", pet_filename); 
a932 3
	/*
	 * Find the zorigin.
	 */
a935 6
		matval.frame	= 1;
		matval.plane	= 1;
		matval.gate	= 1;
		matval.data	= 0;
		matval.bed	= 0;

d952 38
d994 2
a995 2
	slice_dim	= ENCODED_SLICE_WIDTH * ENCODED_SLICE_HEIGHT;
	zorigin_offset	= DEFAULT_ZORIGIN - *pzorigin;
d1001 1
a1001 2
		horizontal_slice->slice_data	= (short *) calloc (ENCODED_SLICE_DIM, 
							sizeof (short));
d1018 2
a1019 1
			mask_slice_image	= (short *) calloc (ENCODED_SLICE_DIM, sizeof (short));
d1021 2
a1022 1
			if (slice_index + zorigin_offset <= PETT6_49)
d1024 8
a1031 5
						slice_index + zorigin_offset, 0, PETT6_49, 
						PETT6_SCANNER, &err_value);
			else
				getimage (mask_slice_image, header, mskfd, pet_mask_file_name, 
					PETT6_49, 0, PETT6_49, PETT6_SCANNER, &err_value);
a1032 6

			for (i = 0; i < slice_dim; i++)
			{
				if (mask_slice_image [i] <= 0)
					horizontal_slice->slice_data [i] = 0;
			}
@


1.81
log
@Added color table Color43.tbl.
@
text
@d2 3
d161 1
a161 1
/*$Header: /home/petsun4/ty7777/src/view25d/RCS/portal.c,v 1.80 1994/05/06 19:40:45 ty7777 Exp ty7777 $*/
d167 1
a167 1
static char rcsid [] = "$Header: /home/petsun4/ty7777/src/view25d/RCS/portal.c,v 1.80 1994/05/06 19:40:45 ty7777 Exp ty7777 $";
d858 1
d860 1
a860 2
	XPoint		ptBottomRight;
	char		atlas_orient	= cAtlasOrientation;
d862 1
a863 1
	float		voxel_depth;
d871 2
d875 1
a875 2
	int		slice_width;
	int		slice_height;
d878 1
a879 1
	short		global_max	= -MAXSHORT;
a914 1

d918 1
d937 2
a938 5
		if (comment_info_data.zorigin != *pzorigin)
		{
			*pzorigin	= comment_info_data.zorigin;
			bZoriginChanged	= TRUE;
		}
d948 1
d974 1
a974 1
			if (slice_index <= PETT6_49)
d976 2
a977 1
					slice_index, 0, PETT6_49, PETT6_SCANNER, &err_value);
@


1.80
log
@Added processing for zorigin display for coronal and sagittal sections.
@
text
@d2 3
d158 1
a158 1
/*$Header: /home/petsun4/ty7777/src/view25d/RCS/portal.c,v 1.79 1994/04/18 17:55:03 ty7777 Exp ty7777 $*/
d164 1
a164 1
static char rcsid [] = "$Header: /home/petsun4/ty7777/src/view25d/RCS/portal.c,v 1.79 1994/04/18 17:55:03 ty7777 Exp ty7777 $";
d3091 1
a3091 1
	|| strncmp (short_color_table_name, "Color42_White0.tbl", 18) == 0)
@


1.79
log
@Added processing for zorigin.
@
text
@d2 3
d155 1
a155 1
/*$Header: /home/petsun4/ty7777/src/view25d/RCS/portal.c,v 1.78 1994/04/14 20:38:12 ty7777 Exp ty7777 $*/
d161 1
a161 1
static char rcsid [] = "$Header: /home/petsun4/ty7777/src/view25d/RCS/portal.c,v 1.78 1994/04/14 20:38:12 ty7777 Exp ty7777 $";
d774 2
d787 10
d807 2
a808 2
		index			= (DEFAULT_ZORIGIN - zorigin) + desired_slice - 1;
		if (index < 0 || index >= MAX_ATLAS_NUM)
d810 2
a811 2
			fprintf (stderr, "The index %d is outside the range [0, %d].\n", 
				index, MAX_ATLAS_NUM);
d814 2
d909 3
a911 3
	/*______________________________________________________
	 * Write 3D image to an ECAT matrix file.
	 *______________________________________________________*/
d939 3
d943 1
d977 1
a977 1
			for (j = 0; j < ENCODED_SLICE_HEIGHT; j++)
d979 2
a980 6
				rows	= j * ENCODED_SLICE_WIDTH;
				for (i = 0; i < ENCODED_SLICE_WIDTH; i++)
				{
					if (mask_slice_image [rows + i] <= 0)
						horizontal_slice->slice_data [rows + i] = 0;
				}
d1002 1
a1002 1
			pet_slice_image = (short *) calloc (slice_dim, sizeof (short));
d1019 1
a1019 1
				for (j = 0; j < slice_height; j++)
d1021 1
a1021 6
					rows	= j * slice_width;
					for (i = 0; i < slice_width; i++)
					{
						pet_slice_image [rows + i] 
							= horizontal_slice->slice_data [rows + i];
					}
d1130 5
d1154 1
a1154 1
			minmax_changed		= TRUE;
@


1.78
log
@Uses slice2z () and z2slice ().
@
text
@d2 3
d152 1
a152 1
/*$Header: /home/petsun4/ty7777/src/view25d/RCS/portal.c,v 1.77 1994/04/13 15:09:59 ty7777 Exp ty7777 $*/
d158 1
a158 1
static char rcsid [] = "$Header: /home/petsun4/ty7777/src/view25d/RCS/portal.c,v 1.77 1994/04/13 15:09:59 ty7777 Exp ty7777 $";
d208 1
a764 2
	int		desired_slice;
	SliceData	*slice;
d767 1
d769 2
d792 8
a799 1
		slice->atlas_index	= atlas_header->index_table [desired_slice - 1];
d831 1
d833 1
d839 2
d846 1
d857 1
d863 1
d865 1
d883 4
a890 2
	if (pett_num == ERROR_SCANNER)
		return;
d892 10
a901 1
	close (imgfd);
d903 19
d1307 1
a1307 1
		region_data->z			= (int) slice2z (slice_index, 31);
d2882 3
a2885 1
	Window		window		= draw_data->window;
a2886 6
	short		first_slice	= nFirstSlice;
	short		last_slice	= nLastSlice;
	short		spacing		= nSpacing;
	char		input_node	= INPUT_NEW;
	SliceData	*slice;
	SliceData	*portal_slice;
a2887 2
	short		minimum;
	short		maximum;
d2889 5
a2893 2
	BOOLEAN		*mag_changed	= &bMagChanged;
	BOOLEAN		*atlas_changed	= &bAtlasChanged;
a2894 3
	char		atlas_orient	= cAtlasOrientation;
	int		*old_atlas_w	= &nOldAtlasWidth;  
	int		*old_atlas_h	= &nOldAtlasHeight;  
d2897 7
d2914 1
a2914 1
	if (*mag_changed || *atlas_changed)
d2919 1
d5466 1
a5466 1
		atlas_coord	= (int) slice2z (slice_num, 31);
d5496 1
a5496 1
		slice_number	= z2slice ((float)slice_coord, 31);
@


1.77
log
@Changed the color table names.
@
text
@d2 3
d149 1
a149 1
/*$Header: /home/petsun4/ty7777/src/view25d/RCS/portal.c,v 1.76 1994/04/12 20:46:15 ty7777 Exp ty7777 $*/
d155 1
a155 1
static char rcsid [] = "$Header: /home/petsun4/ty7777/src/view25d/RCS/portal.c,v 1.76 1994/04/12 20:46:15 ty7777 Exp ty7777 $";
d1257 1
a1257 1
		region_data->z			= (int) (SliceZ (slice_index));
d5414 1
a5414 1
		atlas_coord	= SliceZ (slice_num);
d5444 1
a5444 1
		slice_number	= ZtoSlice (slice_coord);
@


1.76
log
@Added frames for color bar.
@
text
@d2 3
d146 1
a146 1
/*$Header: /home/petsun4/ty7777/src/view25d/RCS/portal.c,v 1.75 1994/04/12 20:08:59 ty7777 Exp ty7777 $*/
d152 1
a152 1
static char rcsid [] = "$Header: /home/petsun4/ty7777/src/view25d/RCS/portal.c,v 1.75 1994/04/12 20:08:59 ty7777 Exp ty7777 $";
d3016 1
a3016 1
	|| strncmp (short_color_table_name, "Color41.tbl", 11) == 0)
@


1.75
log
@Adding frames to black and white color bar.
@
text
@d2 3
d143 1
a143 1
/*$Header: /amd/home/petsun4/ty7777/src/view25d/RCS/portal.c,v 1.74 1994/04/12 15:27:41 ty7777 Exp ty7777 $*/
d149 1
a149 1
static char rcsid [] = "$Header: /amd/home/petsun4/ty7777/src/view25d/RCS/portal.c,v 1.74 1994/04/12 15:27:41 ty7777 Exp ty7777 $";
d3005 6
a3064 6

	extension	= strrchr (color_table_name, '/');
	if (extension != NULL && strncmp (extension, "/", 1) == 0)
		short_color_table_name	= extension + 1;
	else
		short_color_table_name	= color_table_name;
@


1.74
log
@Lowered () is changed.
@
text
@d2 3
d140 1
a140 1
/*$Header: /home/petsun4/ty7777/src/view25d/RCS/portal.c,v 1.73 1994/04/07 16:52:09 ty7777 Exp ty7777 $*/
d146 1
a146 1
static char rcsid [] = "$Header: /home/petsun4/ty7777/src/view25d/RCS/portal.c,v 1.73 1994/04/07 16:52:09 ty7777 Exp ty7777 $";
d2985 16
a3000 8
	short	increment;
	short	xstart;
	short	ystart;
	short	w;
	short	h;
	char	i;
	Pixel	color_pixel;
	BOOLEAN	direction_flag;
d3002 11
a3012 1
	increment	= length / NCOLORS;
d3017 2
d3024 2
d3027 7
d3055 14
@


1.73
log
@Final checking in.
@
text
@d2 3
d137 1
a137 1
/*$Header: /home/petsun4/ty7777/src/view25d/RCS/portal.c,v 1.72 1994/02/17 17:27:44 ty7777 Exp ty7777 $*/
d143 1
a143 1
static char rcsid [] = "$Header: /home/petsun4/ty7777/src/view25d/RCS/portal.c,v 1.72 1994/02/17 17:27:44 ty7777 Exp ty7777 $";
d3888 1
a3888 1
	char	*lower_name;
d3893 2
a3894 1
	lower_name	= Lowered (name, strlen (name));
d4086 1
d4147 3
d4160 1
a4160 1
				if (strcmp (Lowered (value, strlen (value)), "true") == 0)
d4173 1
a4173 1
				if (strcmp (Lowered (value, strlen (value)), "true") == 0)
d4186 1
a4186 1
				if (strcmp (Lowered (value, strlen (value)), "true") == 0)
d4199 1
a4199 1
				if (strcmp (Lowered (value, strlen (value)), "true") == 0)
d4212 1
a4212 1
				if (strcmp (Lowered (value, strlen (value)), "true") == 0)
d4327 1
a4327 1
				if (strcmp (Lowered (value, strlen (value)), "true") == 0)
d4376 1
a4376 1
					if (strcmp (Lowered (value, strlen (value)), "true") == 0)
d4417 1
a4417 1
				if (strcmp (Lowered (value, strlen (value)), "true") == 0)
d4452 1
a4452 1
					if (strcmp (Lowered (value, strlen (value)), "true") == 0)
d4616 1
a4616 1
				if (strcmp (Lowered (value, strlen (value)), "true") == 0)
d4629 1
a4629 1
				if (strcmp (Lowered (value, strlen (value)), "true") == 0)
d4674 1
a4674 1
				if (strcmp (Lowered (value, strlen (value)), "true") == 0)
@


1.72
log
@Fixed show points error for FACING_LEFT slices.
@
text
@d2 3
d134 1
a134 1
/*$Header: /home/petsun4/ty7777/src/view25d/RCS/portal.c,v 1.71 1994/02/11 22:23:15 ty7777 Exp ty7777 $*/
d140 1
a140 1
static char rcsid [] = "$Header: /home/petsun4/ty7777/src/view25d/RCS/portal.c,v 1.71 1994/02/11 22:23:15 ty7777 Exp ty7777 $";
d570 1
a570 4
	Function:	ReadAtlasHeader
	Arguments:	atlas_filename: pointer to atlas image filename	
	Description:	Read atlas header and set the rAtlasHeader 
			structure.
d572 9
a580 2
	Return Value:	none. to new atlas slice.
	Author:		Tom Yang
@


1.71
log
@Fixed region display problem.
@
text
@d2 3
d131 1
a131 1
/*$Header: /home/petsun4/ty7777/src/view25d/RCS/portal.c,v 1.70 1994/01/24 20:08:25 ty7777 Exp ty7777 $*/
d137 1
a137 1
static char rcsid [] = "$Header: /home/petsun4/ty7777/src/view25d/RCS/portal.c,v 1.70 1994/01/24 20:08:25 ty7777 Exp ty7777 $";
d2233 1
a2233 2
					draw_portal_data->symbol_displayed [data_set->file_index]
					= TRUE;
d5591 7
a5597 1
			cx	= best_portal->xold + current_header->centerx;
a5628 1

@


1.70
log
@Added copyright information.
@
text
@d2 3
d128 1
a128 1
/*$Header: /home/petsun4/ty7777/src/view25d/RCS/portal.c,v 1.69 1994/01/12 21:37:49 ty7777 Exp ty7777 $*/
d134 1
a134 1
static char rcsid [] = "$Header: /home/petsun4/ty7777/src/view25d/RCS/portal.c,v 1.69 1994/01/12 21:37:49 ty7777 Exp ty7777 $";
d1224 1
a1224 1
    			region_data->region_input [i].x	= (tempx - REGION_SLICE_CX)
d1226 1
a1226 1
    			region_data->region_input [i].y	= (tempy - REGION_SLICE_CY)
d2132 9
a2140 3
					sx	= ROUND (region_input [i].x / current_header->pixel_size);
					sy	= ROUND (region_input [i].y / current_header->pixel_size);
					sz	= ROUND (region_input [i].z / current_header->pixel_size);
d2234 1
a2234 1
			 		 * Reverse coord. orientation and scale 
@


1.69
log
@Fix GetLegendDim bug.
@
text
@d2 3
d125 1
a125 1
/*$Header: /home/petsun4/ty7777/src/view25d/RCS/portal.c,v 1.68 1994/01/11 22:24:18 ty7777 Exp ty7777 $*/
d131 1
a131 1
static char rcsid [] = "$Header: /home/petsun4/ty7777/src/view25d/RCS/portal.c,v 1.68 1994/01/11 22:24:18 ty7777 Exp ty7777 $";
d2864 1
a2864 2
		InputPetData (szPetFileName, atlas_list, first_slice,
				last_slice, spacing);
@


1.68
log
@Added processing for legend.
@
text
@d2 3
d122 1
a122 1
/*$Header: /export/home/petsun4/ty7777/src/view25d/RCS/portal.c,v 1.67 1994/01/11 17:55:38 ty7777 Exp ty7777 $*/
d128 1
a128 1
static char rcsid [] = "$Header: /export/home/petsun4/ty7777/src/view25d/RCS/portal.c,v 1.67 1994/01/11 17:55:38 ty7777 Exp ty7777 $";
d3349 1
a3349 2
			string_width	= XTextWidth (font_struct, short_name, 
					strlen (short_name)) + height * 2;
@


1.67
log
@Make the Show Coordinates right for Talairach atlases.
@
text
@d2 3
d119 1
a119 1
/*$Header: /home/petsun4/ty7777/src/view25d/RCS/portal.c,v 1.66 1994/01/11 16:15:52 ty7777 Exp ty7777 $*/
d125 1
a125 1
static char rcsid [] = "$Header: /home/petsun4/ty7777/src/view25d/RCS/portal.c,v 1.66 1994/01/11 16:15:52 ty7777 Exp ty7777 $";
d3305 2
a3306 1
PUBLIC void GetLegendDim (display, files, nfiles, legend_font, legend_width, legend_height)
d3313 1
a3320 1
	short		font_height;
d3332 1
a3332 1
	font_height	= font_struct->ascent + font_struct->descent;
d3345 1
a3345 1
				short_name	= extension;
d3355 2
a3356 2
	*legend_width	= width;
	*legend_height	= font_height * (actual_list_size - 1) * 1.2 + font_height; 
d3406 1
a3406 1
				short_name	= extension;
@


1.66
log
@Changed the HD6 Brain and T88 Brain to original and hd6tot88.
@
text
@d2 3
d116 1
a116 1
/*$Header: /home/petsun4/ty7777/src/view25d/RCS/portal.c,v 1.65 1993/12/16 15:51:27 ty7777 Exp ty7777 $*/
d122 1
a122 1
static char rcsid [] = "$Header: /home/petsun4/ty7777/src/view25d/RCS/portal.c,v 1.65 1993/12/16 15:51:27 ty7777 Exp ty7777 $";
d5617 1
d5622 1
@


1.65
log
@Modified DrawLabel. Added GetLabelDim.
@
text
@d2 3
d113 1
a113 1
/*$Header: /home/petsun4/ty7777/src/view25d/RCS/portal.c,v 1.64 1993/12/14 20:00:07 ty7777 Exp ty7777 $*/
d119 1
a119 1
static char rcsid [] = "$Header: /home/petsun4/ty7777/src/view25d/RCS/portal.c,v 1.64 1993/12/14 20:00:07 ty7777 Exp ty7777 $";
d1149 2
d1176 1
a1176 1
	for (i = 0; i < HEADER; i++)
d1178 2
a1179 5
		if (fgets (line, MAXLINE, rgnfp) == NULL)
		{
			fprintf (stderr, "Error: region file %s is empty.\n", rgn_filename); 
			return FAIL;
		}
d1181 6
d4388 2
a4389 2
					XmStringCreate (bool_buffer? "Talairach 88":
					"HD6", XmSTRING_DEFAULT_CHARSET)); n++;
a5613 1
	/*
a5615 1
		printf ("1: x = %d y = %d z = %d\n", ax, ay, az);
a5616 1
		printf ("2: x = %d y = %d z = %d\n", ax, ay, az);
a5617 1
	*/
@


1.64
log
@Added processing for AF3D display in UpdatePortals.
@
text
@d2 3
d110 1
a110 1
/*$Header: /home/petsun4/ty7777/src/view25d/RCS/portal.c,v 1.63 1993/12/13 20:21:48 ty7777 Exp ty7777 $*/
d116 1
a116 1
static char rcsid [] = "$Header: /home/petsun4/ty7777/src/view25d/RCS/portal.c,v 1.63 1993/12/13 20:21:48 ty7777 Exp ty7777 $";
d3341 1
a3341 2
	*legend_height	= font_height * actual_list_size 
				+ (actual_list_size - 1) * 0.2 * font_height;
d3401 114
d3602 7
a3608 8
					if (alignment_flag == ALIGNMENT_CENTER)
					{
						xstart	-= string_width / 2;
					}
					else if (alignment_flag == ALIGNMENT_RIGHT)
					{
						xstart	-= string_width;
					}
a3640 1

d3643 5
a3647 8
				if (alignment_flag == ALIGNMENT_CENTER)
				{
					ystart	-= string_width / 2;
				}
				else if (alignment_flag == ALIGNMENT_RIGHT)
				{
					ystart	-= string_width;
				}
d3656 1
a3656 1
				xstart	+= (font_height * line_spacing) / LINE_SPACING_FACTOR;
@


1.63
log
@Deleted old DrawLabel.
@
text
@d2 3
d107 1
a107 1
/*$Header: /home/petsun4/ty7777/src/view25d/RCS/portal.c,v 1.62 1993/12/13 20:20:22 ty7777 Exp ty7777 $*/
d113 1
a113 1
static char rcsid [] = "$Header: /home/petsun4/ty7777/src/view25d/RCS/portal.c,v 1.62 1993/12/13 20:20:22 ty7777 Exp ty7777 $";
d1520 7
d1529 8
d1539 3
a1541 1
	short			k;		/* counter */
d1543 1
a1543 2
	int			mask_top;		
	int			mask_bottom;		
d1545 11
a1555 1
	int			temp_bottom;
d1557 11
a1567 2
	short			xstart;		/* portal x start */
	short			ystart;		/* portal y start */
a1569 2
	short			xinc_mm;	/* portal x increment in millimeter */
	short			yinc_mm;	/* portal y increment in millimeter */
d1572 4
a1575 27
	short			xinc;		/* portal x increment in millimeter */
	short			yinc;		/* portal y increment in millimeter */
	short			xlabel_mm;
	short			ylabel_mm;
	char			stringbuf [MAXLINE];	/* buffer for label */
	XFontStruct		*font_struct;
	int			direction_hint;	
	int			font_ascent;
	int			font_descent;
	XCharStruct		overall;
	short			label_xorigin;		
	short			label_yorigin;		
	short			left;
	short			top;
	short			right;
	short			bottom;
	BOOLEAN			low2high;
	BOOLEAN			slice_num_flag;
	short			colorbar_xstart;
	short			colorbar_ystart;
	short			colorbar_length;
	short			colorbar_width;
	BOOLEAN			hori_colorbar;
	short			minimum;
	short			maximum;
	FILE			*atlasfp;
	FILE			*maskfp;
a1576 10
	unsigned int		mask_size;
	unsigned int		any_slice_size;
	short			*mask_slice;
	short			*abs_mask_slice;
	short			*atlas_slice;
	short			*databuf;		/* buffer for interpolated atlas image */
	DRAW_PORTAL_DATA	draw_portal_data;
	char			pet_value_flag;
	BOOLEAN			pet_exist	= FALSE;
	float			slice_scale	= dSliceMagnification;
d1585 1
a1585 1
		draw_portal_data.spacing		= &nSpacing;
d2195 2
a2196 2
					((coordinate >= slice->slice_xyz - *draw_portal_data->spacing) && 
					(coordinate < slice->slice_xyz + *draw_portal_data->spacing))) 
d4356 6
d5041 4
@


1.62
log
@Modified DrawLabel.
@
text
@d2 3
d104 1
a104 1
/*$Header: /home/petsun4/ty7777/src/view25d/RCS/portal.c,v 1.61 1993/12/13 19:43:50 ty7777 Exp ty7777 $*/
d110 1
a110 1
static char rcsid [] = "$Header: /home/petsun4/ty7777/src/view25d/RCS/portal.c,v 1.61 1993/12/13 19:43:50 ty7777 Exp ty7777 $";
a3552 96

/*
PUBLIC void DrawLabel (display, window, gc, x, y, x2, y2, color_pixel, font_struct, 
			text_string, alignment_flag, line_spacing, text_orient)
	Display		*display;
	Window		window;
	GC		gc;
	int		x, y, x2, y2;
	Pixel		color_pixel;
	XFontStruct	*font_struct;
	char		*text_string;
	char		alignment_flag;
	int		line_spacing;
	char		text_orient;
{
	int		xstart;
	int		ystart;
	int		text_length;
	char		*string_buffer;
	int		i, j, k;
	int		font_height;
	int		string_width;

	i		= 0;
	text_length	= strlen (text_string);
	font_height	= font_struct->ascent + font_struct->descent;
	string_buffer	= (char *) pkg_malloc (text_length, "DrawLabel", "string_buffer");

	strncpy (string_buffer, "\0", text_length);
	XSetFont (display, gc, font_struct->fid);
	XSetForeground (display, gc, color_pixel);

	xstart	= x;
	ystart	= y;
	while (i < text_length)
	{
		j	= 0;

		do
		{
			string_buffer [j++] = text_string [i++];
		} while (i < text_length && text_string [i] != '\n');

		string_buffer [j++] = text_string [i++];

		switch (text_orient) 
		{
			case ORIENT_HORI : 	
				string_width	= XTextWidth (font_struct, 
						string_buffer, strlen (string_buffer));

				xstart	= x;
				if (alignment_flag == ALIGNMENT_CENTER)
				{
					xstart	-= string_width / 2;
				}
				else if (alignment_flag == ALIGNMENT_RIGHT)
				{
					xstart	-= string_width;
				}

				XDrawString (display, window, gc, xstart, ystart, 
					string_buffer, strlen (string_buffer));
				ystart	+= (font_height * line_spacing) / LINE_SPACING_FACTOR;
				break;
			case ORIENT_VERT :
				ystart	= y;

				string_width	= font_height * strlen (string_buffer);

				if (alignment_flag == ALIGNMENT_CENTER)
				{
					ystart	-= string_width / 2;
				}
				else if (alignment_flag == ALIGNMENT_RIGHT)
				{
					ystart	-= string_width;
				}

				for (k = 0; k < strlen (string_buffer); k++) 
				{
					XDrawString (display, window, gc, 
						xstart, ystart + (font_height * k), 
						string_buffer + k, 1);
				}

				xstart	+= (font_height * line_spacing) / LINE_SPACING_FACTOR;
				break;
		}

		strncpy (string_buffer, "\0", text_length);
	}

	XtFree (string_buffer);
}
*/
@


1.61
log
@Deleted debugging lines.
@
text
@d2 3
d101 1
a101 1
/*$Header: /home/petsun4/ty7777/src/view25d/RCS/portal.c,v 1.60 1993/12/13 15:19:59 ty7777 Exp ty7777 $*/
d107 1
a107 1
static char rcsid [] = "$Header: /home/petsun4/ty7777/src/view25d/RCS/portal.c,v 1.60 1993/12/13 15:19:59 ty7777 Exp ty7777 $";
d3406 11
d3419 148
d3645 1
@


1.60
log
@After adding view25d.
@
text
@d2 3
d98 1
a98 1
/*$Header: /home/petsun4/ty7777/src/view25d/RCS/portal.c,v 1.59 1993/12/08 21:02:40 ty7777 Exp ty7777 $*/
d104 1
a104 1
static char rcsid [] = "$Header: /home/petsun4/ty7777/src/view25d/RCS/portal.c,v 1.59 1993/12/08 21:02:40 ty7777 Exp ty7777 $";
d1285 1
d1579 5
d2189 3
d3287 1
d3311 1
a3311 1
		if (strlen (files [i]) > 0)
d3347 1
d3370 1
a3370 1
		if (strlen (files [i]) > 0)
a3450 1
printf ("line_spacing = %d\n", line_spacing);
@


1.59
log
@Fixed problem for reading default symbol type and symbol color.
@
text
@d2 3
d95 1
a95 1
/*$Header: /home/petsun4/ty7777/src/view25d/RCS/portal.c,v 1.58 1993/11/02 16:52:32 ty7777 Exp ty7777 $*/
d101 1
a101 1
static char rcsid [] = "$Header: /home/petsun4/ty7777/src/view25d/RCS/portal.c,v 1.58 1993/11/02 16:52:32 ty7777 Exp ty7777 $";
d3267 109
d3437 1
@


1.58
log
@Changed ErrorMinMax.
@
text
@d2 3
d92 1
a92 1
/*$Header: /home/petsun4/ty7777/src/view25d/RCS/portal.c,v 1.57 1993/11/01 21:57:27 ty7777 Exp ty7777 $*/
d98 1
a98 1
static char rcsid [] = "$Header: /home/petsun4/ty7777/src/view25d/RCS/portal.c,v 1.57 1993/11/01 21:57:27 ty7777 Exp ty7777 $";
d3772 1
d3774 2
a3775 1
	char			*symbol_shape	 	= cSymbolType; 
d4117 2
d4131 1
a4131 1
					*(symbol_shape + i)	
d4133 1
d4624 1
a4624 1
					symbol_names [*(symbol_shape + i)], 
d4644 1
a4644 1
	if (*(symbol_shape + *symbol_alter_set) >= MAX_SYMBOL_NUM)
d4646 1
a4646 1
		i	= *(symbol_shape + *symbol_alter_set) - MAX_SYMBOL_NUM;
d4651 1
a4651 1
		i	= *(symbol_shape + *symbol_alter_set);
@


1.57
log
@Fixed error checking for Fran.
@
text
@d2 3
d89 1
a89 1
/*$Header: /home/petsun4/ty7777/src/view25d/RCS/portal.c,v 1.56 1993/10/28 15:44:36 ty7777 Exp ty7777 $*/
d95 1
a95 1
static char rcsid [] = "$Header: /home/petsun4/ty7777/src/view25d/RCS/portal.c,v 1.56 1993/10/28 15:44:36 ty7777 Exp ty7777 $";
d3382 2
a3383 1
	if (pet_value_flag == PETVALUE_POSITIVE)
d3385 3
a3387 11
		if (*maximum < 0)
			*maximum *= -1;
		else if (*maximum == 0)
			*maximum = - *minimum;
	}
	else if (pet_value_flag == PETVALUE_NEGATIVE)
	{
		if (*minimum > 0)
			*minimum *= -1;
		else if (*minimum == 0)
			*minimum = - *maximum;
@


1.56
log
@Fixed bug for displaying sagittal slices facing on left with atlas trim on.
@
text
@d2 3
d86 1
a86 1
/*$Header: /home/petsun4/ty7777/src/view25d/RCS/portal.c,v 1.55 1993/10/22 20:05:04 ty7777 Exp ty7777 $*/
d92 1
a92 1
static char rcsid [] = "$Header: /home/petsun4/ty7777/src/view25d/RCS/portal.c,v 1.55 1993/10/22 20:05:04 ty7777 Exp ty7777 $";
d3404 1
a3404 1
	if (pet_value_flag == PETVALUE_POSITIVE && auto_flag)
d3408 1
a3408 1
	else if (pet_value_flag == PETVALUE_NEGATIVE && auto_flag)
@


1.55
log
@Change RegularMinMax.
@
text
@d2 3
d83 1
a83 1
/*$Header: /home/petsun4/ty7777/src/view25d/RCS/portal.c,v 1.54 1993/09/27 19:00:52 ty7777 Exp ty7777 $*/
d89 1
a89 1
static char rcsid [] = "$Header$";
d1937 3
d1942 1
a1942 6
						x + current_header->centerx 
						+ (current_header->centerx - tempy), 
						y + j,
						x + current_header->centerx 
						+ (current_header->centerx - tempx), 
						y + j);
d1964 9
@


1.54
log
@Added gray color button for atlas color.
@
text
@d2 3
d80 1
a80 1
/*$Header: /home/petsun4/ty7777/src/view25d/RCS/portal.c,v 1.53 1993/09/23 20:40:58 ty7777 Exp ty7777 $*/
d86 1
a86 1
static char rcsid [] = "$Id";
d1852 1
a1852 1
			ColorBarText (display, window, gc, minimum, maximum, font_struct, 
d2305 1
a2305 1
			ColorBarText (display, window, gc, minimum, maximum, FontStruct, 
d2991 2
a2992 2
short		min_pet_value;
short		max_pet_value;
d3023 3
a3025 3
	RegularMinMax (pet_value_flag, &min_pet_value, &max_pet_value);
	min_value	= min_pet_value;
	max_value	= max_pet_value;
d3387 5
a3391 1
	if (pet_value_flag == PETVALUE_POSITIVE)
d3395 1
a3395 1
	else if (pet_value_flag == PETVALUE_NEGATIVE)
@


1.53
log
@View and Log Coordinates File.
@
text
@d2 3
d77 1
a77 1
/*$Header: /home/petsun4/ty7777/src/view25d/RCS/portal.c,v 1.52 1993/07/26 22:01:59 ty7777 Exp ty7777 $*/
d3543 1
a3543 1
			else 
d3545 2
d4323 1
a4323 1
						MAX_NONIMAGE_COLOR), arglist, n);
d4894 1
a4894 1
				MAX_NONIMAGE_COLOR, TOGGLE_COLOR, value); 
@


1.52
log
@Modified mormula for HD6 to T88 conversion.
@
text
@d2 3
d74 1
a74 1
/*$Header: /home/petsun4/ty7777/src/view25d/RCS/portal.c,v 1.51 1993/07/13 15:06:51 ty7777 Exp $*/
d158 1
a161 1
PRIVATE void		Transformation ();
d243 1
d284 1
a284 1
	if (path_len < 0 || path_len > bytes - sizeof (RawGammaZPoint))
a285 1
printf ("Yuh-Wen 1\n");
a286 1
printf ("Yuh-Wen 2\n");
d385 1
a385 1
 
d387 6
a392 8
/*_____________________________________________________________________________      
	Function:       Transformation
	Arguments:	dOldWidth, dOldHeight:	old space dimension.
			nNewWidth, nNewHeight:	new space dimension.
			nOldx, nOldy:		old coordinates.
			npNewx, npNewy:		new coordinates.
	Description:
			Transform coordinates from one space to another.
d394 2
a395 4
	Return Value:	none.
	Author:		Tom Yang 
			(03/18/1991)
______________________________________________________________________________*/ 
d397 5
a401 7
PRIVATE void Transformation (dScaleSize, dOldCenterx, dOldCentery, 
			     nOldx, nOldy, nNewCenterx, nNewCentery, npNewx, npNewy)
float	dScaleSize;
float	dOldCenterx, dOldCentery;
int	nOldx, nOldy;
int	nNewCenterx, nNewCentery;
int	*npNewx, *npNewy;
d403 103
a505 2
	*npNewx	= ROUND (dScaleSize * (nOldx - dOldCenterx) + nNewCenterx);
	*npNewy = ROUND (dScaleSize * (nOldy - dOldCentery) + nNewCentery);
a1220 1
	int		fd;
d1223 2
d1237 1
a1237 1
				(fd	= open (filenames [i], O_RDONLY, 0)) == -1)
d1247 7
a1253 1
				d	= MakeGammaZData (fd, c);	
d5173 1
d5291 5
a5295 3
		fprintf (logfp, "Atlas File:		%s\n", szAtlasFileName);
		fprintf (logfp, "Pet Image File:		%s\n", szPetFileName);
		fprintf (logfp, "Coordinate (z, y, x):	(%d, %d, %d)\n\n", az, ax, ay);
@


1.51
log
@After adding show point location.
@
text
@d2 3
d71 1
a71 1
/*$Header: /home/petsun4/ty7777/src/view25d/RCS/portal.c,v 1.50 1993/07/06 16:49:49 ty7777 Exp $*/
d1081 1
a1081 1
			region_data->z	= ROUND (1.072 * region_data->z);
d1086 1
a1086 1
					= ROUND (0.897 * region_data->region_input [i].x);
d1088 1
a1088 1
					= ROUND (1.055 * region_data->region_input [i].y - 11.0);
@


1.50
log
@Before working on getting points.
@
text
@d2 3
d68 1
a68 1
/*$Header: /home/petsun4/ty7777/src/view25d/RCS/portal.c,v 1.49 1993/06/03 19:38:56 ty7777 Exp ty7777 $*/
d121 1
d279 1
d281 1
d422 2
a424 1
	ATLAS_HEADER	*atlas_header	= &rAtlasHeader;
d505 5
d2048 1
a2048 1
					sx	= ROUND ((gammaz_point->x * -1.0) 
d2050 1
a2050 1
					sy	= ROUND ((gammaz_point->y * -1.0) 
d2052 1
a2052 1
					sz	= ROUND ((gammaz_point->z * -1.0)
a3144 1
	static char	*function	= "ButtonDownEventHandler";
d3156 1
a3157 3
	string_buffer	= (char *) pkg_malloc (text_length, 
					function, "string_buffer");

a3394 28
		Lowered
	Arguments:
	Description:
		Convert a character string to lower case.
	Author:
		Tom (Tongzeng) Yang
		(12/08/1991)
_______________________________________________________________________________________________*/

PUBLIC char *Lowered (string, length)
	char	*string;
	int	length;
{
	char	*lower_name;
	int	i;

	lower_name	= (char *) pkg_malloc (length + 1, "Lowered", "lower_name");
	strncpy (lower_name, "\0", length + 1);

	for (i = 0; i < length; i++)
		lower_name [i] = tolower (*(string + i));

	return	lower_name;
}


/*________________________________________________________________________________________________	
	Function:
d3499 1
a3499 1
	XtFree (lower_name);
a3522 2
	char	*lower_name;

a3553 1
	char		*lower_name;
d5037 152
@


1.49
log
@Make coronal and saggital reginos display work.
@
text
@d2 3
d65 1
a65 1
/*$Header: /home/petsun4/ty7777/src/view25d/RCS/portal.c,v 1.48 1993/06/03 14:33:17 ty7777 Exp ty7777 $*/
d944 1
d965 2
a966 2
			if (ReadRegion (filenames [i], filling_type [i], 
				region_color [i], region_sets) == FAIL)
d989 1
a989 1
PRIVATE int ReadRegion (rgn_filename, filling_type, region_color, region_sets)
d994 1
d1048 4
d1053 4
a1056 2
    			region_data->region_input [i].x	= tempx;
    			region_data->region_input [i].y	= tempy;
d1064 13
d1921 2
a1922 4
				point.x	= (region_set->region_input [i].x - REGION_SLICE_CX) 
						* RGN_PIXEL_WIDTH;
				point.y	= (region_set->region_input [i].y - REGION_SLICE_CY)
						* RGN_PIXEL_WIDTH;
d1924 2
a1925 1
				if (coordinate == slice->slice_xyz)
d3949 19
d4687 3
@


1.48
log
@After coronal and saggital regions show.
@
text
@d2 3
d62 1
a62 1
/*$Header: /home/petsun4/ty7777/src/view25d/RCS/portal.c,v 1.47 1993/06/02 17:17:14 ty7777 Exp ty7777 $*/
a1406 1
		draw_portal_data.region_style		= &cRegionStyle;
d3487 1
a3487 1
			for (index = 0; index < 2 * MAX_SYMBOL_NUM; index++)
d3626 1
d3633 6
a3638 1
	char			*alter_set		= &cActiveAF3DSet;
d3869 57
d3928 1
a3928 1
				*alter_set	= atoi (value) - 1;
d3932 1
a3932 1
				SetSelectData (symbol_menu->toggle_alter_set [*alter_set], True);
d3937 1
a3937 1
			if (strcmp (label, "DisplayOnSet:") == 0)
d4428 31
d4486 1
a4486 1
	SetSelectData (symbol_menu->toggle_color_set [*(symbol_color + *alter_set)], True);
d4488 1
a4488 1
	if (*(symbol_shape + *alter_set) >= MAX_SYMBOL_NUM)
d4490 1
a4490 1
		i	= *(symbol_shape + *alter_set) - MAX_SYMBOL_NUM;
d4495 1
a4495 1
		i	= *(symbol_shape + *alter_set);
d4504 1
a4504 1
	XmScaleSetValue (*symbol_menu->size_scale, *(symbol_size + *alter_set));
d4533 1
d4543 2
d4624 22
d4647 1
a4647 1
	fprintf (file, "DisplayOnSet:		On\n");
@


1.47
log
@After multiple regions display worked.
@
text
@d2 3
d59 1
a59 1
/*$Header: /home/petsun4/ty7777/src/view25d/RCS/portal.c,v 1.46 1993/05/17 17:17:50 ty7777 Exp $*/
d132 1
a132 1
PRIVATE double		GetCoordinate ();
d197 1
a197 1
		point:		GammazPoint.
d200 1
a200 1
		Get the coordinate of a gammaz point in the current active
d206 2
a207 2
PRIVATE double GetCoordinate (point, atlas_orient)
	GammaZPoint	*point;
d210 4
a213 4
	if (atlas_orient	== TRANSVERSE)
		return	point->z;
	else if (atlas_orient	== CORONAL)
		return	point->y;
d215 1
a215 1
		return	point->x;
d1728 2
d1731 2
a1732 1
	GammaZPoint	*point;			/* point to plot */
d1736 6
a1741 1
	int		i, j;			/* counter */
a1743 6
	int		rows;
	Pixel		ColorPixel;
	int		rgn_pet_pixelsize;
	short		x; 
	short		y; 
	double		coordinate;
d1747 2
d1889 5
a1893 2
			coordinate	= region_set->z;
			if (coordinate == slice->slice_xyz)
d1895 18
a1912 1
				region_draw = (XPoint *) pkg_malloc (region_set->region_pixel_num 
d1914 1
a1914 1
				for (i = 0; i < region_set->region_pixel_num; i++)
d1916 28
a1943 10
					Transformation ((float) slice->rgn_pet_pixelsize, 
			    			(REGION_SLICE_WIDTH / 2 - 1) + 0.5, 
						(REGION_SLICE_HEIGHT / 2 - 1) + 0.5, 
			    			region_set->region_input [i].x, 
			    			region_set->region_input [i].y, 
			    			current_header->centerx, 
						current_header->centery, 
			    			&tempx, &tempy);
	    				region_draw [i].x = tempx - slice->rgn_pet_pixelsize / 2;
	    				region_draw [i].y = tempy - slice->rgn_pet_pixelsize / 2;
d1951 1
a1951 1
					for (i = 0; i < region_set->region_pixel_num; i++)
d1954 2
a1955 2
							region_draw [i].x + x - tempx / 2,
							region_draw [i].y + y - tempx / 2,
d1963 2
a1964 2
					DrawOutlinedRegion (display, window, gc, x, y, tempx, 
							region_set->region_pixel_num, region_draw);
d1969 1
a1969 1
					for (i = 0; i < region_set->region_pixel_num; i++)
d1972 2
a1973 2
							region_draw [i].x + x - tempx / 2,
							region_draw [i].y + y - tempx / 2,
d1979 1
d1999 4
a2002 1
				point = (GammaZPoint *) llretrieve (data_set->points);
d2011 1
a2011 1
					sx	= ROUND ((point->x * -1.0) 
d2013 1
a2013 1
					sy	= ROUND ((point->y * -1.0) 
d2015 1
a2015 1
					sz	= ROUND ((point->z * -1.0)
d2994 1
a2994 1
PRIVATE void DrawOutlinedRegion (display, window, gc, x, y, pixel_width, num_pixels, pixel_points)
a2997 2
short		x;
short		y;
a3037 3

	xmin += x;
	ymin += y;
@


1.46
log
@Move CreateXorGC () to xor.c in libhp.a.
@
text
@d2 3
d56 1
a56 1
/*$Header: /home/petsun4/ty7777/src/view25d/RCS/portal.c,v 1.45 1993/05/17 16:23:48 ty7777 Exp ty7777 $*/
d124 1
d136 2
a137 1
PRIVATE void		InputRegionData ();
d172 1
a172 2
	Description:
			Compare two gammaz data points by their z value.
d174 2
a175 2
			0 if z value of a equals z value of b
			1 if z value of a greater than z value of b
d181 1
a181 5
	char	atlas_orient;
	double	acoord;
	double	bcoord;

	if (acoord < bcoord)
d183 1
a183 1
	if (acoord > bcoord)
d188 1
a588 1
		slice->region_exist	= FALSE;
d918 53
a970 1
	Arguments:	rgn_filename: pointer to region filename	
d973 2
a974 1
	Return Value:	void.
d979 1
a979 2
PRIVATE void InputRegionData (rgn_filename, input_node, atlas, first_slice, 
							last_slice, spacing)
d981 3
a983 5
char	input_node;
llist	atlas;
short	first_slice;
short	last_slice;
short	spacing;
d985 2
a986 3
	FILE		*trg_file_ptr; 			/* input file pointer */
	SliceData	*slice;
	char		atlas_assigned_num;
a988 1
	int		desired_slice;
a995 1
	int		size_list;
d997 1
a997 1
	static char	*function = "InputRegionData";
d1000 1
a1000 1
	 * Open a region .TRG file 
d1002 2
a1003 2
  	trg_file_ptr = fopen (rgn_filename, "r");
  	if (trg_file_ptr == (FILE *) NULL) 
d1005 2
a1006 3
		fprintf (stderr, "Can't Open %s\n", rgn_filename);
		perror ("Region .trg file:fopen");
		exit (-1);
d1009 3
a1011 1
	/* Ignore the First HEADER Lines in the trg File */
d1014 5
a1018 2
		if ( fgets (line, MAXLINE, trg_file_ptr) == NULL )
			fprintf (stderr, "fgets error: file is empty.\n"); 
d1020 1
a1020 1
	fscanf (trg_file_ptr, "%d %d %f %f %f %d %d", 
d1022 1
a1022 1
	fscanf (trg_file_ptr, "%d %d %d %d %d %d", &i, &slice_index, 
d1025 2
a1026 13
	size_list = llsize (atlas);

	if (last_slice < last_rgn_slice)
		last_rgn_slice = last_slice;
	if (first_slice > first_rgn_slice)
		first_rgn_slice = first_slice;

	/* 
	 * Skip atlases until we find the first slice with a region input. 
	 */
	lltail (atlas);
	atlas_assigned_num = 0;
	if (first_rgn_slice > first_slice && first_rgn_slice <= last_slice)
d1028 8
a1035 1
		for (i = 0; i < first_rgn_slice - first_slice; i++)
d1037 3
a1039 23
			slice = llretrieve (atlas);
			if (slice->region_exist)
			{
				XtFree (slice->region_input);
				slice->region_exist	= FALSE;
			}
			atlas_assigned_num++; 
			llprevious (atlas);			
		} 
	}

	j		= 0;
	desired_slice	= first_rgn_slice;
	while (fscanf (trg_file_ptr, "%d %d", &slice_index, &pixel_num) != EOF &&
		j < num_slices)
	{
		if (slice_index < first_rgn_slice || slice_index > last_rgn_slice
			|| slice_index != desired_slice)
		{
			for (i = 0; i < pixel_num; i++)
			{
				fscanf (trg_file_ptr, "%2x %2x", &tempx, &tempy);
			}
a1040 11
		else
		{
			slice = llretrieve (atlas);
			if (slice->region_exist)
				XtFree (slice->region_input);
			else
				slice->region_exist = TRUE;
			slice->rgn_pixel_num	= pixel_num;
			atlas_assigned_num++; 
			slice->region_input	= (XPoint *) pkg_malloc (pixel_num 
				* sizeof (XPoint), function, "slice->region_input");
d1042 10
a1051 9
			for (i = 0; i < pixel_num; i++)
			{
				fscanf (trg_file_ptr, "%2x %2x", &tempx, &tempy);
	    			slice->region_input[i].x	= tempx;
	    			slice->region_input[i].y	= tempy;
			}
			llprevious (atlas);
			desired_slice	+= spacing;
		}
d1055 1
a1055 16
	if (atlas_assigned_num < size_list)
	{
		llhead (atlas);
		for (i = 0; i < size_list - atlas_assigned_num; i++)
		{
			slice = llretrieve (atlas);
			if (slice->region_exist)
			{
				XtFree (slice->region_input);
				slice->region_exist	= FALSE;
			}
			llnext (atlas);
		}
	}

	fclose (trg_file_ptr);
a1167 1
	portalSlice->rgn_pixel_num	= slice->rgn_pixel_num;
a1168 1
	portalSlice->region_exist	= slice->region_exist;
d1171 1
a1171 1
	 * Memory allocation and compute resized region. 
a1175 22
	if (portalSlice->region_exist)
	{
		portalSlice->region = (XPoint *) pkg_malloc(slice->rgn_pixel_num 
					* sizeof (XPoint), function, "portalSlice->region");
		for (i = 0; i < slice->rgn_pixel_num; i++)
		{
    			/* 
			 * Transformation into Atlas Space Coordinates. 
			 */ 
			Transformation ((float) rgn_pet_pixelsize, 
			    		(REGION_SLICE_WIDTH / 2 - 1) + 0.5, 
					(REGION_SLICE_HEIGHT / 2 - 1) + 0.5, 
			    		slice->region_input [i].x, 
			    		slice->region_input [i].y, 
			    		current_header->centerx, 
					current_header->centery, 
			    		&tempx, &tempy);
	    		portalSlice->region [i].x = tempx - rgn_pet_pixelsize / 2;
	    		portalSlice->region [i].y = tempy - rgn_pet_pixelsize / 2;
		}
	}

d1400 1
a1400 1
		draw_portal_data.display_region_flag	= &bDisplayRegion;
d1725 3
d1729 1
a1730 2
	GammaZData	*data_set;
	GammaZPoint	*point;			/* point to plot */
d1876 1
a1876 1
	if (*draw_portal_data->display_region_flag && slice->region_exist)
d1878 6
a1883 5
		XSetForeground (display, gc, REGION_CELL);
		tempx	= slice->rgn_pet_pixelsize;
		if (*draw_portal_data->region_style == REGION_FILLED)
		{
			for (i = 0; i < slice->rgn_pixel_num; i++)
d1885 15
a1899 12
				XFillRectangle (display, window, gc, 
						slice->region[i].x + x - tempx / 2,
						slice->region[i].y + y - tempx / 2,
						tempx, tempx);
			}
		}
		else if (*draw_portal_data->region_style == REGION_OUTLINE)
		{
			XSetLineAttributes (display, gc, 5, LineSolid, CapButt, JoinMiter);
			DrawOutlinedRegion (display, window, gc, x, y, tempx, slice->rgn_pixel_num,
						slice->region);
			XSetLineAttributes (display, gc, 1, LineSolid, CapButt, JoinMiter);
d1901 32
a1932 9
		}
		else
		{
			for (i = 0; i < slice->rgn_pixel_num; i++)
			{
				XDrawRectangle (display, window, gc, 
						slice->region[i].x + x - tempx / 2,
						slice->region[i].y + y - tempx / 2,
						tempx, tempx);
d1934 1
a1934 1
		}
a2164 2
			if (slice->region_exist)
				XtFree (slice->region);
a2269 3
		if (slice->region_exist)
			XtFree (slice->region);

a2288 2
		if (slice->region_exist)
			XtFree (slice->region_input);
d2302 32
d2603 2
a2604 1
	if (bRegionImageSelected)
d2606 2
a2607 2
		InputRegionData (szRegionFileName, input_node, atlas_list, 
				first_slice, last_slice, spacing);
a3655 13
			if (strcmp (label, "DisplayRegionFlag:") == 0)
			{
				if (strcmp (Lowered (value, strlen (value)), "true") == 0)
					bool_buffer	= TRUE;
				else
					bool_buffer	= FALSE;

				SetSelectData (*data_type_menu->region, bool_buffer);
				bDisplayRegion	= bool_buffer;

				continue;
			}

a4109 18
			if (strcmp (label, "RegionColor:") == 0)
			{
				n	= 0;
				XtSetArg (arglist [n], XmNset, False); n++;
				XtSetValues (GetActiveWidget (default_parameters->region_color_set, 
						MAX_NONIMAGE_COLOR), arglist, n);

				widget_buffer	
				= GetWidgetFromName (default_parameters->region_color_set,
							value, TOGGLE_COLOR, &n);

				n	= 0;
				XtSetArg (arglist [n], XmNset, True); n++;
				XtSetValues (widget_buffer, arglist, n);

				continue;
			}

a4431 3
	bool_buffer	= XmToggleButtonGetState (*data_type_menu->region);
	fprintf (file, "DisplayRegionFlag:	%s\n", bool_buffer? "True": "False");

a4600 4

	GetNameFromWidget (default_parameters->region_color_set, 
				MAX_NONIMAGE_COLOR, TOGGLE_COLOR, value); 
	fprintf (file, "RegionColor:		%s\n", value);
@


1.45
log
@Fixed any scale problem.
@
text
@d2 3
d53 1
a53 1
/*$Header: /usr/local/src/view25d/RCS/portal.c,v 1.44 1993/05/07 21:55:53 ty7777 Exp $*/
a3112 34
}

PUBLIC GC CreateXorGC (w)
	Widget	w;
{
	XGCValues	values;
	GC		gc;
	Arg		wargs[2];

	/*
	* Get the colors used by the widget.
	*/
	XtSetArg (wargs[0], XtNforeground, &values.foreground);
	XtSetArg (wargs[1], XtNbackground, &values.background);
	XtGetValues (w, wargs, 2);

	/*
	* Set the fg to the XOR of the fg and bg, so if it is
	* XOR'ed with bg, the result will be fg and vice-versa.
	* This effectively achieves inverse video for the line.
	*/
	values.foreground	= values.foreground ^ values.background;

	/*
	* Set the rubber band gc to use XOR mode and draw 
	* a dashed line.
	*/
	values.line_style	= LineSolid;
	values.function		= GXxor;

	gc	= XtGetGC (w, GCForeground | GCBackground | GCFunction 
			| GCLineStyle, &values);

	return gc;
@


1.44
log
@Processing for pet mask image.
@
text
@d2 3
d50 1
a50 1
/*$Header: /home/petsun4/ty7777/src/view25d/RCS/portal.c,v 1.43 1993/05/07 16:56:25 ty7777 Exp ty7777 $*/
d1465 1
a1465 1
		if (*draw_portal_data.display_atlas_flag)
d1534 2
a1535 1
			if (slice->atlas_index >= 0 && *draw_portal_data.display_atlas_flag)
d1679 3
a1681 2
			if (slice->atlas_index >= 0)
				XtFree (atlas_slice);
@


1.43
log
@Before testing number of slices.
@
text
@d2 3
d47 1
a47 1
/*$Header: /home/petsun4/ty7777/src/view25d/RCS/portal.c,v 1.42 1993/04/05 17:32:58 ty7777 Exp ty7777 $*/
d608 6
a613 8
	static char	*function = "InputPetData";
	short		*pet_slice_image;
	short		*mask_slice_image;
	short		*header;
	short		slice_index;
	short		num_slices;
	int		pett_num;
	BOOLEAN		err_value = SUCCEED;
d615 4
d620 1
d622 3
a626 14
	int		rows;
	XPoint		ptUpperLeft;
	XPoint		ptBottomRight;
	BOOLEAN		pettvi_14	= FALSE;
	short		temp_pet_value;
	short		global_min	= MAXSHORT;
	short		global_max	= -MAXSHORT;
	BOOLEAN		minmax_changed	= FALSE;
	int		imgfd;
	int		mskfd;
	BOOLEAN		encoded;
	llist		slice3d_list;
	HorizontalSlice	*horizontal_slice;
	char		atlas_orient	= cAtlasOrientation;
d629 1
d631 9
a639 1
	char		*pet_mask_file_name	= szPetMaskFileName;
d681 1
a681 10
		mask_slice_image	= (short *) calloc (ENCODED_SLICE_DIM, sizeof (short));
		mskfd	= open (pet_mask_file_name, O_RDONLY, 0);
		if (mskfd == -1)
			fprintf (stderr, "Can't open mask file %s\n", pet_mask_file_name);

		getimage (mask_slice_image, header, mskfd, 
			pet_mask_file_name, slice_index, 0, 
			49, PETT6_SCANNER, &err_value);
		close (mskfd);
		for (j = 0; j < ENCODED_SLICE_HEIGHT; j++)
d683 2
a684 2
			rows	= j * ENCODED_SLICE_WIDTH;
			for (i = 0; i < ENCODED_SLICE_WIDTH; i++)
d686 2
a687 2
				if (mask_slice_image [rows + i] <= 0)
					horizontal_slice->slice_data [rows + i] = 0;
d689 21
a712 1
		free (mask_slice_image);
d3636 13
d4419 1
d4447 2
a4448 5
	fprintf (file, "DisplayAtlasFlag:	%s\n", bDisplayAtlas? "True": "False");
	fprintf (file, "DisplayPetFlag:		%s\n", bDisplayPet? "True": "False");
	fprintf (file, "DisplayRegionFlag:	%s\n", bDisplayRegion? "True": "False");
	fprintf (file, "DisplayLabelFlag:	%s\n", bDisplayLabel? "True": "False");
	fprintf (file, "SliceNumZValueFlag:	%s\n", *slice_number_flag? "True": "False");
d4450 16
a4465 1
	GetNameFromWidget (default_parameters->data_type_menu->orientation_set, 
@


1.42
log
@After add AF3D points works.
@
text
@d2 3
d44 1
a44 1
/*$Header: /home/petsun4/ty7777/src/view25d/RCS/portal.c,v 1.41 1993/02/23 18:15:15 ty7777 Exp ty7777 $*/
d1184 1
a1184 1
			rgn_pet_pixelsize	= ROUND (PETT6_PIXEL_SIZE 
@


1.41
log
@Before fixing ECAT image bug.
@
text
@d2 3
d41 1
a41 1
/*$Header: /home/petsun4/ty7777/src/view25d/RCS/portal.c,v 1.40 1993/01/28 15:42:56 ty7777 Exp ty7777 $*/
d219 1
d246 1
a246 1
	pkg_read (fd, &s[1], 1, function, "s[1]");
@


1.40
log
@Before changing libcti.a
@
text
@d2 3
d38 1
a38 1
/*$Header: /home/petsun4/ty7777/src/view25d/RCS/portal.c,v 1.39 1993/01/13 19:32:49 ty7777 Exp $*/
d3580 8
d4408 2
@


1.39
log
@Modified "atlas trim" to make it work correctly.
@
text
@d2 3
d35 1
a35 1
/*$Header: /home/petsun4/ty7777/src/view25d/RCS/portal.c,v 1.38 1993/01/11 15:51:00 ty7777 Exp ty7777 $*/
d1037 1
a1037 1
			symbol_size, data_sets)
d1043 1
d1075 4
a1078 3
					d->symbol_shape	= *(symbol_type + i);
					d->pixel_color	= *(pixel_color + i);
					d->symbol_size	= *(symbol_size + i);
a1820 54
	/*
	 * Atlas trim.
	 */
	/*
	if (*draw_portal_data->atlas_trim && slice->pet_exist)
	{
		XSetForeground (display, gc, BACKGROUND_CELL);
		if (atlas_orient != FACING_RIGHT)
		{
			for (j = 0; j < current_header->height; j++) 
			{
				tempx	= draw_portal_data->mask_slice [2 * j];
				tempy	= draw_portal_data->mask_slice [2 * j + 1];

				if (tempx <= tempy)
				{
					XDrawLine (display, window, gc, 
						x + slice->pet_xstart, y + j, x + tempx - 1, y + j);
					XDrawLine (display, window, gc, x + tempy + 1, y + j, 
						x + slice->pet_width - 1, y + j);
				}
				else
					XDrawLine (display, window, gc, 
						x + slice->pet_xstart, y + j, 
						x + slice->pet_width - 1, y + j);
			}
		}
		else
		{
			for (j = 0; j < current_header->height; j++) 
			{
				tempx	= draw_portal_data->mask_slice [2 * j];
				tempy	= draw_portal_data->mask_slice [2 * j + 1];

				if (tempx <= tempy)
				{
					XDrawLine (display, window, gc, 
						x + slice->pet_xstart, y + j, 
						x + current_header->centerx 
						+ (current_header->centerx - tempy) - 1, y + j);
					XDrawLine (display, window, gc, 
						x + current_header->centerx 
						+ (current_header->centerx - tempx) + 1, y + j,
						x + slice->pet_width - 1, y + j);
				}
				else
					XDrawLine (display, window, gc, 
						x + slice->pet_xstart, y + j, 
						x + slice->pet_width - 1, y + j);
			}
		}
	}
	*/

d1879 1
a1879 1
			XSetLineAttributes (display, gc, 5, LineSolid, CapRound, JoinRound);
d1882 1
a1882 1
			XSetLineAttributes (display, gc, 1, LineSolid, CapRound, JoinRound);
d1907 2
d1962 1
d2545 1
a2545 1
		pixelAF3DColor, nSymbolSize, data_sets_list);
d3845 7
a4368 2
	FILE			*file;
	int			int_buffer;
d4370 2
a4371 3
	char			value [MAXLINE];
	char			*string;
	FORMAT_SCREEN_MENU	*format_screen_menu	= default_parameters->format_screen_menu;
d4373 1
d4375 2
a4376 4
	short			first_slice		= nFirstSlice;
	short			last_slice		= nLastSlice;
	short			spacing			= nSpacing;
	BOOLEAN			*slice_number_flag	= &bSliceNumberFlag;
d4378 2
a4379 2
	int			i;
	BOOLEAN			*symbol_onoff		= bDisplaySymbol;
a4380 1
	char			**color_list	 	= nonImageColorList; 
d4383 6
d4475 3
@


1.38
log
@Add atlas trim.
@
text
@d2 3
d32 1
a32 1
/*$Header: /home/petsun4/ty7777/src/view25d/RCS/portal.c,v 1.37 1992/12/31 21:56:51 ty7777 Exp ty7777 $*/
d94 2
a1110 1
	float		*slice_scale	= &dSliceMagnification;
d1152 2
a1153 2
			    		slice->region_input[i].x, 
			    		slice->region_input[i].y, 
d1157 2
a1158 2
	    		portalSlice->region[i].x = tempx - rgn_pet_pixelsize / 2;
	    		portalSlice->region[i].y = tempy - rgn_pet_pixelsize / 2;
d1325 8
a1332 1
	short			i;		/* counter */
d1373 1
d1379 1
a1402 1
		i			= 0;
a1428 2

			mask_size	= sizeof (short) * 2 * current_header->height;
d1430 1
d1455 2
a1456 1
		while (i < list_size)
a1500 22
			if (!current_header->any_scale_flag && slice->atlas_index >= 0)
			{
				mask_slice	= (short *) malloc (mask_size);

				if (fseek (maskfp, slice->atlas_index 
							* mask_size, SEEK_SET) != 0)
				{
					fprintf (stderr, 
						"UpdatePortals (portal.c): Seeking Error\n");
					exit (-1);
				}

				if (fread (mask_slice, mask_size, 1, maskfp) != 1)
				{
					fprintf (stderr,"%d fread error\n");
					perror ("view25d");
					exit(-1);
				}

				draw_portal_data.mask_slice	= mask_slice;
			}

d1538 89
d1642 1
a1642 1
			if (!current_header->any_scale_flag && slice->atlas_index >= 0)
d1650 1
a1650 1
			i++;
d1739 1
a1739 1
		if (current_header->any_scale_flag)
d1743 2
a1744 6
				rows = j * current_header->width;
				for (i = 0; i < current_header->width && 
					draw_portal_data->atlas_slice[rows + i] 
							< ATLAS_THRESHOLD; i++)
					;
				tempx = i;
a1745 6
				for (i = current_header->width - 1; i >= 0 && 
	     				draw_portal_data->atlas_slice[rows + i] 
							< ATLAS_THRESHOLD; i--)
					;
				tempy = i;

d1748 1
a1748 1
					tempx + x, j + y, tempy + x, j + y);
d1753 1
a1753 1
			if (atlas_orient != FACING_RIGHT)
d1755 2
a1756 4
				for (j = 0; j < current_header->height; j++) 
				{
					tempx	= draw_portal_data->mask_slice [2 * j];
					tempy	= draw_portal_data->mask_slice [2 * j + 1];
d1758 8
a1765 4
					if (tempx <= tempy)
						XDrawLine (display, window, gc, 
						x + tempx, y + j, x + tempy, y + j);
				}
a1766 17
			else
			{
				for (j = 0; j < current_header->height; j++) 
				{
					tempx	= draw_portal_data->mask_slice [2 * j];
					tempy	= draw_portal_data->mask_slice [2 * j + 1];

					if (tempx <= tempy)
						XDrawLine (display, window, gc, 
							x + current_header->centerx 
							+ (current_header->centerx - tempy), 
							y + j,
							x + current_header->centerx 
							+ (current_header->centerx - tempx), 
							y + j);
				}
			}
d1775 1
a1775 2
		i = 0;
		while (i < slice->pet_point_num)
d1777 5
a1781 1
			ColorPixel = slice->pet_point_pixel [i];
d1783 10
a1792 5
			XSetForeground (display, gc, ColorPixel);
			do
			{
				XDrawPoint (display, window, gc, x + slice->pet_point_coord [i].x,
								y + slice->pet_point_coord [i].y);
d1794 1
a1794 2
			} while (i < slice->pet_point_num &&
			slice->pet_point_pixel [i] == ColorPixel);
d1796 18
d1819 1
d1823 1
a1823 1
		if (current_header->any_scale_flag)
a1826 29
				rows = j * current_header->width;
				for (i = 0; i < current_header->width && 
					draw_portal_data->atlas_slice[rows + i] 
							< ATLAS_THRESHOLD; i++)
					;
				tempx = i;

				for (i = current_header->width - 1; i >= 0 && 
	     				draw_portal_data->atlas_slice[rows + i] 
							< ATLAS_THRESHOLD; i--)
					;
				tempy = i;

				if (tempx <= tempy)
				{
					XDrawLine (display, window, gc, 
						x, y + j, x + tempx - 1, y + j);
					XDrawLine (display, window, gc, x + tempy + 1, y + j, 
						x + current_header->width - 1, y + j);
				}
				else
					XDrawLine (display, window, gc, 
						x, y + j, x + current_header->width - 1, y + j);
			}
		} 
		else if (atlas_orient != FACING_RIGHT)
		{
			for (j = 0; j < current_header->height; j++) 
			{
d1868 1
@


1.37
log
@Before Randy's change.
@
text
@d2 3
d29 1
a29 1
/*$Header: /home/petsun4/ty7777/src/view25d/RCS/portal.c,v 1.36 1992/12/07 20:34:28 ty7777 Exp ty7777 $*/
d1245 1
a1245 1
				pet_coord_databuf[rows + i] == PET_BACK_VALUE; i++)
d1250 1
a1250 1
				pet_coord_databuf[rows + i] == PET_BACK_VALUE; i--)
d1377 1
d1724 1
a1724 1
			ColorPixel = slice->pet_point_pixel[i];
d1729 2
a1730 2
				XDrawPoint (display, window, gc, x + slice->pet_point_coord[i].x,
								y + slice->pet_point_coord[i].y);
d1733 1
a1733 1
			slice->pet_point_pixel[i] == ColorPixel);
d1737 81
d3948 13
d4513 4
@


1.36
log
@Adding a message box when the user gives an ascii af3d file.
@
text
@d2 3
d26 1
a26 1
/*$Header: /usr/local/src/view25d/RCS/portal.c,v 1.35 1992/12/07 15:51:57 ty7777 Exp ty7777 $*/
d2405 1
@


1.35
log
@Same as the last version.
@
text
@d2 3
d23 1
a23 1
/*$Header: /home/petsun4/ty7777/src/view25d/RCS/portal.c,v 1.34 1992/12/03 20:25:12 ty7777 Exp ty7777 $*/
d161 1
a161 1
		a:		GammazPoint, point.
a198 1
	static char	*function = "MakeGammaZData";
d200 1
a200 1
	llist		points;		/* list of points */
d202 1
a202 2
	GammaZPoint	*point;		/* new point to make structure */
	short		path_len;	/* length of path string */
d204 1
a204 2
	short		desc_len;	/* length of AF3D description */
	char		*description;	/* pointer to AF3D description */
d206 1
d208 6
a213 2
	int		i;		/* counter */
	char		s[2];		/* temp var to use test char and */
d228 10
d239 1
a239 1
	 * Allocate mem for the path and read it. 
d250 1
a250 1
	 * Allocate mem for the description and read it. 
d1058 5
a1062 3
				d->symbol_shape	= *(symbol_type + i);
				d->pixel_color	= *(pixel_color + i);
				d->symbol_size	= *(symbol_size + i);
d1064 5
a1068 4
				/* 
			 	 * Add data set to global list. 
			 	 */
				lladd (data_sets, d);			
@


1.34
log
@Before testing libcti.a library.
@
text
@d2 3
d20 1
a20 1
/*$Header: /home/petsun4/ty7777/src/view25d/RCS/portal.c,v 1.33 1992/11/20 16:35:26 ty7777 Exp ty7777 $*/
@


1.33
log
@Working and Updated version.
@
text
@d2 3
d17 1
a17 1
/*$Header: /home/petsun4/ty7777/src/view25d/RCS/portal.c,v 1.31 1992/10/30 21:51:25 ty7777 Exp $*/
a69 1
#include <petutil/petutil.h>
d2381 2
@


1.32
log
@Before adding uncompress for compressed files.
@
text
@d14 1
a14 1
/*$Header: /home/petsun4/ty7777/src/view25d/RCS/portal.c,v 1.31 1992/10/30 21:51:25 ty7777 Exp ty7777 $*/
d628 1
a628 1
			fprintf (stderr, "Can't open %s\n", pet_filename); 
d641 1
a641 1

@


1.31
log
@portal.c checking in.
@
text
@d2 3
d14 1
a14 1
/*$Header: /home/petsun4/ty7777/src/view25d/RCS/portal.c,v 1.30 1992/09/28 16:47:24 ty7777 Exp ty7777 $*/
d628 1
a628 1
			fprintf (stderr, "Can't open %d\n", pet_filename); 
d641 1
a641 1
		close (mskfd);
@


1.30
log
@After Add "xlabel" button.
@
text
@d2 3
d11 8
a18 1
/*$Header: /home/petsun4/ty7777/src/view25d/RCS/portal.c,v 1.29 1992/09/23 19:30:26 ty7777 Exp ty7777 $*/
a866 1
	static char	*function = "InputRegionData";
d868 1
a868 3
	char		line[MAXLINE];          	/* line buffer */
	int		i;				/* counter */
	int		j;				/* counter */
d870 1
a870 3
	int		slice_index;
	int		pixel_num;
	int		tempx, tempy;
d872 1
d874 2
d877 3
a879 1
	SliceData	*slice;
d881 2
a882 1
	int		num_slices;
d884 3
a886 1
	/* open a region .TRG file */
d933 2
a934 1
	j	= 0;
d938 2
a939 1
		if (slice_index < first_rgn_slice || slice_index > last_rgn_slice)
d965 1
@


1.29
log
@Same as the last version.
@
text
@d2 3
d8 1
a8 1
/*$Header: /home/petsun4/ty7777/src/view25d.d/RCS/portal.c,v 1.28 1992/08/26 21:28:42 ty7777 Exp ty7777 $*/
a69 1
PRIVATE void		DrawSymbol ();
a2720 157
}


/*____________________________________________________________________	
	Function::
		DrawSymbol	
	Parameters:
		display:	X Display pointer.
		window:		X window to draw into.
		gc:		graphics context.
		x:		upper left x coord. of rectangle.
		y:		upper left y coord. of rectangle.
		w:		width of rectangle in pixels.
		h:		height of rectangle in pixels.
	Description:
		Draw AF3D symbols.
	Author:	Tom (Tongzeng) Yang
		(08/28/1991)
____________________________________________________________________*/

PRIVATE void DrawSymbol (display, window, gc, x, y, w, h, symbol_type)
Display		*display;
Window		window;
GC		gc;
short		x, y;			/* coord. of upper left cornet of rect. */
unsigned short	w, h;			/* width and height of rectangle */
char		symbol_type;
{
	XPoint	points [5];

	switch (symbol_type)
	{
		case RECTANGLE:
			XDrawRectangle (display, window, gc, x, y, w, h); 
			break;
		case FILLED_RECTANGLE:
			XFillRectangle (display, window, gc, x, y, w, h); 
			break;
		case CIRCLE:
			XDrawArc (display, window, gc, x, y, w, h, 0, 360 * 64); 
			break;
		case FILLED_CIRCLE:
			XFillArc (display, window, gc, x, y, w, h, 0, 360 * 64); 
			break;
		case DIAMOND:
		case FILLED_DIAMOND:
			points [0].x	= x + w / 2;
			points [0].y	= y;
			points [1].x	= x + w;
			points [1].y	= y + h / 2;
			points [2].x	= x + w / 2;
			points [2].y	= y + h;
			points [3].x	= x;
			points [3].y	= y + h / 2;
			points [4].x	= points [0].x;
			points [4].y	= points [0].y;

			if (symbol_type == DIAMOND)
			{
				XDrawLines (display, window, gc, 
					points, 5, CoordModeOrigin);
			}
			else if (symbol_type == FILLED_DIAMOND)
			{
				XFillPolygon (display, window, gc, 
					points, 5, Convex, CoordModeOrigin);
			}
			break;
		case UP_TRIANGLE:
		case FILLED_UP_TRIANGLE:
			points [0].x	= x + w / 2;
			points [0].y	= y;
			points [1].x	= x;
			points [1].y	= y + h;
			points [2].x	= x + w;
			points [2].y	= y + h;
			points [3].x	= points [0].x;
			points [3].y	= points [0].y;

			if (symbol_type == UP_TRIANGLE)
			{
				XDrawLines (display, window, gc, 
					points, 4, CoordModeOrigin);
			}
			else if (symbol_type == FILLED_UP_TRIANGLE)
			{
				XFillPolygon (display, window, gc, 
					points, 4, Convex, CoordModeOrigin);
			}
			break;
		case DOWN_TRIANGLE:
		case FILLED_DOWN_TRIANGLE:
			points [0].x	= x + w / 2;
			points [0].y	= y + h;
			points [1].x	= x;
			points [1].y	= y;
			points [2].x	= x + w;
			points [2].y	= y;
			points [3].x	= points [0].x;
			points [3].y	= points [0].y;

			if (symbol_type == DOWN_TRIANGLE)
			{
				XDrawLines (display, window, gc, 
					points, 4, CoordModeOrigin);
			}
			else if (symbol_type == FILLED_DOWN_TRIANGLE)
			{
				XFillPolygon (display, window, gc, 
					points, 4, Convex, CoordModeOrigin);
			}
			break;
		case LEFT_TRIANGLE:
		case FILLED_LEFT_TRIANGLE:
			points [0].x	= x;
			points [0].y	= y + h / 2;
			points [1].x	= x + w;
			points [1].y	= y;
			points [2].x	= x + w;
			points [2].y	= y + h;
			points [3].x	= points [0].x;
			points [3].y	= points [0].y;

			if (symbol_type == LEFT_TRIANGLE)
			{
				XDrawLines (display, window, gc, 
					points, 4, CoordModeOrigin);
			}
			else if (symbol_type == FILLED_LEFT_TRIANGLE)
			{
				XFillPolygon (display, window, gc, 
					points, 4, Convex, CoordModeOrigin);
			}
			break;
		case RIGHT_TRIANGLE:
		default: 
			points [0].x	= x + w;
			points [0].y	= y + h / 2;
			points [1].x	= x;
			points [1].y	= y;
			points [2].x	= x;
			points [2].y	= y + h;
			points [3].x	= points [0].x;
			points [3].y	= points [0].y;

			if (symbol_type == RIGHT_TRIANGLE)
			{
				XDrawLines (display, window, gc, 
					points, 4, CoordModeOrigin);
			}
			else if (symbol_type == FILLED_RIGHT_TRIANGLE)
			{
				XFillPolygon (display, window, gc, 
					points, 4, Convex, CoordModeOrigin);
			}
			break;
	}
@


1.28
log
@Testing RCS checking in.
@
text
@d1 5
a5 2
/*$Log$*/
/*$Header$*/
@


1.27
log
@After fixing font bug (reported by Julie Fiez).
@
text
@d1 2
a2 2
/*Log*/
/*Header*/
@


1.26
log
@After lateral and medial atlas slices work.
@
text
@d1 2
d3500 1
a3500 1
		strcat (font_string, "*medium");
d3502 1
a3502 1
		strcat (font_string, "*bold");
d3505 1
a3505 1
		strcat (font_string, "*r*");
d3507 1
a3507 1
		strcat (font_string, "*i*");
d3509 1
a3509 1
		strcat (font_string, "*o*");
@


1.25
log
@After default masking file worked.
@
text
@d4776 4
a4779 2
	else if ((atlas_orient == FACING_LEFT || atlas_orient == FACING_RIGHT) 
					&& strstr (szBuffer, "sagittal") == NULL)
@


1.24
log
@After Mask File Selection Worked.
@
text
@d4750 4
a4753 3
	char			szBuffer [MAXLINE];
	char			atlas_name [MAXLINE];
	char			*library_path	= szLibraryPathName;
d4761 2
a4762 1
		if (strstr (szBuffer, "Talairach_") == NULL)
d4764 1
d4766 1
d4768 1
d4789 11
@


1.23
log
@Before adding mask menu.
@
text
@d4760 5
a4764 1
		strcat (atlas_name, "HD6_transverse.atl");
@


1.22
log
@Before adding file selection box for pet mask.
@
text
@d571 1
d614 1
a614 1
		mskfd	= open ("/usr/local/lib/VIEW25D/TMPLT99.DAT", O_RDONLY, 0);
d616 1
a616 1
			fprintf (stderr, "Can't open mask image TMPLT99.DAT\n");
d619 1
a619 1
			"/usr/local/lib/VIEW25D/TMPLT99.DAT", slice_index, 0, 
d4055 1
a4055 1
				strcpy (color_table_name, COLOR_TABLE_PATH);
d4752 1
d4758 4
a4761 1
		strcpy (atlas_name, "/usr/local/lib/VIEW25D/HD6_transverse.atl");
d4763 4
a4766 1
		strcpy (atlas_name, "/usr/local/lib/VIEW25D/Talairach_coronal.atl");
d4769 4
a4772 1
		strcpy (atlas_name, "/usr/local/lib/VIEW25D/Talairach_sagittal.atl");
@


1.21
log
@After AF3D All Planes Worked.
@
text
@d1320 1
d1773 2
a1774 2
					((coordinate >= slice->slice_xyz - 1.0) && 
					(coordinate < slice->slice_xyz + 1.0))) 
@


1.20
log
@AF3D menu works.
@
text
@d1320 1
d1771 3
a1773 2
				if ((coordinate >= slice->slice_xyz - 1.0) && 
					(coordinate < slice->slice_xyz + 1.0)) 
@


1.19
log
@After AF3D menu works.
@
text
@d65 1
d117 5
a121 1
	if (a->z < b->z)
d123 1
a123 1
	if (a->z > b->z)
d125 1
a125 1
	return(0);
d128 13
d142 12
d1255 1
a1255 1
PUBLIC void	UpdatePortals (display, window, gc, current_header, plist)
d1261 1
a1309 1
	char			atlas_orient;
a1339 1
		atlas_orient		= cAtlasOrientation;
d1582 4
d1769 3
a1771 2
				if ((point->z > slice->slice_xyz - 1.0) && 
					(point->z <= slice->slice_xyz + 1.0)) 
d1776 26
a1801 8
					tempx	= current_header->centerx 
						+ ROUND ((point->x * -1.0) 
						/ current_header->pixel_size);
					tempy	= current_header->centery 
						+ ROUND ((point->y * -1.0) 
						/ current_header->pixel_size);
					tempx	+= x - data_set->symbol_size / 2;
					tempy	+= y - data_set->symbol_size / 2;
d1803 5
d2395 1
a2395 1
			pixelAF3DColor, nSymbolSize, data_sets_list);
d2410 1
a2410 1
	UpdatePortals (display, window, gc, current_header, portal_list);
@


1.18
log
@Before AF3D menu cancel button works.
@
text
@d49 1
d3280 1
d3358 7
d3462 2
a3463 1
PUBLIC void GetDefaultParameters (display, root_window, gc, file_name, default_parameters)
d3469 1
d3477 2
a3478 1
	Arg			arglist[2];
d3498 1
d3504 12
d3519 1
a3519 1
		fprintf (stderr, "Erroe: Cannot Open file %s\n", file_name);
d3727 68
a3948 6
			nxOldColorBar		= *xcolor_bar; 
			nyOldColorBar		= *ycolor_bar; 
			nOldColorBarLength	= *color_bar_length; 
			nOldColorBarWidth	= *color_bar_width; 
			bOldHoriColorBar	= *color_bar_orient;

d4211 1
a4211 1
			fprintf (stderr, "Erroe: GetDefaultParameters\n");
d4215 59
d4312 7
d4323 1
a4323 1
		fprintf (stderr, "Erroe: Cannot Open file %s\n", file_name);
d4375 29
@


1.17
log
@After AF3D menu works.
@
text
@d944 2
a945 1
PRIVATE void InputAF3DData (filenames, display_symbol, symbol_type, pixel_color, data_sets)
d950 1
d982 1
a1287 1
		draw_portal_data.symbol_size		= &nSymbolSize;
d1747 2
a1748 2
					tempx	+= x - *draw_portal_data->symbol_size / 2;
					tempy	+= y - *draw_portal_data->symbol_size / 2;
d1751 2
a1752 2
							*draw_portal_data->symbol_size, 
							*draw_portal_data->symbol_size, 
d2337 1
a2337 1
				pixelAF3DColor, data_sets_list);
@


1.16
log
@Before AF3D menu works.
@
text
@d56 7
a63 1
PRIVATE GammaZData	*MakeGammaZData ();
a64 1
PRIVATE SCALE_HEADER	*BuildQueue ();
d66 3
d71 4
a74 2
PRIVATE void		InputAF3DData ();
PRIVATE void		get_gammaz ();
a75 9
PRIVATE SliceData	*ResizeSlice ();
PRIVATE void		BuildPortals ();
PRIVATE void		ResizePortals ();
PRIVATE Portal		*MakePortal (); 
PRIVATE void		FormatScreen ();
PRIVATE void		DrawPortal ();
PRIVATE void		DrawOutlinedRegion ();
PRIVATE void		GetPetDimension ();
PRIVATE void		GetPetCenter ();
d936 2
a937 2
	Arguments:	AF3D_filename: pointer to AF3D loci points filename	
	Description:	Read region slices into atlas list.
d944 6
a949 4
PRIVATE void InputAF3DData (draw_data, AF3D_filename, input_node)
DRAW_DATA	*draw_data;
char		*AF3D_filename;
char		input_node;
d951 4
a954 1
	FILE	*AF3D_incoming;
d956 6
a961 2
	AF3D_incoming	= fopen (AF3D_filename, "rb");
	if (AF3D_incoming == NULL)
d963 26
a988 3
		fprintf (stderr, "Can't Open %s\n", AF3D_filename);
		perror ("AF3D:fopen");
		exit (-1);
a989 5

	/* 
	 * Add event handler for input from Sybase application 
	 */
	XtAddInput (fileno (AF3D_incoming), XtInputReadMask, get_gammaz, draw_data);
d1285 1
a1285 5
		draw_portal_data.display_AF3D_flag	= &bDisplayAF3D;
		draw_portal_data.symbol_type		= cSymbolType;
		draw_portal_data.symbol_color		= pixelAF3DColor;
		draw_portal_data.symbol_width		= &nSymbolWidth;
		draw_portal_data.symbol_height		= &nSymbolHeight;
d1721 1
a1721 1
	if (*draw_portal_data->display_AF3D_flag && llsize (data_sets) > 0)
a1723 1
		XSetForeground (display, gc, *draw_portal_data->symbol_color);
d1727 1
d1745 2
a1746 2
					tempx	+= x - *draw_portal_data->symbol_width / 2;
					tempy	+= y - *draw_portal_data->symbol_height / 2;
d1749 3
a1751 3
							*draw_portal_data->symbol_width, 
							*draw_portal_data->symbol_height, 
							*draw_portal_data->symbol_type);
d1959 3
a1961 3
	temp = *pnFirst;
	*pnFirst = *pnSecond;
	*pnSecond = temp;
d1993 1
a1993 2
	Arguments:	display:	pointer to X Display 
			plist:		portal linked list.
a2008 2
	GammaZPoint	*point;
	GammaZData	*data_set;
d2057 18
a2201 33
/*________________________________________________________________________________________	
	Function:
		get_gammmaz	
	Arguments:
		display: X display pointer
		fd: UNIX file descriptor 
		id: XtInputId 
	Description:
		Callback function for input of gammaz data. Called when any
		data is available on fd.
________________________________________________________________________________________*/

PRIVATE void get_gammaz (draw_data, fd, id)
DRAW_DATA	*draw_data;
int		*fd;
XtInputId	*id;
{
	Display		*display = draw_data->display;
	GammaZData	*d;			/* new data set */
	char		c;			/* test char */

	if (read (*fd, &c, 1) != 1)		/* if nothing in file, then return */
		return;
	d	= MakeGammaZData (*fd, c);	/* make new data set from input */
	lladd (data_sets, d);			/* add data set to global list */
	if (bDisplayAF3D)
	{
		UpdatePortals (display, draw_data->window, draw_data->gc, 
						rCurrentScaleHeader, plist);	
	}
}


d2334 2
a2335 4
	if (bAF3DImageSelected)
	{
		InputAF3DData (draw_data, szAF3DFileNames [0], input_node);
	}
d2350 1
a2350 2
	if (!bDisplayAF3D)
		UpdatePortals (display, window, gc, current_header, portal_list);
d2670 1
a2670 1
PUBLIC void DrawSymbol (display, window, gc, x, y, w, h, symbol_type)
a3538 13
			if (strcmp (label, "DisplayAF3DFlag:") == 0)
			{
				if (strcmp (Lowered (value, strlen (value)), "true") == 0)
					bool_buffer	= TRUE;
				else
					bool_buffer	= FALSE;

				SetSelectData (*data_type_menu->AF3D, bool_buffer);
				bDisplayAF3D	= bool_buffer;

				continue;
			}

a4174 1
	fprintf (file, "DisplayAF3DFlag:	%s\n", bDisplayAF3D? "True": "False");
@


1.15
log
@Before AF3D menu works.
@
text
@d1258 2
a1259 2
		draw_portal_data.symbol_type		= &cSymbolType;
		draw_portal_data.symbol_color		= &pixelAF3DColor;
@


1.14
log
@Before AF3D menu works.
@
text
@d2330 1
a2330 1
		InputAF3DData (draw_data, szAF3DFileName, input_node);
@


1.13
log
@After changing AF3D drawing part.
@
text
@d821 1
d831 1
d849 1
a849 1
		&tempx, &tempy, &x, &y, &z, &i, &slice_index);
d860 3
a862 1
	/* Skip atlases until we find the first slice with a region input */
d880 3
a882 1
	while (fscanf (trg_file_ptr, "%d %d", &slice_index, &pixel_num) != EOF)
d911 1
@


1.12
log
@Draw AF3D points.
@
text
@a72 1
PRIVATE void		AddPointData ();
a478 1
		slice->points		= llinit ();
a1001 1
	portalSlice->points		= slice->points;
a1145 61
	Function:	AddPointData
	Arguments:	display: pointer to X Display 
			atlas: linked list of atlas slices
			data_set: pointer to GammaZData to add
	Description: 	Add point data to the atlas slices.

	Return Value:	None.
________________________________________________________________________________*/

PRIVATE void	AddPointData (display, atlas, data_set)
Display		*display;
llist		atlas;			/* atlas data (list of SliceData) */
GammaZData	*data_set;		/* single gammaz data set */
{


	SliceData	*slice;		/* pointer to step thru atlas */
	GammaZPoint	*point;		/* pointer to step thru point list */


	/* 
	 * For all the points in the data set 
	 */ 
	llhead (data_set->points);
	do 
	{
		/* 
		 * Retrieve the current point 
		 */
		point = (GammaZPoint *) llretrieve (data_set->points);

		/* 
		 * For each atlas slice. 
		 */
		llhead (atlas);
		do 
		{

			/* 
			 * Get the current slice. 
			 */
			slice = (SliceData *) llretrieve (atlas);

			/* 
			 * If the point belongs to this slice then add
			 * it to the list of plotted points on the slice 
			 */
			if ((point->z > slice->slice_xyz - 1.0) && 
				(point->z <= slice->slice_xyz + 1.0)) 
			{
printf ("Add: x = %f y = %f z = %f\n", point->x, point->y, point->z);
				lladd (slice->points, point);	
			} 

		} while (llnext (atlas) != FAIL);

	} while (llnext (data_set->points) != FAIL);
}


/*________________________________________________________________________________	
d1693 1
a1704 1
printf ("Draw: x = %f y = %f z = %f\n", point->x, point->y, point->z);
a1725 36
	/*
	if (*draw_portal_data->display_AF3D_flag && llsize (slice->points) > 0)
	{
	*/
	    	/* 
		 * for all the points on the slice 
		 */
		/*
	    	llhead (slice->points);
		point	= (GammaZPoint *) llretrieve (slice->points);
		XSetForeground (display, gc, *draw_portal_data->symbol_color);

	    	do 
	    	{
			point	= (GammaZPoint *) llretrieve (slice->points);
		*/

			/* 
			 * Reverse coord. orientation and scale 
			 */
			/*
			tempx	= current_header->centerx + ROUND ((point->x * -1.0) 
							/ current_header->pixel_size);
			tempy	= current_header->centery + ROUND ((point->y * -1.0) 
							/ current_header->pixel_size);
			tempx	+= x - *draw_portal_data->symbol_width / 2;
			tempy	+= y - *draw_portal_data->symbol_height / 2;

			DrawSymbol (display, window, gc, tempx, tempy, 
				*draw_portal_data->symbol_width, 
				*draw_portal_data->symbol_height, 
				*draw_portal_data->symbol_type);
		} while (llnext(slice->points) != FAIL);
	}
	*/

a2016 12
		/* 
		 * Remove all point refs from slice. 
		 */
		if (llsize (slice->points) > 0) 
		{
			llhead (slice->points);
			do 
			{
				lldelete (slice->points);
			} while (llsize (slice->points) > 0);
		}

a2180 1
	AddPointData (display, atlas, d);	/* add point data to atlas */
@


1.11
log
@Before AF3D Change.
@
text
@d1199 1
d1574 1
d1754 37
d1793 1
d1797 1
d1805 1
d1810 1
d1824 1
@


1.10
log
@Before AF3D Change.
@
text
@a479 1
		slice->data_sets	= llinit ();
a1003 1
	portalSlice->data_sets		= slice->data_sets;
a1204 17


	/* 
	 * For each atlas slice. 
	 */
	llhead (atlas);
	slice = (SliceData *) llretrieve (atlas);
	do 
	{
		slice = (SliceData *) llretrieve (atlas);

		/* 
		 * Record that this data set has been plotted to the slice. 
		 */
		lladd (slice->data_sets, data_set);

	} while (llnext (atlas) != FAIL);
d1620 1
a1620 1
			for (j = 0; j < current_header->height; j++) 
d1622 4
a1625 2
				tempx	= draw_portal_data->mask_slice [2 * j];
				tempy	= draw_portal_data->mask_slice [2 * j + 1];
d1627 4
a1630 3
				if (tempx <= tempy)
					XDrawLine (display, window, gc, 
					tempx + x, j + y, tempy + x, j + y);
d1632 17
d1673 3
d1703 2
a1704 1
						x + current_header->centerx + (current_header->centerx - j), 
a2082 12
		}

		/* 
		 * Remove all dataset refs from slice. 
		 */
		if (llsize (slice->data_sets) > 0) 
		{
			llhead (slice->data_sets);
			do 
			{
				lldelete (slice->data_sets);
			} while (llsize (slice->data_sets) > 0);
@


1.9
log
@Fixed facing-right misalignment problem.
@
text
@d155 4
a158 2
	/* allocate the data set header */
	data = (GammaZData *) pkg_malloc (sizeof (GammaZData), function, "data");
d160 3
a162 1
	/* keep the test character and read the rest of the path_len var */
d167 3
a169 1
	/* allocate mem for the path and read it */
d173 3
a175 1
	/* get the length of the description string */
d178 3
a180 1
	/* allocate mem for the description and read it */
d184 3
a186 1
	/* read the af3d id */
d189 3
a191 1
	/* read the number of points */
d194 3
a196 1
	/* initialize the point list */
d204 3
a206 1
	/* allocate a buffer for point reading */
d209 3
a211 1
	/* read the gammaz points */
d214 3
a216 1
		/* read a raw point */
d219 3
a221 1
		/* allocate mem for internal point representation */
d224 10
a233 8
		/* fill the internal point structure */
		point->x = rawpoint->x;
		point->y = rawpoint->y;
		point->z = rawpoint->z;
		point->sig = rawpoint->sig;
		point->mag = rawpoint->mag;
		point->z_score = rawpoint->z_score;
		point->data_set = data;
d241 3
a243 1
	/* free the raw point buffer */
d247 10
a256 8
	/* fill the dataset header */
	data->path_len = path_len;
	data->path = path;
	data->desc_len = desc_len;
	data->description = description;
	data->af3d_id = af3d_id;
	data->num_points = num_points;
	data->points = points;
d284 1
a284 1
	*npNewx = ROUND (dScaleSize * (nOldx - dOldCenterx) + nNewCenterx);
d595 1
a595 1
			for (i = 0; i <= ENCODED_SLICE_HEIGHT; i++)
d700 1
a700 1
				pet_slice_image[i] == PET_BACK_VALUE; i++)
d721 1
a721 1
				pet_slice_image[i] == PET_BACK_VALUE; i--)
d743 1
a743 1
				tempy = i;
a944 1
	GammaZData	*d;			/* new data set */
d946 1
a946 1
	AF3D_incoming = fopen (AF3D_filename, "rb");
d954 3
a956 1
	/* add event handler for input from Sybase application */
d1026 2
a1027 2
			    		REGION_SLICE_WIDTH / 2 + 0.5, 
					REGION_SLICE_HEIGHT / 2 + 0.5, 
d1033 2
a1034 2
	    		portalSlice->region[i].x = tempx;
	    		portalSlice->region[i].y = tempy;
d1068 6
d1094 1
a1094 1
				pet_coord_databuf[rows + i] == PET_BACK_VALUE; i++)
d1099 1
a1099 1
				pet_coord_databuf[rows + i] == PET_BACK_VALUE; i--)
d1136 4
a1139 4
	 			portalSlice->pet_point_pixel[temp_coord_num] 
					= pet_coord_databuf[rows + i] + PET_COLOR_START;
				portalSlice->pet_point_coord[temp_coord_num].x = i + xoffset;
				portalSlice->pet_point_coord[temp_coord_num].y = j + yoffset;
d1171 3
a1173 1
	/* for all the points in the data set */ 
d1177 3
a1179 1
		/* retrieve the current point */
d1182 3
a1184 1
		/* for each atlas slice */
d1189 3
a1191 1
			/* get the current slice */
d1194 6
a1199 3
			/* if the point is belongs on this slice then add
			/*   it to the list of plotted points on the slice */
			if ((point->z > slice->slice_xyz - 1.0) && (point->z <= slice->slice_xyz + 1.0)) 
d1209 3
a1211 1
	/* for each atlas slice */
d1213 1
a1213 1
	slice = (SliceData *) llretrieve(atlas);
d1218 3
a1220 1
		/* record that this data set has been plotted to the slice */
d1243 3
a1245 1
	/* allocate mem for the Portal header */
d1248 3
a1250 1
	/* assign portal header */
d1253 3
a1255 1
	/* return the new portal */
d1304 1
a1304 1
	BOOLEAN			hori_colorbar;
d1309 1
d1321 3
a1323 2
	char			pet_value_flag	= cPetValueFlag;
	char			atlas_orient	= cAtlasOrientation;
d1356 3
d1360 3
a1362 1
		/* move to head of portal list */
d1401 3
a1403 1
		/* for each portal */
d1409 5
a1413 4
			portal	= (Portal *) llretrieve (plist);
			slice	= portal->slice;
			xinc	= ROUND (xinc_mm / current_header->pixel_size);
			yinc	= ROUND (yinc_mm / current_header->pixel_size);
d1423 1
a1423 1
			if (bSliceNumberFlag)
d1515 8
d1544 1
a1544 1
		if (*draw_portal_data.display_pet_flag)
d1555 6
a1697 1
						/*
a1698 3
						(current_header->width - 1 - j) + x, i + y);
						*/
						XDrawPoint (display, window, gc, 
a1705 7
	/*	for Testing
	XSetForeground (display, gc, REGION_CELL);
	XFillRectangle (display, window, gc, 
			current_header->centerx + x - 2,
			current_header->centery + y - 2,
			4, 4);
	*/
d1760 3
a1762 1
			/* reverse coord. orientation and scale */
a1818 1
	int			temp;
d1822 3
d1844 2
a1845 2
			XClearArea (display, window, x, y, 
					nOldAtlasWidth, nOldAtlasHeight, FALSE);
d1875 1
a1875 1
		if (pet_exist)
d2254 1
a2254 1
	d = MakeGammaZData (*fd, c);		/* make new data set from input */
d2258 1
d2261 1
d2415 2
a2416 1
	UpdatePortals (display, window, gc, current_header, portal_list);
d3662 1
d4538 4
a4541 4
			atlas_orientation:	atlas orientation, transverse,
						coronal, or sagittal.
			slice_cx:		pointer to slice center x.
			slice_cy:		pointer to slice center y.
d4567 37
@


1.8
log
@Before testing of center.
@
text
@d1352 2
a1353 2
			portal->x = xoffset - current_header->centerx;
			portal->y = yoffset - current_header->centery;
d1519 3
a1521 1
	/* get header variables */
d1528 1
a1528 1
	 * Draw Mask
d1616 1
d1619 4
d1628 7
@


1.7
log
@Update with error.
@
text
@d74 2
d183 3
a185 1
	/* set the comparison function for llinsert */
d209 3
a211 1
		/* insert the point into the point list */
d432 3
a434 1
	/* set comparison function for llinsert */
d437 3
a439 1
	/* build the atlas list */
d445 3
a447 1
		/* allocate mem for a slice */
d483 1
d506 6
d513 3
a515 1
	/* allocate header */
d538 38
a575 2
	lltail (atlas_list);
	slice_index = first_slice;
d578 7
d588 1
a588 1
			 * Allocate and zero the image array. 
d590 11
a600 5
			slice	= llretrieve (atlas_list);
			slice->pet_raw = (short *) calloc (ENCODED_SLICE_DIM, sizeof (short));
			imgfd	= open (pet_filename, O_RDONLY, 0);
			if (imgfd == -1)
				fprintf (stderr, "Can't open %d\n", pet_filename); 
d602 16
a617 6
			getimage (slice->pet_raw, header, imgfd, pet_filename, slice_index, 
				encoded, num_slices, pett_num, &err_value);

			close (imgfd);	

			if (err_value == FAIL)
d619 13
a631 1
				slice->pet_exist = FALSE;
d633 16
d651 1
a651 13
				mask_slice_image	= (short *) calloc (ENCODED_SLICE_DIM, 
										sizeof (short));
				mskfd	= open ("/usr/local/lib/VIEW25D/TMPLT99.DAT", O_RDONLY, 0);
				if (mskfd == -1)
					fprintf (stderr, "Can't open mask image TMPLT99.DAT\n");

				getimage (mask_slice_image, header, mskfd, 
				"/usr/local/lib/VIEW25D/TMPLT99.DAT", slice_index, 0, 
				49, PETT6_SCANNER, &err_value);

				close (mskfd);

				for (j = 0; j < ENCODED_SLICE_HEIGHT; j++)
d653 4
a656 2
					rows	= j * ENCODED_SLICE_WIDTH;
					for (i = 0; i < ENCODED_SLICE_WIDTH; i++)
d658 3
a660 3
						if (mask_slice_image [rows + i] < 0)
							slice->pet_raw [rows + i] 
								= PET_BACK_VALUE;
d662 1
a663 1
				free (mask_slice_image);
a665 9
			slice_index += abs (spacing);
		}
		while (llprevious (atlas_list) != FAIL && slice_index <= last_slice);

		lltail (atlas_list);
		slice_index	= first_slice;
		do
		{
printf ("Yuh-wen 1\n");
a666 1
printf ("Yuh-wen 2\n");
d669 4
a672 4
			for (i = 0; i < ENCODED_SLICE_DIM && 
				slice->pet_raw[i] == PET_BACK_VALUE; i++)
				;
			if (i >= ENCODED_SLICE_DIM)
d675 2
a676 1
				free (slice->pet_raw);
a680 1
printf ("Yuh-wen 3\n");
d682 2
a683 2
			i /= ENCODED_SLICE_WIDTH;
			if (i >= ENCODED_SLICE_HEIGHT)
d685 1
a685 1
				i = ENCODED_SLICE_HEIGHT - 1;
d688 1
a688 1
			ptUpperLeft.y = i;
d690 2
a691 2
			for (i = ENCODED_SLICE_DIM - 1;  i >= 0 && 
				slice->pet_raw[i] == PET_BACK_VALUE; i--)
d693 1
a693 1
			i /= ENCODED_SLICE_WIDTH;
d695 2
a696 2
				i = 0;
			ptBottomRight.y = i;
d698 2
a699 2
			tempx = ENCODED_SLICE_WIDTH - 1;
			tempy = 0;
d702 3
a704 3
				rows = j * ENCODED_SLICE_WIDTH;
				for (i = 0; i < ENCODED_SLICE_WIDTH && 
				slice->pet_raw[rows + i] == PET_BACK_VALUE; i++)
d707 1
a707 1
					tempx	= i;
d709 2
a710 2
				for (i = ENCODED_SLICE_WIDTH - 1; i >= 0 &&
				slice->pet_raw[rows + i] == PET_BACK_VALUE; i--)
d713 1
a713 1
					tempy	= i;
a716 1
printf ("Yuh-wen 4\n");
d726 2
a727 1
printf ("Yuh-wen 5\n");
d730 1
a730 1
				rows	= j * ENCODED_SLICE_WIDTH;
d733 2
a734 2
					temp_pet_value	= slice->pet_raw [rows + i];
					slice->pet_input [rows + i] = temp_pet_value;
a741 1
printf ("Yuh-wen 6\n");
d743 1
a743 1
			free (slice->pet_raw);
d755 13
a767 1
printf ("Yuh-wen 7\n");
d943 2
a944 1
PRIVATE SliceData *ResizeSlice (current_header, slice, minimum, maximum)
d949 2
d966 3
a968 1
	/* allocate memory for portal slice */
d979 3
a981 1
	/* memory allocation and compute resized region */
d991 3
a993 1
    			/* Transformation into Atlas Space Coordinates */ 
d1007 3
a1009 1
	/* memory allocation for pet image */
d1025 3
a1027 1
		/* compute pet image offset */
d1029 2
a1030 2
		    		ENCODED_SLICE_WIDTH / 2 + 0.5, 
				ENCODED_SLICE_HEIGHT / 2 + 0.5, 
d1035 4
a1038 1
				&xoffset, &yoffset);
d1040 3
a1042 1
		/* resize and convert pet image */
d1079 3
a1081 1
		/* compute PET pixels and coordinates */
d1339 3
a1341 1
			/* get a portal */
d1405 2
a1414 5
printf ("Testing 1: slice_size = %d\n", slice_size);
				atlas_slice	= (short *) pkg_malloc (slice_size,
							"UpdatePortals", "atlas_slice");
printf ("Testing 2\n");

a1469 1
			hori_colorbar	= bHorizontalColorBar;
d1474 1
d1567 3
a1569 1
	/* put the PET image on the screen */
d1622 3
a1624 1
	/* draw region */
d1659 3
a1661 1
	/* draw AF3D points */
d1664 3
a1666 1
	    	/* for all the points on the slice */
d1690 3
a1692 1
	/* compute the z-coord label dimension and put the label on image */
d1704 1
a1704 1
/*________________________________________________________________________________	
d1714 1
a1714 1
_________________________________________________________________________________*/
d1739 3
a1741 1
		/* move to head of portal list */
d1746 3
a1748 1
			/* get a portal */
d1750 2
d1755 2
a1756 2
			w	= current_header->width + 7 * ROUND (1 / current_header->pixel_size);
			h	= current_header->height + 7 * ROUND (1 / current_header->pixel_size);
d1760 6
a1765 4
				w	= pkg_max (w, slice->pet_width 
						+ slice->rgn_pet_pixelsize);
				h	= pkg_max (h, slice->pet_height 
						+ slice->rgn_pet_pixelsize);
a1767 8
			/*
			x	= portal->x + current_header->centerx - w / 2;
			y	= portal->y + current_header->centery - h / 2;
			*/
			x	= portal->x;
			y	= portal->y;

			XClearArea (display, window, x, y, w, h, FALSE);
d1772 8
a1779 6
		/* Clear Color Bar */
		hori_colorbar	= bHorizontalColorBar;
		x		= nxColorBarStart;
		y		= nyColorBarStart;
		length		= nColorBarLength;
		width		= nColorBarWidth;
d1809 2
a1810 1
PRIVATE void ResizePortals (current_header, plist, atlas, minimum, maximum) 
d1816 2
d1819 3
a1821 3
	Portal			*portal;	/* current portal */
	SliceData		*slice;		/* current slice */
	int			size;		/* size of portal list */
d1823 1
a1823 1
	size = llsize (atlas);
d1830 3
a1832 1
			/* move to head of portal list */
a1833 1
			size--;
d1835 3
a1837 1
			/* get slice and portal */
d1841 3
a1843 1
			/* Free memory that will change for portal->slice */
d1852 3
a1854 1
			/* Resize slices */
d1856 2
a1857 1
			portal->slice = ResizeSlice (current_header, slice, minimum, maximum);
d1859 4
a1862 2
			/* Make new portal */
			portal = MakePortal (portal->slice);
d1922 1
a1922 1
/*_____________________________________________________________________________________	
d1928 2
a1929 2
	Description:	Clear portal data from memory. Removes all points from screen and data 
			structures.
d1932 1
a1932 1
_____________________________________________________________________________________*/
d1944 3
a1946 1
	/* clear plist data */
d1968 3
a1970 1
	/* clear memory corresponding to points and data_sets in slice */
d1974 3
a1976 1
		/* get a slice */
d1979 3
a1981 1
		/* remove all point refs from slice */
d1991 3
a1993 1
		/* remove all dataset refs from slice */
d2012 3
a2014 1
	/* clear data_sets */
d2018 3
a2020 1
		/* get a data set */
d2023 3
a2025 1
		/* remove all points in data set */
d2037 3
a2039 1
		/* free mem for header strings */
d2218 1
a2218 1
/*______________________________________________________________________________________	
d2226 1
a2226 1
______________________________________________________________________________________*/
d2237 4
a2240 4
	short		first_slice;
	short		last_slice;
	short		spacing;
	char		input_node = INPUT_NEW;
a2243 1
	SCALE_HEADER	*current_header;
d2246 1
d2250 5
a2261 4
	first_slice	= nFirstSlice;
	last_slice	= nLastSlice;
	spacing		= nSpacing;

d2276 6
d2286 5
d2292 1
a2293 2
	current_header		= rCurrentScaleHeader;

d2313 1
d2315 2
a2316 1
		BuildPortals (current_header, atlas_list, portal_list, &minimum, &maximum);
d2318 2
a2319 1
		ResizePortals (current_header, portal_list, atlas_list, &minimum, &maximum);
d2343 2
a2344 1
PRIVATE void BuildPortals (current_header, atlas_list, portal_list, minimum, maximum) 
d2350 2
d2364 2
a2365 1
			portal_slice	= ResizeSlice (current_header, slice, minimum, maximum);
d3451 5
d3797 1
a3797 1
				nxColorBarStart	= atoi (value);
d3805 1
a3805 1
				nyColorBarStart	= atoi (value);
d3813 1
a3813 1
				nColorBarWidth	= atoi (value);
d3821 1
a3821 1
				nColorBarLength	= atoi (value);
d3835 1
a3835 1
				bHorizontalColorBar	= bool_buffer;
d3840 6
d4403 72
@


1.6
log
@Before coronal and sagittal functions are added.
@
text
@a470 1
	short		*pet_slice_image;
d523 5
a527 2
			/* Allocate and Zero the image array */
			pet_slice_image = (short *) calloc (ENCODED_SLICE_DIM, sizeof (short));
d532 1
a532 1
			getimage (pet_slice_image, header, imgfd, pet_filename, slice_index, 
a536 3
			slice = llretrieve (atlas_list);
			if (slice->pet_exist)
				XtFree (slice->pet_input);
d555 1
a555 4
				for (i = 0; i < ENCODED_SLICE_DIM && 
					pet_slice_image[i] == PET_BACK_VALUE; i++)
					;
				if (i >= ENCODED_SLICE_DIM)
d557 7
a563 5
					slice->pet_exist	= FALSE;
					free (pet_slice_image);
					free (mask_slice_image);
					slice_index += abs (spacing);
					continue;
d565 2
a566 2
				else
					slice->pet_exist	= TRUE;
d568 3
a570 5
				i /= ENCODED_SLICE_WIDTH;
				if (i >= ENCODED_SLICE_HEIGHT)
				{
					i = ENCODED_SLICE_HEIGHT - 1;
				}
d572 21
a592 1
				ptUpperLeft.y = i;
d594 5
a598 7
				for (i = ENCODED_SLICE_DIM - 1;  i >= 0 && 
					pet_slice_image[i] == PET_BACK_VALUE; i--)
					;
				i /= ENCODED_SLICE_WIDTH;
				if (i < 0)
					i = 0;
				ptBottomRight.y = i;
d600 1
a600 10
				tempx = ENCODED_SLICE_WIDTH - 1;
				tempy = 0;
				for (j = ptUpperLeft.y; j <= ptBottomRight.y; j++)
				{
					rows = j * ENCODED_SLICE_WIDTH;
					for (i = 0; i < ENCODED_SLICE_WIDTH && 
					pet_slice_image[rows + i] == PET_BACK_VALUE; i++)
						;
					if (i < tempx)
						tempx = i;
d602 7
a608 8
					for (i = ENCODED_SLICE_WIDTH - 1; i >= 0 &&
					pet_slice_image[rows + i] == PET_BACK_VALUE; i--)
						;
					if (i > tempy)
					tempy = i;
				}
				ptUpperLeft.x	= tempx;
				ptBottomRight.x	= tempy;
d610 10
a619 4
				slice->pet_xstart	= ptUpperLeft.x;
				slice->pet_ystart	= ptUpperLeft.y; 
				slice->pet_width	= (ptBottomRight.x - ptUpperLeft.x + 1); 
				slice->pet_height	= (ptBottomRight.y - ptUpperLeft.y + 1); 
d621 9
a629 3
				slice->pet_input	= (short *) pkg_malloc (slice->pet_width 
							* slice->pet_height * sizeof (short), 
							function, "slice->pet_input");
d631 13
a643 2
				tempx	= 0;
				for (j = ptUpperLeft.y; j <= ptBottomRight.y; j++)
d645 2
a646 9
					rows	= j * ENCODED_SLICE_WIDTH;
					for (i = ptUpperLeft.x; i <= ptBottomRight.x; i++)
					{
						if (mask_slice_image [rows + i] > 0)
							temp_pet_value	
								= pet_slice_image [rows + i];
						else
							temp_pet_value	= PET_BACK_VALUE;
						slice->pet_input[tempx++] = temp_pet_value;
d648 4
a651 5
						if (temp_pet_value > global_max)
							global_max	= temp_pet_value;
						if (temp_pet_value < global_min)
							global_min	= temp_pet_value;
					}
a652 2
				minmax_changed		= TRUE;
				free (mask_slice_image);
d654 3
a656 2

			free (pet_slice_image);
d668 1
a1283 2
				atlas_slice = (short *) malloc (slice_size);

d1291 5
@


1.6.1.1
log
@Before coronal and sagittal functions are added.
@
text
@d181 1
a181 3
	/* 
	 * Set the comparison function for llinsert. 
	 */
d205 1
a205 3
		/* 
		 * Insert the point into the point list. 
		 */
d426 1
a426 3
	/* 
	 * Set comparison function for llinsert. 
	 */
d429 1
a429 3
	/* 
	 * Build the atlas list. 
	 */
d435 1
a435 3
		/* 
		 * Allocate memory for a slice. 
		 */
d524 1
a524 3
			/* 
			 * Allocate and Zero the image array. 
			 */
d1201 1
a1201 3
			/* 
			 * Get a portal. 
			 */
d1610 4
d1668 1
a1668 1
	size	= llsize (atlas);
d1675 1
a1675 3
			/* 
			 * Move to head of portal list. 
			 */
d1677 1
d1679 1
a1679 3
			/* 
			 * Get slice and portal. 
			 */
d1683 1
a1683 3
			/* 
			 * Free memory that will change for portal->slice. 
			 */
d1692 1
a1692 3
			/* 
			 * Resize slices. 
			 */
d1696 2
a1697 4
			/* 
			 * Make new portal. 
			 */
			portal	= MakePortal (portal->slice);
@


1.6.1.2
log
@After slice3d_list are added.
@
text
@a503 2
	llist		slice3d_list;
	HorizontalSlice	*horizontal_slice;
a527 18
	slice3d_list	= llinit ();
	for (i = 1; i <= num_slices; i++)
	{
		horizontal_slice	= (HorizontalSlice *) pkg_malloc (sizeof (HorizontalSlice), 
						function, "horizontal_slice");
		horizontal_slice->slice_index	= i;
		horizontal_slice->slice_data	= (short *) calloc (ENCODED_SLICE_DIM, 
							sizeof (short));
		imgfd	= open (pet_filename, O_RDONLY, 0);
		if (imgfd == -1)
			fprintf (stderr, "Can't open %d\n", pet_filename); 
		getimage (horizontal_slice->slice_data, header, imgfd, pet_filename, i, 
				encoded, num_slices, pett_num, &err_value);
		close (imgfd);	

		lladd (slice3d_list, horizontal_slice);
	}

d529 1
a529 1
	slice_index	= first_slice;
a661 13

	/* 
	 * Clear slice3d_list data. 
	 */
	llhead (slice3d_list);			
	while (llsize (slice3d_list) > 0) 
	{
		horizontal_slice	= (HorizontalSlice *) llretrieve (slice3d_list);
		XtFree (horizontal_slice->slice_data);
		XtFree (horizontal_slice);

		lldelete (slice3d_list);
	} 
@


1.6.1.3
log
@Before coronal and sagittal image is displayed.
@
text
@d548 2
a551 8
		lltail (atlas_list);
		slice_index	= first_slice;
		llhead (slice3d_list);			
		for (i = 1; i < first_slice; i++)
		{
			llnext (slice3d_list);
		}

d558 3
a560 10
			horizontal_slice	= (HorizontalSlice *) llretrieve (slice3d_list);
			for (j = 0; j < ENCODED_SLICE_HEIGHT; j++)
			{
				rows	= j * ENCODED_SLICE_WIDTH;
				for (i = 0; i <= ENCODED_SLICE_HEIGHT; i++)
				{
					pet_slice_image [rows + i] 
						= horizontal_slice->slice_data [rows + i];
				}
			}
d562 5
d570 11
a580 5
			mask_slice_image	= (short *) calloc (ENCODED_SLICE_DIM, 
									sizeof (short));
			mskfd	= open ("/usr/local/lib/VIEW25D/TMPLT99.DAT", O_RDONLY, 0);
			if (mskfd == -1)
				fprintf (stderr, "Can't open mask image TMPLT99.DAT\n");
d582 1
a582 1
			getimage (mask_slice_image, header, mskfd, 
d586 1
a586 1
			close (mskfd);
d588 4
a591 10
			for (i = 0; i < ENCODED_SLICE_DIM && 
				pet_slice_image[i] == PET_BACK_VALUE; i++)
			;
			if (i >= ENCODED_SLICE_DIM)
			{
				slice->pet_exist	= FALSE;
				free (pet_slice_image);
				free (mask_slice_image);
				slice_index += abs (spacing);
				for (j = 1; j <= abs (spacing); j++)
d593 5
a597 1
					llnext (slice3d_list);
d599 2
a600 4
				continue;
			}
			else
				slice->pet_exist	= TRUE;
d602 5
a606 5
			i /= ENCODED_SLICE_WIDTH;
			if (i >= ENCODED_SLICE_HEIGHT)
			{
				i = ENCODED_SLICE_HEIGHT - 1;
			}
d608 1
a608 1
			ptUpperLeft.y = i;
d610 2
a611 15
			for (i = ENCODED_SLICE_DIM - 1;  i >= 0 && 
				pet_slice_image[i] == PET_BACK_VALUE; i--)
			;
			i /= ENCODED_SLICE_WIDTH;
			if (i < 0)
				i = 0;
			ptBottomRight.y = i;

			tempx = ENCODED_SLICE_WIDTH - 1;
			tempy = 0;
			for (j = ptUpperLeft.y; j <= ptBottomRight.y; j++)
			{
				rows = j * ENCODED_SLICE_WIDTH;
				for (i = 0; i < ENCODED_SLICE_WIDTH && 
				pet_slice_image[rows + i] == PET_BACK_VALUE; i++)
d613 4
a616 2
				if (i < tempx)
					tempx = i;
d618 10
a627 8
				for (i = ENCODED_SLICE_WIDTH - 1; i >= 0 &&
				pet_slice_image[rows + i] == PET_BACK_VALUE; i--)
					;
				if (i > tempy)
				tempy = i;
			}
			ptUpperLeft.x	= tempx;
			ptBottomRight.x	= tempy;
d629 8
a636 4
			slice->pet_xstart	= ptUpperLeft.x;
			slice->pet_ystart	= ptUpperLeft.y; 
			slice->pet_width	= (ptBottomRight.x - ptUpperLeft.x + 1); 
			slice->pet_height	= (ptBottomRight.y - ptUpperLeft.y + 1); 
d638 4
a641 3
			slice->pet_input	= (short *) pkg_malloc (slice->pet_width 
						* slice->pet_height * sizeof (short), 
						function, "slice->pet_input");
d643 6
a648 5
			tempx	= 0;
			for (j = ptUpperLeft.y; j <= ptBottomRight.y; j++)
			{
				rows	= j * ENCODED_SLICE_WIDTH;
				for (i = ptUpperLeft.x; i <= ptBottomRight.x; i++)
d650 9
a658 6
					if (mask_slice_image [rows + i] > 0)
						temp_pet_value	
							= pet_slice_image [rows + i];
					else
						temp_pet_value	= PET_BACK_VALUE;
					slice->pet_input[tempx++] = temp_pet_value;
d660 5
a664 4
					if (temp_pet_value > global_max)
						global_max	= temp_pet_value;
					if (temp_pet_value < global_min)
						global_min	= temp_pet_value;
d666 2
d669 1
a669 2
			minmax_changed		= TRUE;
			free (mask_slice_image);
a671 4
			for (i = 1; i <= abs (spacing); i++)
			{
				llnext (slice3d_list);
			}
@


1.6.1.4
log
@After mask.
@
text
@d531 1
a531 1
	for (slice_index = 1; slice_index <= num_slices; slice_index++)
d535 1
a535 1
		horizontal_slice->slice_index	= slice_index;
d541 1
a541 1
		getimage (horizontal_slice->slice_data, header, imgfd, pet_filename, slice_index, 
a544 19
		mask_slice_image	= (short *) calloc (ENCODED_SLICE_DIM, sizeof (short));
		mskfd	= open ("/usr/local/lib/VIEW25D/TMPLT99.DAT", O_RDONLY, 0);
		if (mskfd == -1)
			fprintf (stderr, "Can't open mask image TMPLT99.DAT\n");

		getimage (mask_slice_image, header, mskfd, 
			"/usr/local/lib/VIEW25D/TMPLT99.DAT", slice_index, 0, 
			49, PETT6_SCANNER, &err_value);
		close (mskfd);
		for (j = 0; j < ENCODED_SLICE_HEIGHT; j++)
		{
			rows	= j * ENCODED_SLICE_WIDTH;
			for (i = 0; i <= ENCODED_SLICE_HEIGHT; i++)
			{
				if (mask_slice_image [rows + i] <= 0)
					horizontal_slice->slice_data [rows + i] = 0;
			}
		}

a545 1
		free (mask_slice_image);
d578 12
d597 1
d659 5
a663 1
					temp_pet_value	= pet_slice_image [rows + i];
d673 1
@


1.6.1.5
log
@Before coronal and sagittal works.
@
text
@a505 2
	char		atlas_orient	= cAtlasOrientation;
	long		slice_dim;		/* dimension of the slice image */
d573 4
a577 5
		if (atlas_orient == TRANSVERSE)
			slice_dim	= ENCODED_SLICE_DIM;
		else
			slice_dim	= ENCODED_SLICE_WIDTH * num_slices;

d583 3
a585 3
			llhead (slice3d_list);			
			pet_slice_image = (short *) calloc (slice_dim, sizeof (short));
			if (atlas_orient == TRANSVERSE)
d587 2
a588 1
				for (i = 1; i < slice_index; i++)
d590 2
a591 1
					llnext (slice3d_list);
a592 10
				horizontal_slice	= (HorizontalSlice *) llretrieve (slice3d_list);
				for (j = 0; j < ENCODED_SLICE_HEIGHT; j++)
				{
					rows	= j * ENCODED_SLICE_WIDTH;
					for (i = 0; i < ENCODED_SLICE_WIDTH; i++)
					{
						pet_slice_image [rows + i] 
							= horizontal_slice->slice_data [rows + i];
					}
				}
a593 32
			else if (atlas_orient == CORONAL)
			{
				for (j = 0; j < num_slices; j++)
				{
					horizontal_slice	
						= (HorizontalSlice *) llretrieve (slice3d_list);
					rows	= j * ENCODED_SLICE_WIDTH;
					for (i = 0; i < ENCODED_SLICE_WIDTH; i++)
					{
						pet_slice_image [rows + i] 
							= horizontal_slice->slice_data [(slice_index - 1) 
							* ENCODED_SLICE_WIDTH + i];
					}
					llnext (slice3d_list);
				}
			}
			else
			{
				for (j = 0; j < num_slices; j++)
				{
					horizontal_slice	
						= (HorizontalSlice *) llretrieve (slice3d_list);
					rows	= j * ENCODED_SLICE_HEIGHT;
					for (i = 0; i < ENCODED_SLICE_HEIGHT; i++)
					{
						pet_slice_image [rows + i] 
							= horizontal_slice->slice_data [i 
							* ENCODED_SLICE_WIDTH + slice_index - 1];
					}
					llnext (slice3d_list);
				}
			}
d598 1
a598 1
			for (i = 0; i < slice_dim && 
d601 1
a601 1
			if (i >= slice_dim)
d606 4
d678 4
@


1.6.1.6
log
@Coronal and Sagittal Works!
@
text
@a506 2
	int		slice_width;
	int		slice_height;
d577 1
a577 9
		{
			slice_width	= ENCODED_SLICE_WIDTH;
			slice_height	= ENCODED_SLICE_HEIGHT;
		}
		else if (atlas_orient == CORONAL)
		{
			slice_width	= ENCODED_SLICE_WIDTH;
			slice_height	= num_slices;
		}
d579 1
a579 5
		{
			slice_width	= ENCODED_SLICE_HEIGHT;
			slice_height	= num_slices;
		}
		slice_dim	= slice_width * slice_height; 
d586 1
a587 1
			llhead (slice3d_list);			
d595 1
a595 1
				for (j = 0; j < slice_height; j++)
d597 2
a598 2
					rows	= j * slice_width;
					for (i = 0; i < slice_width; i++)
d607 1
a607 1
				for (j = 0; j < slice_height; j++)
d611 2
a612 2
					rows	= j * slice_width;
					for (i = 0; i < slice_width; i++)
d623 1
a623 1
				for (j = 0; j < slice_height; j++)
d627 2
a628 2
					rows	= j * slice_width;
					for (i = 0; i < slice_width; i++)
d654 2
a655 2
			i /= slice_width;
			if (i >= slice_height)
d657 1
a657 1
				i = slice_height - 1;
d662 1
a662 1
			for (i = slice_dim - 1;  i >= 0 && 
d665 1
a665 1
			i /= slice_width;
d670 1
a670 1
			tempx = slice_width - 1;
d674 3
a676 3
				rows = j * slice_width;
				for (i = 0; i < slice_width && 
				pet_slice_image [rows + i] == PET_BACK_VALUE; i++)
d681 2
a682 2
				for (i = slice_width - 1; i >= 0 &&
				pet_slice_image [rows + i] == PET_BACK_VALUE; i--)
d702 1
a702 1
				rows	= j * slice_width;
@


1.6.1.7
log
@Before offset errors are corrected.
@
text
@d511 1
a511 3
	/* 
	 * Allocate header 
	 */
a603 8
				if (slice_index > num_slices)
				{
					slice->pet_exist	= FALSE;
					free (pet_slice_image);
					slice_index	+= abs (spacing);
					continue;
				}

d662 1
a662 1
				slice_index	+= abs (spacing);
d668 1
a668 1
			i	/= slice_width;
d671 1
a671 1
				i	= slice_height - 1;
d674 1
a674 1
			ptUpperLeft.y	= i;
d679 1
a679 1
			i	/= slice_width;
d681 2
a682 2
				i	= 0;
			ptBottomRight.y	= i;
d684 2
a685 2
			tempx	= slice_width - 1;
			tempy	= 0;
@


1.6.1.8
log
@Flip of facing-right sagittal pet image.
@
text
@d645 1
a645 1
			else if (atlas_orient == FACING_LEFT)
a654 16
							= horizontal_slice->slice_data [i 
							* ENCODED_SLICE_WIDTH + slice_index - 1];
					}
					llnext (slice3d_list);
				}
			}
			else
			{
				for (j = 0; j < slice_height; j++)
				{
					horizontal_slice	
						= (HorizontalSlice *) llretrieve (slice3d_list);
					rows	= j * slice_width;
					for (i = 0; i < slice_width; i++)
					{
						pet_slice_image [rows + (slice_width - 1 - i)] 
@


1.6.1.9
log
@Before testing center.
@
text
@a73 2
PRIVATE void		GetPetDimension ();
PRIVATE void		GetPetCenter ();
d509 1
a509 1
	long		slice_dim;			/* dimension of the slice image */
d580 15
a594 1
		GetPetDimension (atlas_orient, num_slices, &slice_width, &slice_height);
d955 1
a955 2
PRIVATE SliceData *ResizeSlice (current_header, slice, minimum, 
				maximum, pet_cx, pet_cy)
a959 2
float		pet_cx;
float		pet_cy;
d975 1
a975 3
	/* 
	 * Allocate memory for portal slice. 
	 */
d986 1
a986 3
	/* 
	 * Memory allocation and compute resized region. 
	 */
d996 1
a996 3
    			/* 
			 * Transformation into Atlas Space Coordinates. 
			 */ 
d1010 1
a1010 3
	/* 
	 * Memory allocation for pet image. 
	 */
d1026 1
a1026 3
		/* 
		 * Compute pet image offset. 
		 */
d1028 2
a1029 2
		    		pet_cx, 
				pet_cy,
d1034 1
a1034 4
				&xoffset, 
				&yoffset);
		portalSlice->pet_xstart	= xoffset;
		portalSlice->pet_ystart	= yoffset;
d1036 1
a1036 3
		/* 
		 * Resize and convert pet image. 
		 */
d1073 1
a1073 3
		/* 
		 * Compute PET pixels and coordinates. 
		 */
d1462 1
a1466 1
			hori_colorbar	= bHorizontalColorBar;
d1559 1
a1559 3
	/* 
	 * Put the PET image on the screen. 
	 */
d1612 1
a1612 3
	/* 
	 * Draw region. 
	 */
d1647 1
a1647 3
	/* 
	 * Draw AF3D points. 
	 */
d1650 1
a1650 3
	    	/* 
		 * for all the points on the slice 
		 */
d1674 1
a1674 3
	/* 
	 * Compute the z-coord label dimension and put the label on image. 
	 */
d1686 1
a1686 1
/*___________________________________________________________________________	
d1696 1
a1696 1
____________________________________________________________________________*/
d1721 1
a1721 3
		/* 
		 * Move to head of portal list. 
		 */
d1726 1
a1726 3
			/* 
			 * Get a portal. 
			 */
a1727 2
			x		= portal->x;
			y		= portal->y;
d1731 2
a1732 2
			XClearArea (display, window, x, y, 
					nOldAtlasWidth, nOldAtlasHeight, FALSE);
d1736 4
a1739 6
				XClearArea (display, window, 
					x + slice->pet_xstart,
					y + slice->pet_ystart,
					slice->pet_width,
					slice->pet_height,
					FALSE);
d1742 4
d1750 6
a1755 8
		/* 
		 * Clear color bar. 
		 */
		x		= nxOldColorBar;
		y		= nyOldColorBar;
		length		= nOldColorBarLength;
		width		= nOldColorBarWidth;
		hori_colorbar	= bOldHoriColorBar;
d1785 1
a1785 2
PRIVATE void ResizePortals (current_header, plist, atlas, 
			minimum, maximum, pet_cx, pet_cy) 
a1790 2
float		pet_cx;
float		pet_cy;
d1792 3
a1794 3
	Portal		*portal;	/* current portal */
	SliceData	*slice;		/* current slice */
	int		size;		/* size of portal list */
d1829 1
a1829 2
			portal->slice	= ResizeSlice (current_header, slice, 
						minimum, maximum, pet_cx, pet_cy);
d1894 1
a1894 1
/*____________________________________________________________________________	
d1900 2
a1901 2
	Description:	Clear portal data from memory. Remove all points from 
			screen and data structures.
d1904 1
a1904 1
____________________________________________________________________________*/
d1916 1
a1916 3
	/* 
	 * Clear plist data. 
	 */
d1938 1
a1938 3
	/* 
	 * Clear memory corresponding to points and data_sets in slice. 
	 */
d1942 1
a1942 3
		/* 
		 * Get a slice. 
		 */
d1945 1
a1945 3
		/* 
		 * Remove all point refs from slice. 
		 */
d1955 1
a1955 3
		/* 
		 * Remove all dataset refs from slice. 
		 */
d1974 1
a1974 3
	/* 
	 * Clear data_sets. 
	 */
d1978 1
a1978 3
		/* 
		 * Get a data set. 
		 */
d1981 1
a1981 3
		/* 
		 * Remove all points in data set. 
		 */
d1993 1
a1993 3
		/* 
		 * Free memory for header strings. 
		 */
d2172 1
a2172 1
/*_____________________________________________________________________________	
d2180 1
a2180 1
_____________________________________________________________________________*/
d2191 4
a2194 4
	short		first_slice	= nFirstSlice;
	short		last_slice	= nLastSlice;
	short		spacing		= nSpacing;
	char		input_node	= INPUT_NEW;
d2198 1
a2200 1
	SCALE_HEADER	*current_header;
a2203 5
	char		atlas_orient	= cAtlasOrientation;
	int		*old_atlas_w	= &nOldAtlasWidth;  
	int		*old_atlas_h	= &nOldAtlasHeight;  
	float		pet_cx;
	float		pet_cy;
d2211 4
a2228 6
		if (llsize (portal_list) > 0 && 
			(llsize (portal_list) == llsize (atlas_list)))
		{
			*old_atlas_w	= rCurrentScaleHeader->width;
			*old_atlas_h	= rCurrentScaleHeader->height;
		}
a2232 5
		if (llsize (portal_list) != llsize (atlas_list))
		{
			*old_atlas_w	= rCurrentScaleHeader->width;
			*old_atlas_h	= rCurrentScaleHeader->height;
		}
a2233 1
	current_header	= rCurrentScaleHeader;
d2235 2
a2255 1
	GetPetCenter (atlas_orient, &pet_cx, &pet_cy); 
d2257 1
a2257 2
		BuildPortals (current_header, atlas_list, portal_list, 
				&minimum, &maximum, pet_cx, pet_cy);
d2259 1
a2259 2
		ResizePortals (current_header, portal_list, atlas_list, 
				&minimum, &maximum, pet_cx, pet_cy);
d2283 1
a2283 2
PRIVATE void BuildPortals (current_header, atlas_list, portal_list, 
			minimum, maximum, pet_cx, pet_cy) 
a2288 2
float		pet_cx;
float		pet_cy;
d2301 1
a2301 2
			portal_slice	= ResizeSlice (current_header, slice, 
						minimum, maximum, pet_cx, pet_cy);
a3386 5
	short			*xcolor_bar		= &nxColorBarStart;
	short			*ycolor_bar		= &nyColorBarStart;
	short			*color_bar_length	= &nColorBarLength;
	short			*color_bar_width	= &nColorBarWidth;
	BOOLEAN			*color_bar_orient	= &bHorizontalColorBar;
d3728 1
a3728 1
				*xcolor_bar	= atoi (value);
d3736 1
a3736 1
				*ycolor_bar	= atoi (value);
d3744 1
a3744 1
				*color_bar_width	= atoi (value);
d3752 1
a3752 1
				*color_bar_length	= atoi (value);
d3766 1
a3766 1
				*color_bar_orient	= bool_buffer;
a3770 6
			nxOldColorBar		= *xcolor_bar; 
			nyOldColorBar		= *ycolor_bar; 
			nOldColorBarLength	= *color_bar_length; 
			nOldColorBarWidth	= *color_bar_width; 
			bOldHoriColorBar	= *color_bar_orient;

a4327 72
}


/*____________________________________________________________________________	
	Procedure:	GetPetDimension.	
			atlas_orientation:	atlas orientation, transverse,
						coronal, or sagittal.
			num_slices:		total number of slices.
			slice_width:		pointer to slice width.
			slice_height:		pointer to slice height.
	Description:	Get the image dimension of a pet image.
	Return:		none. 
	Author:		Tom (Tongzeng) Yang
			(05/28/1992)
_____________________________________________________________________________*/

PRIVATE void GetPetDimension (atlas_orient, num_slices, slice_width, slice_height)
	char	atlas_orient;
	short	num_slices;
	int	*slice_width;
	int	*slice_height;
{
	if (atlas_orient == TRANSVERSE)
	{
		*slice_width	= ENCODED_SLICE_WIDTH;
		*slice_height	= ENCODED_SLICE_HEIGHT;
	}
	else if (atlas_orient == CORONAL)
	{
		*slice_width	= ENCODED_SLICE_WIDTH;
		*slice_height	= num_slices;
	}
	else
	{
		*slice_width	= ENCODED_SLICE_HEIGHT;
		*slice_height	= num_slices;
	}
}


/*____________________________________________________________________________	
	Procedure:	GetPetCenter.	
			atlas_orientation:	atlas orientation, transverse,
						coronal, or sagittal.
			slice_cx:		pointer to slice center x.
			slice_cy:		pointer to slice center y.
	Description:	Get the image center of a pet image.
	Return:		none. 
	Author:		Tom (Tongzeng) Yang
			(05/28/1992)
_____________________________________________________________________________*/

PRIVATE void GetPetCenter (atlas_orient, slice_cx, slice_cy)
	char	atlas_orient;
	float	*slice_cx;
	float	*slice_cy;
{
	if (atlas_orient == TRANSVERSE)
	{
		*slice_cx	= CX_IMAGE;
		*slice_cy	= CY_IMAGE;
	}
	else if (atlas_orient == CORONAL)
	{
		*slice_cx	= CX_IMAGE;
		*slice_cy	= CZ_IMAGE;
	}
	else
	{
		*slice_cx	= CY_IMAGE;
		*slice_cy	= CZ_IMAGE;
	}
@


1.6.1.10
log
@Same as 1.6.1.9
@
text
@@


1.5
log
@Display Coronal and Sagittal Atlas.
@
text
@d1217 2
a1218 4
				if (atlas_orient == TRANSVERSE)
					sprintf (stringbuf, "%d", ZtoSlice (slice->slice_xyz)); 
				else
					sprintf (stringbuf, "%d", XYtoSlice (slice->slice_xyz)); 
d1305 1
a1305 1
			DrawPortal (display, window, gc, current_header, &draw_portal_data);
d1360 1
a1360 1
PRIVATE void	DrawPortal (display, window, gc, current_header, draw_portal_data)
d1366 1
d1449 3
a1451 2
		for (i = 0; i < current_header->height; i++)
			for (j = 0; j < current_header->width; j++)
d1453 1
a1453 2
				if (draw_portal_data->atlas_slice 
					[i * current_header->width + j] > 0)
d1455 5
a1459 1
					XDrawPoint (display, window, gc, j + x, i + y);
d1462 16
d3242 1
a3242 1
	char			*orient_flag		= &cAtlasOrientation;
d3363 1
a3363 1
				*orient_flag	= (char) n;
d3377 1
a3377 4
					if (*orient_flag == TRANSVERSE)
						*first_slice	= ZtoSlice (*first_slice);
					else
						*first_slice	= XYtoSlice (*first_slice);
d3389 1
a3389 4
					if (*orient_flag == TRANSVERSE)
						*last_slice	= ZtoSlice (*last_slice);
					else
						*last_slice	= XYtoSlice (*last_slice);
d4161 30
@


1.4
log
@Atlas change.
@
text
@d424 1
d441 1
a441 1
		slice->slice_xyz	= SliceZ (desired_slice);
d1125 1
d1216 6
a1221 1
				sprintf (stringbuf, "%d", ZtoSlice (slice->slice_xyz)); 
d1223 8
a1230 1
				sprintf (stringbuf, "Z = %d", slice->slice_xyz); 
d1870 1
d1885 1
a1885 1
			if (slice->slice_xyz != SliceZ (*last_slice))
d1893 1
a1893 1
				if (slice->slice_xyz != SliceZ (first_slice))
d3924 1
d3946 3
a3948 11
		spacing	*= 2; 
		if (cAtlasOrientation == TRANSVERSE)
		{
			first_slice	= SliceZ (first_slice);
			last_slice	= SliceZ (last_slice);
		}
		else
		{
			first_slice	= SliceXY (first_slice);
			last_slice	= SliceXY (last_slice);
		}
d4118 30
@


1.3
log
@Save and get the atlas orientation menu.
@
text
@d11 2
a12 2
		M. Todd Gamble and Tom Yang.
		12/13/90
d266 1
a266 1
	FILE		*atlasfp;	/* file pointer to atlas header */
d268 1
a268 1
	char		label[MAXLINE];	/* text label in header file */ 
d276 4
a279 2
	/* open the header file */
	atlasfp	= fopen(atlas_filename,"r");
d287 3
a289 1
	/* read header information */
d297 3
a299 1
	/* Read Header for Scale 0.25 */
d310 3
a312 1
	/* Read Header for Scale 0.50 */
d323 3
a325 1
	/* Read Header for Scale 1.00 */
d336 5
a340 2
	/* Read Index Table */
	for (i = 0; i < TRANSVERSE_ATLAS_NUM; i++)
d342 1
a342 2
		fscanf (atlasfp, "%d %d %d", &pet_slice_num, &index, &z_value);
		atlas_header->index_table[i]	= index;
d440 1
a440 1
		slice->slice_z		= SliceZ (desired_slice);
d847 1
a847 1
	portalSlice->slice_z		= slice->slice_z;
d1012 1
a1012 1
			if ((point->z > slice->slice_z - 1.0) && (point->z <= slice->slice_z + 1.0)) 
d1214 1
a1214 1
				sprintf (stringbuf, "%d", ZtoSlice (slice->slice_z)); 
d1216 1
a1216 1
				sprintf (stringbuf, "Z = %d", slice->slice_z); 
d1870 1
a1870 1
			if (slice->slice_z != SliceZ (*last_slice))
d1878 1
a1878 1
				if (slice->slice_z != SliceZ (first_slice))
d1917 1
a1917 1
	if (s1->slice_z < s2->slice_z)
d1919 1
a1919 1
	if (s1->slice_z > s2->slice_z)
d2031 1
d2044 2
a2045 1
	if (*mag_changed)
d2047 3
@


1.2
log
@Deleted header_only Flag from getimage ().
@
text
@d2945 3
d3066 10
d3191 1
d3193 2
d3301 20
d3323 8
a3330 2
				nFirstSlice	= *slice_number_flag? atoi (value):
							ZtoSlice (atoi (value));
d3338 8
a3345 2
				nLastSlice	= *slice_number_flag? atoi (value):
							ZtoSlice (atoi (value));
d3888 3
a3890 3
	short			*first_slice		= &nFirstSlice;
	short			*last_slice		= &nLastSlice;
	short			*spacing		= &nSpacing;
d3907 21
a3927 6
	fprintf (file, "FirstSlice:		%d\n", 
		*slice_number_flag? *first_slice: SliceZ (*first_slice));
	fprintf (file, "LastSlice:		%d\n", 
		*slice_number_flag? *last_slice: SliceZ (*last_slice));
	fprintf (file, "Spacing:		%d\n", 
		*slice_number_flag? *spacing: *spacing * 2);
@


1.1
log
@Initial revision
@
text
@d518 1
a518 1
				encoded, num_slices, pett_num, FALSE, &err_value);
d539 1
a539 1
				49, PETT6_SCANNER, FALSE, &err_value);
@
