head	2.27;
access;
symbols;
locks; strict;
comment	@# @;


2.27
date	95.10.26.19.03.20;	author ty7777;	state Exp;
branches;
next	2.26;

2.26
date	95.09.07.16.56.00;	author ty7777;	state Exp;
branches;
next	2.25;

2.25
date	95.09.06.18.27.56;	author ty7777;	state Exp;
branches;
next	2.24;

2.24
date	95.08.31.20.19.33;	author ty7777;	state Exp;
branches;
next	2.23;

2.23
date	95.08.28.21.09.54;	author ty7777;	state Exp;
branches;
next	2.22;

2.22
date	95.08.28.15.40.45;	author ty7777;	state Exp;
branches;
next	2.21;

2.21
date	95.08.02.16.50.06;	author ty7777;	state Exp;
branches;
next	2.20;

2.20
date	95.07.31.19.07.26;	author ty7777;	state Exp;
branches;
next	2.19;

2.19
date	95.07.27.17.04.53;	author ty7777;	state Exp;
branches;
next	2.18;

2.18
date	95.07.26.20.42.09;	author ty7777;	state Exp;
branches;
next	2.17;

2.17
date	95.07.21.16.58.20;	author ty7777;	state Exp;
branches;
next	2.16;

2.16
date	95.07.07.17.14.11;	author ty7777;	state Exp;
branches;
next	2.15;

2.15
date	95.06.30.15.23.02;	author ty7777;	state Exp;
branches;
next	2.14;

2.14
date	95.06.14.20.12.53;	author ty7777;	state Exp;
branches;
next	2.13;

2.13
date	95.06.13.20.13.10;	author ty7777;	state Exp;
branches;
next	2.12;

2.12
date	95.06.12.19.32.33;	author ty7777;	state Exp;
branches;
next	2.11;

2.11
date	95.06.07.14.36.51;	author ty7777;	state Exp;
branches;
next	2.10;

2.10
date	95.06.05.19.52.46;	author ty7777;	state Exp;
branches;
next	2.9;

2.9
date	95.01.17.20.08.42;	author ty7777;	state Exp;
branches;
next	2.8;

2.8
date	95.01.12.19.51.37;	author ty7777;	state Exp;
branches;
next	2.7;

2.7
date	94.12.01.20.11.20;	author ty7777;	state Exp;
branches;
next	2.6;

2.6
date	94.12.01.17.13.16;	author ty7777;	state Exp;
branches;
next	2.5;

2.5
date	94.11.04.16.21.31;	author ty7777;	state Exp;
branches;
next	2.4;

2.4
date	94.11.03.20.14.26;	author ty7777;	state Exp;
branches;
next	2.3;

2.3
date	94.10.28.16.18.25;	author ty7777;	state Exp;
branches;
next	2.2;

2.2
date	94.10.19.19.26.41;	author ty7777;	state Exp;
branches;
next	2.1;

2.1
date	94.10.19.17.05.19;	author ty7777;	state Exp;
branches;
next	1.66;

1.66
date	94.10.18.20.07.38;	author ty7777;	state Exp;
branches;
next	1.65;

1.65
date	94.10.18.19.42.10;	author ty7777;	state Exp;
branches;
next	1.64;

1.64
date	94.10.17.20.12.05;	author ty7777;	state Exp;
branches;
next	1.63;

1.63
date	94.08.30.14.38.52;	author ty7777;	state Exp;
branches;
next	1.62;

1.62
date	94.08.17.21.20.16;	author ty7777;	state Exp;
branches;
next	1.61;

1.61
date	94.08.17.19.47.17;	author ty7777;	state Exp;
branches;
next	1.60;

1.60
date	94.08.17.19.08.14;	author ty7777;	state Exp;
branches;
next	1.59;

1.59
date	94.08.16.16.30.47;	author ty7777;	state Exp;
branches;
next	1.58;

1.58
date	94.08.12.16.59.52;	author ty7777;	state Exp;
branches;
next	1.57;

1.57
date	94.05.19.14.12.38;	author ty7777;	state Exp;
branches;
next	1.56;

1.56
date	94.04.18.17.56.06;	author ty7777;	state Exp;
branches;
next	1.55;

1.55
date	94.01.24.20.10.05;	author ty7777;	state Exp;
branches;
next	1.54;

1.54
date	94.01.13.18.12.07;	author ty7777;	state Exp;
branches;
next	1.53;

1.53
date	94.01.11.22.29.44;	author ty7777;	state Exp;
branches;
next	1.52;

1.52
date	94.01.10.23.30.59;	author ty7777;	state Exp;
branches;
next	1.51;

1.51
date	93.12.16.17.09.26;	author ty7777;	state Exp;
branches;
next	1.50;

1.50
date	93.12.16.15.53.06;	author ty7777;	state Exp;
branches;
next	1.49;

1.49
date	93.12.14.20.01.38;	author ty7777;	state Exp;
branches;
next	1.48;

1.48
date	93.12.13.15.20.37;	author ty7777;	state Exp;
branches;
next	1.47;

1.47
date	93.12.08.21.01.57;	author ty7777;	state Exp;
branches;
next	1.46;

1.46
date	93.11.02.16.53.31;	author ty7777;	state Exp;
branches;
next	1.45;

1.45
date	93.10.22.20.05.40;	author ty7777;	state Exp;
branches;
next	1.44;

1.44
date	93.09.27.19.02.36;	author ty7777;	state Exp;
branches;
next	1.43;

1.43
date	93.09.24.18.09.42;	author ty7777;	state Exp;
branches;
next	1.42;

1.42
date	93.09.23.20.43.26;	author ty7777;	state Exp;
branches;
next	1.41;

1.41
date	93.07.13.15.08.16;	author ty7777;	state Exp;
branches;
next	1.40;

1.40
date	93.07.06.16.52.01;	author ty7777;	state Exp;
branches;
next	1.39;

1.39
date	93.06.02.17.18.07;	author ty7777;	state Exp;
branches;
next	1.38;

1.38
date	93.05.07.21.58.19;	author ty7777;	state Exp;
branches;
next	1.37;

1.37
date	93.05.07.20.29.29;	author ty7777;	state Exp;
branches;
next	1.36;

1.36
date	93.04.05.17.34.49;	author ty7777;	state Exp;
branches;
next	1.35;

1.35
date	93.02.18.16.19.51;	author ty7777;	state Exp;
branches;
next	1.34;

1.34
date	93.01.28.15.45.51;	author ty7777;	state Exp;
branches;
next	1.33;

1.33
date	93.01.11.15.52.20;	author ty7777;	state Exp;
branches;
next	1.32;

1.32
date	92.12.03.20.26.39;	author ty7777;	state Exp;
branches;
next	1.31;

1.31
date	92.09.28.16.50.10;	author ty7777;	state Exp;
branches;
next	1.30;

1.30
date	92.09.23.19.33.05;	author ty7777;	state Exp;
branches;
next	1.29;

1.29
date	92.08.26.21.31.18;	author ty7777;	state Exp;
branches;
next	1.28;

1.28
date	92.08.26.21.29.38;	author ty7777;	state Exp;
branches;
next	1.27;

1.27
date	92.08.03.18.55.05;	author ty7777;	state Exp;
branches;
next	1.26;

1.26
date	92.08.03.15.03.52;	author ty7777;	state Exp;
branches;
next	1.25;

1.25
date	92.07.31.20.53.02;	author ty7777;	state Exp;
branches;
next	1.24;

1.24
date	92.07.22.19.40.07;	author ty7777;	state Exp;
branches;
next	1.23;

1.23
date	92.07.20.19.32.31;	author ty7777;	state Exp;
branches;
next	1.22;

1.22
date	92.07.20.15.35.05;	author ty7777;	state Exp;
branches;
next	1.21;

1.21
date	92.07.17.18.05.54;	author ty7777;	state Exp;
branches;
next	1.20;

1.20
date	92.07.16.18.58.06;	author ty7777;	state Exp;
branches;
next	1.19;

1.19
date	92.07.16.14.33.43;	author ty7777;	state Exp;
branches;
next	1.18;

1.18
date	92.07.14.20.59.20;	author ty7777;	state Exp;
branches;
next	1.17;

1.17
date	92.07.14.15.01.34;	author ty7777;	state Exp;
branches;
next	1.16;

1.16
date	92.07.09.22.17.24;	author ty7777;	state Exp;
branches;
next	1.15;

1.15
date	92.07.08.18.50.05;	author ty7777;	state Exp;
branches;
next	1.14;

1.14
date	92.07.06.22.24.47;	author ty7777;	state Exp;
branches;
next	1.13;

1.13
date	92.07.06.18.20.16;	author ty7777;	state Exp;
branches;
next	1.12;

1.12
date	92.07.02.19.19.59;	author ty7777;	state Exp;
branches;
next	1.11;

1.11
date	92.07.02.15.14.05;	author ty7777;	state Exp;
branches;
next	1.10;

1.10
date	92.06.30.21.51.34;	author ty7777;	state Exp;
branches;
next	1.9;

1.9
date	92.06.01.13.51.25;	author ty7777;	state Exp;
branches;
next	1.8;

1.8
date	92.05.26.14.50.11;	author ty7777;	state Exp;
branches;
next	1.7;

1.7
date	92.05.21.19.50.28;	author ty7777;	state Exp;
branches;
next	1.6;

1.6
date	92.05.21.17.22.59;	author ty7777;	state Exp;
branches;
next	1.5;

1.5
date	92.05.20.19.51.07;	author ty7777;	state Exp;
branches;
next	1.4;

1.4
date	92.05.20.15.13.21;	author ty7777;	state Exp;
branches;
next	1.3;

1.3
date	92.05.05.21.01.16;	author ty7777;	state Exp;
branches;
next	1.2;

1.2
date	92.05.05.19.47.55;	author ty7777;	state Exp;
branches;
next	1.1;

1.1
date	92.04.28.18.04.38;	author ty7777;	state Exp;
branches;
next	;


desc
@View25d C Source Code First Version.
@


2.27
log
@Change slices only if zorigin_image1 is changed.
@
text
@/*$Log: view25d.callbacks,v $
# Revision 2.26  1995/09/07  16:56:00  ty7777
# Fix the z0 mistach problem.
#
# Revision 2.25  1995/09/06  18:27:56  ty7777
# Before fixing the bugs reported by Avi.
#
# Revision 2.24  1995/08/31  20:19:33  ty7777
# Before watch cursor works.
#
# Revision 2.23  1995/08/28  21:09:54  ty7777
# After color bar works.
#
# Revision 2.22  1995/08/28  15:40:45  ty7777
# Before adding mutual image1 and image2 point display.
#
# Revision 2.21  1995/08/02  16:50:06  ty7777
# Tracking works.
#
# Revision 2.20  1995/07/31  19:07:26  ty7777
# After show multiple point works.
#
# Revision 2.19  1995/07/27  17:04:53  ty7777
# Allowed any patterns to day for file selection.
#
# Revision 2.18  1995/07/26  20:42:09  ty7777
# Image overlay worked!
#
# Revision 2.17  1995/07/21  16:58:20  ty7777
# Before adding new things.
#
# Revision 2.16  1995/07/07  17:14:11  ty7777
# Two data sets works correctly.
#
# Revision 2.15  1995/06/30  15:23:02  ty7777
#  Before making further changes, tow independent color bars worked.
#
# Revision 2.14  1995/06/14  20:12:53  ty7777
# Added processing for analyze .hdr files.
#
# Revision 2.13  1995/06/13  20:13:10  ty7777
# Added procesing for reading .hdr files.
#
# Revision 2.12  1995/06/12  19:32:33  ty7777
# Added MRI processing.
#
# Revision 2.11  1995/06/07  14:36:51  ty7777
# relieve the ckecking for 75 slices.
#
# Revision 2.10  1995/06/05  19:52:46  ty7777
# Same as the last version.
#
# Revision 2.9  1995/01/17  20:08:42  ty7777
# Deleted things that are related to data_stes.
#
# Revision 2.8  1995/01/12  19:51:37  ty7777
# Deleted ClearData () inside comments.
#
# Revision 2.7  1994/12/01  20:11:20  ty7777
# Get rid of path in .atl files.
#
# Revision 2.6  1994/12/01  17:13:16  ty7777
# Pass library_path from the main program to callback functions.
#
# Revision 2.5  1994/11/04  16:21:31  ty7777
# Use slice 31 as the default z0.
#
# Revision 2.4  1994/11/03  20:14:26  ty7777
# Added processing for local_path.
#
# Revision 2.3  1994/10/28  16:18:25  ty7777
# Added checking for the z0 slice.
#
# Revision 2.2  1994/10/19  19:26:41  ty7777
# Fixed the pwd problem for show files.
#
# Revision 2.1  1994/10/19  17:05:19  ty7777
# Same as the last version.
#
# Revision 1.66  1994/10/18  20:07:38  ty7777
# *pattern* works.
#
# Revision 1.65  1994/10/18  19:42:10  ty7777
# After *pattern works.
#
# Revision 1.64  1994/10/17  20:12:05  ty7777
# After *.pattern works.
#
# Revision 1.63  1994/08/30  14:38:52  ty7777
# Modified read_file ().
#
# Revision 1.62  1994/08/17  21:20:16  ty7777
# Use the zvalues as the reference for transverse PET iamges.
#
# Revision 1.61  1994/08/17  19:47:17  ty7777
# Display the bottom slices.
#
# Revision 1.60  1994/08/17  19:08:14  ty7777
# Added dynamic change for X, Y, and Z values.
#
# Revision 1.59  1994/08/16  16:30:47  ty7777
# Added the callback function ShowDataTypeCallback ().
#
# Revision 1.58  1994/08/12  16:59:52  ty7777
# Added error checking for slice numbers.
#
# Revision 1.57  1994/05/19  14:12:38  ty7777
# Change from (z, x, y) to (x, y, z).
#
# Revision 1.56  1994/04/18  17:56:06  ty7777
# Added processing for view25d.
#
# Revision 1.55  1994/01/24  20:10:05  ty7777
# Same as the last one.
#
# Revision 1.54  1994/01/13  18:12:07  ty7777
# Added text view for creating af3d files.
#
# Revision 1.53  1994/01/11  22:29:44  ty7777
# Added processing for Legend Dim.
#
# Revision 1.52  1994/01/10  23:30:59  ty7777
# Change names for HD6 Brain and T88 Brain.
#
# Revision 1.51  1993/12/16  17:09:26  ty7777
# Fixed problem for the DrawLabel bounding rectangle.
#
# Revision 1.50  1993/12/16  15:53:06  ty7777
# Added processing for TextEdit.
#
# Revision 1.49  1993/12/14  20:01:38  ty7777
# Added proicessing for dMaximumDistance.
#
# Revision 1.48  1993/12/13  15:20:37  ty7777
# After adding view25d.
#
# Revision 1.47  1993/12/08  21:01:57  ty7777
# Fixed default symbol type and color problem.
#
# Revision 1.46  1993/11/02  16:53:31  ty7777
# Same as the last version.
#
# Revision 1.45  1993/10/22  20:05:40  ty7777
# Change calling for RegularMinMax.
#
# Revision 1.44  1993/09/27  19:02:36  ty7777
# Added processing for gray color button.
#
# Revision 1.43  1993/09/24  18:09:42  ty7777
# Added search function.
#
# Revision 1.42  1993/09/23  20:43:26  ty7777
# View and Log Coordinates File.
#
# Revision 1.41  1993/07/13  15:08:16  ty7777
# Dynamicaly displaying point coordinates.
#
# Revision 1.40  1993/07/06  16:52:01  ty7777
# Before working on Dr.Raichle's problem.
#
# Revision 1.39  1993/06/02  17:18:07  ty7777
# After multiple regions display worked.
#
# Revision 1.38  1993/05/07  21:58:19  ty7777
# Add Processing for mask pet image.
#
# Revision 1.37  1993/05/07  20:29:29  ty7777
# Before mask processing.
#
# Revision 1.36  1993/04/05  17:34:49  ty7777
# After add AF3D points works.
#
# Revision 1.35  1993/02/18  16:19:51  ty7777
# Before changing defaults.
#
# Revision 1.34  1993/01/28  15:45:51  ty7777
# Before changing libcti.a.
#
# Revision 1.33  1993/01/11  15:52:20  ty7777
# Add atlas trim processing.
#
# Revision 1.32  1992/12/03  20:26:39  ty7777
# Before testing the libcti.a library function.
#
# Revision 1.31  1992/09/28  16:50:10  ty7777
# After adding "xlabel" button.
#
# Revision 1.30  1992/09/23  19:33:05  ty7777
# AF3D files have the same path.
#
# Revision 1.29  1992/08/26  21:31:18  ty7777
# Fixing font bug (reported by Julie Fiez) anf testing RCS checking in mechanism.
#*/
/*$Header: /data/petsun4/src/view25d/RCS/view25d.callbacks,v 2.26 1995/09/07 16:56:00 ty7777 Exp ty7777 $*/


void QuitCallback (w, clientData, callData)
Widget w;
caddr_t clientData;
caddr_t callData;
{
	exit (0);
}


void CancelCallback (w, clientData, callData)
Widget w;
caddr_t clientData;
caddr_t callData;
{
	Widget dialog = (Widget) clientData;
	XtUnmanageChild (dialog);
}


void ShowMenuCallback (w, clientData, callData)
Widget w;
caddr_t clientData;
caddr_t callData;
{
	Widget dialog = (Widget) clientData;
	XtManageChild (dialog);
}


/*________________________________________________________________________________________	
	Procedure:
		ClearWindowCallback
	Parameters:
		w: Widget, widget where callback was triggered.
		clientData: caddr_t, client data.
		call_data: caddr_t, callback data.
	Description:
		Callback function for clearing data and window.
		Author: Tom Yang 
		(06/01/91)
________________________________________________________________________________________*/
void ClearWindowCallback (w, clientData, callData)
Widget w;
caddr_t clientData;
caddr_t callData;
{
	DRAW_DATA	*drawData	= (DRAW_DATA *) clientData;

	XClearArea (drawData->display, drawData->window, 
		0, 0, DRAW_AREA_WIDTH, DRAW_AREA_HEIGHT, FALSE);
}


/*________________________________________________________________________________________	
	Procedure:
		MagScaleCallback
	Parameters:
		w: Widget, widget where callback was triggered.
		clientData: caddr_t, client data.
		call_data: caddr_t, callback data.
	Description:
		Callback function for the option menu.
		Author: Tom Yang 
		(06/07/91)
________________________________________________________________________________________*/

void MagScaleCallback (w, clientData, callData)
Widget w;
caddr_t clientData;
caddr_t callData;
{
	MAG_SCALE_DATA		*mag_scale_data		= (MAG_SCALE_DATA *) clientData;
	MAG_SCALE_MENU		*mag_scale_menu		= mag_scale_data->mag_scale_menu;

	BOOLEAN			*auto_image1_value_flag	= &bAutoImage1ValueFlag;
	BOOLEAN			*auto_image2_value_flag	= &bAutoImage2ValueFlag;
	Display			*display		= mag_scale_data->draw_data->display;
	Widget			widget_buffer;
	Window			window			= mag_scale_data->draw_data->window;
	char			*magnify_index		= &cMagnifyIndex; 
	char 			node_flag		= mag_scale_data->node_flag;
	char			*image1_value_flag	= &cImage1ValueFlag;
	char			*image2_value_flag	= &cImage2ValueFlag;
	char 			*str1;
	char 			*str2;
	char			szBuffer [MAXLINE];
	float			*slice_scale		= &dSliceMagnification;
	float			new_scale		= *slice_scale;
	int			i;
	short			*image1_max_pixel_value	= &nMaxImage1Value;
	short			*image2_max_pixel_value	= &nMaxImage2Value;
	short			*image1_min_pixel_value	= &nMinImage1Value;
	short			*image2_min_pixel_value	= &nMinImage2Value;

	XDefineCursor (display, window, mag_scale_data->draw_data->cursor);

	if (node_flag != CANCEL)
	{
		if (XmToggleButtonGetState (mag_scale_menu->mag_set [MAG_ANY_INDEX]))
		{
			str1		= XmTextGetString (*mag_scale_menu->text_mag_any);
			new_scale	= atof (str1);
			if (new_scale <= 0.1)
				new_scale = 0.1;
			XtFree (str1);
			*magnify_index	= MAG_ANY_INDEX;
		}
		else
		{
			*magnify_index	= GetActiveIndex (mag_scale_menu->mag_set, MAG_NUM - 1);
			new_scale	= magnify_table [*magnify_index];
		}

		if (pkg_abs (*slice_scale - new_scale) >= ERROR_BOUND)
		{
			*slice_scale	= new_scale;
			bMagChanged	= TRUE;
		}

		*image1_value_flag	= GetActiveIndex (mag_scale_menu->scale_set_image1, SCALE_NUM);
		*auto_image1_value_flag = XmToggleButtonGetState (*mag_scale_menu->auto_minmax_image1);
		str1 = XmTextGetString (*mag_scale_menu->min_text_image1);
		str2 = XmTextGetString (*mag_scale_menu->max_text_image1);
		if (strlen (str1) > 0 && strlen (str2) > 0)
		{
			*image1_min_pixel_value = atoi (str1);
			*image1_max_pixel_value = atoi (str2);

			ErrorCheckMinMax (*image1_value_flag, image1_min_pixel_value, image1_max_pixel_value);
		}
		XtFree (str1);
		XtFree (str2);

		*image2_value_flag	= GetActiveIndex (mag_scale_menu->scale_set_image2, SCALE_NUM);
		*auto_image2_value_flag = XmToggleButtonGetState (*mag_scale_menu->auto_minmax_image2);
		str1 = XmTextGetString (*mag_scale_menu->min_text_image2);
		str2 = XmTextGetString (*mag_scale_menu->max_text_image2);
		if (strlen (str1) > 0 && strlen (str2) > 0)
		{
			*image2_min_pixel_value = atoi (str1);
			*image2_max_pixel_value = atoi (str2);

			ErrorCheckMinMax (*image2_value_flag, image2_min_pixel_value, image2_max_pixel_value);
		}
		XtFree (str1);
		XtFree (str2);

		if (node_flag == REDRAW)
		{
			RedrawPortals (mag_scale_data->draw_data, alist1, plist1, alist2, plist2);
		}
	}
	else
	{
		SetSelectData (GetActiveWidget (mag_scale_menu->mag_set, MAG_NUM), False);
		SetSelectData (mag_scale_menu->mag_set [*magnify_index], True);

		sprintf (szBuffer, "%.2f", new_scale);
		XmTextSetString (*mag_scale_menu->text_mag_any, szBuffer); 

		SetSelectData (GetActiveWidget (mag_scale_menu->scale_set_image1, SCALE_NUM), False);
		SetSelectData (mag_scale_menu->scale_set_image1 [*image1_value_flag], True);
		SetSelectData (*mag_scale_menu->auto_minmax_image1, *auto_image1_value_flag);

		sprintf (szBuffer, "%d", *image1_min_pixel_value);
		XmTextSetString (*mag_scale_menu->min_text_image1, szBuffer); 
		sprintf (szBuffer, "%d", *image1_max_pixel_value);
		XmTextSetString (*mag_scale_menu->max_text_image1, szBuffer); 

		SetSelectData (GetActiveWidget (mag_scale_menu->scale_set_image2, SCALE_NUM), False);
		SetSelectData (mag_scale_menu->scale_set_image2 [*image2_value_flag], True);
		SetSelectData (*mag_scale_menu->auto_minmax_image2, *auto_image2_value_flag);

		sprintf (szBuffer, "%d", *image2_min_pixel_value);
		XmTextSetString (*mag_scale_menu->min_text_image2, szBuffer); 
		sprintf (szBuffer, "%d", *image2_max_pixel_value);
		XmTextSetString (*mag_scale_menu->max_text_image2, szBuffer); 
	}
		
	XUndefineCursor (display, window);
	XtUnmanageChild (*mag_scale_data->frame);
}


/*________________________________________________________________________________________	
	Procedure:
		FormatScreenCallback
	Parameters:
		w:		Widget, widget where callback was triggered.
		clientData:	caddr_t, client data.
		call_data:	caddr_t, callback data.
	Description:
		Callback function for formatting brain slices on screen.
		Author: Tom (Tongzeng) Yang 
		(07/02/91)
________________________________________________________________________________________*/

void FormatScreenCallback (w, clientData, callData)
Widget w;
caddr_t clientData;
caddr_t callData;
{
	FORMAT_SCREEN_DATA	*formatScreenData	= (FORMAT_SCREEN_DATA *) clientData;
	FORMAT_SCREEN_MENU	*format_screen_menu	= formatScreenData->format_screen_menu;
	Display			*display		= formatScreenData->draw_data->display;
	Window			window			= formatScreenData->draw_data->window;
	GC			gc			= formatScreenData->draw_data->gc;
	short			*xformat		= &nxFormatedScreen;
	short			*yformat		= &nyFormatedScreen;
	short			*format_width		= &nFormatedScreenWidth;
	short			*format_height		= &nFormatedScreenHeight;
	short			*xstart1		= &nxImage1Start;
	short			*ystart1		= &nyImage1Start;
	short			*xstart2		= &nxImage2Start;
	short			*ystart2		= &nyImage2Start;
	short			*xoffset		= &nxOffsetMillimeter;
	short			*yoffset		= &nyOffsetMillimeter;
	short			*xrow_row		= &nxRowRowMillimeter;
	short			*yrow_row		= &nyRowRowMillimeter;
	short			*xlabel_start		= &nxLabelStart;
	short			*ylabel_start		= &nyLabelStart;
	BOOLEAN			*low2high		= &bLow2High;
	char 			*str1;
	char 			*str2;
	char 			node_flag		= formatScreenData->node_flag;
	int			i;
	char			szBuffer [MAXLINE];

	XDefineCursor (display, window, formatScreenData->draw_data->cursor);

	if (node_flag != CANCEL)
	{
		str1	= XmTextGetString (*format_screen_menu->format_x);
		str2	= XmTextGetString (*format_screen_menu->format_y);

		if (strlen (str1) > 0 && strlen (str2) > 0)
		{
			*xformat	= atoi (str1);
	 		*yformat	= atoi (str2);
		}

		XtFree (str1);
		XtFree (str2);

		str1	= XmTextGetString (*format_screen_menu->format_width);
		str2	= XmTextGetString (*format_screen_menu->format_height);

		if (strlen (str1) > 0 && strlen (str2) > 0)
		{
			*format_width	= atoi (str1);
			*format_height	= atoi (str2);
		}

		XtFree (str1);
		XtFree (str2);

		str1	= XmTextGetString (*format_screen_menu->xstart_text_image1);
		str2	= XmTextGetString (*format_screen_menu->ystart_text_image1);

		if (strlen (str1) > 0 && strlen (str2) > 0)
		{
			*xstart1 = atoi (str1);
			*ystart1 = atoi (str2);
		}

		XtFree (str1);
		XtFree (str2);

		str1	= XmTextGetString (*format_screen_menu->xstart_text_image2);
		str2	= XmTextGetString (*format_screen_menu->ystart_text_image2);

		if (strlen (str1) > 0 && strlen (str2) > 0)
		{
			*xstart2 = atoi (str1);
			*ystart2 = atoi (str2);
		}

		XtFree (str1);
		XtFree (str2);

		str1	= XmTextGetString (*format_screen_menu->xoffset_text);
		str2	= XmTextGetString (*format_screen_menu->yoffset_text);

		if (strlen (str1) > 0 && strlen (str2) > 0)
		{
			*xoffset = atoi (str1);
			*yoffset = atoi (str2);
		}

		XtFree (str1);
		XtFree (str2);

		str1	= XmTextGetString (*format_screen_menu->rowxoffset_text);
		str2	= XmTextGetString (*format_screen_menu->rowyoffset_text);

		if (strlen (str1) > 0 && strlen (str2) > 0)
		{
			*xrow_row = atoi (str1);
			*yrow_row = atoi (str2);
		}

		XtFree (str1);
		XtFree (str2);

		str1	= XmTextGetString (*format_screen_menu->label_xstart);
		str2	= XmTextGetString (*format_screen_menu->label_ystart);

		if (strlen (str1) > 0 && strlen (str2) > 0)
		{
			*xlabel_start = atoi (str1);
			*ylabel_start = atoi (str2);
		}
		XtFree (str1);
		XtFree (str2);

		*low2high	= XmToggleButtonGetState (*format_screen_menu->display_order);

		if (node_flag == REDRAW)
		{
			RedrawPortals (formatScreenData->draw_data, alist1, plist1, alist2, plist2);
		}
	}
	else
	{
		sprintf (szBuffer, "%d", *xformat); 
		XmTextSetString (*format_screen_menu->format_x, szBuffer); 
		sprintf (szBuffer, "%d", *yformat); 
		XmTextSetString (*format_screen_menu->format_y, szBuffer); 

		sprintf (szBuffer, "%d", *format_width); 
		XmTextSetString (*format_screen_menu->format_width, szBuffer); 
		sprintf (szBuffer, "%d", *format_height); 
		XmTextSetString (*format_screen_menu->format_height, szBuffer); 

		sprintf (szBuffer, "%d", *xstart1); 
		XmTextSetString (*format_screen_menu->xstart_text_image1, szBuffer); 
		sprintf (szBuffer, "%d", *ystart1); 
		XmTextSetString (*format_screen_menu->ystart_text_image1, szBuffer); 

		sprintf (szBuffer, "%d", *xstart2); 
		XmTextSetString (*format_screen_menu->xstart_text_image2, szBuffer); 
		sprintf (szBuffer, "%d", *ystart2); 
		XmTextSetString (*format_screen_menu->ystart_text_image2, szBuffer); 

		sprintf (szBuffer, "%d", *xoffset); 
		XmTextSetString (*format_screen_menu->xoffset_text, szBuffer); 
		sprintf (szBuffer, "%d", *yoffset); 
		XmTextSetString (*format_screen_menu->yoffset_text, szBuffer); 

		sprintf (szBuffer, "%d", *xrow_row); 
		XmTextSetString (*format_screen_menu->rowxoffset_text, szBuffer); 
		sprintf (szBuffer, "%d", *yrow_row); 
		XmTextSetString (*format_screen_menu->rowyoffset_text, szBuffer); 

		sprintf (szBuffer, "%d", *xlabel_start); 
		XmTextSetString (*format_screen_menu->label_xstart, szBuffer); 
		sprintf (szBuffer, "%d", *ylabel_start); 
		XmTextSetString (*format_screen_menu->label_ystart, szBuffer); 

		SetSelectData (*format_screen_menu->display_order, *low2high);
	}
		
	XUndefineCursor (display, window);
	XtUnmanageChild (*formatScreenData->frame);
}


/*________________________________________________________________________________________________	
	Procedure:
		ToggleLabelCallback
	Parameters:
		w: Widget, widget where callback was triggered.
		clientData: caddr_t, client data.
		call_data: caddr_t, callback data.
	Description:
		Callback function for changing the toggle label.
		Author: Tom Yang 
		(12/05/91)
________________________________________________________________________________________________*/

void		ToggleLabelCallback (w, clientData, callData)
Widget		w;
caddr_t		clientData;
caddr_t		callData;
{
	XmToggleButtonCallbackStruct	*ToggleData		
					= (XmToggleButtonCallbackStruct *) callData;
	LABEL_CHANGE_DATA		*labelChangeData	
					= (LABEL_CHANGE_DATA *) clientData;
	Arg				arglist [2];
	BOOLEAN				status;
	XmString			xmstr;
	char				szBuffer [MAXLINE];
	int				n = 0;

	status	= ToggleData->set;
	XtSetArg (arglist [n], XmNset, status? TRUE: FALSE); n++;
	if (status)
		strcpy (szBuffer, labelChangeData->label_true);
	else
		strcpy (szBuffer, labelChangeData->label_false);
	xmstr	= XmStringCreate (szBuffer, XmSTRING_DEFAULT_CHARSET);
	XtSetArg (arglist [n], XmNlabelString, xmstr); n++;
	XtSetValues (w, arglist, n);
	XtFree (xmstr);
}


/*________________________________________________________________________________________________	
	Procedure:
		SaveOptionsCallback
	Parameters:
		w: Widget, widget where callback was triggered.
		clientData: caddr_t, client data.
		call_data: caddr_t, callback data.
	Description:
		Callback function for processing "Save Options" menu.
		Author: Tom Yang 
		(12/05/91)
________________________________________________________________________________________________*/

void		SaveOptionsCallback (w, clientData, callData)
Widget		w;
caddr_t		clientData;
caddr_t		callData;
{
	SAVE_IMAGE_DATA		*save_image_data	= (SAVE_IMAGE_DATA *) clientData;

	Arg			arglist [2];
	BOOLEAN			*windump_format		= &bWinDumpFile;
	BOOLEAN			*save_whole_screen	= &bSaveWholeScreen;
	XmString		xmstr;
	char			buffer [MAXLINE];
	int			n;

	if (save_image_data->node_flag != CANCEL)
	{
		
		*windump_format	
		= XmToggleButtonGetState (save_image_data->file_format);
		*save_whole_screen	
		= XmToggleButtonGetState (save_image_data->area_saved);

		if (*windump_format)
		{
			if (*save_whole_screen)
				XtManageChild (save_image_data->information);
			else
				cPointerState	= SaveRegionState;			
		}
	}
	else
	{
		n	= 0;
		XtSetArg (arglist[n], XmNset, *windump_format); n++;
		if (*windump_format)
			strcpy (buffer, "File Format: Window Dump ");
		else
			strcpy (buffer, "File Format: PostScript ");
		xmstr	= XmStringCreate (buffer, XmSTRING_DEFAULT_CHARSET);
		XtSetArg (arglist[n], XmNlabelString, xmstr); n++;
		XtSetValues (save_image_data->file_format, arglist, n);
		XtFree (xmstr);

		n	= 0;
		XtSetArg (arglist[n], XmNset, *save_whole_screen); n++;
		if (*save_whole_screen)
			strcpy (buffer, "Area Saved: Entire Window");
		else
			strcpy (buffer, "Area Saved: User Defined ");
		xmstr	= XmStringCreate (buffer, XmSTRING_DEFAULT_CHARSET);
		XtSetArg (arglist[n], XmNlabelString, xmstr); n++;
		XtSetValues (save_image_data->area_saved, arglist, n);
		XtFree (xmstr);
	}

	XtUnmanageChild (save_image_data->dialog);
}


/*_________________________________________________________________________________	
	Procedure:
		NonImageColorCallback
	Parameters:
		w: Widget, widget where callback was triggered.
		clientData: caddr_t, client data.
		call_data: caddr_t, callback data.
	Description:
		Callback function for setting the colors for background, atlas, 
		region, and labels.
		Author: Tom Yang 
		(07/16/91)
________________________________________________________________________________*/
void NonImageColorCallback (w, clientData, callData)
Widget w;
caddr_t clientData;
caddr_t callData;
{
	NONIMAGE_COLOR_DATA	*nonImageColorData	= (NONIMAGE_COLOR_DATA *) clientData;
	Display			*display		= nonImageColorData->display;
	int			n;
	Arg			arglist [1];
	Pixel			selected_color_pixel;
	Widget			selected_color_button;
	XColor			color;
	Colormap		dcmap;

	selected_color_button	
		= GetActiveWidget (nonImageColorData->color_set, 
					nonImageColorData->num_colors);
	n	= 0;
	XtSetArg (arglist [n], XtNbackground, &selected_color_pixel); n++;
	XtGetValues (selected_color_button, arglist, n);

	color.pixel	= selected_color_pixel;
	dcmap		= XDefaultColormap (display, DefaultScreen (display));
	XQueryColor (display, dcmap, &color); 

	nonImageColorData->rgb_value->red	= color.red;
	nonImageColorData->rgb_value->green	= color.green;
	nonImageColorData->rgb_value->blue	= color.blue;

	ImageColormap (display, nonImageColorData->root_window, 
		szImage1ColorTableName, szImage2ColorTableName);

	XtUnmanageChild (*nonImageColorData->dialog);
}


/*___________________________________________________________________________________________	
	Procedure:
		ImageColorCallback
	Parameters:
		w: Widget, widget where callback was triggered.
		clientData: caddr_t, client data.
		call_data: caddr_t, callback data.
	Description:
		Callback function for changing color tables for pet images.
		Author: Tom Yang 
		(05/31/91)
__________________________________________________________________________________________*/

void ImageColorCallback (w, clientData, callData)
Widget w;
caddr_t clientData;
caddr_t callData;
{
	IMAGE_COLOR_DATA	*petColorData = (IMAGE_COLOR_DATA *) clientData;
	char			*StrColorTableName;
	Widget			color_table_list;
	char			*color_table_name	= petColorData->color_table_name;
	XmString		item;

	color_table_list	= XmSelectionBoxGetChild (w, XmDIALOG_LIST);

	if (petColorData->node_flag != CANCEL)
	{
		StrColorTableName	
		= XmTextGetString (XmSelectionBoxGetChild (w, XmDIALOG_TEXT));

		strcpy (color_table_name, petColorData->library_path);
		strcat (color_table_name, StrColorTableName);

		if (petColorData->image_status == OpenImage1)
			ImageColormap (petColorData->display, petColorData->root_window, 
					color_table_name, szImage2ColorTableName);
		else
			ImageColormap (petColorData->display, petColorData->root_window, 
					szImage1ColorTableName, color_table_name);

		XtFree (StrColorTableName);
	}
	else
	{
		item	= XmStringCreate (strrchr (color_table_name, '/') + 1, 
					XmSTRING_DEFAULT_CHARSET);
		XmListSelectItem (color_table_list, item, True);
		XtFree (item);
	}

	XtUnmanageChild (petColorData->dialog);
}

void SetButtonStateCallback (w, clientData, callData)
Widget w;
caddr_t clientData;
caddr_t callData;
{
	STATUS_CHANGE_DATA	*buttonStatusData	
				= (STATUS_CHANGE_DATA *) clientData;

	*(buttonStatusData->bool_var) = buttonStatusData->bool_value;
}

void SetRadioToggleCallback (w, clientData, callData)
Widget	w;
caddr_t clientData;
caddr_t callData;
{
	int	n = 0;
	Arg	arglist [1];

	if (XmToggleButtonGetState (w))
	{
		XtSetArg (arglist [n], XmNset, TRUE); n++;
		XtSetValues (w, arglist, n);
	}
}

void SetValueRadioToggleCallback (w, clientData, callData)
Widget	w;
caddr_t clientData;
caddr_t callData;
{
	int	n = 0;
	Arg	arglist [1];
	STATUS_CHANGE_DATA	*buttonStatusData	
				= (STATUS_CHANGE_DATA *) clientData;

	if (XmToggleButtonGetState (w))
	{
		XtSetArg (arglist [n], XmNset, TRUE); n++;
		XtSetValues (w, arglist, n);

		*(buttonStatusData->bool_var) = buttonStatusData->bool_value;
	}
}


/*_________________________________________________________________________________	
	Procedure:
		ShowFileSelectionCallback
	Parameters:
		w: Widget, widget where callback was triggered.
		clientData: caddr_t, client data.
		call_data: caddr_t, callback data.
	Description:
		Callback function for displaying labels of file selection menu.
		Author: Tom Yang 
		(06/07/91)
________________________________________________________________________________*/

void ShowFileSelectionCallback (w, clientData, callData)
Widget w;
caddr_t clientData;
caddr_t callData;
{
	FILE_SELECTION_DATA	*fileSelectionData	
				= (FILE_SELECTION_DATA *) clientData;
	Widget			dialog			
				= fileSelectionData->dialog; 

	Arg			arglist [4];
	BOOLEAN			item_new;
	Widget			dir_list;
	Widget			file_list;
	XmString		xmfile_pattern;
	XmString		item;
	XmString		xmpath_name;
	char			file_name [MAXLINE];
	char			file_pattern [MAXLINE];
	char			path_name [MAXLINE];
	char			pure_pathname [MAXLINE];
	char			*sbuffer;
	int			n;

	cFileState	= fileSelectionData->file_state;

	switch (fileSelectionData->file_state)
	{
		case OpenAtlas:
			strcpy (path_name, szAtlasPathName);
			strcpy (file_name, szAtlasFileName);
			break;
		case OpenImage1:
			strcpy (path_name, szImage1PathName);
			strcpy (file_name, szImage1FileName);
			break;
		case OpenImage2:
			strcpy (path_name, szImage2PathName);
			strcpy (file_name, szImage2FileName);
			break;
		case OpenRegion:
			strcpy (path_name, szRegionPathName);
			strcpy (file_name, szRegionFileNames [cActiveRegionSet]);
			break;
		case OpenMask:
			strcpy (path_name, szImageMaskPathName);
			strcpy (file_name, szImageMaskFileName);
			break;
		case OpenAF3D:
			strcpy (path_name, szAF3DPathName);
			strcpy (file_name, szAF3DFileNames [cActiveAF3DSet]);

			XtUnmanageChild (*fileSelectionData->parent);

			break;
		case GetDefaults:
		case SaveDefaults:
			strcpy (path_name, szDefaultsPathName);
			strcpy (file_name, szDefaultsFileName);
			break;
		case SaveWinDump:
			strcpy (path_name, szWinDumpPathName);
			strcpy (file_name, szWinDumpFileName);
			break;
		case SaveCoordinates:
			strcpy (path_name, szCoordinatesPathName);
			strcpy (file_name, szCoordinatesFileName);
			break;
	}

	memset (pure_pathname, 0, MAXLINE); 
	sbuffer		= strrchr (path_name, '/');
	if (sbuffer && *sbuffer)
	{
		strncpy (pure_pathname, path_name, strlen (path_name)  - strlen (sbuffer));
		if ((sbuffer + 1) && *(sbuffer + 1))
			strcpy (file_pattern, sbuffer + 1);
		else
			strcpy (file_pattern, filePatternList [fileSelectionData->file_state]);
	}
	else
	{
		strcpy (pure_pathname, fileSelectionData->local_path);
		strcpy (file_pattern, filePatternList [fileSelectionData->file_state]);
	}

	xmpath_name	= XmStringCreate (pure_pathname, XmSTRING_DEFAULT_CHARSET);
	xmfile_pattern	= XmStringCreate (file_pattern, XmSTRING_DEFAULT_CHARSET);
	n	= 0;
	XtSetArg (arglist [n], XmNselectionLabelString, 
		fileSelectionData->label_selection); n++;
	XtSetArg (arglist [n], XmNdirectory, xmpath_name); n++;
	XtSetArg (arglist [n], XmNfilterLabelString, 
		fileSelectionData->label_path); n++;
	XtSetArg (arglist [n], XmNpattern, xmfile_pattern); n++;
	XtSetValues (dialog, arglist, n); 
	XtFree (xmpath_name);
	XtFree (xmfile_pattern);

	if (strlen (pure_pathname) > 0)
	{
		dir_list	= XmFileSelectionBoxGetChild (dialog, XmDIALOG_DIR_LIST);

		if (strcmp (pure_pathname, fileSelectionData->local_path) == 0)  
			strcat (pure_pathname, "/.");

		item		= XmStringCreate (pure_pathname, XmSTRING_DEFAULT_CHARSET);

		if (item_new	= !XmListItemExists (dir_list, item))
			XmListAddItem (dir_list, item, 1);
		XmListSelectItem (dir_list, item, True);
		XmListSetItem (dir_list, item);

		if (!item_new)
			XtFree (item);
	}

	file_list	= XmFileSelectionBoxGetChild (dialog, XmDIALOG_LIST);
	if (strlen (file_name) > 0)
	{
		item		= XmStringCreate (file_name, XmSTRING_DEFAULT_CHARSET);
		if (item_new	= !XmListItemExists (file_list, item))
		{
			XmListAddItem (file_list, item, 1);
		}
		XmListSelectItem (file_list, item, True);
		XmListSetItem (file_list, item);

		if (!item_new)
			XtFree (item);
	}
	else
	{
		XmListDeselectAllItems (file_list);	
	}

	XtManageChild (dialog);
}


void RedrawScreenCallback (w, clientData, callData)
Widget w;
caddr_t clientData;
caddr_t callData;
{
	DRAW_DATA	*draw_data	= (DRAW_DATA *) clientData;
	Display		*display	= draw_data->display;
	Window		window		= draw_data->window;

	/*
	XDefineCursor (display, window, draw_data->cursor);
	*/
	
	XMapRaised (display, cursor_window);

	RedrawPortals (draw_data, alist1, plist1, alist2, plist2);
	XUnmapWindow (display, cursor_window);

	/*
	XUndefineCursor (display, window);
	*/
}


/*______________________________________________________________________________________	
	Procedure:
		ShowDataTypeCallback
	Parameters:
		w: Widget, widget where callback was triggered.
		clientData: caddr_t, client data.
		call_data: caddr_t, callback data.
	Description:
		Callback function for opening Data Type menu.
		Author: Tom Yang 
		(08/16/94)
_______________________________________________________________________________________*/

void ShowDataTypeCallback (w, clientData, callData)
Widget w;
caddr_t clientData;
caddr_t callData;
{
	DATA_TYPE_DATA		*data_type	= (DATA_TYPE_DATA *) clientData;
	DATA_TYPE_MENU		*data_type_menu = data_type->default_parameters->data_type_menu;

	Arg			arglist [2];
	char			atlas_orient	= cAtlasOrientation;
	char			szBuffer [MAXLINE];
	int			n;
	short			*first		= &nFirstSlice;
	short			*last		= &nLastSlice;

	if (!(bSliceNumberFlag))
	{
		*first	= GetSliceCoord (*first, atlas_orient, zorigin_image1);
		*last	= GetSliceCoord (*last, atlas_orient, zorigin_image1);
	}

	sprintf (szBuffer, "%d", *first);
	XmTextSetString (*data_type_menu->first_slice, szBuffer); 
	sprintf (szBuffer, "%d", *last);
	XmTextSetString (*data_type_menu->last_slice, szBuffer); 

	XtManageChild (data_type->dialog);
}


/*______________________________________________________________________________________	
	Procedure:
		DataTypeCallback
	Parameters:
		w: Widget, widget where callback was triggered.
		clientData: caddr_t, client data.
		call_data: caddr_t, callback data.
	Description:
		Callback function for Data Type menu.
		Author: Tom Yang 
		(06/07/91)
_______________________________________________________________________________________*/

void DataTypeCallback (w, clientData, callData)
Widget w;
caddr_t clientData;
caddr_t callData;
{
	DATA_TYPE_DATA		*selectSliceOKData	
				= (DATA_TYPE_DATA *) clientData;
	Widget			dialog			
				= selectSliceOKData->dialog; 
	Display			*display		
				= selectSliceOKData->draw_data->display;
	Window			window			
				= selectSliceOKData->draw_data->window;
	DATA_TYPE_MENU		*data_type_menu
				= selectSliceOKData->default_parameters->data_type_menu;

	Arg			arglist [2];
	Boolean			*apply_mask1		= &bApplyMask1;
	Boolean			*apply_mask2		= &bApplyMask2;
	Boolean			*atlas_trim		= &bAtlasTrim;
	Boolean			*display_atlas1		= &bDisplayAtlas1;
	Boolean			*display_atlas2		= &bDisplayAtlas2;
	Boolean			*display_label		= &bDisplayLabel;
	Boolean			*display_image1		= &bDisplayImage1;
	Boolean			*display_image2		= &bDisplayImage2;
	Boolean			*slice_num_flag		= &bSliceNumberFlag;
	char			*atlas_orient		= &cAtlasOrientation;
	char			node			= selectSliceOKData->node_flag;
	char			*image1_filename	= szImage1FileName;
	char			*image2_filename	= szImage2FileName;
	char 			*str1;
	char 			*str2;
	char			szBuffer [MAXLINE];
	float			voxel_depth;
	float			voxel_height;
	float			voxel_width;
	int			image_type;
	int			n;
	short			first;
	short			*first_slice	= &nFirstSlice;
	short			height;
	short			last;
	short			*last_slice	= &nLastSlice;			
	short			max_slice_num;
	short			min_slice_num;
	short			num_slices;
	short			space;
	short			*spacing	= &nSpacing;			
	short			width;
	struct Matval		matval;

	XDefineCursor (display, window, selectSliceOKData->draw_data->cursor);

	if (node != CANCEL)
	{
		*atlas_trim	= XmToggleButtonGetState (*data_type_menu->atlas_trim);
		*display_atlas1	= XmToggleButtonGetState (*data_type_menu->atlas1);
		*display_image1	= XmToggleButtonGetState (*data_type_menu->image1);
		*apply_mask1	= XmToggleButtonGetState (*data_type_menu->mask1);
		*display_atlas2	= XmToggleButtonGetState (*data_type_menu->atlas2);
		*display_image2	= XmToggleButtonGetState (*data_type_menu->image2);
		*apply_mask2	= XmToggleButtonGetState (*data_type_menu->mask2);
		*display_label	= XmToggleButtonGetState (*data_type_menu->label);
		*slice_num_flag	= XmToggleButtonGetState (*data_type_menu->slice_num_flag);
		*atlas_orient	= GetActiveIndex (data_type_menu->orientation_set, ORIENTATION_NUM);
		SetDefaultAtlas (*atlas_orient, selectSliceOKData->default_parameters->library_path);

		str1 = XmTextGetString (*data_type_menu->first_slice);
		str2 = XmTextGetString (*data_type_menu->last_slice);

		if (strlen (str1) > 0 && strlen (str2) > 0)
		{
			*first_slice	= atoi (str1);
			*last_slice	= atoi (str2);

			if (!(*slice_num_flag))
			{
				*first_slice	= GetSliceNumber (*first_slice, 
						*atlas_orient, zorigin_image1);
				*last_slice	= GetSliceNumber (*last_slice, 
						*atlas_orient, zorigin_image1);
			}

			/*
			 * Check if the first and last slice are within the allowed range
			 * and change the boundary slices if necessary.
			 */
			if (strlen (image1_filename) > 0)
			{
				matval.frame	= 1;
				matval.plane	= 1;
				matval.gate	= 1;
				matval.data	= 0;
				matval.bed	= 0;

				if (getimagedim (image1_filename, matval, &image_type, &width, &height, 
				&num_slices, &voxel_width, &voxel_height, &voxel_depth) == FAIL)
					return;

				if (*atlas_orient == TRANSVERSE)
				{
					max_slice_num	= num_slices;
				}
				else if (*atlas_orient == CORONAL)
				{
					max_slice_num	= height;
				}
				else
				{
					max_slice_num	= width;
				}
			}
			else
			{
				if (*atlas_orient == TRANSVERSE)
				{
					max_slice_num	= MAX_TRANS_ATLAS_NUM;
				}
				else if (*atlas_orient == CORONAL)
				{
					max_slice_num	= MAX_ATLAS_NUM;
				}
				else
				{
					max_slice_num	= MAX_ATLAS_NUM;
				}
			}

			min_slice_num	= 1;

			if (*first_slice < min_slice_num || *first_slice > max_slice_num)
			{
				fprintf (stderr, 
			"Your first slice %d is outside the allowed range of [%d, %d].\n",
				*first_slice, min_slice_num, max_slice_num);

				if (*first_slice < min_slice_num)
					*first_slice	= min_slice_num;
				else if (*first_slice > max_slice_num)
					*first_slice	= max_slice_num;

				fprintf (stderr, 
			"The number %d is assigned as the new first slice.\n", 
				*first_slice);
			}

			if (*last_slice < min_slice_num || *last_slice > max_slice_num)
			{
				fprintf (stderr, 
			"Your last slice %d is outside the allowed range of [%d, %d].\n",
				*last_slice, min_slice_num, max_slice_num);

				if (*last_slice < min_slice_num)
					*last_slice	= min_slice_num;
				else if (*last_slice > max_slice_num)
					*last_slice	= max_slice_num;

				fprintf (stderr, 
			"The number %d is assigned as the new last slice.\n", 
				*last_slice);
			}

			/*
			 * Make sure the first slice is always no greater than the last slice.
			 */
			if (*first_slice > *last_slice)
				Swap (first_slice, last_slice);
		}
		XtFree (str1);
		XtFree (str2);

		str1 = XmTextGetString (*data_type_menu->spacing);
		*spacing = atoi (str1);

		if (!(*slice_num_flag))
		{
			*spacing	= *spacing / 2;
		}

		if (*spacing <= 0 || (*first_slice == *last_slice))
			*spacing	= 1;
		XtFree (str1);

		if (node == REDRAW)
		{
			RedrawPortals (selectSliceOKData->draw_data, alist1, plist1, alist2, plist2);
		}
	}
	else
	{
		SetSelectData (*data_type_menu->atlas_trim, *atlas_trim);
		SetSelectData (*data_type_menu->atlas1, *display_atlas1);
		SetSelectData (*data_type_menu->image1, *display_image1);
		SetSelectData (*data_type_menu->mask1, *apply_mask1);
		SetSelectData (*data_type_menu->atlas2, *display_atlas2);
		SetSelectData (*data_type_menu->image2, *display_image2);
		SetSelectData (*data_type_menu->mask2, *apply_mask2);
		SetSelectData (*data_type_menu->label, *display_label);

		if (*slice_num_flag)
			strcpy (szBuffer, "Slice Numbers");
		else if (*atlas_orient == TRANSVERSE)
			strcpy (szBuffer, "Z Values");
		else if (*atlas_orient == CORONAL)
			strcpy (szBuffer, "Y Values");
		else 
			strcpy (szBuffer, "X Values");

		n	= 0;
		XtSetArg (arglist [n], XmNset, *slice_num_flag); n++;
		XtSetArg (arglist [n], XmNlabelString, XmStringCreate (szBuffer, 
			XmSTRING_DEFAULT_CHARSET)); n++;
		XtSetValues (*data_type_menu->slice_num_flag, arglist, n);

		SetSelectData (GetActiveWidget (data_type_menu->orientation_set, ORIENTATION_NUM), False);
		SetSelectData (data_type_menu->orientation_set [*atlas_orient], True);

	}

	first	= *first_slice;
	last	= *last_slice;
	space	= *spacing;

	if (!(*slice_num_flag))
	{
		space	*= 2; 
		first	= GetSliceCoord (first, *atlas_orient, zorigin_image1);
		last	= GetSliceCoord (last, *atlas_orient, zorigin_image1);
	}

	sprintf (szBuffer, "%d", first);
	XmTextSetString (*data_type_menu->first_slice, szBuffer); 
	sprintf (szBuffer, "%d", last);
	XmTextSetString (*data_type_menu->last_slice, szBuffer); 
	sprintf (szBuffer, "%d", space);
	XmTextSetString (*data_type_menu->spacing, szBuffer); 

	XUndefineCursor (display, window);
	XtUnmanageChild (dialog);
}


/*___________________________________________________________________________________	
	Procedure:
		SetToggleCallback
	Parameters:
		w: Widget, widget where callback was triggered.
		clientData: caddr_t, client data.
		call_data: caddr_t, callback data.
	Description:
		Callback function for Select Data menu widget to set the current
		display state.
		Author: Tom Yang 
		(05/21/91)
_____________________________________________________________________________________*/

void SetToggleCallback (w, clientData, callData)
Widget		w;
caddr_t		clientData;
caddr_t		callData;
{
	XmToggleButtonCallbackStruct		*ToggleData 
					= (XmToggleButtonCallbackStruct *) callData;
	int				n = 0;
	Arg				arglist [1];

	XtSetArg (arglist [n], XmNset, (ToggleData->set)? TRUE: FALSE); n++;
	XtSetValues (w, arglist, n);
}


/*____________________________________________________________________________________	
	Procedure:
		SetPointerStatusCallback
	Parameters:
		w: Widget, widget where callback was triggered.
		clientData: caddr_t, client data.
		call_data: caddr_t, callback data.
	Description:
		Callback function for setting pointer state.
		display state.
		Author: Tom Yang 
		(05/21/91)
____________________________________________________________________________________*/

void SetPointerStatusCallback (w, clientData, call_data)
Widget	w;
caddr_t	clientData;
caddr_t	call_data;
{
	cPointerState	= (PointerStatus) clientData;
}


/*________________________________________________________________________	
	Procedure:
		ShowImageMinMaxCallback
	Parameters:
		w: Widget, widget where callback was triggered.
		clientData: caddr_t, client data.
		call_data: caddr_t, callback data.
	Description:
		Callback function to show minimum and maximum PETT image pixel value.
		Author: Tom Yang 
		(06/27/91)
________________________________________________________________________*/
void ShowImageMinMaxCallback (w, clientData, callData)
Widget	w;
caddr_t clientData;
caddr_t callData;
{
	AUTO_IMAGE_VALUE_DATA		*autoImageValueData	
					= (AUTO_IMAGE_VALUE_DATA *) clientData;
	XmToggleButtonCallbackStruct	*ToggleData	
					= (XmToggleButtonCallbackStruct *) callData;

	Arg				arglist [1];
	char				szBuffer [MAXLINE];
	int				n;
	short				max;
	short				min;

	n	= 0;
	XtSetArg (arglist [n], XmNset, (ToggleData->set)? TRUE: FALSE); n++;
	XtSetValues (w, arglist, n);

	GetImageMinMax (autoImageValueData->image1_flag, ToggleData->set, &min, &max);

	sprintf (szBuffer, "%d", min);
	XmTextSetString (autoImageValueData->minimum_text, szBuffer); 
	sprintf (szBuffer, "%d", max);
	XmTextSetString (autoImageValueData->maximum_text, szBuffer); 
}


/*_________________________________________________________________________________	
	Procedure:
		CancelFileSelectionCallback
	Parameters:
		w: Widget, widget where callback was triggered.
		clientData: caddr_t, client data.
		call_data: caddr_t, callback data.
	Description:
		Callback function for canceling file selection box.
		Author: Tom Yang 
		(04/09/93)
________________________________________________________________________________*/

void CancelFileSelectionCallback (w, clientData, callData)
Widget w;
caddr_t clientData;
caddr_t callData;
{
	DATA_FILE_SELECTION		*selectFileData	
				= (DATA_FILE_SELECTION *) clientData;

	XtUnmanageChild (selectFileData->dialog);

	if (cFileState == OpenAF3D)
		XtManageChild (*selectFileData->parent);
}


/*________________________________________________________________________	
	Procedure:
		SelectFileCallback
	Parameters:
		w: Widget, widget where callback was triggered.
		clientData: caddr_t, client data.
		call_data: caddr_t, callback data.
	Description:
		Callback function to change a Bool value passed in from clientData.
		Author: Tom (Tongzeng) Yang 
		(06/28/91)
_________________________________________________________________________*/
void SelectFileCallback (w, clientData, callData)
Widget	w;
caddr_t clientData;
caddr_t callData;
{
	DATA_FILE_SELECTION		*selectFileData	
				= (DATA_FILE_SELECTION *) clientData;

	Arg			arglist [2];
	BOOLEAN			encoded;
	COMMENT_INFO		comment_info_data;
	Display			*display	= selectFileData->draw_data->display;
	FILE			*fp;
	FileStatus		file_state	= cFileState;  	/* file type */
	GC			gc		= selectFileData->draw_data->gc;
	MatrixFile		*fptr;
	Widget			dialog		= selectFileData->dialog;
	Widget			file_list;
	Widget			*message_box	= &errorMessageBox;
	XmString		xmstring_buffer;
	char			alter_index;
	char			atlas_orient	= cAtlasOrientation;
	char			*dirname;
	char			*extension;
	char			*filename;
	char			s [2];		
	char			short_filename1 [MAXLINE];
	char			short_filename2 [MAXLINE];
	char			*string;
	char			*string1;
	char			*string2;
	char			szBuffer [MAXLINE];
	char			szBuffer1 [MAXLINE];
	char			szBuffer2 [MAXLINE];
	float			atlas_coord;
	float			voxel_depth;
	float			voxel_height;
	float			voxel_width;
	int			fd;
	int			imgfd;
	int			n;
	int			pett_num;
	int			*pzorigin_image1	= &zorigin_image1;
	int			*pzorigin_image2	= &zorigin_image2;
	int			return_value;
	int			zorigin_new;
	long			bytes;
	short			*first_slice	= &nFirstSlice;
	short			height;
	short			*last_slice	= &nLastSlice;			
	short			max_slice_num;
	short			min_slice_num;
	short			num_slices;
	short			path_len;	/* length of path string */
	short			width;
	struct Matval		matval;

	strncpy (szBuffer, "\0", MAXLINE);
	strncpy (szBuffer1, "\0", MAXLINE);
	strncpy (szBuffer2, "\0", MAXLINE);
	dirname	= XmTextGetString (XmFileSelectionBoxGetChild (dialog, 
							XmDIALOG_FILTER_TEXT));
	string1		= strrchr (dirname, '/');
	strncpy (szBuffer1, dirname, strlen (dirname)  - strlen (string1) + 1);
	filename	= XmTextGetString (XmFileSelectionBoxGetChild (dialog, 
							XmDIALOG_TEXT));
	strcpy (szBuffer2, szBuffer1);
	string2		= strrchr (filename, '/');
	if (string2 != NULL)
	{
		strcpy (szBuffer, string2 + 1);
	}
	else
	{
		strcpy (szBuffer, filename);
	}

	strcat (szBuffer1, ".");
	strcat (szBuffer2, szBuffer);
	if (file_state == OpenImage1)
	{
		strcpy (short_filename1, szBuffer);
		string1		= strrchr (szImage2FileName, '/');
		if (string1 != NULL)
			strcpy (short_filename2, string1 + 1);
		else if (strlen (szImage2FileName) > 0)
			strcpy (short_filename2, szImage2FileName);
		else
			strcpy (short_filename2, "NULL");
	}
	else if (file_state == OpenImage2)
	{
		string1		= strrchr (szImage1FileName, '/');
		if (string1 != NULL)
			strcpy (short_filename1, string1 + 1);
		else if (strlen (szImage1FileName) > 0)
			strcpy (short_filename1, szImage1FileName);
		else
			strcpy (short_filename1, "NULL");
		strcpy (short_filename2, szBuffer);
	}

	/*
	 * Check for directory existance.
	 */
	if ((fp = fopen (szBuffer1, "r")) == NULL)
	{
		n	= 0;
		XtSetArg (arglist [n], XmNmessageString, xmStrErrorMessages [ERROR_DIR_NOTEXIST]); n++;
		XtSetValues (*message_box, arglist, n);

		XtManageChild (*message_box);

		fclose (fp);
		XtFree (dirname);
		XtFree (filename);

		return;	
	}
	fclose (fp);

	/*
	 * Check for file existance if reading.
	 */
	if (file_state == OpenAtlas || file_state == OpenImage1 || file_state == OpenImage2 
	|| file_state == OpenAF3D || file_state == OpenRegion || file_state == OpenMask)
	{
		extension	= strrchr (szBuffer2, '/');
		if (szBuffer2 == NULL || (extension != NULL && strcmp (extension, "/") == 0)
			|| (fd = open (szBuffer2, O_RDONLY, 0)) == -1)
		{
			n	= 0;
			XtSetArg (arglist [n], XmNmessageString, xmStrErrorMessages [ERROR_FILE_EMPTY]); n++;
			XtSetValues (*message_box, arglist, n);

			XtManageChild (*message_box);
			close (fd);
			XtFree (dirname);
			XtFree (filename);
			return;
		}
		if (file_state == OpenAF3D && getfile_type (szBuffer2) == BINARY)
		{
			/* 
	 		 * Read the the path_len var. 
 			 */
			pkg_read (fd, s, 2, "SelectFileCallback", "s");
			memcpy ((char *) &path_len, s, 2);

			bytes		= lseek (fd, 0L, 2);
			if (path_len <= 0 || path_len > bytes - sizeof (RawGammaZPoint))
			{
				n	= 0;
				XtSetArg (arglist [n], XmNmessageString, 
					xmStrErrorMessages [ERROR_AF3D_FORMAT]); n++;
				XtSetValues (*message_box, arglist, n);
				XtManageChild (*message_box);

				close (fd);
				XtFree (dirname);
				XtFree (filename);
				return;
			}

		}
	}
	close (fd);

	file_list	= XmFileSelectionBoxGetChild (dialog, XmDIALOG_LIST);

	switch (file_state)
	{
		case OpenAtlas:
			if (strcmp (szAtlasFileName, szBuffer2) != 0)
			{
				strcpy (szAtlasFileName, szBuffer2);
				bAtlasChanged	= TRUE;
				SetDefaultAtlas (atlas_orient,
				selectFileData->default_parameters->library_path);
			}
			strcpy (szAtlasPathName, dirname);
			ReadAtlasHeader (szBuffer2, selectFileData->default_parameters->library_path);

			break;
		case OpenImage1:
		case OpenImage2:
			/*
			 * Obtain the zorigin for the PET image.
			 */
			imgfd	= open (szBuffer2, O_RDONLY, 0);
			if (imgfd == -1)
			{
				fprintf (stderr, "Can't open %d\n", szBuffer2); 
				return;
			}

			pett_num	= getimage_type (imgfd, szBuffer2, &encoded, &num_slices);
			close (imgfd);

			if (pett_num == ERROR_SCANNER)
			{
				sprintf (szBuffer, 
				"There is either an error in image %s or no .ifh or .hdr files can be found.",
					szBuffer2);

				xmstring_buffer	= XmStringCreate (szBuffer, XmSTRING_DEFAULT_CHARSET);
				n	= 0;
				XtSetArg (arglist [n], XmNmessageString, xmstring_buffer); n++;
				XtSetValues (*message_box, arglist, n);
				XtManageChild (*message_box);
				XtFree (xmstring_buffer);

				return;
			}

			if (pett_num == ECAT_SCANNER)
			{
				matval.frame	= 1;
				matval.plane	= 1;
				matval.gate	= 1;
				matval.data	= 0;
				matval.bed	= 0;

				fptr	= OpenEcat (szBuffer2, &num_slices, &width, &height, 
					&voxel_width, &voxel_depth, matval);
				if (fptr == (MatrixFile *) NULL)
				{
					fprintf (stderr, "Cannnot open image %s.\n", szBuffer2);
					return;
				}

				comment_info (fptr->mhptr->study_description, &comment_info_data);
				zorigin_new	= comment_info_data.zorigin;
				matrix_close (fptr);

				if (zorigin_new == 0)
				{
					strcpy (szBuffer, 
			"No z0 slice found. The program will use slice 31 as z0 in processing.\n");
					xmstring_buffer	= XmStringCreate (szBuffer, 
						XmSTRING_DEFAULT_CHARSET); 

					n	= 0;
					XtSetArg (arglist [n], XmNmessageString, xmstring_buffer); n++;
					XtSetValues (*message_box, arglist, n);
					XtManageChild (*message_box);

					XtFree (xmstring_buffer);

					zorigin_new	= DEFAULT_ZORIGIN;
				}
			}
			else
			{
				zorigin_new	= DEFAULT_ZORIGIN;
			}
			 
			/*
			 * Update the PET path and file name.
			 */
			bzero (szBuffer, MAXLINE);
			strcpy (szBuffer, szAtlasCoordinate);
			strcat (szBuffer, "Image 1:   ");
			if (file_state == OpenImage1)
			{
				strcpy (szImage1PathName, dirname);
				strcpy (szImage1FileName, szBuffer2);
				bImage1Selected	= TRUE;
			}
			else
			{
				strcpy (szImage2PathName, dirname);
				strcpy (szImage2FileName, szBuffer2);
				bImage2Selected	= TRUE;
			}
			strcat (szBuffer, short_filename1);
			strcat (szBuffer, "   Image 2:   "); 
			strcat (szBuffer, short_filename2); 

			xmstring_buffer	= XmStringCreate (szBuffer, 
					XmSTRING_DEFAULT_CHARSET); 
			n	= 0;
			XtSetArg (arglist [n], XmNlabelString, xmstring_buffer); n++;
			XtSetValues (wImageNameCascade, arglist, n);
			free (xmstring_buffer);

			if ((file_state == OpenImage1 && zorigin_new != *pzorigin_image1)
			|| (file_state == OpenImage2 && zorigin_new != *pzorigin_image2)
			|| pett_num == INTERFILE)
			{
				/*
			 	 * Change the first and last slice in the new coordinate
			 	 * system for transverse slices.
			 	 */
				if (file_state == OpenImage1 && cAtlasOrientation == TRANSVERSE)
				{
					atlas_coord	= slice2z (*first_slice, *pzorigin_image1);
					*first_slice	= z2slice (atlas_coord, zorigin_new);

					atlas_coord	= slice2z (*last_slice, *pzorigin_image1);
					*last_slice	= z2slice (atlas_coord, zorigin_new);
				}

				if (file_state == OpenImage1 && zorigin_new != *pzorigin_image1)
				{
					*pzorigin_image1	= zorigin_new;
					bImage1ZoriginChanged	= TRUE;
				}
				else if (file_state == OpenImage2 && zorigin_new != *pzorigin_image2)
				{
					*pzorigin_image2	= zorigin_new;
					bImage2ZoriginChanged	= TRUE;
				}

				/*
			 	 * Check if the first and last slice are within the allowed range
			 	 * and change the boundary slices if necessary.
			 	 */
				return_value	= getimagedim (szBuffer2, matval, &pett_num, &width, 
						&height, &num_slices, &voxel_width, &voxel_height, 
						&voxel_depth);

				if (return_value == FAIL)
					sprintf (szBuffer, 
				"Either there is error in image %s or no .ifh or .hdr files can be found.",
					szBuffer2);
				else if (return_value == MODE_USE_ANALYZE_HEADER)
					sprintf (szBuffer, 
						"The analyze %s.hdr file is used to get voxel size.",
						szBuffer2);
				else if (return_value == MODE_DEFAULT_VOXEL_SIZE)
					strcpy (szBuffer, "The voxel size is set to 1mm x 1mm x 1.25mm.");

				if (return_value != SUCCEED)
				{
					xmstring_buffer	= XmStringCreate (szBuffer, XmSTRING_DEFAULT_CHARSET);
					n	= 0;
					XtSetArg (arglist [n], XmNmessageString, xmstring_buffer); n++;
					XtSetValues (*message_box, arglist, n);
					XtManageChild (*message_box);
					XtFree (xmstring_buffer);
				}

				if (return_value == FAIL)
					return;

				if (atlas_orient == TRANSVERSE)
				{
					max_slice_num	= num_slices;
				}
				else if (atlas_orient == CORONAL)
				{
					max_slice_num	= height;
				}
				else
				{
					max_slice_num	= width;
				}

				min_slice_num	= 1;

				if (*first_slice < min_slice_num || *first_slice > max_slice_num)
				{
					fprintf (stderr, 
			"Your first slice %d is outside the allowed range of [%d, %d].\n",
					*first_slice, min_slice_num, max_slice_num);

					if (*first_slice < min_slice_num)
						*first_slice	= min_slice_num;
					else if (*first_slice > max_slice_num)
						*first_slice	= max_slice_num;

					fprintf (stderr, 
			"The number %d is assigned as the new first slice.\n", 
					*first_slice);
				}

				if (*last_slice < min_slice_num || *last_slice > max_slice_num)
				{
					fprintf (stderr, 
			"Your last slice %d is outside the allowed range of [%d, %d].\n",
					*last_slice, min_slice_num, max_slice_num);

					if (*last_slice < min_slice_num)
						*last_slice	= min_slice_num;
					else if (*last_slice > max_slice_num)
						*last_slice	= max_slice_num;

					fprintf (stderr, 
				"The number %d is assigned as the new last slice.\n", 
					*last_slice);
				}
			}

			break;
		case OpenRegion:
			alter_index	= cActiveRegionSet;
			strcpy (szRegionPathName, dirname);
			strcpy (szRegionFileNames [alter_index], szBuffer2);

			if (string2 != NULL)
				string	= string2 + 1;
			else
				string	= filename;

			n	= 0;
			XtSetArg (arglist [n], XmNlabelString,
				XmStringCreate (string, XmSTRING_DEFAULT_CHARSET)); n++;
			XtSetValues (selectFileData->region_file_label [alter_index], arglist, n);
			break;
		case OpenMask:
			strcpy (szImageMaskPathName, dirname);
			strcpy (szImageMaskFileName, szBuffer2);
			break;
		case OpenAF3D:
			alter_index	= cActiveAF3DSet;
			strcpy (szAF3DPathName, dirname);
			strcpy (szAF3DFileNames [alter_index], szBuffer2);

			if (string2 != NULL)
				string	= string2 + 1;
			else
				string	= filename;

			n	= 0;
			XtSetArg (arglist [n], XmNlabelString,
				XmStringCreate (string, XmSTRING_DEFAULT_CHARSET)); n++;
			XtSetValues (selectFileData->AF3D_symbol_label [alter_index], arglist, n);
			break;
		case GetDefaults:
			GetDefaultParameters (display, selectFileData->root_window, gc,
				filename, selectFileData->default_parameters,
				xmStrSymbolSize);
			strcpy (szDefaultsPathName, dirname);
			strcpy (szDefaultsFileName, szBuffer2);
			break;
		case SaveDefaults:
			strcpy (szDefaultsPathName, dirname);

			string	= strstr (szBuffer2, ".defaults");
			if (string == NULL || strcmp (string, ".defaults") != 0)
				strcat (szBuffer2, ".defaults");
			strcpy (szDefaultsFileName, szBuffer2);

			SaveDefaultParameters (szBuffer2, 
				selectFileData->default_parameters);

			break;
		case SaveWinDump:
			strcpy (szWinDumpPathName, dirname);

			string	= strstr (szBuffer2, ".xwd");
			if (string == NULL || strcmp (string, ".xwd") != 0)
				strcat (szBuffer2, ".xwd");
			strcpy (szWinDumpFileName, szBuffer2);
			XtManageChild (selectFileData->information);
			break;
		case SaveCoordinates:
			strcpy (szCoordinatesPathName, dirname);

			string	= strstr (szBuffer2, ".log");
			if (string == NULL || strcmp (string, ".log") != 0)
				strcat (szBuffer2, ".log");
			strcpy (szCoordinatesFileName, szBuffer2);
			break;
	}

	XtFree (dirname);
	XtFree (filename);
	XtUnmanageChild (dialog);
	if (file_state == OpenAF3D)
		XtManageChild (*selectFileData->parent);
}


/*_________________________________________________________________________________	
	Procedure:
		SaveWinDumpCallback
	Parameters:
		Widget	w;
		caddr_t clientData;
		caddr_t callData;
	Description:
		Callback function for saving window in window dump format. 
		Author: Tom (Tongzeng) Yang 
		(12/03/91)
___________________________________________________________________________________*/
Widget SaveWinDumpCallback (w, clientData, callData)
Widget	w;
caddr_t clientData;
caddr_t callData;
{
	DRAW_DATA	*draw_data	= (DRAW_DATA *) clientData;
	Display		*display	= draw_data->display;
	Window		window		= draw_data->window;

	WindowDump (display, window, FALSE, 0, 0, 0, 0);
}


/*________________________________________________________________________________________________	
	Procedure:
		ColorBarCallback
	Parameters:
		w: Widget, widget where callback was triggered.
		clientData: caddr_t, client data.
		call_data: caddr_t, callback data.
	Description:
		Callback function to change a Bool value passed in from clientData.
		Author: Tom (Tongzeng) Yang 
		(06/28/91)
________________________________________________________________________________________________*/
void ColorBarCallback (w, clientData, callData)
Widget	w;
caddr_t clientData;
caddr_t callData;
{
	COLOR_BAR_DATA	*colorBarData		= (COLOR_BAR_DATA *) clientData;

	BOOLEAN		auto_image1_value_flag	= bAutoImage1ValueFlag;
	BOOLEAN		auto_image2_value_flag	= bAutoImage2ValueFlag;
	BOOLEAN		*image1_colorbar_exist	= &bImage1ColorBarExist;
	BOOLEAN		*image2_colorbar_exist	= &bImage2ColorBarExist;
	BOOLEAN		*horizontal_flag1	= &bImage1HorizontalColorBar;
	BOOLEAN		*horizontal_flag2	= &bImage2HorizontalColorBar;
	BOOLEAN		*onoff_image1		= &bImage1ColorBarOnOff;
	BOOLEAN		*onoff_image2		= &bImage2ColorBarOnOff;
	COLOR_BAR_MENU	*color_bar_menu		= colorBarData->color_bar_menu;
	Display		*display		= colorBarData->draw_data->display;
	GC		gc			= colorBarData->draw_data->gc;
	Window		window			= colorBarData->draw_data->window;
	XFontStruct	*font_struct		= FontStruct;
	XRectangle	*image1_colorbar_max	= &rectImage1ColorBarMax;
	XRectangle	*image2_colorbar_max	= &rectImage2ColorBarMax;
	XRectangle	*image1_colorbar_middle	= &rectImage1ColorBarMiddle;
	XRectangle	*image2_colorbar_middle	= &rectImage2ColorBarMiddle;
	XRectangle	*image1_colorbar_min	= &rectImage1ColorBarMin;
	XRectangle	*image2_colorbar_min	= &rectImage2ColorBarMin;
	char		node			= colorBarData->node_flag;
	char		image1_value_flag	= cImage1ValueFlag;
	char		image2_value_flag	= cImage2ValueFlag;
	char 		*str1;
	char 		*str2;
	char		szBuffer [MAXLINE];
	int		hcolorbar;
	int		wcolorbar;
	short		*length1		= &nImage1ColorBarLength;
	short		*length2		= &nImage2ColorBarLength;
	short		minimum;
	short		maximum;
	short		*width1			= &nImage1ColorBarWidth;
	short		*width2			= &nImage2ColorBarWidth;
	short		*x1			= &nxImage1ColorBarStart;
	short		*x2			= &nxImage2ColorBarStart;
	short		*y1			= &nyImage1ColorBarStart;
	short		*y2			= &nyImage2ColorBarStart;

	if (node != CANCEL)
	{
		nxImage1OldColorBar		= *x1;
		nyImage1OldColorBar		= *y1;
		nImage1OldColorBarLength	= *length1;
		nImage1OldColorBarWidth		= *width1;
		bImage1OldHoriColorBar		= *horizontal_flag1;

		nxImage2OldColorBar		= *x2;
		nyImage2OldColorBar		= *y2;
		nImage2OldColorBarLength	= *length2;
		nImage2OldColorBarWidth		= *width2;
		bImage2OldHoriColorBar		= *horizontal_flag2;

		if (node == REDRAW)
		{
			if (*onoff_image1)
			{
				wcolorbar	= *length1;
				hcolorbar	= *width1;

				if (!(*horizontal_flag1))
					Swap (&wcolorbar, &hcolorbar);

				XClearArea (display, window, *x1, *y1, wcolorbar, hcolorbar, FALSE); 
				GetImageMinMax (TRUE, auto_image1_value_flag, &minimum, &maximum);
				DrawColorBarText (display, window, gc, &minimum, &maximum, font_struct, 
					*horizontal_flag1, *x1, *y1, *length1, *width1, TRUE,
					auto_image1_value_flag, image1_value_flag,
					image1_colorbar_exist, image1_colorbar_min,
					image1_colorbar_middle, image1_colorbar_max);
			}

			if (*onoff_image2)
			{
				wcolorbar	= *length2;
				hcolorbar	= *width2;

				if (!(*horizontal_flag2))
					Swap (&wcolorbar, &hcolorbar);

				XClearArea (display, window, *x2, *y2, wcolorbar, hcolorbar, FALSE); 
				GetImageMinMax (FALSE, auto_image2_value_flag, &minimum, &maximum);
				DrawColorBarText (display, window, gc, &minimum, &maximum, font_struct, 
					*horizontal_flag2, *x2, *y2, *length2, *width2, TRUE,
					auto_image2_value_flag, image2_value_flag,
					image2_colorbar_exist, image2_colorbar_min,
					image2_colorbar_middle, image2_colorbar_max);
			}
		}

		*horizontal_flag1	= XmToggleButtonGetState (*color_bar_menu->image1_orientation);
		*onoff_image1		= XmToggleButtonGetState (*color_bar_menu->image1_onoff);

		str1 = XmTextGetString (*color_bar_menu->image1_xstart);
		str2 = XmTextGetString (*color_bar_menu->image1_ystart);

		if (strlen (str1) > 0 && strlen (str2) > 0)
		{
			*x1	= atoi (str1);
			*y1	= atoi (str2);
		}
		XtFree (str1);
		XtFree (str2);

		str1 = XmTextGetString (*color_bar_menu->image1_width);
		str2 = XmTextGetString (*color_bar_menu->image1_height);

		if (strlen (str1) > 0 && strlen (str2) > 0)
		{
			*length1	= atoi (str1);
			*width1		= atoi (str2);
		}
		XtFree (str1);
		XtFree (str2);

		*horizontal_flag2	= XmToggleButtonGetState (*color_bar_menu->image2_orientation);
		*onoff_image2		= XmToggleButtonGetState (*color_bar_menu->image2_onoff);

		str1 = XmTextGetString (*color_bar_menu->image2_xstart);
		str2 = XmTextGetString (*color_bar_menu->image2_ystart);

		if (strlen (str1) > 0 && strlen (str2) > 0)
		{
			*x2	= atoi (str1);
			*y2	= atoi (str2);
		}
		XtFree (str1);
		XtFree (str2);

		str1 = XmTextGetString (*color_bar_menu->image2_width);
		str2 = XmTextGetString (*color_bar_menu->image2_height);

		if (strlen (str1) > 0 && strlen (str2) > 0)
		{
			*length2	= atoi (str1);
			*width2		= atoi (str2);
		}
		XtFree (str1);
		XtFree (str2);

		if (node == REDRAW)
		{
			if (*onoff_image1)
			{
				DrawColorBar (display, window, gc, *x1, *y1, *length1, *width1, 
				*horizontal_flag1, image1_value_flag, szImage1ColorTableName, TRUE); 

				XSetForeground (display, gc, LABEL_CELL);
				GetImageMinMax (TRUE, auto_image1_value_flag, &minimum, &maximum);
				DrawColorBarText (display, window, gc, &minimum, &maximum, font_struct, 
					*horizontal_flag1, *x1, *y1, *length1, *width1, FALSE, 
					auto_image1_value_flag, image1_value_flag,
					image1_colorbar_exist, image1_colorbar_min,
					image1_colorbar_middle, image1_colorbar_max);
			}

			if (*onoff_image2)
			{
				DrawColorBar (display, window, gc, *x2, *y2, *length2, *width2, 
				*horizontal_flag2, image2_value_flag, szImage2ColorTableName, FALSE); 

				XSetForeground (display, gc, LABEL_CELL);
				GetImageMinMax (FALSE, auto_image2_value_flag, &minimum, &maximum);
				DrawColorBarText (display, window, gc, &minimum, &maximum, font_struct, 
					*horizontal_flag2, *x2, *y2, *length2, *width2, FALSE, 
					auto_image2_value_flag, image2_value_flag,
					image2_colorbar_exist, image2_colorbar_min,
					image2_colorbar_middle, image2_colorbar_max);
			}
		}
	}
	else
	{
		sprintf (szBuffer, "%d", *x1); 
		XmTextSetString (*color_bar_menu->image1_xstart, szBuffer); 

		sprintf (szBuffer, "%d", *y1); 
		XmTextSetString (*color_bar_menu->image1_ystart, szBuffer); 

		sprintf (szBuffer, "%d", *length1); 
		XmTextSetString (*color_bar_menu->image1_width, szBuffer); 

		sprintf (szBuffer, "%d", *width1); 
		XmTextSetString (*color_bar_menu->image1_height, szBuffer); 

		SetSelectData (*color_bar_menu->image1_orientation, *horizontal_flag1);
		SetSelectData (*color_bar_menu->image1_onoff, *onoff_image1);

		sprintf (szBuffer, "%d", *x2); 
		XmTextSetString (*color_bar_menu->image2_xstart, szBuffer); 

		sprintf (szBuffer, "%d", *y2); 
		XmTextSetString (*color_bar_menu->image2_ystart, szBuffer); 

		sprintf (szBuffer, "%d", *length2); 
		XmTextSetString (*color_bar_menu->image2_width, szBuffer); 

		sprintf (szBuffer, "%d", *width2); 
		XmTextSetString (*color_bar_menu->image2_height, szBuffer); 

		SetSelectData (*color_bar_menu->image2_orientation, *horizontal_flag2);
		SetSelectData (*color_bar_menu->image2_onoff, *onoff_image2);
	}

	XtUnmanageChild (*colorBarData->dialog);
}


/*________________________________________________________________________________________________	
	Procedure:
		BrowseListCallback
	Parameters:
		w: Widget, widget where callback was triggered.
		clientData: caddr_t, client data.
		call_data: caddr_t, callback data.
	Description:
		Callback function to browse list and set selected item to a text fields.
		Author: Tom (Tongzeng) Yang 
		(07/21/91)
________________________________________________________________________________________________*/
void BrowseListCallback (w, clientData, callData)
Widget	w;
caddr_t clientData;
caddr_t callData;
{
	Widget			text_widget	= (Widget) clientData;
	XmListCallbackStruct	*call_data	= (XmListCallbackStruct *) callData;
	char			*text;

	XmStringGetLtoR (call_data->item, XmSTRING_DEFAULT_CHARSET, &text);
	XmTextSetString (text_widget, text); 
}


/*__________________________________________________________________________________	
	Procedure:
		SetTextFontCallback
	Parameters:
		w: Widget, widget where callback was triggered.
		clientData: caddr_t, client data.
		call_data: caddr_t, callback data.
	Description:
		Callback function to set font for label text.
		Author: Tom (Tongzeng) Yang 
		(07/24/91)
__________________________________________________________________________________*/
void SetTextFontCallback (w, clientData, callData)
Widget	w;
caddr_t clientData;
caddr_t callData;
{
	FONT_DATA	*font_data	= (FONT_DATA *)	clientData;
	FONT_MENU	*font_menu	= font_data->font_menu;

	Arg		arglist [1];
	Display		*display	= font_data->draw_data->display;
	GC		gc		= font_data->draw_data->gc;
	Widget		widget_buffer;
	XFontStruct	*font_struct;
	char		*alignment	= &cAlignment;
	char		*buffer;
	char		*color_index	= &cTextColorIndex;
	char		font_color_name [MAXLINE];
	char		*font_string;
	char		*orient_index	= &cFontOrientIndex;
	char		size_string [MAXLINE];
	char		*slant_index	= &cFontSlantIndex;
	char		*weight_index	= &cFontWeightIndex;
	int		i;
	int		*line_spacing	= &nLineSpacing;
	int		n;
	int		point_size;

	widget_buffer	= GetActiveWidget (font_menu->font_color_set, 
						MAX_NONIMAGE_COLOR);
	if (font_data->node_flag != CANCEL)
	{

		n	= 0;
		XtSetArg (arglist [n], XtNbackground, &pixelTextColor); n++;
		XtGetValues (widget_buffer, arglist, n);
		*color_index	
			= (char) GetActiveIndex (font_menu->font_color_set, 
							MAX_NONIMAGE_COLOR);

		*slant_index	= GetActiveIndex (font_menu->slant_set, SLANT_NUM);
		*weight_index	= GetActiveIndex (font_menu->weight_set, WEIGHT_NUM);
		*orient_index	= GetActiveIndex (font_menu->orient_set, ORIENT_NUM);
		*alignment	= GetActiveIndex (font_menu->alignment_set,
						ALIGNMENT_NUM);

		XmScaleGetValue (*font_menu->line_spacing, line_spacing);

		font_string	= GetFontName (font_menu->font_list, 
						font_menu->font_name,
						font_menu->weight_set,
						font_menu->slant_set,
						font_menu->size_list,
						font_menu->size_name);

		/* 
		 * Free old font and load new font. 
		 */
		font_struct	= XLoadQueryFont (display, font_string);
		if (font_struct == 0)
			fprintf (stderr, "Can Not Find Font %s\n", font_string);
		else
		{
			XFreeFont (display, FontStruct);
			FontStruct	= font_struct;
		}

		XtFree (font_string);
	}
	else
	{
		SetSelectData (widget_buffer, False);
		SetSelectData (font_menu->font_color_set[cTextColorIndex], True);

		XmListSelectPos (*font_menu->font_list, nFontNameIndex, True);
		XmTextSetString (*font_menu->font_name, fontTable [nFontNameIndex - 1]);

		XmListSelectPos (*font_menu->size_list, nFontSizeIndex, True);
		XmTextSetString (*font_menu->size_name, fontSizeTable [nFontSizeIndex - 1]);

		widget_buffer	
			= GetActiveWidget (font_menu->slant_set, SLANT_NUM);
		SetSelectData (widget_buffer, False);
		SetSelectData (font_menu->slant_set[*slant_index], True);

		widget_buffer	
			= GetActiveWidget (font_menu->weight_set, WEIGHT_NUM);
		SetSelectData (widget_buffer, False);
		SetSelectData (font_menu->weight_set[*weight_index], True);

		widget_buffer	
			= GetActiveWidget (font_menu->orient_set, WEIGHT_NUM);
		SetSelectData (widget_buffer, False);
		SetSelectData (font_menu->orient_set[*orient_index], True);

		widget_buffer	
			= GetActiveWidget (font_menu->alignment_set, 
					ALIGNMENT_NUM);
		SetSelectData (widget_buffer, False);
		SetSelectData (font_menu->alignment_set[*alignment], True);

		XmScaleSetValue (*font_menu->line_spacing, *line_spacing);
	}

	XtUnmanageChild (font_data->frame);
}


/*________________________________________________________________________________________________	
	Procedure:
		ButtonDownEventHandler
	Parameters:
		w: Widget, widget where callback was triggered.
		clientData: caddr_t, client data.
		event: XEvent, callback data.
	Description:
		Event handling function to for button down.
		Author: Tom (Tongzeng) Yang 
		(07/30/91)
________________________________________________________________________________________________*/
void ButtonDownEventHandler (w, clientData, event)
Widget	w;
caddr_t clientData;
XEvent	*event;
{
	GRAPHICS_DATA	*graphics_data	= (GRAPHICS_DATA *) clientData;

	Display		*display	= graphics_data->draw_data->display;
	GC		gc		= graphics_data->draw_data->gc;
	GC		xorgc		= graphics_data->xorgc;
	PointerStatus	*pointer_state;
	Window		root_window	= DefaultRootWindow (display);
	Window		window		= graphics_data->draw_data->window;
	XFontStruct	*font_struct	= FontStruct;
	XImage		*retimage;
	char		alignment_flag	= cAlignment;
	char		orient		= cFontOrientIndex;
	int		format; 
	int		left;
	int		nitems; 
	int		type; 
	int		xstart;
	int		ystart;
	short		*legend_font_height	= &nAF3DLegendFontHeight;
	short		*legend_height	= &nAF3DLegendHeight;
	short		*legend_width	= &nAF3DLegendWidth;
	static char	*function	= "ButtonDownEventHandler";

	pointer_state	= &cPointerState;
	graphics_data->last_x = graphics_data->start_x = event->xbutton.x;
	graphics_data->last_y = graphics_data->start_y = event->xbutton.y;
	graphics_data->button_down_first	= TRUE;

	switch (*pointer_state)
	{
		case	SaveRegionState:
		case	CutState:
		case	CopyState:
			DrawRectangle (display, window, xorgc, 
					graphics_data->start_x, graphics_data->start_y,
					graphics_data->last_x, graphics_data->last_y);

			break;
		case	PasteState:
			if (XGetWindowProperty (display, root_window, XA_PRIMARY,
					0, sizeof (XImage), FALSE, IMAGE_DATA_TYPE, 
					&type, &format, &nitems, &left, &retimage) 
					== Success && type == IMAGE_DATA_TYPE)
			{
				wClipboard	= retimage->width;
				hClipboard	= retimage->height;
				XDestroyImage (retimage);
			}

			XDrawRectangle (display, window, xorgc, 
					graphics_data->start_x, 
					graphics_data->start_y,
					wClipboard, 
					hClipboard);

			break;
		case	LabelState:
			GetLabelDim (font_struct, szTextString, nLineSpacing, orient, 
			&graphics_data->label_width, &graphics_data->label_height);

			xstart	= graphics_data->start_x;
			ystart	= graphics_data->start_y;
			GetTextStart (orient, alignment_flag, graphics_data->label_width, 
				graphics_data->label_height, &xstart, &ystart);

			XDrawRectangle (display, window, xorgc, xstart, ystart - font_struct->ascent,
					graphics_data->label_width,
					graphics_data->label_height);

			break;
		case	ShowPointState:
		case	ShowMultiplePointState:
			ShowCoordinates (display, window, xorgc, event->xbutton.x, event->xbutton.y, 
				rCurrentScaleHeader, plist1, plist2, cAtlasOrientation, 
				wImageNameCascade, FALSE);
			break;
		case	AF3DLegendState:
			GetLegendDim (display, szAF3DFileNames, MAX_AF3DSET_NUM, AF3D_LEGEND_FONT,
			legend_width, legend_height, legend_font_height);
			XDrawRectangle (display, window, xorgc, 
					graphics_data->start_x - *legend_font_height / 2, 
					graphics_data->start_y - *legend_font_height / 2,
					*legend_width, 
					*legend_height);
			break;
		default:
			break;
	}
}


/*________________________________________________________________________________________________	
	Procedure:
		ButtonMoveEventHandler
	Parameters:
		w: Widget, widget where callback was triggered.
		clientData: caddr_t, client data.
		event: XEvent, callback data.
	Description:
		Event handling function for button move.
		Author: Tom (Tongzeng) Yang 
		(08/15/91)
________________________________________________________________________________________________*/
void ButtonMoveEventHandler (w, clientData, event)
Widget	w;
caddr_t clientData;
XEvent	*event;
{
	GRAPHICS_DATA	*graphics_data	= (GRAPHICS_DATA *) clientData;

	Display		*display	= graphics_data->draw_data->display;
	GC		xorgc		= graphics_data->xorgc;
	Window		window		= graphics_data->draw_data->window;
	XFontStruct	*font_struct	= FontStruct;
	char		alignment_flag	= cAlignment;
	char		orient		= cFontOrientIndex;
	int		xstart;
	int		ystart;
	short		legend_font_height	= nAF3DLegendFontHeight;
	short		*legend_height	= &nAF3DLegendHeight;
	short		*legend_width	= &nAF3DLegendWidth;
	unsigned int	*clipboard_h	= &hClipboard;
	unsigned int	*clipboard_w	= &wClipboard;

	if (graphics_data->button_down_first)
	{
		switch (cPointerState)
		{
			case	SaveRegionState:
			case	CutState:
			case	CopyState:
				DrawRectangle (display, window, xorgc, 
					graphics_data->start_x, graphics_data->start_y, 
					graphics_data->last_x, graphics_data->last_y);

				graphics_data->last_x	= event->xbutton.x,
				graphics_data->last_y	= event->xbutton.y,

				DrawRectangle (display, window, xorgc, 
					graphics_data->start_x, graphics_data->start_y, 
					graphics_data->last_x, graphics_data->last_y);
				break;
			case	PasteState:
				XDrawRectangle (display, window, xorgc, 
					graphics_data->start_x, 
					graphics_data->start_y,
					*clipboard_w, 
					*clipboard_h);

				graphics_data->start_x	= event->xbutton.x,
				graphics_data->start_y	= event->xbutton.y,

				XDrawRectangle (display, window, xorgc, 
					graphics_data->start_x, 
					graphics_data->start_y,
					*clipboard_w, 
					*clipboard_h);

				break;
			case	LabelState:
				xstart	= graphics_data->start_x;
				ystart	= graphics_data->start_y;
				GetTextStart (orient, alignment_flag, graphics_data->label_width, 
					graphics_data->label_height, &xstart, &ystart);

				XDrawRectangle (display, window, xorgc, 
				xstart, ystart - font_struct->ascent,
				graphics_data->label_width, graphics_data->label_height);

				xstart = graphics_data->start_x	= event->xbutton.x;
				ystart = graphics_data->start_y	= event->xbutton.y;
				GetTextStart (orient, alignment_flag, graphics_data->label_width, 
					graphics_data->label_height, &xstart, &ystart);

				XDrawRectangle (display, window, xorgc, 
				xstart, ystart - font_struct->ascent,
				graphics_data->label_width, graphics_data->label_height);

				break;
			case	ShowPointState:
			case	ShowMultiplePointState:
				xstart	= graphics_data->start_x;
				ystart	= graphics_data->start_y;

				ShowCoordinates (display, window, xorgc, xstart, ystart, 
					rCurrentScaleHeader, plist1, plist2, 
					cAtlasOrientation, wImageNameCascade, FALSE);

				xstart = graphics_data->start_x	= event->xbutton.x;
				ystart = graphics_data->start_y	= event->xbutton.y;

				ShowCoordinates (display, window, xorgc, xstart, ystart, 
					rCurrentScaleHeader, plist1, plist2, 
					cAtlasOrientation, wImageNameCascade, FALSE);

				break;
			case	AF3DLegendState:
				XDrawRectangle (display, window, xorgc, 
					graphics_data->start_x - legend_font_height / 2, 
					graphics_data->start_y - legend_font_height / 2,
					*legend_width, 
					*legend_height);

				graphics_data->start_x	= event->xbutton.x;
				graphics_data->start_y	= event->xbutton.y;

				XDrawRectangle (display, window, xorgc, 
					graphics_data->start_x - legend_font_height / 2, 
					graphics_data->start_y - legend_font_height / 2,
					*legend_width, 
					*legend_height);
				break;
			default:
				break;
		}
	}
}


/*________________________________________________________________________________________________	
	Procedure:
		ButtonReleaseEventHandler
	Parameters:
		w: Widget, widget where callback was triggered.
		clientData: caddr_t, client data.
		event: XEvent, callback data.
	Description:
		Event handling function for button release.
		Author: Tom (Tongzeng) Yang 
		(08/16/91)
________________________________________________________________________________________________*/
void ButtonReleaseEventHandler (w, clientData, event)
Widget	w;
caddr_t clientData;
XEvent	*event;
{
	GRAPHICS_DATA		*graphics_data	= (GRAPHICS_DATA *) clientData;

	Colormap		colormap;
	Display			*display	= graphics_data->draw_data->display;
	GC			gc		= graphics_data->draw_data->gc;
	GC			xorgc		= graphics_data->xorgc;
	PointerStatus		*pointer_state;
	Window			root_window	= DefaultRootWindow (display);
	Window			window		= graphics_data->draw_data->window;
	XColor			*colors;
	XColor			*retcolors;
	XFontStruct		*font_struct	= FontStruct;
	XImage			*image;
	XImage			*retimage;
	XmString		clip_label;
	XWindowAttributes	win_info;
	char			alignment_flag	= cAlignment;
	char			*image_data;
	char			orient		= cFontOrientIndex;
	char			*retimage_data;
	char			szBuffer [MAXLINE];
	char			*text_string	= szTextString;
	int			format;
	int			i;
	int			id;
	int			left;
	int			length;
	int			ncolors;
	int			nitems;
	int			result;
	int			*retncolors;
	int			type;
	int			x;
	int			y;
	int			x2;
	int			y2;
	long			dataid;
	long			itemid;
	short			legend_font_height	= nAF3DLegendFontHeight;
	static int		cnt;
	unsigned int		buffer_size;
	unsigned int		*clipboard_w	= &wClipboard;
	unsigned int		*clipboard_h	= &hClipboard;

	pointer_state	= &cPointerState;

	if (graphics_data->button_down_first)
	{
		switch (*pointer_state)
		{
			case	SaveRegionState:
			case	CutState:
			case	CopyState:
				DrawRectangle (display, window, xorgc, 
					graphics_data->start_x, graphics_data->start_y, 
					graphics_data->last_x, graphics_data->last_y);

				graphics_data->last_x	= event->xbutton.x,
				graphics_data->last_y	= event->xbutton.y,

				x	= graphics_data->start_x;
				y	= graphics_data->start_y;
				x2	= graphics_data->last_x;
				y2	= graphics_data->last_y;
				CheckPoints (&x, &y, &x2, &y2);
				if (x == x2 || y == y2)
					break;

				*clipboard_w	= x2 - x;
				*clipboard_h	= y2 - y;

				if (*pointer_state != SaveRegionState) 
				{
					if (!XGetWindowAttributes (display, window, &win_info)) 
						fprintf (stderr, "Can't get target window attributes.");

					ncolors	= GetXColors (display, &win_info, &colors);

					image	= XGetImage (display, window, x, y, 
							x2 - x, y2 - y, AllPlanes, ZPixmap);
					if (!image) 
					{
						fprintf (stderr, "unable to get image at %dx%d+%d+%d\n",
							x2 -x, y2 - y, x, y);
						exit (1);
					}
					XChangeProperty (display, root_window, XA_PRIMARY,
						IMAGE_DATA_TYPE, 32, PropModeReplace,
						(unsigned char *) image,
						sizeof (XImage) / 4);

					XChangeProperty (display, root_window, XA_SECONDARY,
						IMAGE_COLOR_TYPE, 32, PropModeReplace,
						(unsigned char *) colors,
						ncolors * sizeof (XColor) / 4);

					XChangeProperty (display, root_window, IMAGE_NCOLOR,
						XA_INTEGER, 16, PropModeReplace,
						(unsigned char *) &ncolors,
						sizeof (int) / 2);

					if (ncolors > 0) 
						free (colors);

					if ((*pointer_state == CutState) && x2 > x && y2 > y)
						XClearArea (display, window, 
							x, y, x2 - x, y2 - y, FALSE);

					/* alloc the pixel buffer */
					buffer_size	= Image_Size (image);
					if ((image_data = malloc (buffer_size)) == NULL)
						printf (stderr, "Can't malloc data buffer.");
					for (i = 0; i < buffer_size; i++)
						image_data[i] = image->data[i];
					
					/* 
					 * Begin the copy. If the clipboard is locked,
					 * keep trying.
					 */
					clip_label = XmStringCreateSimple ("to_clipboard");
					while ((result = 
						XmClipboardStartCopy (display, window, clip_label,
							XtLastTimestampProcessed (display),
							NULL, NULL, &itemid)) != ClipboardSuccess)
						;
					XmStringFree (clip_label);

					/*
					 * Copy the data.
					 */
					while ((result = 
						XmClipboardCopy (display, window, itemid,
							"STRING", image_data, buffer_size,
							cnt, NULL)) != ClipboardSuccess)
						;

					/*
					 * End the transaction.
					 */
					while ((result = 
						XmClipboardEndCopy (display, window, itemid)) 
						!= ClipboardSuccess)
						;

					free (image_data);
					XDestroyImage (image);
				}
				else
				{
					WindowDump (display, window, TRUE, 
							x, y, x2 - x, y2 - y);
				}

				break;
			case	PasteState:
				XDrawRectangle (display, window, xorgc, 
					graphics_data->start_x, 
					graphics_data->start_y,
					*clipboard_w, 
					*clipboard_h);

				graphics_data->start_x	= event->xbutton.x;
				graphics_data->start_y	= event->xbutton.y;

				if (XGetWindowProperty (display, root_window, XA_PRIMARY,
						0, sizeof (XImage), FALSE, IMAGE_DATA_TYPE, 
						&type, &format, &nitems, &left, &retimage) 
						== Success && type == IMAGE_DATA_TYPE)
				{
					if (XGetWindowProperty (display, root_window, 
						IMAGE_NCOLOR, 0, sizeof (int), FALSE, 
						XA_INTEGER, &type, &format, &nitems, 
						&left, &retncolors) 
						!= Success || type != XA_INTEGER)
					{
						return;
					}

					if (XGetWindowProperty (display, root_window, 
						XA_SECONDARY, 0, *retncolors * sizeof (XColor), 
						FALSE, IMAGE_COLOR_TYPE, &type, &format, 
						&nitems, &left, &retcolors) 
						!= Success || type != IMAGE_COLOR_TYPE)
					{
						return;
					}

					/*
				 	 * Retrieve the current contents of the clipboard.
				 	 */
					do 
					{
						result	= XmClipboardInquireLength (display,
							window, "STRING", &length);
					} while (result == ClipboardLocked);

					if (length == 0)
						return;

					retimage_data	= XtMalloc (length);

					do
					{
						result = XmClipboardRetrieve (display, window,
							"STRING", retimage_data, length, &x, &id);
					} while (result == ClipboardLocked);

					retimage->data	= retimage_data;

					colormap	= DefaultColormap (display, 
								DefaultScreen (display));
					DoPseudo (display, &colormap, *retncolors, 
							retcolors, retimage, retimage);

					XPutImage(display, window, gc, retimage, 0, 0, 
						graphics_data->start_x, 
						graphics_data->start_y, 
			  			retimage->width, retimage->height);

					XtFree (retncolors);
					XtFree (retcolors);

					XtFree (retimage_data);

					XDestroyImage (retimage);

					ImageColormap (display, graphics_data->root_window, 
						szImage1ColorTableName, szImage2ColorTableName);
				}

				break;
			case	ShowPointState:
			case	ShowMultiplePointState:
				x	= graphics_data->start_x;
				y	= graphics_data->start_y;

				ShowCoordinates (display, window, xorgc, x, y,
					rCurrentScaleHeader, plist1, plist2, 
					cAtlasOrientation, wImageNameCascade, FALSE);

				x = graphics_data->start_x = event->xbutton.x;
				y = graphics_data->start_y = event->xbutton.y;

				ShowCoordinates (display, window, gc, x, y,
					rCurrentScaleHeader, plist1, plist2, 
					cAtlasOrientation, wImageNameCascade, TRUE);

				break;
			case	LabelState:
				x	= graphics_data->start_x;
				y	= graphics_data->start_y;
				GetTextStart (orient, alignment_flag, graphics_data->label_width, 
					graphics_data->label_height, &x, &y);

				XDrawRectangle (display, window, xorgc, x, y - font_struct->ascent,
					graphics_data->label_width, graphics_data->label_height);

				graphics_data->start_x	= event->xbutton.x;
				graphics_data->start_y	= event->xbutton.y;

				DrawLabel (display, window, gc, 
					graphics_data->start_x, graphics_data->start_y, 
					graphics_data->last_x, graphics_data->last_y, 
					pixelTextColor, font_struct, text_string, 
					alignment_flag, nLineSpacing, orient);

				XtFree (text_string);

				sprintf (szBuffer, "%d", graphics_data->start_x);
				XmTextSetString (graphics_data->xtext_edit_coord, szBuffer);
				sprintf (szBuffer, "%d", graphics_data->start_y);
				XmTextSetString (graphics_data->ytext_edit_coord, szBuffer);

				*pointer_state	= NoState; 

				break;
			case	AF3DLegendState:
				XDrawRectangle (display, window, xorgc, 
					graphics_data->start_x - legend_font_height / 2, 
					graphics_data->start_y - legend_font_height / 2,
					nAF3DLegendWidth,
					nAF3DLegendHeight);

				graphics_data->start_x	= event->xbutton.x;
				graphics_data->start_y	= event->xbutton.y;

				DrawLegend (display, window, gc, 
					graphics_data->start_x, 
					graphics_data->start_y, 
					szAF3DFileNames, 
					MAX_AF3DSET_NUM, 
					AF3D_LEGEND_FONT, 
					pixelTextColor,
					pixelAF3DColor, 
					cSymbolType);

				break;
			default:
				break;
		}
	}

	if (*pointer_state != ShowMultiplePointState)
	{
		*pointer_state				= NoState; 
		graphics_data->button_down_first	= FALSE;
	}
}


/*________________________________________________________________________________________________	
	Procedure:
		TextEditCallback
	Parameters:
		Widget	w;
		caddr_t clientData;
		caddr_t callData;
	Description:
		Callback function to select text for labels.
		Author: Tom (Tongzeng) Yang 
		(08/1/91)
________________________________________________________________________________________________*/
Widget TextEditCallback (w, clientData, callData)
Widget	w;
caddr_t clientData;
caddr_t callData;
{
	TEXT_EDIT_DATA	*text_edit_data	= (TEXT_EDIT_DATA *) clientData;

	PointerStatus	*pointer_state; 
	char		*str1;
	char		*str2;
	char		szBuffer [MAXLINE];
	char		*text_string;
	short		*xstart		= &xTextEditStart;
	short		*ystart		= &yTextEditStart;

	pointer_state	= &cPointerState; 

	/*
	 * Get the string of text.
	 */
	if (text_edit_data->node_flag == SELECT || text_edit_data->node_flag == REDRAW)
	{
		text_string = szTextString = XmTextGetString (text_edit_data->text);
	}

	/*
	 * Set the pointer status.
	 */
	if (text_edit_data->node_flag == SELECT)
	{
		*pointer_state	= LabelState; 
	}
	else
	{
		*pointer_state	= NoState; 
	}

	/*
	 * Processing.
	 */
	if (text_edit_data->node_flag == REDRAW)
	{
		str1 = XmTextGetString (text_edit_data->xstart);
		str2 = XmTextGetString (text_edit_data->ystart);

		if (strlen (str1) > 0 && strlen (str2) > 0)
		{
			*xstart	= atoi (str1);
			*ystart	= atoi (str2);
		}
		XtFree (str1);
		XtFree (str2);

		DrawLabel (text_edit_data->draw_data->display, 
			text_edit_data->draw_data->window, 
			text_edit_data->draw_data->gc, 
			*xstart, *ystart, 0, 0, 
			pixelTextColor, FontStruct, szTextString, 
			cAlignment, nLineSpacing, cFontOrientIndex);
		XtFree (text_string);
	}
	else if (text_edit_data->node_flag == CANCEL)
	{
		sprintf (szBuffer, "%d", *xstart);
		XmTextSetString (text_edit_data->xstart, szBuffer);
		sprintf (szBuffer, "%d", *ystart);
		XmTextSetString (text_edit_data->ystart, szBuffer);
	}

	XtUnmanageChild (text_edit_data->dialog);
}


/*______________________________________________________________________________________	
	Procedure:
		SelectSlicesCallback
	Parameters:
		w: Widget, widget where callback was triggered.
		clientData: caddr_t, client data.
		call_data: caddr_t, callback data.
	Description:
		Callback function for setting the current display state and change the
		Text in first, last, and spacing widgets.
		Author: Tom Yang 
		(08/14/91)
______________________________________________________________________________________*/

void		SelectSlicesCallback (w, clientData, callData)
Widget		w;
caddr_t		clientData;
caddr_t		callData;
{
	XmToggleButtonCallbackStruct	*ToggleData		
						= (XmToggleButtonCallbackStruct *) callData;
	SELECT_SLICES_DATA		*select_slices_data
						= (SELECT_SLICES_DATA *) clientData;
	Widget				text_first	= select_slices_data->text_first;
	Widget				text_last	= select_slices_data->text_last;
	Widget				text_spacing	= select_slices_data->text_spacing;

	Arg				arglist [2];
	BOOLEAN				status;
	XmString			xmstr;
	char				szBuffer [MAXLINE];
	char				atlas_orient;
	int				n;
	short				first_value	= nFirstSlice;	
	short				last_value	= nLastSlice;
	short				spacing_value	= nSpacing;

	atlas_orient	= GetActiveIndex (select_slices_data->orientation_set, ORIENTATION_NUM);
	status		= ToggleData->set;
	n		= 0;
	XtSetArg (arglist [n], XmNset, status); n++;

	if (status)
		strcpy (szBuffer, "Slice Numbers");
	else if (atlas_orient == TRANSVERSE)
		strcpy (szBuffer, "Z Values");
	else if (atlas_orient == CORONAL)
		strcpy (szBuffer, "Y Values");
	else 
		strcpy (szBuffer, "X Values");

	if (!status)
	{
		spacing_value	*= 2; 
		first_value	= GetSliceCoord (first_value, atlas_orient, zorigin_image1);
		last_value	= GetSliceCoord (last_value, atlas_orient, zorigin_image1);
	}

	xmstr	= XmStringCreate (szBuffer, XmSTRING_DEFAULT_CHARSET); 
	n	= 0;
	XtSetArg (arglist [n], XmNlabelString, xmstr); n++;
	XtSetValues (w, arglist, n);
	XtFree (xmstr);

	sprintf (szBuffer, "%d", first_value);
	XmTextSetString (text_first, szBuffer);

	sprintf (szBuffer, "%d", last_value);
	XmTextSetString (text_last, szBuffer);

	sprintf (szBuffer, "%d", spacing_value);
	XmTextSetString (text_spacing, szBuffer);
}


/*______________________________________________________________________________________	
	Procedure:
		SetAtlasOrientCallback

	Parameters:
		w:		Widget, widget where callback was triggered.
		clientData:	caddr_t, client data.
		call_data:	caddr_t, callback data.

	Description:
		Callback function for setting the current toggle button for the 
		atlas orientation and changing the label for the X, Y, and Z values
		accordingly.

	Author:	Tom Yang 
		(08/17/94)
______________________________________________________________________________________*/

void SetAtlasOrientCallback (w, clientData, callData)
Widget	w;
caddr_t clientData;
caddr_t callData;
{
	DATA_TYPE_MENU	*data_type_menu	= (DATA_TYPE_MENU *) clientData;

	Arg		arglist [1];
	BOOLEAN		slice_num_flag;
	XmString	xmstr;
	char		atlas_orient;
	char		szBuffer [MAXLINE];
	int		n;

	if (XmToggleButtonGetState (w))
	{
		n	= 0;
		XtSetArg (arglist [n], XmNset, TRUE); n++;
		XtSetValues (w, arglist, n);
	}

	slice_num_flag	= XmToggleButtonGetState (*data_type_menu->slice_num_flag);
	atlas_orient	= GetActiveIndex (data_type_menu->orientation_set, ORIENTATION_NUM);
	if (slice_num_flag)
		strcpy (szBuffer, "Slice Numbers");
	else if (atlas_orient == TRANSVERSE)
		strcpy (szBuffer, "Z Values");
	else if (atlas_orient == CORONAL)
		strcpy (szBuffer, "Y Values");
	else 
		strcpy (szBuffer, "X Values");

	n	= 0;
	xmstr	= XmStringCreate (szBuffer, XmSTRING_DEFAULT_CHARSET); 
	XtSetArg (arglist [n], XmNlabelString, xmstr); n++;
	XtSetValues (*data_type_menu->slice_num_flag, arglist, n);
	XtFree (xmstr);
}

void MagnificationScaleCallback (w, clientData, callData)
Widget w;
caddr_t clientData;
caddr_t callData;
{
	MAGNIFICATION_SCALE_DATA	*magnification_scale_data 
						= (MAGNIFICATION_SCALE_DATA *) clientData;
	char				szBuffer [MAXLINE];
	short				min;
	short				max;

	XtManageChild (magnification_scale_data->dialog);

	GetImageMinMax (TRUE, bAutoImage1ValueFlag, &min, &max);
	sprintf (szBuffer, "%d", min); 
	XmTextSetString (magnification_scale_data->image1_text_min, szBuffer); 
	sprintf (szBuffer, "%d", max); 
	XmTextSetString (magnification_scale_data->image1_text_max, szBuffer); 

	GetImageMinMax (FALSE, bAutoImage2ValueFlag, &min, &max);
	sprintf (szBuffer, "%d", min); 
	XmTextSetString (magnification_scale_data->image2_text_min, szBuffer); 
	sprintf (szBuffer, "%d", max); 
	XmTextSetString (magnification_scale_data->image2_text_max, szBuffer); 
}


/*____________________________________________________________________________	
	Procedure:
		ShowRegionMenuCallback
	Parameters:
		w: Widget, widget where callback was triggered.
		clientData: caddr_t, client data.
		call_data: caddr_t, callback data.
	Description:
		Callback function for opening region menu.
		Author: Tom Yang 
		(05/20/93)
____________________________________________________________________________*/

void ShowRegionMenuCallback (w, clientData, callData)
Widget w;
caddr_t clientData;
caddr_t callData;
{
	Widget dialog = (Widget) clientData;

	cOldActiveRegionSet	= cActiveRegionSet;

	XtManageChild (dialog);
}


/*______________________________________________________________________________________	
	Procedure:
		SelectTalairachRegionCallback
	Parameters:
		w: Widget, widget where callback was triggered.
		clientData: caddr_t, client data.
		call_data: caddr_t, callback data.
	Description:
		Callback function for setting the current region coordinates, either
		the Talairach or the HD6 coordinates. The label for toggleTalairach88Region
		changes dynamically.
		Author: Tom Yang 
		(06/04/93)
______________________________________________________________________________________*/

void		SelectTalairachRegionCallback (w, clientData, callData)
Widget		w;
caddr_t		clientData;
caddr_t		callData;
{
	Arg				arglist [2];
	BOOLEAN				status;
	XmToggleButtonCallbackStruct	*ToggleData;		
	char				szBuffer [MAXLINE];
	int				n;

	ToggleData	= (XmToggleButtonCallbackStruct *) callData;
	status		= ToggleData->set;
	if (status)
		strcpy (szBuffer, "hd6tot88");
	else 
		strcpy (szBuffer, "original");

	n	= 0;
	XtSetArg (arglist [n], XmNset, status); n++;
	XtSetArg (arglist [n], XmNlabelString,
		XmStringCreate (szBuffer, XmSTRING_DEFAULT_CHARSET)); n++;
	XtSetValues (w, arglist, n);
}


/*____________________________________________________________________________	
	Procedure:
		RegionCallback
	Parameters:
		w: Widget, widget where callback was triggered.
		clientData: caddr_t, client data.
		call_data: caddr_t, callback data.
	Description:
		Callback function for processing regions of interest.
		Author: Tom Yang 
		(05/21/93)
____________________________________________________________________________*/

void		RegionCallback (w, clientData, callData)
Widget		w;
caddr_t		clientData;
caddr_t		callData;
{
	REGION_DATA	*region_data		= (REGION_DATA *) clientData;
	REGION_MENU	*region_menu		= region_data->region_menu;
	Screen		*screen;
	BOOLEAN		*display_region		= bDisplayRegion;
	BOOLEAN		*talairach_region	= &bTalairachRegionFlag;
	char		*region_type		= cRegionType;
	char		*dynamic_region_type	= cDynamicRegionType;
	char		*region_color		= cRegionColor;
	char		*dynamic_region_color	= cDynamicRegionColor;
	Pixel		*pixel_region_color	= pixelRegionColor;
	Pixel		foreground;
	Pixel		background;
	Pixmap		pixmap_symbol;
	int		n;
	Arg		arglist [3];
	int		i;
	char		alter_index		= cOldActiveRegionSet;
	char		shape_index;
	char		szBuffer [MAXLINE];

	if (region_data->node_flag != CANCEL)
	{
		wActiveRegionColor	= GetActiveWidget (region_menu->toggle_color_set, 
								MAX_NONIMAGE_COLOR);

		for (i = 0; i < MAX_REGIONSET_NUM; i++)
		{
			*(display_region + i)	= XmToggleButtonGetState 
							(region_menu->display_onoff_set [i]);

			/*
			 * Get region color code.
			 */
			*(region_color + i)	= *(dynamic_region_color + i);

			/*
			 * Get region color pixel and shape code.
			 */
			n = 0;
			XtSetArg (arglist [n], XtNforeground, pixel_region_color + i); n++;
			XtGetValues (region_menu->toggle_color_set [*(region_color + i)], arglist, n);

			*(region_type + i)		= *(dynamic_region_type + i);
		}

		*talairach_region	= XmToggleButtonGetState (*region_menu->toggle_talairach_region);

		if (region_data->node_flag == REDRAW)
		{
			RedrawPortals (region_data->draw_data, alist1, plist1, alist2, plist2);
		}
	}
	else
	{
		n = 0;
		XtSetArg (arglist [n], XtNbackground, &background); n++;
		XtGetValues (region_menu->toggle_pattern_set [0], arglist, n);

		screen	= XtScreen (region_menu->label_pattern_set [0]);

		for (i = 0; i < MAX_REGIONSET_NUM; i++)
		{
			SetSelectData (region_menu->display_onoff_set [i], *(display_region + i));

			n = 0;
			XtSetArg (arglist [n], XtNforeground, &foreground); n++;
			XtGetValues (region_menu->toggle_color_set [*(region_color + i)], arglist, n);

			pixmap_symbol	= XmGetPixmap (screen,  
						region_data->symbol_name [*(region_type + i)], 
						foreground, background);

			n = 0;
			XtSetArg (arglist [n], XmNlabelType, XmPIXMAP); n++;
			XtSetArg (arglist [n], XmNlabelPixmap, pixmap_symbol); n++;
			XtSetValues (region_menu->label_pattern_set [i], arglist, n);
		}

		SetSelectData (GetActiveWidget (region_menu->toggle_alter_set, MAX_REGIONSET_NUM), False);
		SetSelectData (region_menu->toggle_alter_set [alter_index], True);

		SetSelectData (GetActiveWidget (region_menu->toggle_color_set, MAX_NONIMAGE_COLOR), False);
		SetSelectData (region_menu->toggle_color_set [*(region_color + alter_index)], True);

		SetSelectData (GetActiveWidget (region_menu->toggle_pattern_set, REGION_STYLE_NUM), False);
		if (*(region_type + alter_index) < SOLID_RECT_INDEX)
			shape_index	= REGION_OUTLINE; 
		else if (*(region_type + alter_index) == SOLID_RECT_INDEX)
			shape_index	= REGION_FILLED; 
		else
			shape_index	= REGION_PIXEL; 
		SetSelectData (region_menu->toggle_pattern_set [shape_index], True);

		if (*talairach_region)
			strcpy (szBuffer, "Talairach 88");
		else 
			strcpy (szBuffer, "HD6");

		n	= 0;
		XtSetArg (arglist [n], XmNset, *talairach_region); n++;
		XtSetArg (arglist [n], XmNlabelString, XmStringCreate (szBuffer, 
			XmSTRING_DEFAULT_CHARSET)); n++;
		XtSetValues (*region_menu->toggle_talairach_region, arglist, n);
	}

	XtUnmanageChild (region_data->dialog);
}


/*______________________________________________________________________________________	
	Procedure:
		DynamicPatternChangeCallback
	Parameters:
		w: Widget, widget where callback was triggered.
		clientData: caddr_t, client data.
		call_data: caddr_t, callback data.
	Description:
		Callback function for dynamic processing pattern changes for regions of 
		interest.
		Author: Tom Yang 
		(05/21/93)
______________________________________________________________________________________*/

void		DynamicPatternChangeCallback (w, clientData, callData)
Widget		w;
caddr_t		clientData;
caddr_t		callData;
{
	Arg			arglist [3];
	REGION_SHOW_DATA	*region_show_data	= (REGION_SHOW_DATA *) clientData;
	REGION_BASIC_DATA	*region_basic_data	= region_show_data->region_basic_data;
	Pixel			background;
	Pixel			foreground;
	Pixmap			pixmap_symbol;
	Widget			color_widget		= wActiveRegionColor;
	char			alter_index		= cActiveRegionSet;
	char			active_pattern		= cActivePatternType;
	char			*region_type		= cRegionType;
	int			n;

	if (region_show_data->color_flag != FAIL) 
	{
		color_widget	= w;
		cDynamicRegionColor [alter_index]	= region_show_data->color_flag;

		if (XmToggleButtonGetState (w))
		{
			n = 0;
			XtSetArg (arglist [n], XmNset, TRUE); n++;
			XtSetValues (w, arglist, n);

			wActiveRegionColor	= w;
		}
	}

	n = 0;
	XtSetArg (arglist [n], XtNforeground, &foreground); n++;
	XtGetValues (color_widget, arglist, n);

	n = 0;
	XtSetArg (arglist [n], XtNbackground, &background); n++;
	XtGetValues (region_basic_data->pattern [0], arglist, n);

	pixmap_symbol	= XmGetPixmap (XtScreen (region_basic_data->pattern_label [alter_index]),  
				region_basic_data->symbol_name [active_pattern], 
				foreground, background);

	n = 0;
	XtSetArg (arglist [n], XmNlabelType, XmPIXMAP); n++;
	XtSetArg (arglist [n], XmNlabelPixmap, pixmap_symbol); n++;
	XtSetValues (region_basic_data->pattern_label [alter_index], arglist, n);

	cDynamicRegionType [alter_index]	= active_pattern;
}


/*______________________________________________________________________________________	
	Procedure:
		AlterRegionCallback
	Parameters:
		w: Widget, widget where callback was triggered.
		clientData: caddr_t, client data.
		call_data: caddr_t, callback data.
	Description:
		Callback function for changing to a new region data set.
		Author: Tom Yang 
		(07/07/92)
______________________________________________________________________________________*/

void AlterRegionCallback (w, clientData, callData)
Widget	w;
caddr_t clientData;
caddr_t callData;
{
	ALTER_REGION_DATA	*alter_region_data	
				= (ALTER_REGION_DATA *) clientData;
	REGION_BASIC_DATA	*region_basic_data
				= alter_region_data->region_basic_data;
	int			n;
	int			i;
	Arg			arglist [3];
	Pixel			background;
	Pixel			foreground;
	Pixmap			pixmap_symbol;
	char			*alter_index	= &cActiveRegionSet;
	char			*active_pattern	= &cActivePatternType;
	char			*region_type	= cRegionType;
	char			shape_index;
	Widget			*color_widget	= &wActiveRegionColor;
	char			string [MAXLINE];

	if (XmToggleButtonGetState (w))
	{
		n = 0;
		XtSetArg (arglist [n], XmNset, TRUE); n++;
		XtSetValues (w, arglist, n);

		*alter_index	= alter_region_data->set_index;

		SetSelectData (region_basic_data->display_onoff [*alter_index], 
				bDisplayRegion [*alter_index]);

		SetSelectData (GetActiveWidget (region_basic_data->pattern_color, 
						MAX_NONIMAGE_COLOR), False);
		*color_widget	= region_basic_data->pattern_color [cRegionColor [*alter_index]];
		SetSelectData (*color_widget, True);

		*active_pattern	= *(region_type + *alter_index);
		if (*active_pattern < SOLID_RECT_INDEX)
			shape_index	= REGION_OUTLINE; 
		else if (*active_pattern == SOLID_RECT_INDEX)
			shape_index	= REGION_FILLED; 
		else
			shape_index	= REGION_PIXEL; 
		SetSelectData (GetActiveWidget (region_basic_data->pattern, REGION_STYLE_NUM), False);
		SetSelectData (region_basic_data->pattern [shape_index], True);

		n = 0;
		XtSetArg (arglist [n], XtNforeground, &foreground); n++;
		XtGetValues (*color_widget, arglist, n);

		n = 0;
		XtSetArg (arglist [n], XtNbackground, &background); n++;
		XtGetValues (region_basic_data->pattern [0], arglist, n);

		pixmap_symbol	= XmGetPixmap (XtScreen (region_basic_data->pattern_label [*alter_index]),  
						region_basic_data->symbol_name [*active_pattern], 
						foreground, background);

		n = 0;
		XtSetArg (arglist [n], XmNlabelType, XmPIXMAP); n++;
		XtSetArg (arglist [n], XmNlabelPixmap, pixmap_symbol); n++;
		XtSetValues (region_basic_data->pattern_label [*alter_index], arglist, n);
	}
}


/*____________________________________________________________________________	
	Procedure:
		ShowAF3DMenuCallback
	Parameters:
		w: Widget, widget where callback was triggered.
		clientData: caddr_t, client data.
		call_data: caddr_t, callback data.
	Description:
		Callback function for opening AF3D representation menu.
		Author: Tom Yang 
		(05/08/92)
____________________________________________________________________________*/

void ShowAF3DMenuCallback (w, clientData, callData)
Widget w;
caddr_t clientData;
caddr_t callData;
{
	Widget dialog = (Widget) clientData;

	cOldActiveAF3DSet	= cActiveAF3DSet;
	XtManageChild (dialog);
}


/*____________________________________________________________________________	
	Procedure:
		AF3DSymbolCallback
	Parameters:
		w: Widget, widget where callback was triggered.
		clientData: caddr_t, client data.
		call_data: caddr_t, callback data.
	Description:
		Callback function for setting AF3D symbols.
		Author: Tom Yang 
		(08/28/91)
____________________________________________________________________________*/

void		AF3DSymbolCallback (w, clientData, callData)
Widget		w;
caddr_t		clientData;
caddr_t		callData;
{
	Arg		arglist [3];
	BOOLEAN		*all_planes		= &bAllPlanes;
	BOOLEAN		*display_symbol		= bDisplaySymbol;
	BOOLEAN		filled;
	Pixel		background;
	Pixel		foreground;
	Pixel		*pixel_symbol_color	= pixelAF3DColor;
	Pixmap		pixmap_symbol;
	Screen		*screen;
	SYMBOL_DATA	*symbol_data		= (SYMBOL_DATA *) clientData;
	SYMBOL_MENU	*symbol_menu		= symbol_data->symbol_menu;
	XmString	*xmsize_symbol		= xmStrSymbolSize;
	char		alter_index		= cOldActiveAF3DSet;
	char		*dynamic_symbol_color	= cDynamicSymbolColor;
	char		*dynamic_symbol_type	= cDynamicSymbolType;
	char		*string;
	char		string1 [MAXLINE];
	char		*symbol_color		= cSymbolColor;
	char		*symbol_type		= cSymbolType;
	float		*max_distance		= &dMaximumDistance;	
	int		i;
	int		n;
	int 		*outline_width		= &nOutlineWidth;
	unsigned short	*symbol_size		= nSymbolSize;

	if (symbol_data->node_flag != CANCEL)
	{
		wActiveAF3DColor	= GetActiveWidget (symbol_menu->toggle_color_set, 
								MAX_NONIMAGE_COLOR);

		for (i = 0; i < MAX_AF3DSET_NUM; i++)
		{
			*(display_symbol + i)	= XmToggleButtonGetState 
							(symbol_menu->display_onoff_set [i]);

			/*
			 * Get symbol color code.
			 */
			*(symbol_color + i)	= *(dynamic_symbol_color + i);

			/*
			 * Get symbol color pixel and shape code.
			 */
			n = 0;
			XtSetArg (arglist [n], XtNforeground, pixel_symbol_color + i); n++;
			XtGetValues (symbol_menu->toggle_color_set [*(symbol_color + i)], arglist, n);

			*(symbol_type + i)	= *(dynamic_symbol_type + i);

			/*
			 * Get symbol size.
			 */
			n = 0;
			XtFree (*(xmsize_symbol + i));
			XtSetArg (arglist [n], XmNlabelString, xmsize_symbol + i); n++;
			XtGetValues (symbol_menu->label_symbol_size_set [i], arglist, n);

			string	= xmstr2str (*(xmsize_symbol + i));
			*(symbol_size + i)	= atoi (string);
			XtFree (string);
		}

		*all_planes	= XmToggleButtonGetState (*symbol_menu->all_planes);

		XmScaleGetValue (*symbol_menu->outline_width, outline_width);

		string		= XmTextGetString (*symbol_menu->text_maximum_distance);
		*max_distance	= atof (string);
		if (*max_distance < 0.0)
			*max_distance = 1.0;
		XtFree (string);

		if (symbol_data->node_flag == REDRAW)
		{
			RedrawPortals (symbol_data->draw_data, alist1, plist1, alist2, plist2);
		}
	}
	else
	{
		n = 0;
		XtSetArg (arglist [n], XtNbackground, &background); n++;
		XtGetValues (symbol_menu->toggle_symbol_set [0], arglist, n);

		screen	= XtScreen (symbol_menu->label_symbol_set [0]);

		for (i = 0; i < MAX_AF3DSET_NUM; i++)
		{
			SetSelectData (symbol_menu->display_onoff_set [i], *(display_symbol + i));

			n = 0;
			XtSetArg (arglist [n], XtNforeground, &foreground); n++;
			XtGetValues (symbol_menu->toggle_color_set [*(symbol_color + i)], arglist, n);

			pixmap_symbol	= XmGetPixmap (screen,  
						symbol_data->symbol_name [*(symbol_type + i)], 
						foreground, background);

			n = 0;
			XtSetArg (arglist [n], XmNlabelType, XmPIXMAP); n++;
			XtSetArg (arglist [n], XmNlabelPixmap, pixmap_symbol); n++;
			XtSetValues (symbol_menu->label_symbol_set [i], arglist, n);

			XtFree (xmsize_symbol [i]);
			itoa (*(symbol_size + i), string1);
			xmsize_symbol [i]	= XmStringCreate (string1, 
							XmSTRING_DEFAULT_CHARSET); 
			n = 0;
			XtSetArg (arglist [n], XmNlabelString, *(xmsize_symbol + i)); n++;
			XtSetValues (symbol_menu->label_symbol_size_set [i], arglist, n);

		}

		SetSelectData (GetActiveWidget (symbol_menu->toggle_alter_set, MAX_AF3DSET_NUM), False);
		SetSelectData (symbol_menu->toggle_alter_set [alter_index], True);

		SetSelectData (GetActiveWidget (symbol_menu->toggle_color_set, MAX_NONIMAGE_COLOR), False);
		SetSelectData (symbol_menu->toggle_color_set [*(symbol_color + alter_index)], True);

		if (*(symbol_type + alter_index) >= MAX_SYMBOL_NUM)
		{
			i	= *(symbol_type + alter_index) - MAX_SYMBOL_NUM;
			filled	= True;
		}
		else
		{
			i	= *(symbol_type + alter_index);
			filled	= False;
		}
		SetSelectData (GetActiveWidget (symbol_menu->toggle_symbol_set, MAX_SYMBOL_NUM), False);
		SetSelectData (symbol_menu->toggle_symbol_set [i], True);
		SetSelectData (*symbol_menu->all_planes, *all_planes);

		SetSelectData (*symbol_menu->filled, filled);

		XmScaleSetValue (*symbol_menu->size_scale, *(symbol_size + alter_index));

		XmScaleSetValue (*symbol_menu->outline_width, *outline_width);

		sprintf (string1, "%.1f", *max_distance);
		XmTextSetString (*symbol_menu->text_maximum_distance, string1); 

	}

	XtUnmanageChild (symbol_data->dialog);
}


/*______________________________________________________________________________________	
	Procedure:
		DynamicSymbolChangeCallback
	Parameters:
		w: Widget, widget where callback was triggered.
		clientData: caddr_t, client data.
		call_data: caddr_t, callback data.
	Description:
		Callback function for setting AF3D symbols.
		Author: Tom Yang 
		(09/07/91)
______________________________________________________________________________________*/

void		DynamicSymbolChangeCallback (w, clientData, callData)
Widget		w;
caddr_t		clientData;
caddr_t		callData;
{
	SYMBOL_SHOW_DATA	*symbol_show_data	
				= (SYMBOL_SHOW_DATA *) clientData;
	SYMBOL_BASIC_DATA	*symbol_basic_data
				= symbol_show_data->symbol_basic_data;
	Widget	color_widget	= wActiveAF3DColor;
	int	n;
	Arg	arglist [3];
	Pixel	background;
	Pixel	foreground;
	Pixmap	pixmap_symbol;
	char	alter_index	= cActiveAF3DSet;
	char	active_symbol	= cActiveSymbolType;

	if (XmToggleButtonGetState (symbol_basic_data->toggle_filled))
		active_symbol	+= FILLED_SYMBOL_START;

	if (symbol_show_data->color_flag != FAIL) 
	{
		color_widget	= w;
		cDynamicSymbolColor [alter_index]	= symbol_show_data->color_flag;

		if (XmToggleButtonGetState (w))
		{
			n = 0;
			XtSetArg (arglist [n], XmNset, TRUE); n++;
			XtSetValues (w, arglist, n);

			wActiveAF3DColor	= w;
		}
	}

	n = 0;
	XtSetArg (arglist [n], XtNforeground, &foreground); n++;
	XtGetValues (color_widget, arglist, n);

	n = 0;
	XtSetArg (arglist [n], XtNbackground, &background); n++;
	XtGetValues (symbol_basic_data->symbol_shape [0], arglist, n);

	pixmap_symbol	= XmGetPixmap (XtScreen (symbol_basic_data->symbol_label [alter_index]),  
						symbol_basic_data->symbol_name [active_symbol], 
						foreground, background);

	n = 0;
	XtSetArg (arglist [n], XmNlabelType, XmPIXMAP); n++;
	XtSetArg (arglist [n], XmNlabelPixmap, pixmap_symbol); n++;
	XtSetValues (symbol_basic_data->symbol_label [alter_index], arglist, n);

	cDynamicSymbolType [alter_index]	= active_symbol;
}


/*______________________________________________________________________________________	
	Procedure:
		DynamicSizeChangeCallback
	Parameters:
		w: Widget, widget where callback was triggered.
		clientData: caddr_t, client data.
		call_data: caddr_t, callback data.
	Description:
		Callback function for dyanmic changing the size of AF3D labels.
		Author: Tom Yang 
		(07/15/91)
______________________________________________________________________________________*/

void		DynamicSizeChangeCallback (w, clientData, callData)
Widget		w;
caddr_t		clientData;
caddr_t		callData;
{
	Widget		*label_symbol_size	= (Widget *) clientData;
	char		alter_index		= cActiveAF3DSet;
	int		symbol_size;
	char		string [MAXLINE];
	XmString	*xmsize_symbol	= xmStrSymbolSize;
	int		n;
	Arg		arglist [1];

	XmScaleGetValue (w, &symbol_size);
	XtFree (xmsize_symbol [alter_index]);
	itoa (symbol_size, string);
	xmsize_symbol [alter_index]	= XmStringCreate (string, XmSTRING_DEFAULT_CHARSET); 

	n	= 0;
	XtSetArg (arglist [n], XmNlabelString, xmsize_symbol [alter_index]); n++;
	XtSetValues (*(label_symbol_size + alter_index), arglist, n);
}


/*______________________________________________________________________________________	
	Procedure:
		AlterSymbolCallback
	Parameters:
		w: Widget, widget where callback was triggered.
		clientData: caddr_t, client data.
		call_data: caddr_t, callback data.
	Description:
		Callback function for changing to a new AF3D data set.
		Author: Tom Yang 
		(07/07/92)
______________________________________________________________________________________*/

void AlterSymbolCallback (w, clientData, callData)
Widget	w;
caddr_t clientData;
caddr_t callData;
{
	ALTER_SYMBOL_DATA	*alter_symbol_data	
				= (ALTER_SYMBOL_DATA *) clientData;
	SYMBOL_BASIC_DATA	*symbol_basic_data
				= alter_symbol_data->symbol_basic_data;
	int			n;
	int			i;
	Arg			arglist [3];
	Pixel			background;
	Pixel			foreground;
	Pixmap			pixmap_symbol;
	char			*alter_index	= &cActiveAF3DSet;
	char			*active_symbol	= &cActiveSymbolType;
	char			*symbol_type	= cSymbolType;
	char			shape_type;
	Widget			*color_widget	= &wActiveAF3DColor;
	unsigned short		*symbol_size	= nSymbolSize;
	XmString		*xmsize_symbol	= xmStrSymbolSize;
	char			string [MAXLINE];

	if (XmToggleButtonGetState (w))
	{
		n = 0;
		XtSetArg (arglist [n], XmNset, TRUE); n++;
		XtSetValues (w, arglist, n);

		*alter_index	= alter_symbol_data->set_index;

		SetSelectData (symbol_basic_data->display_onoff 
					[*alter_index], bDisplaySymbol [*alter_index]);

		SetSelectData (GetActiveWidget (symbol_basic_data->symbol_color, 
						MAX_NONIMAGE_COLOR), False);
		*color_widget	= symbol_basic_data->symbol_color [cSymbolColor [*alter_index]];
		SetSelectData (*color_widget, True);

		SetSelectData (GetActiveWidget (symbol_basic_data->symbol_shape, 
							MAX_SYMBOL_NUM), False);
		shape_type	= *(symbol_type + *alter_index);
		if (shape_type < FILLED_SYMBOL_START)
		{
			*active_symbol	= shape_type; 
			SetSelectData (symbol_basic_data->toggle_filled, False);
		}
		else
		{
			*active_symbol	= shape_type - FILLED_SYMBOL_START; 
			SetSelectData (symbol_basic_data->toggle_filled, True);
		}
		SetSelectData (symbol_basic_data->symbol_shape [*active_symbol], True);

		n = 0;
		XtSetArg (arglist [n], XtNforeground, &foreground); n++;
		XtGetValues (*color_widget, arglist, n);

		n = 0;
		XtSetArg (arglist [n], XtNbackground, &background); n++;
		XtGetValues (symbol_basic_data->symbol_shape [0], arglist, n);

		pixmap_symbol	= XmGetPixmap (XtScreen (symbol_basic_data->symbol_label [*alter_index]),  
						symbol_basic_data->symbol_name [shape_type], 
						foreground, background);

		n = 0;
		XtSetArg (arglist [n], XmNlabelType, XmPIXMAP); n++;
		XtSetArg (arglist [n], XmNlabelPixmap, pixmap_symbol); n++;
		XtSetValues (symbol_basic_data->symbol_label [*alter_index], arglist, n);

		XmScaleSetValue (symbol_basic_data->scale_symbol_size, *(symbol_size + *alter_index));

		XtFree (xmsize_symbol [*alter_index]);
		itoa (*(symbol_size + *alter_index), string);
		xmsize_symbol [*alter_index]	= XmStringCreate (string, 
							XmSTRING_DEFAULT_CHARSET); 

		n	= 0;
		XtSetArg (arglist [n], XmNlabelString, xmsize_symbol [*alter_index]); n++;
		XtSetValues (symbol_basic_data->symbol_size_label [*alter_index], arglist, n);
	}
}


/*_________________________________________________________________________________	
	Procedure:
		RefreshCallback
	Parameters:
		Widget	w;
		caddr_t clientData;
		caddr_t callData;
	Description:
		Callback function for refreshing a screen.
		Author: Tom (Tongzeng) Yang 
		(11/26/91)
___________________________________________________________________________________*/
void RefreshCallback (w, clientData, callData)
Widget	w;
caddr_t clientData;
caddr_t callData;
{
	BOOLEAN		overlay;
	DRAW_DATA	*draw_data	= (DRAW_DATA *) clientData;

	/*
	 * Process data for image 1
	 */
	if (bDisplayImage2 && bImage2Selected && strlen (szImage2FileName) > 0)
	{
		UpdatePortals (draw_data->display, draw_data->window, draw_data->gc, 
			rCurrentScaleHeader, plist2, cAtlasOrientation, &bDisplayAtlas2,
			&bDisplayImage2, nxImage2Start, nyImage2Start, bAutoImage2ValueFlag, 
			cImage2ValueFlag, nxImage2ColorBarStart, nyImage2ColorBarStart, 
			nImage2ColorBarWidth, nImage2ColorBarLength, bImage2HorizontalColorBar, 
			bImage2ColorBarOnOff, szImage2ColorTableName, &bImage2ColorBarExist, 
			&rectImage2ColorBarMin, &rectImage2ColorBarMiddle, &rectImage2ColorBarMax,
			FALSE, zorigin_image2, FALSE);

		nxImage2OldColorBar		= nxImage2ColorBarStart;
		nyImage2OldColorBar		= nyImage2ColorBarStart;
		nImage2OldColorBarLength	= nImage2ColorBarLength;
		nImage2OldColorBarWidth		= nImage2ColorBarWidth;
		bImage2OldHoriColorBar		= bImage2HorizontalColorBar;
	}

	/*
	 * Process data for image 1
	 */
	if (bDisplayImage1 && bImage1Selected && strlen (szImage1FileName) > 0)
	{
		if (nxImage1Start == nxImage2Start && nyImage1Start == nyImage2Start)
			overlay	= TRUE;
		else
			overlay	= FALSE;

		UpdatePortals (draw_data->display, draw_data->window, draw_data->gc, 
			rCurrentScaleHeader, plist1, cAtlasOrientation, &bDisplayAtlas1,
			&bDisplayImage1, nxImage1Start, nyImage1Start, bAutoImage1ValueFlag, 
			cImage1ValueFlag, nxImage1ColorBarStart, nyImage1ColorBarStart, 
			nImage1ColorBarWidth, nImage1ColorBarLength, bImage1HorizontalColorBar, 
			bImage1ColorBarOnOff, szImage1ColorTableName, &bImage1ColorBarExist, 
			&rectImage1ColorBarMin, &rectImage1ColorBarMiddle, &rectImage1ColorBarMax,
			TRUE, zorigin_image1, overlay);

		nxImage1OldColorBar		= nxImage1ColorBarStart;
		nyImage1OldColorBar		= nyImage1ColorBarStart;
		nImage1OldColorBarLength	= nImage1ColorBarLength;
		nImage1OldColorBarWidth		= nImage1ColorBarWidth;
		bImage1OldHoriColorBar		= bImage1HorizontalColorBar;
	}
}


/*___________________________________________________________________________________	
	Procedure:
		xlabelCallback
	Parameters:
		w: Widget, widget where callback was triggered.
		clientData: caddr_t, client data.
		call_data: caddr_t, callback data.
	Description:
		Callback function for invoking xlabel.
		Author: Tom Yang 
		(09/24/92)
_____________________________________________________________________________________*/

void xlabelCallback (w, clientData, callData)
Widget		w;
caddr_t		clientData;
caddr_t		callData;
{
	system ("xlabel &");
}


/*___________________________________________________________________________________	
	Procedure:
		ShowAddPointsMenuCallback
	Parameters:
		w: Widget, widget where callback was triggered.
		clientData: caddr_t, client data.
		call_data: caddr_t, callback data.
	Description:
		Callback function for invoking "Add AF3D Points" menu.
		Author: Tom Yang 
		(03/31/93)
_____________________________________________________________________________________*/

void ShowAddPointsMenuCallback (w, clientData, callData)
Widget w;
caddr_t clientData;
caddr_t callData;
{
	FILE			*fp;
	OPEN_ADDPOINTS_DATA	*open_addpoints_data	= (OPEN_ADDPOINTS_DATA *) clientData;
	char			*af3d_file;
	char			*text;
	struct stat		statb;

	XtUnmanageChild (open_addpoints_data->parent);
	XtManageChild (open_addpoints_data->frame);
	af3d_file	= szAF3DFileNames [cActiveAF3DSet];
	if (af3d_file && *af3d_file)
	{
		XmTextSetString (*open_addpoints_data->af3d_file, af3d_file);
		/*
		XmTextFieldSetCursorPosition (*open_addpoints_data->af3d_file, strlen (af3d_file));
		*/
		if (getfile_type (af3d_file) == ASCII)
		{
			/* 
			 * Make sure the file is a regular text file and open it 
			 */
			if (stat (af3d_file, &statb) == -1 ||
			(statb.st_mode & S_IFMT) != S_IFREG ||
			!(fp = fopen (af3d_file, "r"))) 
			{
				if ((statb.st_mode & S_IFMT) == S_IFREG)
					perror (af3d_file); /* send to stderr why we can't read it */
				else
					fprintf (stderr, "%s: not a regular file\n", af3d_file);
				return;
			}

			/* 
	 		 * Put the contents of the file in the Text widget by allocating
 			 * enough space for the entire file, reading the file into the
	 		 * allocated space, and using XmTextSetString() to show the file.
	 		 */
			if (!(text = XtMalloc ((unsigned) (statb.st_size + 1)))) 
			{
				fprintf (stderr, "Can't alloc enough space for %s", af3d_file);
				fclose (fp);
				return;
			}

			if (!fread (text, sizeof (char), statb.st_size + 1, fp))
				fprintf (stderr, "Warning: may not have read entire file!\n");

			text [statb.st_size]	= 0; /* be sure to NULL-terminate */

			/* 
			 * Insert file contents in Text widget 
			 */
			XmTextSetString (*open_addpoints_data->coordinates, text);
			/*
			XmTextFieldSetCursorPosition (*open_addpoints_data->coordinates, strlen (text));
			*/
			XtFree (text);
			fclose (fp);
		}
	}
}


/*___________________________________________________________________________________	
	Procedure:
		AddPointsCallback
	Parameters:
		w: Widget, widget where callback was triggered.
		clientData: caddr_t, client data.
		call_data: caddr_t, callback data.
	Description:
		Callback function for invoking "Add AF3D Points" menu.
		Author: Tom Yang 
		(03/31/93)
_____________________________________________________________________________________*/
#define	PERMS		0755

void AddPointsCallback (w, clientData, callData)
Widget w;
caddr_t clientData;
caddr_t callData;
{
	ADD_POINTS_DATA	*addpoints_data	= (ADD_POINTS_DATA *) clientData;
	Arg		arglist [1];
	FILE		*fp;
	Widget		*message_box	= &errorMessageBox;
	XmString	xmstring;
	char		alter_index	= cActiveAF3DSet;
	char		buffer [MAXLINE];
	char		*data_string;
	char		*extension;
	char		*file_name;
	char		line [MAXLINE];
	char		*short_name;
	char		*string_buffer;
	int		i;
	int		j;
	int		n;
	int		num_points;
	int		text_length;
	float		x;	
	float		y;	
	float		z;	

	if (addpoints_data->node_flag != CANCEL)
	{
		file_name	= XmTextGetString (*addpoints_data->af3d_file);

		extension	= strrchr (file_name, '/');
		if (strlen (file_name) == 0 || (extension != NULL && strcmp (extension, "/") == 0)) 
		{
			n	= 0;
			XtSetArg (arglist [n], XmNmessageString, xmStrErrorMessages [ERROR_FILE_EMPTY]); n++;
			XtSetValues (*message_box, arglist, n);

			XtManageChild (*message_box);
			return;
		}

		strcpy (szAF3DFileNames [alter_index], file_name);

		if (extension != NULL && strncmp (extension, "/", 1) == 0)
			short_name	= extension + 1;
		else
			short_name	= file_name;
		xmstring	= XmStringCreate (short_name, XmSTRING_DEFAULT_CHARSET); 

		n	= 0;
		XtSetArg (arglist [n], XmNlabelString, xmstring); n++;
		XtSetValues (addpoints_data->AF3D_symbol_label [alter_index], arglist, n);

		XtFree (xmstring);

		data_string	= XmTextGetString (*addpoints_data->coordinates);

		/*
		 * Calculate number of points.
		 */
		num_points	= 0;
		text_length	= strlen (data_string);
		string_buffer	= (char *) pkg_malloc (text_length, "AddPointsCallback", "string_buffer");
		i		= 0;
		while (i < text_length)
		{
			j	= 0;
			strncpy (string_buffer, "\0", text_length);
			do
			{
				string_buffer [j++] = data_string [i++];
			} while (i < text_length && data_string [i] != '\n');

			string_buffer [j++] = data_string [i++];

			if (sscanf (string_buffer, "%f %f %f", &x, &y, &z) == 3) 
				num_points++;
		}

		if (num_points == 0)
		{
			fprintf (stderr, "Error: There is no AF3D points in your window.\n"); 
			return;
		}

		/*
		 * Write af3d points to file.
		 */
		if ((fp = fopen (file_name, "w")) == NULL)
		{
			fprintf (stderr, "Error: opening AF3D file %s for writing.\n", file_name);
			return;
		}

		/* Save text in coordinates file. */
		fprintf (fp, "%s", data_string);

		fclose (fp);

		XtFree (file_name);
		XtFree (data_string);
	}

	XmTextSetString (*addpoints_data->af3d_file, "");
	XmTextSetString (*addpoints_data->coordinates, "");
	XtUnmanageChild (*addpoints_data->frame);
	XtManageChild (*addpoints_data->parent);
}


/* climb widget tree until we get to the top.  Return the Shell */
Widget GetTopShell (w)
Widget	w;
{
	while (w && !XtIsWMShell (w))
		w	= XtParent (w);
	return w;
}


/* The callback function for the "Ok" button.  Since this is not a
 * predefined Motif dialog, the "widget" parameter is not the dialog
 * itself.  That is only done by Motif dialog callbacks.  Here in the
 * real world, the callback routine is called directly by the widget
 * that was invoked.  Thus, we must pass the dialog as the client
 * data to get its handle.  (We could get it using GetTopShell(),
 * but this way is quicker, since it's immediately available.)
 */
void DestroyShell(widget, shell)
Widget	widget, shell;
{
	XtDestroyWidget (shell);
}


/* CreateActionArea can be put in a file and then put in a window library. Tom Yang 9/17/93*/
#define TIGHTNESS 20

Widget CreateActionArea (parent, actions, num_actions)
Widget		parent;
ActionAreaItem	*actions;
int		num_actions;
{
	Widget	action_area, widget;
	int	i;

	action_area	= XtVaCreateWidget ("action_area", xmFormWidgetClass, parent,
			XmNfractionBase,	TIGHTNESS * num_actions - 1,
			XmNleftOffset,		10,
			XmNrightOffset,		10,
			NULL);

	for (i = 0; i < num_actions; i++) 
	{
		widget	= XtVaCreateManagedWidget (actions[i].label,
			xmPushButtonWidgetClass,	action_area,
			XmNleftAttachment,		i? XmATTACH_POSITION: XmATTACH_FORM,
			XmNleftPosition,		TIGHTNESS * i,
			XmNtopAttachment,		XmATTACH_FORM,
			XmNbottomAttachment,		XmATTACH_FORM,
			XmNrightAttachment, i != num_actions - 1? XmATTACH_POSITION: XmATTACH_FORM,
			XmNrightPosition,		TIGHTNESS * i + (TIGHTNESS - 1),
			XmNshowAsDefault,		i == 0,
			XmNdefaultButtonShadowThickness,	1,
			NULL);
		if (actions [i].callback)
		{
			XtAddCallback (widget, XmNactivateCallback,
				actions [i].callback, actions [i].data);
		}

		if (i == 0) 
		{
		/* Set the action_area's default button to the first widget
		 * created (or, make the index a parameter to the function
		 * or have it be part of the data structure). Also, set the
		 * pane window constraint for max and min heights so this
		 * particular pane in the PanedWindow is not resizable.
		 */
			Dimension height, h;

			XtVaGetValues (action_area, XmNmarginHeight, &h, NULL);
			XtVaGetValues (widget, XmNheight, &height, NULL);
			height	+= 2 * h;
			XtVaSetValues (action_area,
				XmNdefaultButton, widget,
				XmNpaneMaximum,   height,
				XmNpaneMinimum,   height,
				NULL);
		}
	}

	XtManageChild (action_area);

	return action_area;
}


/*___________________________________________________________________________________	
	Procedure:
		ViewLogFileDialog
	Parameters:
		w:		Widget,		widget where callback was triggered.
		clientData:	caddr_t,	client data.
		call_data:	caddr_t,	callback data.
	Description:
		Callback function for viewing and editing AF3D log files.
		Author: Tom Yang 
		(09/17/93)
_____________________________________________________________________________________*/
void ViewLogFileDialog (w, clientData, callData)
Widget	w;
caddr_t	clientData;
caddr_t	callData;
{
	extern Widget CreateActionArea ();
	extern void DestroyShell ();
	extern void clear_pushed ();
	extern void close_dialog ();
	extern void read_file ();
	extern void save_pushed ();
	extern void search_text ();

	Arg			args [9];
	BOOLEAN			update_textfield	= TRUE;
	Widget			dialog, pane, text_w, widget, action_area;
	Widget			file_w;
	Widget			rowcol_h;
	Widget			rowcol;
	Widget			search_w;
	Widget			text_output;
	XmFileSelectionBoxCallbackStruct *cbs;
	XmString		string;
	char			*cstring;
	char			*logfile	= szCoordinatesFileName;
	char			*short_logfile;
	int			n;
	static ActionAreaItem	action_items [] = {
		{"Save",	save_pushed,	NULL},
		{"Clear",	clear_pushed,	NULL},
		{"Close",	close_dialog,	NULL},
	};

	/* Set up a DialogShell as a popup window.  Set the delete
	 * window protocol response to XmDESTROY to make sure that
	 * the window goes away appropriately. Otherwise, it's XmUNMAP
	 * which means it'd be lost forever, since we're not storing
	 * the widget globally or statically to this function.
	 */
	dialog	= XtVaCreatePopupShell ("ViewLog",
				xmDialogShellWidgetClass, GetTopShell (w),
				XmNtitle, "View and Edit Coordinates Log File",
				XmNdeleteResponse, XmDESTROY,
				NULL);

	/*
	 * Now that the dialog is created, set the Close button's
	 * client data, so close_dialog () will know what to destroy.
	 */
	action_items [2].data	= (caddr_t) dialog;

	/* 
	 * Create the paned window as a child of the dialog. This will
	 * contain the control area (a Form widget) and the action area
	 * (created by CreateActionArea () using the action_items above).
	 */
	pane	= XtVaCreateWidget ("pane", 
		xmPanedWindowWidgetClass, dialog,
		XmNsashWidth,  1, 
		XmNsashHeight, 1, 
		NULL);

	/* Create a RowColumn in the form for Label and Text widgets.
	 * This is the control area.
	 */
	rowcol	= XtVaCreateWidget ("rowcol", xmRowColumnWidgetClass, pane, NULL);

	string	= XmStringCreateSimple ("File Name:");
	XtVaCreateManagedWidget ("label", xmLabelWidgetClass, rowcol,
		XmNlabelString,    string,
		NULL);
	XmStringFree (string);

	file_w = XtVaCreateManagedWidget ("file-name", xmTextFieldWidgetClass, rowcol, NULL);

	rowcol_h	= XtVaCreateWidget ("rowcol_h", 
			xmRowColumnWidgetClass, rowcol, 
			XmNorientation, XmHORIZONTAL, NULL);
	XtVaCreateManagedWidget ("Search Pattern:", xmLabelWidgetClass, rowcol_h, NULL);
	search_w	= XtVaCreateManagedWidget ("search-text", xmTextFieldWidgetClass, rowcol_h, NULL);
	XtManageChild (rowcol_h);

	text_output	= XtVaCreateManagedWidget ("text-out", 
			xmTextWidgetClass,		rowcol, 
			XmNeditable,			False,
			XmNcursorPositionVisible,	False,
			XmNshadowThickness,		0,
			XmNsensitive,			False,
			NULL);

	n	= 0;
	XtSetArg (args [n], XmNrows,                  7); n++;
	XtSetArg (args [n], XmNcolumns,               50); n++;
	XtSetArg (args [n], XmNeditMode,              XmMULTI_LINE_EDIT); n++;
	XtSetArg (args [n], XmNwordWrap,              True); n++;
	text_w	= XmCreateScrolledText (rowcol, "logfile_text", args, n);

	XtManageChild (text_w);
	XtManageChild (rowcol);

	/* 
	 * Update the file name and put the contents of the file in text_w.
	 */
	if (*logfile)
	{
		if ((cstring = strrchr (logfile, '/')) != NULL)
			short_logfile	= cstring + 1; 
		else
			short_logfile	= logfile;
		XmTextFieldSetString (file_w, short_logfile);
		read_file (file_w, text_w, callData);
	}

	/* Store filename text widget to ScrolledText object. */
	XtVaSetValues (text_w, XmNuserData, file_w, NULL);

	/* Store text_output widget to search_w. */
	XtVaSetValues (search_w, XmNuserData, text_output, NULL);

	XtAddCallback (file_w, XmNactivateCallback, read_file, text_w);
	XtAddCallback (search_w, XmNactivateCallback, search_text, text_w);

	/* 
	 * Set the client data "Save", "Clear", "Search", 
	 * button's callbacks. 
	 */
	action_items [0].data		= (caddr_t) text_w;
	action_items [1].data		= (caddr_t) text_w;

	/* Create the action area -- we don't need the widget it returns. */
	action_area = CreateActionArea (pane, action_items, XtNumber (action_items));

	XtManageChild (pane);
	XtPopup (dialog, XtGrabNone);
}

/*--------------*/
/* The next four functions are the callback routines for the buttons
 * in the action area for the dialog created above.  
 */
static void close_dialog (w, shell)
Widget w, shell;
{
	XtDestroyWidget (shell);
}

/* The "Save" button was pushed or the user pressed Return */
void save_pushed (w, text_w, cbs)
Widget			w;
Widget			text_w;
XmAnyCallbackStruct	*cbs;
{
	FILE		*fp;
	Widget		file_w;
	char		cbuffer [MAXLINE];
	char		*coordinates_file	= szCoordinatesFileName;
	char		*coordinates_path	= szCoordinatesPathName;
	char		*filename; 
	char		*string;
	char		*text;

	/* the user data stored the file_w widget in the text_w. */
	XtVaGetValues (text_w, XmNuserData, &file_w, NULL);
	filename	= XmTextFieldGetString (file_w);

	if (!filename || !*filename)
	{
		if (filename)
			XtFree (filename);
		return;
	}

	memset (cbuffer, 0, MAXLINE); 
	if ((string = strrchr (filename, '/')) != NULL)
	{
		strncpy (cbuffer, filename, strlen (filename)  - strlen (string) + 1);
		text	= strchr (filename, '*');
		if (text && *text)
		{
			strcat (cbuffer, text);
		}
		else
		{
			strcpy (cbuffer, filePatternList [SaveCoordinates]);
		}

		strcpy (coordinates_path, cbuffer);
		strcpy (coordinates_file, filename);
	}
	else 
	{
		text	= strrchr (coordinates_path, '/');
		if (text && *text)
		{
			strncpy (cbuffer, coordinates_path, 
				strlen (coordinates_path)  - strlen (text) + 1);
			strcat (cbuffer, filename);
		}
		else
			strcpy (cbuffer, filename);
		strcpy (coordinates_file, cbuffer);
	}
	XtFree (filename);

	if ((fp = fopen (coordinates_file, "w")) == NULL)
	{
		fprintf (stderr, "Error: opening file %s for writing.\n", coordinates_file);
		return;
	}

	text	= XmTextGetString (text_w);

	/* Save text in coordinates file. */
	fprintf (fp, "%s", text);

	/* free all allocated space and we're outta here. */
	XtFree (text);
	fclose (fp);
}

static void clear_pushed (w, text_w, cbs)
Widget w, text_w;         /* the text field is the client data */
XmAnyCallbackStruct *cbs;
{
    /* cancel the whole operation; reset to NULL. */
    XmTextSetString (text_w, "");
}

static void search_text (w, text_w, cbs)
Widget			w; 
Widget			text_w;         /* the text widget is the client data */
XmAnyCallbackStruct	*cbs;
{
	Boolean		found = False;
	Widget		text_output;
	XmTextPosition	pos;
	char		buf [32];
	char		*p; 
	char		*search_pat; 
	char		*text;
	int		length;

	/* the user data stored the text_output widget in the search_w. */
	XtVaGetValues (w, XmNuserData, &text_output, NULL);

	/* get the text that is about to be searched */
	if (!(text = XmTextGetString (text_w)) || !*text) 
	{
		XmTextSetString (text_output, "No text to search.");
		XtFree (text);	/* may have been ""; free it */
		return;
	}

	/* get the pattern we're going to search for in the text. */
	if (!(search_pat = XmTextGetString (w)) || !*search_pat) 
	{
		XmTextSetString (text_output, "Specify a search pattern.");
		XtFree (text);	/* this we know is a string; free it */
		XtFree (search_pat);	/* this may be "", XtFree() checks.. */
		return;
	}
	length	= strlen (search_pat);

	/* 
	 * Start searching at current cursor position + 1 to find
	 * the -next- occurrance of text.  we may be sitting on it.
	 */
	pos	= XmTextGetCursorPosition (text_w);
	for (p = &text [pos + 1]; p = index (p, *search_pat); p++)
		if (!strncmp (p, search_pat, length)) 
		{
			found = True;
			break;
		}
	if (!found) 
	{ /* didn't find pattern? */
		/* search from beginning till we've passed "pos" */
		for (p = text; (p = index(p, *search_pat)) && p - text <= pos; p++)
			if (!strncmp (p, search_pat, length)) 
			{
				found = True;
				break;
			}
	}

	if (!found)
		XmTextSetString (text_output, "Pattern not found.");
	else 
	{
		pos	= (XmTextPosition) (p - text);
		sprintf (buf, "Pattern found at position %ld.", pos);
		XmTextSetString (text_output, buf);
		XmTextSetInsertionPosition (text_w, pos);
	}

	XtFree (text);
	XtFree (search_pat);
}

/* 
 * Routine called by ViewLogCallback. The specified file must be a regular 
 * file and readable. If so, it's contents are displayed in the text_w provided
 * as the client_data to this function.
 */
void read_file (widget, text_w, cbs)
	Widget	widget;
	Widget	text_w;		/* text widget that contains the contents of filename */
	caddr_t	cbs;
{
	FILE		*fp;
	Widget		file_w;
	char		*filename;
	char		*text;
	struct stat	statb;

	if (XtIsSubclass (widget, xmTextFieldWidgetClass) ||
	XtIsSubclass (widget, xmTextWidgetClass)) 
	{
		if (XtIsSubclass (widget, xmTextFieldWidgetClass))
			filename	= XmTextFieldGetString (widget);
		else
			filename	= XmTextGetString (widget);
		file_w		= widget; /* this *is* the file_w */
	} 

	if (!filename || !*filename) 
	{
		if (filename)
			XtFree (filename);
		return;
	}

	if (getfile_type (filename) != ASCII)
	{
		XtFree (filename);
		return;
	}

	/* make sure the file is a regular text file and open it */
	if (stat (filename, &statb) == -1 ||
	(statb.st_mode & S_IFMT) != S_IFREG ||
	!(fp = fopen (filename, "r"))) 
	{
		if ((statb.st_mode & S_IFMT) == S_IFREG)
			perror (filename); /* send to stderr why we can't read it */
		else
			fprintf (stderr, "%s: not a regular file\n", filename);
		XtFree (filename);
		return;
	}

	/* 
	 * Put the contents of the file in the Text widget by allocating
	 * enough space for the entire file, reading the file into the
	 * allocated space, and using XmTextSetString() to show the file.
	 */
	if (!(text = XtMalloc ((unsigned) (statb.st_size + 1)))) 
	{
		fprintf (stderr, "Can't alloc enough space for %s", filename);
		fclose (fp);
		return;
	}

	if (!fread (text, sizeof (char), statb.st_size + 1, fp))
		fprintf (stderr, "Warning: may not have read entire file!\n");

	text [statb.st_size]	= 0; /* be sure to NULL-terminate */

	/* insert file contents in Text widget */
	XmTextSetString (text_w, text);

	/* make sure text field is up to date */
	if (file_w != widget) 
	{
		/* only necessary if activated from FileSelectionDialog */
		XmTextFieldSetString (file_w, filename);
		XmTextFieldSetCursorPosition (file_w, strlen (filename));
	}

	/* free all allocated space and we're outta here. */
	XtFree (text);
	XtFree (filename);
	fclose (fp);
}
@


2.26
log
@Fix the z0 mistach problem.
@
text
@d2 3
d194 1
a194 1
/*$Header: /data/petsun4/src/view25d/RCS/view25d.callbacks,v 2.25 1995/09/06 18:27:56 ty7777 Exp ty7777 $*/
d1728 1
a1728 1
				if (cAtlasOrientation == TRANSVERSE)
a2114 1
printf ("min = %d max = %d\n", minimum, maximum);
@


2.25
log
@Before fixing the bugs reported by Avi.
@
text
@d2 3
d191 1
a191 1
/*$Header: /data/petsun4/src/view25d/RCS/view25d.callbacks,v 2.24 1995/08/31 20:19:33 ty7777 Exp ty7777 $*/
d990 1
d1473 2
a1474 1
	int			*pzorigin	= &zorigin_image1;
d1717 3
a1719 1
			if (zorigin_new != *pzorigin || pett_num == INTERFILE)
d1727 1
a1727 1
					atlas_coord	= slice2z (*first_slice, *pzorigin);
d1730 1
a1730 1
					atlas_coord	= slice2z (*last_slice, *pzorigin);
d1734 1
a1734 1
				if (zorigin_new != *pzorigin)
d1736 1
a1736 1
					*pzorigin	= zorigin_new;
d1738 5
@


2.24
log
@Before watch cursor works.
@
text
@d2 3
d188 1
a188 1
/*$Header: /data/petsun4/src/view25d/RCS/view25d.callbacks,v 2.23 1995/08/28 21:09:54 ty7777 Exp ty7777 $*/
d982 1
d984 3
d988 3
d992 1
@


2.23
log
@After color bar works.
@
text
@d2 3
d185 1
a185 1
/*$Header: /data/petsun4/src/view25d/RCS/view25d.callbacks,v 2.22 1995/08/28 15:40:45 ty7777 Exp ty7777 $*/
d1061 2
a1062 1
	Boolean			*display_atlas		= &bDisplayAtlas;
a1095 1
		*display_atlas	= XmToggleButtonGetState (*data_type_menu->atlas);
d1097 1
d1100 1
a1230 1
		SetSelectData (*data_type_menu->atlas, *display_atlas);
d1232 1
d1235 1
d3851 6
a3856 6
			rCurrentScaleHeader, plist2, cAtlasOrientation, &bDisplayImage2,
			nxImage2Start, nyImage2Start, bAutoImage2ValueFlag, cImage2ValueFlag, 
			nxImage2ColorBarStart, nyImage2ColorBarStart, nImage2ColorBarWidth, 
			nImage2ColorBarLength, bImage2HorizontalColorBar, bImage2ColorBarOnOff,
			szImage2ColorTableName, &bImage2ColorBarExist, &rectImage2ColorBarMin,
			&rectImage2ColorBarMiddle, &rectImage2ColorBarMax,
d3877 6
a3882 6
			rCurrentScaleHeader, plist1, cAtlasOrientation, &bDisplayImage1,
			nxImage1Start, nyImage1Start, bAutoImage1ValueFlag, cImage1ValueFlag, 
			nxImage1ColorBarStart, nyImage1ColorBarStart, nImage1ColorBarWidth, 
			nImage1ColorBarLength, bImage1HorizontalColorBar, bImage1ColorBarOnOff,
			szImage1ColorTableName, &bImage1ColorBarExist, &rectImage1ColorBarMin,
			&rectImage1ColorBarMiddle, &rectImage1ColorBarMax,
@


2.22
log
@Before adding mutual image1 and image2 point display.
@
text
@d2 3
d182 1
a182 1
/*$Header: /data/petsun4/src/view25d/RCS/view25d.callbacks,v 2.21 1995/08/02 16:50:06 ty7777 Exp ty7777 $*/
d1923 2
d1934 6
d1987 3
a1989 1
					auto_image1_value_flag, image1_value_flag);
d1997 1
a1997 1
				if (!(*horizontal_flag1))
d2004 3
a2006 1
					auto_image2_value_flag, image2_value_flag);
d2071 3
a2073 1
					auto_image1_value_flag, image1_value_flag);
d2083 1
d2086 3
a2088 1
					auto_image2_value_flag, image2_value_flag);
d3848 4
a3851 2
			nImage2ColorBarLength, bImage2HorizontalColorBar, FALSE, 
			zorigin_image2, FALSE);
d3874 4
a3877 2
			nImage1ColorBarLength, bImage1HorizontalColorBar, TRUE, 
			zorigin_image1, overlay);
@


2.21
log
@Tracking works.
@
text
@d2 3
d179 1
a179 1
/*$Header: /data/petsun4/src/view25d/RCS/view25d.callbacks,v 2.20 1995/07/31 19:07:26 ty7777 Exp ty7777 $*/
d295 1
a295 1
		if (*slice_scale != new_scale)
d1004 2
a1005 2
	short			first;
	short			last;
a1006 3
	first	= nFirstSlice;
	last	= nLastSlice;

d1009 2
a1010 2
		first	= GetSliceCoord (first, atlas_orient);
		last	= GetSliceCoord (last, atlas_orient);
d1013 1
a1013 1
	sprintf (szBuffer, "%d", first);
d1015 1
a1015 1
	sprintf (szBuffer, "%d", last);
d1110 4
a1113 2
				*first_slice	= GetSliceNumber (*first_slice, *atlas_orient);
				*last_slice	= GetSliceNumber (*last_slice, *atlas_orient);
d1258 2
a1259 2
		first	= GetSliceCoord (first, *atlas_orient);
		last	= GetSliceCoord (last, *atlas_orient);
d1449 1
a1449 1
	int			*pzorigin	= &zorigin;
d1710 1
a1710 1
					bZoriginChanged	= TRUE;
d1918 2
d1922 2
a1923 2
	BOOLEAN		auto_image1_value_flag	= bAutoImage1ValueFlag;
	BOOLEAN		auto_image2_value_flag	= bAutoImage2ValueFlag;
d1964 4
a1967 2
			wcolorbar		= *length1;
			hcolorbar		= *width1;
d1969 2
a1970 2
			if (!(*horizontal_flag1))
				Swap (&wcolorbar, &hcolorbar);
d1972 6
a1977 5
			XClearArea (display, window, *x1, *y1, wcolorbar, hcolorbar, FALSE); 
			GetImageMinMax (TRUE, auto_image1_value_flag, &minimum, &maximum);
			DrawColorBarText (display, window, gc, &minimum, &maximum, font_struct, 
				*horizontal_flag1, *x1, *y1, *length1, *width1, TRUE,
				auto_image1_value_flag, image1_value_flag);
d1979 4
a1982 2
			wcolorbar		= *length2;
			hcolorbar		= *width2;
d1984 2
a1985 2
			if (!(*horizontal_flag1))
				Swap (&wcolorbar, &hcolorbar);
d1987 6
a1992 5
			XClearArea (display, window, *x2, *y2, wcolorbar, hcolorbar, FALSE); 
			GetImageMinMax (FALSE, auto_image2_value_flag, &minimum, &maximum);
			DrawColorBarText (display, window, gc, &minimum, &maximum, font_struct, 
				*horizontal_flag2, *x2, *y2, *length2, *width2, TRUE,
				auto_image2_value_flag, image2_value_flag);
d1996 1
d2021 1
d2047 3
a2049 1
			DrawColorBar (display, window, gc, *x1, *y1, *length1, *width1, 
d2052 6
a2057 5
			XSetForeground (display, gc, LABEL_CELL);
			GetImageMinMax (TRUE, auto_image1_value_flag, &minimum, &maximum);
			DrawColorBarText (display, window, gc, &minimum, &maximum, font_struct, 
				*horizontal_flag1, *x1, *y1, *length1, *width1, FALSE, 
				auto_image1_value_flag, image1_value_flag);
d2059 3
a2061 1
			DrawColorBar (display, window, gc, *x2, *y2, *length2, *width2, 
d2064 6
a2069 5
			XSetForeground (display, gc, LABEL_CELL);
			GetImageMinMax (FALSE, auto_image2_value_flag, &minimum, &maximum);
			DrawColorBarText (display, window, gc, &minimum, &maximum, font_struct, 
				*horizontal_flag2, *x2, *y2, *length2, *width2, FALSE, 
				auto_image2_value_flag, image2_value_flag);
d2087 1
d2102 1
d2956 2
a2957 2
		first_value	= GetSliceCoord (first_value, atlas_orient);
		last_value	= GetSliceCoord (last_value, atlas_orient);
d3828 2
a3829 1
			nImage2ColorBarLength, bImage2HorizontalColorBar, FALSE, FALSE);
d3852 2
a3853 1
			nImage1ColorBarLength, bImage1HorizontalColorBar, TRUE, overlay);
@


2.20
log
@After show multiple point works.
@
text
@d2 3
d176 1
a176 1
/*$Header: /data/petsun4/src/view25d/RCS/view25d.callbacks,v 2.19 1995/07/27 17:04:53 ty7777 Exp ty7777 $*/
d2323 3
a2325 2
			ShowCoordinates (event->xbutton.x, event->xbutton.y, rCurrentScaleHeader,
				plist1, cAtlasOrientation, wImageNameCascade, FALSE);
d2432 2
a2433 3
				ShowCoordinates (event->xbutton.x, event->xbutton.y, 
					rCurrentScaleHeader, plist1, cAtlasOrientation, 
					wImageNameCascade, FALSE);
d2435 11
d2720 14
a2733 3
				ShowCoordinates (event->xbutton.x, event->xbutton.y, 
					rCurrentScaleHeader, plist1, cAtlasOrientation, 
					wImageNameCascade, TRUE);
@


2.19
log
@Allowed any patterns to day for file selection.
@
text
@d2 3
d173 1
a173 1
/*$Header: /data/petsun4/src/view25d/RCS/view25d.callbacks,v 2.18 1995/07/26 20:42:09 ty7777 Exp ty7777 $*/
d2319 1
d2427 1
d2705 1
d2764 5
a2768 2
	*pointer_state				= NoState; 
	graphics_data->button_down_first	= FALSE;
@


2.18
log
@Image overlay worked!
@
text
@d2 3
d170 1
a170 1
/*$Header: /data/petsun4/src/view25d/RCS/view25d.callbacks,v 2.17 1995/07/21 16:58:20 ty7777 Exp ty7777 $*/
a884 11
	sbuffer	= strchr (path_name, '*');
	if (sbuffer && *sbuffer)
	{
		strcpy (file_pattern, sbuffer);
	}
	else
	{
		n	= fileSelectionData->file_state;
		strcpy (file_pattern, filePatternList [n]);
	}
		
d888 1
d890 5
d898 1
@


2.17
log
@Before adding new things.
@
text
@d2 3
d167 1
a167 1
/*$Header: /data/petsun4/src/view25d/RCS/view25d.callbacks,v 2.16 1995/07/07 17:14:11 ty7777 Exp ty7777 $*/
d3763 1
d3766 10
a3775 5
	UpdatePortals (draw_data->display, draw_data->window, draw_data->gc, 
		rCurrentScaleHeader, plist1, cAtlasOrientation, &bDisplayImage1,
		nxImage1Start, nyImage1Start, bAutoImage1ValueFlag, cImage1ValueFlag, 
		nxImage1ColorBarStart, nyImage1ColorBarStart, nImage1ColorBarWidth, 
		nImage1ColorBarLength, bImage1HorizontalColorBar, TRUE);
d3777 6
a3782 5
	nxImage1OldColorBar		= nxImage1ColorBarStart;
	nyImage1OldColorBar		= nyImage1ColorBarStart;
	nImage1OldColorBarLength	= nImage1ColorBarLength;
	nImage1OldColorBarWidth		= nImage1ColorBarWidth;
	bImage1OldHoriColorBar		= bImage1HorizontalColorBar;
d3784 9
a3792 5
	UpdatePortals (draw_data->display, draw_data->window, draw_data->gc, 
		rCurrentScaleHeader, plist2, cAtlasOrientation, &bDisplayImage2,
		nxImage2Start, nyImage2Start, bAutoImage2ValueFlag, cImage2ValueFlag, 
		nxImage2ColorBarStart, nyImage2ColorBarStart, nImage2ColorBarWidth, 
		nImage2ColorBarLength, bImage2HorizontalColorBar, FALSE);
d3794 12
a3805 5
	nxImage2OldColorBar		= nxImage2ColorBarStart;
	nyImage2OldColorBar		= nyImage2ColorBarStart;
	nImage2OldColorBarLength	= nImage2ColorBarLength;
	nImage2OldColorBarWidth		= nImage2ColorBarWidth;
	bImage2OldHoriColorBar		= bImage2HorizontalColorBar;
@


2.16
log
@Two data sets works correctly.
@
text
@d2 3
d164 1
a164 1
/*$Header: /data/petsun4/src/view25d/RCS/view25d.callbacks,v 2.15 1995/06/30 15:23:02 ty7777 Exp ty7777 $*/
d175 1
d185 1
a1609 5

			if (pett_num == INTERFILE)
				bInterfile	= TRUE;
			else 
				bInterfile	= FALSE;
@


2.15
log
@ Before making further changes, tow independent color bars worked.
@
text
@d2 3
d161 1
a161 1
/*$Header: /data/petsun4/src/view25d/RCS/view25d.callbacks,v 2.14 1995/06/14 20:12:53 ty7777 Exp ty7777 $*/
d235 3
d239 1
d241 4
d247 1
a247 1
	char 			node_flag		= mag_scale_data->node_flag;
a249 5
	char			*pet_value_flag		= &cImage1ValueFlag;
	short			*min_pixel_value	= &nMinImage1Value;
	short			*max_pixel_value	= &nMaxImage1Value;
	BOOLEAN			*auto_pet_value_flag	= &bAutoImage1ValueFlag;
	char			*magnify_index		= &cMagnifyIndex; 
d251 4
a254 2
	Widget			widget_buffer;
	char			szBuffer [MAXLINE];
d260 1
a260 1
		if (XmToggleButtonGetState (mag_scale_menu->mag_set[MAG_ANY_INDEX]))
d281 8
a288 1
		*pet_value_flag	= GetActiveIndex (mag_scale_menu->scale_set, SCALE_NUM);
d290 4
a293 1
		*auto_pet_value_flag = XmToggleButtonGetState (*mag_scale_menu->auto_pet_minmax);
d295 4
a298 4
		str1 = XmTextGetString (*mag_scale_menu->min_text);

		str2 = XmTextGetString (*mag_scale_menu->max_text);

d301 2
a302 2
			*min_pixel_value = atoi (str1);
			*max_pixel_value = atoi (str2);
d304 1
a304 1
			ErrorCheckMinMax (*pet_value_flag, min_pixel_value, max_pixel_value);
a305 1

d317 1
a317 1
		SetSelectData (mag_scale_menu->mag_set[*magnify_index], True);
d322 3
a324 2
		SetSelectData (GetActiveWidget (mag_scale_menu->scale_set, SCALE_NUM), False);
		SetSelectData (mag_scale_menu->scale_set[*pet_value_flag], True);
d326 4
a329 1
		SetSelectData (*mag_scale_menu->auto_pet_minmax, *auto_pet_value_flag);
d331 3
a333 2
		sprintf (szBuffer, "%d", *min_pixel_value);
		XmTextSetString (*mag_scale_menu->min_text, szBuffer); 
d335 4
a338 2
		sprintf (szBuffer, "%d", *max_pixel_value);
		XmTextSetString (*mag_scale_menu->max_text, szBuffer); 
d373 4
a376 2
	short			*xstart			= &nxImage1Start;
	short			*ystart			= &nyImage1Start;
d418 2
a419 2
		str1	= XmTextGetString (*format_screen_menu->xstart_text);
		str2	= XmTextGetString (*format_screen_menu->ystart_text);
d423 2
a424 2
			*xstart = atoi (str1);
			*ystart = atoi (str2);
d430 12
d496 4
a499 4
		sprintf (szBuffer, "%d", *xstart); 
		XmTextSetString (*format_screen_menu->xstart_text, szBuffer); 
		sprintf (szBuffer, "%d", *ystart); 
		XmTextSetString (*format_screen_menu->ystart_text, szBuffer); 
d501 5
d1039 2
a1040 1
	Boolean			*apply_mask		= &bApplyMask;
d1044 2
a1045 1
	Boolean			*display_pet		= &bDisplayPet;
d1078 4
a1081 2
		*display_pet	= XmToggleButtonGetState (*data_type_menu->pet);
		*apply_mask	= XmToggleButtonGetState (*data_type_menu->mask);
d1210 4
a1213 2
		SetSelectData (*data_type_menu->pet, *display_pet);
		SetSelectData (*data_type_menu->mask, *apply_mask);
d1313 1
a1313 1
		ShowPetMinMaxCallback
d1323 1
a1323 1
void ShowPetMinMaxCallback (w, clientData, callData)
d1332 3
d1336 1
a1336 3
	Arg				arglist [1];
	char				min_text [MAXLINE];
	char				max_text [MAXLINE];
a1337 1
	short				max;
d1343 1
a1343 1
	GetImageMinMax (TRUE, ToggleData->set, &min, &max);
d1345 4
a1348 4
	sprintf (min_text, "%d", min);
	sprintf (max_text, "%d", max);
	XmTextSetString (autoImageValueData->minimum_text, min_text); 
	XmTextSetString (autoImageValueData->maximum_text, max_text); 
d1467 1
d1515 2
a1516 2
	if (file_state == OpenAtlas || file_state == OpenImage1 || OpenImage2 || file_state == OpenAF3D
		|| file_state == OpenRegion || file_state == OpenMask)
d1910 2
a1911 1
	BOOLEAN		auto_pet_value_flag	= bAutoImage1ValueFlag;
d1918 2
a1919 1
	char		pet_value_flag		= cImage1ValueFlag;
d1959 4
a1962 3
			GetImageMinMax (TRUE, auto_pet_value_flag, &minimum, &maximum);
			ColorBarText (display, window, gc, &minimum, &maximum, font_struct, 
				*horizontal_flag1, *x1, *y1, *length1, *width1, TRUE);
d1971 4
a1974 3
			GetImageMinMax (FALSE, auto_pet_value_flag, &minimum, &maximum);
			ColorBarText (display, window, gc, &minimum, &maximum, font_struct, 
				*horizontal_flag2, *x2, *y2, *length2, *width2, TRUE);
d2028 1
a2028 1
				*horizontal_flag1, pet_value_flag, szImage1ColorTableName, TRUE); 
d2031 4
a2034 3
			GetImageMinMax (TRUE, auto_pet_value_flag, &minimum, &maximum);
			ColorBarText (display, window, gc, &minimum, &maximum, font_struct, 
				*horizontal_flag1, *x1, *y1, *length1, *width1, FALSE, pet_value_flag);
d2037 1
a2037 1
				*horizontal_flag2, pet_value_flag, szImage2ColorTableName, FALSE); 
d2040 4
a2043 3
			GetImageMinMax (FALSE, auto_pet_value_flag, &minimum, &maximum);
			ColorBarText (display, window, gc, &minimum, &maximum, font_struct, 
				*horizontal_flag2, *x2, *y2, *length2, *width2, FALSE, pet_value_flag);
d2992 4
d2997 1
d2999 1
a2999 1
	XmTextSetString (magnification_scale_data->text_min, szBuffer); 
d3001 1
a3001 1
	XmTextSetString (magnification_scale_data->text_max, szBuffer); 
d3763 22
a3784 1
		rCurrentScaleHeader, plist1, cAtlasOrientation);
@


2.14
log
@Added processing for analyze .hdr files.
@
text
@d2 3
d158 1
a158 1
/*$Header: /data/petsun4/src/view25d/RCS/view25d.callbacks,v 2.13 1995/06/13 20:13:10 ty7777 Exp ty7777 $*/
a205 2
	Display		*display;
	llist		temp_plist	= plist;
d207 2
a208 3
	display = drawData->display;

	XClearArea (display, drawData->window, 0, 0, DRAW_AREA_WIDTH, DRAW_AREA_HEIGHT, FALSE);
d230 4
a233 4
	MAG_SCALE_DATA		*mag_scale_data	= (MAG_SCALE_DATA *) clientData;
	MAG_SCALE_MENU		*mag_scale_menu	= mag_scale_data->mag_scale_menu;
	Display			*display	= mag_scale_data->draw_data->display;
	Window			window		= mag_scale_data->draw_data->window;
d236 7
a242 7
	char 			node_flag	= mag_scale_data->node_flag;
	float			*slice_scale	= &dSliceMagnification;
	float			new_scale	= *slice_scale;
	char			*pet_value_flag	= &cPetValueFlag;
	short			*min_pixel_value	= &nMinPetValue;
	short			*max_pixel_value	= &nMaxPetValue;
	BOOLEAN			*auto_pet_value_flag	= &bAutoPetValueFlag;
d294 1
a294 1
			RedrawPortals (mag_scale_data->draw_data, atlas, plist);
d349 2
a350 2
	short			*xstart			= &nxImageStart;
	short			*ystart			= &nyImageStart;
a357 1
	BOOLEAN			*atlas_trim		= &bAtlasTrim;
a439 1
		*atlas_trim	= XmToggleButtonGetState (*format_screen_menu->atlas_trim);
d443 1
a443 1
			RedrawPortals (formatScreenData->draw_data, atlas, plist);
d641 2
a642 1
	PetColormap (display, nonImageColorData->root_window, szColorTableName);
d650 1
a650 1
		PetColorCallback
d661 1
a661 1
void PetColorCallback (w, clientData, callData)
d666 5
a670 7
	PET_COLOR_DATA	*petColorData 
			= (PET_COLOR_DATA *) clientData;
	char		*StrColorTableName;
	Widget		color_table_list;
	char		*color_table_name	= szColorTableName;
	int		*color_table_index	= &nColorTableIndex;
	XmString	item;
d682 6
a687 2
		PetColormap (petColorData->display, 
			petColorData->root_window, color_table_name);
d793 3
a795 3
		case OpenPet:
			strcpy (path_name, szPetPathName);
			strcpy (file_name, szPetFileName);
d797 4
d806 2
a807 2
			strcpy (path_name, szPetMaskPathName);
			strcpy (file_name, szPetMaskFileName);
d915 1
a915 1
	RedrawPortals (draw_data, atlas, plist);
d996 10
a1005 8
	Boolean			*apply_mask	= &bApplyMask;
	Boolean			*display_atlas	= &bDisplayAtlas;
	Boolean			*display_label	= &bDisplayLabel;
	Boolean			*display_pet	= &bDisplayPet;
	Boolean			*slice_num_flag	= &bSliceNumberFlag;
	char			*atlas_orient	= &cAtlasOrientation;
	char			node		= selectSliceOKData->node_flag;
	char			*pet_filename	= szPetFileName;
d1032 1
d1058 1
a1058 1
			if (strlen (pet_filename) > 0)
d1066 1
a1066 1
				if (getimagedim (pet_filename, matval, &image_type, &width, &height, 
d1156 1
a1156 1
			RedrawPortals (selectSliceOKData->draw_data, atlas, plist);
d1162 1
d1279 2
a1280 2
	AUTO_PET_VALUE_DATA			*autoPetValueData	
					= (AUTO_PET_VALUE_DATA *) clientData;
d1294 1
a1294 1
	GetPetMinMax (ToggleData->set, &min, &max);
d1298 2
a1299 2
	XmTextSetString (autoPetValueData->minimum_text, min_text); 
	XmTextSetString (autoPetValueData->maximum_text, max_text); 
d1369 2
d1420 22
d1465 1
a1465 1
	if (file_state == OpenAtlas || file_state == OpenPet || file_state == OpenAF3D
d1525 2
a1526 1
		case OpenPet:
d1556 5
a1605 4
			strcpy (szPetPathName, dirname);
			strcpy (szPetFileName, szBuffer2);
			bPetImageSelected	= TRUE;

d1608 17
a1624 1
			strcat (szBuffer, szBuffer2);
a1660 2
printf ("return_value = %d\n", return_value);
printf ("pett_num = %d\n", pett_num);
d1750 2
a1751 2
			strcpy (szPetMaskPathName, dirname);
			strcpy (szPetMaskFileName, szBuffer2);
d1856 1
a1856 1
	COLOR_BAR_DATA	*colorBarData	= (COLOR_BAR_DATA *) clientData;
d1858 10
a1867 9
	BOOLEAN		*horizontal_flag	= &bHorizontalColorBar;
	BOOLEAN		auto_pet_value_flag	= bAutoPetValueFlag;
	COLOR_BAR_MENU	*color_bar_menu	= colorBarData->color_bar_menu;
	Display		*display	= colorBarData->draw_data->display;
	GC		gc		= colorBarData->draw_data->gc;
	Window		window		= colorBarData->draw_data->window;
	XFontStruct	*font_struct	= FontStruct;
	char		node		= colorBarData->node_flag;
	char		pet_value_flag	= cPetValueFlag;
d1873 2
a1874 1
	short		*length		= &nColorBarLength;
d1877 6
a1882 3
	short		*width		= &nColorBarWidth;
	short		*x		= &nxColorBarStart;
	short		*y		= &nyColorBarStart;
d1886 5
a1890 5
		nxOldColorBar		= *x;
		nyOldColorBar		= *y;
		nOldColorBarLength	= *length;
		nOldColorBarWidth	= *width;
		bOldHoriColorBar	= *horizontal_flag;
d1892 6
d1900 2
a1901 2
			wcolorbar		= *length;
			hcolorbar		= *width;
d1903 1
a1903 1
			if (!(*horizontal_flag))
d1906 2
a1907 2
			XClearArea (display, window, *x, *y, wcolorbar, hcolorbar, FALSE); 
			GetPetMinMax (auto_pet_value_flag, &minimum, &maximum);
d1909 12
a1920 1
				*horizontal_flag, *x, *y, *length, *width, TRUE);
d1923 1
a1923 1
		*horizontal_flag	= XmToggleButtonGetState (*color_bar_menu->orientation);
d1925 2
a1926 2
		str1 = XmTextGetString (*color_bar_menu->xstart);
		str2 = XmTextGetString (*color_bar_menu->ystart);
d1930 2
a1931 2
			*x	= atoi (str1);
			*y	= atoi (str2);
d1936 2
a1937 2
		str1 = XmTextGetString (*color_bar_menu->width);
		str2 = XmTextGetString (*color_bar_menu->height);
d1941 2
a1942 2
			*length	= atoi (str1);
			*width	= atoi (str2);
d1947 24
d1973 2
a1974 2
			DrawColorBar (display, window, gc, *x, *y, 
				*length, *width, *horizontal_flag, pet_value_flag); 
d1977 1
a1977 1
			GetPetMinMax (auto_pet_value_flag, &minimum, &maximum);
d1979 9
a1987 1
				*horizontal_flag, *x, *y, *length, *width, FALSE, pet_value_flag);
d1992 2
a1993 2
		sprintf (szBuffer, "%d", *x); 
		XmTextSetString (*color_bar_menu->xstart, szBuffer); 
d1995 2
a1996 2
		sprintf (szBuffer, "%d", *y); 
		XmTextSetString (*color_bar_menu->ystart, szBuffer); 
d1998 2
a1999 2
		sprintf (szBuffer, "%d", *length); 
		XmTextSetString (*color_bar_menu->width, szBuffer); 
d2001 2
a2002 2
		sprintf (szBuffer, "%d", *width); 
		XmTextSetString (*color_bar_menu->height, szBuffer); 
d2004 15
a2018 1
		SetSelectData (*color_bar_menu->orientation, *horizontal_flag);
d2259 1
a2259 1
				plist, cAtlasOrientation, wImageNameCascade, FALSE);
d2366 1
a2366 1
					rCurrentScaleHeader, plist, cAtlasOrientation, 
d2636 2
a2637 2
					PetColormap (display, graphics_data->root_window, 
								szColorTableName);
d2643 1
a2643 1
					rCurrentScaleHeader, plist, cAtlasOrientation, 
d2935 1
a2935 1
	GetPetMinMax (bAutoPetValueFlag, &min, &max);
d3078 1
a3078 1
			RedrawPortals (region_data->draw_data, atlas, plist);
d3403 1
a3403 1
			RedrawPortals (symbol_data->draw_data, atlas, plist);
d3702 1
a3702 1
		rCurrentScaleHeader, plist, cAtlasOrientation);
@


2.13
log
@Added procesing for reading .hdr files.
@
text
@d2 3
d155 1
a155 1
/*$Header: /data/petsun4/src/view25d/RCS/view25d.callbacks,v 2.12 1995/06/12 19:32:33 ty7777 Exp ty7777 $*/
d1342 1
a1342 1
	Arg			arglist [1];
d1375 1
d1504 1
d1507 12
d1520 1
a1520 1
			close (imgfd);
d1581 1
a1581 1
			if (zorigin_new != *pzorigin)
d1596 5
a1600 2
				*pzorigin	= zorigin_new;
				bZoriginChanged	= TRUE;
d1606 28
a1633 2
				if (getimagedim (szBuffer2, matval, &pett_num, &width, &height, 
				&num_slices, &voxel_width, &voxel_height, &voxel_depth) == FAIL)
@


2.12
log
@Added MRI processing.
@
text
@d2 3
d152 1
a152 1
/*$Header: /data/petsun4/src/view25d/RCS/view25d.callbacks,v 2.11 1995/06/07 14:36:51 ty7777 Exp ty7777 $*/
d1494 1
d1496 2
a1603 1
printf ("Harvard: min_slice_num = %d max_slice_num = %d\n", min_slice_num, max_slice_num);
@


2.11
log
@relieve the ckecking for 75 slices.
@
text
@d2 3
d149 1
a149 1
/*$Header: /data/petsun4/src/view25d/RCS/view25d.callbacks,v 2.10 1995/06/05 19:52:46 ty7777 Exp ty7777 $*/
a1085 1
printf ("Stanford: min_slice_num = %d max_slice_num = %d\n", min_slice_num, max_slice_num);
@


2.10
log
@Same as the last version.
@
text
@d2 3
d146 1
a146 1
/*$Header: /data/petsun4/src/view25d/RCS/view25d.callbacks,v 2.9 1995/01/17 20:08:42 ty7777 Exp ty7777 $*/
d989 1
d993 5
d1000 1
d1005 1
d1008 2
a1009 1
	int			n;
d1041 1
a1041 1
			if (*atlas_orient == TRANSVERSE)
d1043 22
a1064 1
				max_slice_num	= MAX_TRANS_ATLAS_NUM;
d1068 12
a1079 1
				max_slice_num	= MAX_ATLAS_NUM;
d1081 1
d1083 1
d1360 1
d1578 4
d1584 1
a1584 1
					max_slice_num	= MAX_TRANS_ATLAS_NUM; 
d1586 4
d1592 1
a1592 1
					max_slice_num	= MAX_ATLAS_NUM;
d1594 1
d1596 1
@


2.9
log
@Deleted things that are related to data_stes.
@
text
@d2 3
d143 1
a143 1
/*$Header: /home/petsun4/ty7777/src/view25d/RCS/view25d.callbacks,v 2.8 1995/01/12 19:51:37 ty7777 Exp ty7777 $*/
@


2.8
log
@Deleted ClearData () inside comments.
@
text
@d2 3
d140 1
a140 1
/*$Header: /home/petsun4/ty7777/src/view25d/RCS/view25d.callbacks,v 2.7 1994/12/01 20:11:20 ty7777 Exp ty7777 $*/
d279 1
a279 1
			RedrawPortals (mag_scale_data->draw_data, atlas, plist, data_sets);
d430 1
a430 1
			RedrawPortals (formatScreenData->draw_data, atlas, plist, data_sets);
d895 1
a895 1
	RedrawPortals (draw_data, atlas, plist, data_sets);
d1091 1
a1091 1
			RedrawPortals (selectSliceOKData->draw_data, atlas, plist, data_sets);
d2848 1
a2848 1
			RedrawPortals (region_data->draw_data, atlas, plist, data_sets);
d3173 1
a3173 1
			RedrawPortals (symbol_data->draw_data, atlas, plist, data_sets);
@


2.7
log
@Get rid of path in .atl files.
@
text
@d2 3
d137 1
a137 1
/*$Header: /home/petsun4/ty7777/src/view25d/RCS/view25d.callbacks,v 2.6 1994/12/01 17:13:16 ty7777 Exp ty7777 $*/
a190 3
	/*
	ClearData (temp_plist, atlas, data_sets);
	*/
@


2.6
log
@Pass library_path from the main program to callback functions.
@
text
@d2 3
d134 1
a134 1
/*$Header: /home/petsun4/ty7777/src/view25d/RCS/view25d.callbacks,v 2.5 1994/11/04 16:21:31 ty7777 Exp ty7777 $*/
d1427 1
a1427 1
			ReadAtlasHeader (szBuffer2);
@


2.5
log
@Use slice 31 as the default z0.
@
text
@d2 3
d131 1
a131 1
/*$Header: /home/petsun4/ty7777/src/view25d/RCS/view25d.callbacks,v 2.4 1994/11/03 20:14:26 ty7777 Exp ty7777 $*/
d661 1
a661 1
		strcpy (color_table_name, szLibraryPathName);
d913 1
a913 1
	DATA_TYPE_MENU		*data_type_menu = data_type->data_type_menu;
d967 1
a967 1
				= selectSliceOKData->data_type_menu;
d1000 1
a1000 1
		SetDefaultAtlas (*atlas_orient);
d1420 2
a1421 1
				SetDefaultAtlas (atlas_orient);
@


2.4
log
@Added processing for local_path.
@
text
@d2 3
d128 1
a128 1
/*$Header: /home/petsun4/ty7777/src/view25d/RCS/view25d.callbacks,v 2.3 1994/10/28 16:18:25 ty7777 Exp ty7777 $*/
d1460 1
a1460 1
			"There is no z0 information in your image. Please add z0 slice with setz0.\n");
d1469 3
a1471 4
					free (xmstring_buffer);
					XtFree (dirname);
					XtFree (filename);
					return;
@


2.3
log
@Added checking for the z0 slice.
@
text
@d2 3
d125 1
a125 1
/*$Header: /home/petsun4/ty7777/src/view25d/RCS/view25d.callbacks,v 2.2 1994/10/19 19:26:41 ty7777 Exp ty7777 $*/
a753 1
	char			*pwd;
a810 1
	pwd	= getenv ("PWD");
d816 1
a816 1
		strcpy (pure_pathname, pwd);
d836 1
a836 1
		if (strcmp (pure_pathname, pwd) == 0)  /* ??? */
@


2.2
log
@Fixed the pwd problem for show files.
@
text
@d2 3
d122 1
a122 1
/*$Header: /home/petsun4/ty7777/src/view25d/RCS/view25d.callbacks,v 2.1 1994/10/19 17:05:19 ty7777 Exp ty7777 $*/
a1391 1

a1419 14
			strcpy (szPetPathName, dirname);
			strcpy (szPetFileName, szBuffer2);
			bPetImageSelected	= TRUE;

			bzero (szBuffer, MAXLINE);
			strcpy (szBuffer, szAtlasCoordinate);
			strcat (szBuffer, szBuffer2);
			xmstring_buffer	= XmStringCreate (szBuffer, 
					XmSTRING_DEFAULT_CHARSET); 
			n	= 0;
			XtSetArg (arglist [n], XmNlabelString, xmstring_buffer); n++;
			XtSetValues (wImageNameCascade, arglist, n);
			free (xmstring_buffer);

d1423 1
a1423 1
			imgfd	= open (szPetFileName, O_RDONLY, 0);
d1425 1
a1425 1
				fprintf (stderr, "Can't open %d\n", szPetFileName); 
d1427 1
a1427 1
			pett_num	= getimage_type (imgfd, szPetFileName, &encoded, &num_slices);
d1441 1
a1441 1
				fptr	= OpenEcat (szPetFileName, &num_slices, &width, &height, 
d1445 1
a1445 1
					fprintf (stderr, "Cannnot open image %s.\n", szPetFileName);
d1452 18
d1475 17
@


2.1
log
@Same as the last version.
@
text
@d2 3
d119 1
a119 1
/*$Header: /home/petsun4/ty7777/src/view25d/RCS/view25d.callbacks,v 1.66 1994/10/18 20:07:38 ty7777 Exp ty7777 $*/
d806 1
a811 1
		pwd	= getenv ("PWD");
a844 1

@


1.66
log
@*pattern* works.
@
text
@d2 3
d116 1
a116 1
/*$Header: /amd/home/petsun4/ty7777/src/view25d/RCS/view25d.callbacks,v 1.65 1994/10/18 19:42:10 ty7777 Exp ty7777 $*/
@


1.65
log
@After *pattern works.
@
text
@d2 3
d113 1
a113 1
/*$Header: /home/petsun4/ty7777/src/view25d/RCS/view25d.callbacks,v 1.64 1994/10/17 20:12:05 ty7777 Exp ty7777 $*/
d788 1
a788 1
	sbuffer	= strrchr (path_name, '*');
d3938 1
a3938 1
		text	= strrchr (filename, '*');
@


1.64
log
@After *.pattern works.
@
text
@d2 3
d110 1
a110 1
/*$Header: /home/petsun4/ty7777/src/view25d/RCS/view25d.callbacks,v 1.63 1994/08/30 14:38:52 ty7777 Exp ty7777 $*/
a734 1
	char			*extension;
d738 1
d740 1
d785 2
a786 2
	extension	= strrchr (file_name, '.');
	if (extension && *extension)
d788 1
a788 2
		strcpy (file_pattern, "*");
		strcat (file_pattern, extension);
d796 12
a808 2
	xmpath_name	= XmStringCreate (path_name, XmSTRING_DEFAULT_CHARSET);
	xmfile_pattern	= XmStringCreate (file_pattern, XmSTRING_DEFAULT_CHARSET);
d819 1
a819 1
	if (strlen (path_name) > 0)
d823 2
a824 3
		pwd	= getenv ("PWD");
		if (strcmp (path_name, pwd) == 0)
			strcat (path_name, "/.");
d826 1
a826 1
		item		= XmStringCreate (path_name, XmSTRING_DEFAULT_CHARSET);
a857 1

d1275 1
a1275 1
	char			*dir_name;
d1277 1
a1277 1
	char			*file_name;
d1308 1
a1308 1
	dir_name	= XmTextGetString (XmFileSelectionBoxGetChild (dialog, 
d1310 3
a1312 3
	string1		= strrchr (dir_name, '/');
	strncpy (szBuffer1, dir_name, strlen (dir_name)  - strlen (string1) + 1);
	file_name	= XmTextGetString (XmFileSelectionBoxGetChild (dialog, 
d1315 1
a1315 1
	string2		= strrchr (file_name, '/');
d1322 1
a1322 1
		strcpy (szBuffer, file_name);
d1339 2
a1340 2
		XtFree (dir_name);
		XtFree (file_name);
d1362 2
a1363 2
			XtFree (dir_name);
			XtFree (file_name);
d1385 2
a1386 2
				XtFree (dir_name);
				XtFree (file_name);
d1405 1
d1410 1
a1410 1
			strcpy (szPetPathName, szBuffer1);
d1530 1
a1530 1
			strcpy (szRegionPathName, szBuffer1);
d1536 1
a1536 1
				string	= file_name;
d1544 1
a1544 1
			strcpy (szPetMaskPathName, szBuffer1);
d1549 1
a1549 1
			strcpy (szAF3DPathName, szBuffer1);
d1555 1
a1555 1
				string	= file_name;
d1564 1
a1564 1
				file_name, selectFileData->default_parameters,
d1566 1
a1566 1
			strcpy (szDefaultsPathName, szBuffer1);
d1570 1
a1570 1
			strcpy (szDefaultsPathName, szBuffer1);
d1582 1
a1582 1
			strcpy (szWinDumpPathName, szBuffer1);
d1591 1
a1591 1
			strcpy (szCoordinatesPathName, szBuffer1);
d1600 2
a1601 2
	XtFree (dir_name);
	XtFree (file_name);
d3931 1
a3931 1
	strncpy (cbuffer, "\0", MAXLINE);
d3935 10
a3944 1
		strcat (cbuffer, ".");
d3950 9
a3958 2
		strncpy (cbuffer, coordinates_path, strlen (coordinates_path)  - 1);
		strcat (cbuffer, filename);
@


1.63
log
@Modified read_file ().
@
text
@d2 3
d107 1
a107 1
/*$Header: /home/petsun4/ty7777/src/view25d/RCS/view25d.callbacks,v 1.62 1994/08/17 21:20:16 ty7777 Exp ty7777 $*/
d724 1
a724 1
	int			n;
d726 1
a726 4
	char			path_name [MAXLINE];
	char			file_name [MAXLINE];
	char			*pwd;
	XmString		xm_path_name;
d729 1
d731 7
a737 1
	BOOLEAN			item_new;
d781 12
a792 4
	XtFree (xmStrPathName);
	xm_path_name	= XmStringCreate (path_name, XmSTRING_DEFAULT_CHARSET);
	xmStrPathName	= xm_path_name;

d794 2
d798 1
a798 1
	XtSetArg (arglist [n], XmNdirectory, xm_path_name); n++;
d801 1
a801 1
	XtSetArg (arglist [n], XmNpattern, fileSelectionData->pattern); n++;
d803 2
d1261 1
a1401 1
			XtFree (xmStrImageName);
d1405 1
a1405 1
			xmStrImageName	= XmStringCreate (szBuffer, 
d1408 1
a1408 1
			XtSetArg (arglist [n], XmNlabelString, xmStrImageName); n++;
d1410 1
@


1.62
log
@Use the zvalues as the reference for transverse PET iamges.
@
text
@d2 3
d104 1
a104 1
/*$Header: /home/petsun4/ty7777/src/view25d/RCS/view25d.callbacks,v 1.61 1994/08/17 19:47:17 ty7777 Exp ty7777 $*/
a3733 1
	extern void activate_cb ();
d3795 1
a3795 1
	XtVaCreateManagedWidget ("label", xmLabelGadgetClass, rowcol,
d3805 1
a3805 1
	XtVaCreateManagedWidget ("Search Pattern:", xmLabelGadgetClass, rowcol_h, NULL);
d3837 1
a3837 1
		read_file (file_w, text_w, cbs);
a4009 14

/*--------------*/

/* When Return is pressed in TextField widget, respond by getting
 * the designated "default button" in the action area and activate
 * it as if the user had selected it.
 */
static void activate_cb (text_w, client_data, cbs)
Widget text_w;              /* user pressed Return in this widget */
XtPointer client_data;        /* action_area passed as client data */
XmAnyCallbackStruct *cbs;   /* borrow the "event" field from this */
{
}

d4018 1
a4018 1
	XmFileSelectionBoxCallbackStruct *cbs;
a4034 7
	else 
	{
		/* file was selected from FileSelectionDialog */
		XmStringGetLtoR (cbs->value, XmSTRING_DEFAULT_CHARSET, &filename);
		/* the user data stored the file_w widget in the text_w */
		XtVaGetValues (text_w, XmNuserData, &file_w, NULL);
	}
@


1.61
log
@Display the bottom slices.
@
text
@d2 3
d101 1
a101 1
/*$Header: /home/petsun4/ty7777/src/view25d/RCS/view25d.callbacks,v 1.60 1994/08/17 19:08:14 ty7777 Exp ty7777 $*/
d1251 1
d1429 13
@


1.60
log
@Added dynamic change for X, Y, and Z values.
@
text
@d2 3
d98 1
a98 1
/*$Header: /home/petsun4/ty7777/src/view25d/RCS/view25d.callbacks,v 1.59 1994/08/16 16:30:47 ty7777 Exp ty7777 $*/
d968 1
a968 2
				max_slice_num	= MAX_TRANS_ATLAS_NUM + (zorigin - DEFAULT_ZORIGIN);
				min_slice_num	= (zorigin - DEFAULT_ZORIGIN) + 1;
a972 1
				min_slice_num	= 1;
d974 1
d1434 1
a1434 3
					max_slice_num	= MAX_TRANS_ATLAS_NUM 
							+ (*pzorigin - DEFAULT_ZORIGIN);
					min_slice_num	= (*pzorigin - DEFAULT_ZORIGIN) + 1;
a1438 1
					min_slice_num	= 1;
d1440 1
@


1.59
log
@Added the callback function ShowDataTypeCallback ().
@
text
@d2 3
d95 1
a95 1
/*$Header: /home/petsun4/ty7777/src/view25d/RCS/view25d.callbacks,v 1.58 1994/08/12 16:59:52 ty7777 Exp ty7777 $*/
a452 1
	int				n = 0;
d455 1
d457 1
d465 2
a466 2
	XtSetArg (arglist [n], XmNlabelString,
		XmStringCreate (szBuffer, XmSTRING_DEFAULT_CHARSET)); n++;
d468 1
d491 2
d495 2
a497 2
	Arg			arglist [2];
	char			buffer [MAXLINE];
d523 2
a524 2
		XtSetArg (arglist[n], XmNlabelString, XmStringCreate (buffer, 
				XmSTRING_DEFAULT_CHARSET)); n++;
d526 1
d534 2
a535 2
		XtSetArg (arglist[n], XmNlabelString, XmStringCreate (buffer, 
				XmSTRING_DEFAULT_CHARSET)); n++;
d537 1
d2490 1
a2490 1
	int				n = 0;
d2493 4
a2499 2
	char				szBuffer [MAXLINE];
	char				atlas_orient;
d2502 2
a2503 1
	status	= ToggleData->set;
d2505 1
d2522 3
a2524 2
	XtSetArg (arglist [n], XmNlabelString,
		XmStringCreate (szBuffer, XmSTRING_DEFAULT_CHARSET)); n++;
d2526 1
d2536 58
@


1.58
log
@Added error checking for slice numbers.
@
text
@d2 3
d92 1
a92 1
/*$Header: /home/petsun4/ty7777/src/view25d/RCS/view25d.callbacks,v 1.57 1994/05/19 14:12:38 ty7777 Exp ty7777 $*/
d830 46
d951 2
a952 1
			 * Check if the first and last slice are within the allowed range.
d1226 1
d1246 1
d1248 3
d1354 1
a1354 1
				SetDefaultAtlas (cAtlasOrientation);
d1416 48
@


1.57
log
@Change from (z, x, y) to (x, y, z).
@
text
@d2 3
d89 1
a89 1
/*$Header: /amd/home/petsun4/ty7777/src/view25d/RCS/view25d.callbacks,v 1.56 1994/04/18 17:56:06 ty7777 Exp ty7777 $*/
d853 2
a854 10
	char 			*str1;
	char 			*str2;
	char			node			
				= selectSliceOKData->node_flag;
	short			*first_slice	= &nFirstSlice;
	short			*last_slice	= &nLastSlice;			
	short			*spacing	= &nSpacing;			
	short			first;
	short			last;
	short			space;
d857 1
a858 1
	Boolean			*display_label	= &bDisplayLabel;
d861 3
d865 8
a873 1
	Arg			arglist [2];
d900 50
@


1.56
log
@Added processing for view25d.
@
text
@d2 3
d86 1
a86 1
/*$Header: /home/petsun4/ty7777/src/view25d/RCS/view25d.callbacks,v 1.55 1994/01/24 20:10:05 ty7777 Exp ty7777 $*/
d3341 1
a3341 1
			if (sscanf (string_buffer, "%f %f %f", &z, &x, &y) == 3) 
@


1.55
log
@Same as the last one.
@
text
@d2 3
d83 1
a83 1
/*$Header: /home/petsun4/ty7777/src/view25d/RCS/view25d.callbacks,v 1.54 1994/01/13 18:12:07 ty7777 Exp ty7777 $*/
d1105 4
d1110 2
d1113 1
d1115 5
a1119 3
	char			szBuffer [MAXLINE];
	char			szBuffer1 [MAXLINE];
	char			szBuffer2 [MAXLINE];
d1121 1
a1121 5
	char			*dir_name;
	FileStatus		file_state	= cFileState;  	/* file type */
	int			n;
	Arg			arglist [1];
	char			alter_index;
d1125 5
a1129 2
	Widget			file_list;
	FILE			*fp;
d1131 5
a1135 3
	Widget			*message_box	= &errorMessageBox;
	char			*extension;
	char			s [2];		/* string holding path length */
d1137 2
d1140 2
d1260 44
@


1.54
log
@Added text view for creating af3d files.
@
text
@d2 3
d80 1
a80 1
/*$Header: /home/petsun4/ty7777/src/view25d/RCS/view25d.callbacks,v 1.53 1994/01/11 22:29:44 ty7777 Exp ty7777 $*/
d800 1
@


1.53
log
@Added processing for Legend Dim.
@
text
@d2 3
d77 1
a77 1
/*$Header: /export/home/petsun4/ty7777/src/view25d/RCS/view25d.callbacks,v 1.52 1994/01/10 23:30:59 ty7777 Exp ty7777 $*/
d3121 1
d3123 3
a3125 2
	XmFileSelectionBoxCallbackStruct *cbs;
	char			*af3d_file		= NULL;
d3133 46
d3203 1
d3205 2
a3206 1
	Arg		arglist [1];
d3208 2
a3211 3
	char		*data_string;
	int		n;
	Widget		*message_box	= &errorMessageBox;
d3213 2
a3214 1
	char		buffer [MAXLINE];
d3217 2
a3222 2
	int		num_points;
	char		*string_buffer;
d3241 6
d3248 1
a3248 2
		XtSetArg (arglist [n], XmNlabelString,
			XmStringCreate (file_name, XmSTRING_DEFAULT_CHARSET)); n++;
d3250 2
@


1.52
log
@Change names for HD6 Brain and T88 Brain.
@
text
@d2 3
d74 1
a74 1
/*$Header: /home/petsun4/ty7777/src/view25d/RCS/view25d.callbacks,v 1.51 1993/12/16 17:09:26 ty7777 Exp ty7777 $*/
d1641 1
d1699 1
a1699 1
			legend_width, legend_height);
d1701 2
a1702 2
					graphics_data->start_x, 
					graphics_data->start_y,
d1739 1
d1808 2
a1809 2
					graphics_data->start_x, 
					graphics_data->start_y,
d1817 2
a1818 2
					graphics_data->start_x, 
					graphics_data->start_y,
d1884 1
d2112 2
a2113 2
					graphics_data->start_x, 
					graphics_data->start_y,
d3119 2
d3124 5
d3241 2
@


1.51
log
@Fixed problem for the DrawLabel bounding rectangle.
@
text
@d2 3
d71 1
a71 1
/*$Header: /home/petsun4/ty7777/src/view25d/RCS/view25d.callbacks,v 1.50 1993/12/16 15:53:06 ty7777 Exp ty7777 $*/
d2365 1
a2365 1
		strcpy (szBuffer, "T88 Brain");
d2367 1
a2367 1
		strcpy (szBuffer, "HD6 Brain");
@


1.50
log
@Added processing for TextEdit.
@
text
@d2 3
d68 1
a68 1
/*$Header: /home/petsun4/ty7777/src/view25d/RCS/view25d.callbacks,v 1.49 1993/12/14 20:01:38 ty7777 Exp ty7777 $*/
d1355 3
a1358 1
	char		node		= colorBarData->node_flag;
d1360 1
d1362 3
a1364 1
	GC		gc		= colorBarData->draw_data->gc;
d1367 3
a1369 2
	short		*x		= &nxColorBarStart;
	short		*y		= &nyColorBarStart;
a1370 5
	short		*width		= &nColorBarWidth;
	BOOLEAN		*horizontal_flag	= &bHorizontalColorBar;
	BOOLEAN		auto_pet_value_flag	= bAutoPetValueFlag;
	char		szBuffer [MAXLINE];
	char		pet_value_flag	= cPetValueFlag;
d1373 3
a1375 3
	int		wcolorbar;
	int		hcolorbar;
	XFontStruct	*font_struct	= FontStruct;
d1500 2
d1504 2
d1507 3
d1511 1
a1511 2
	char		*buffer;
	int		point_size;
d1513 2
a1514 2
	char		font_color_name [MAXLINE];
	XFontStruct	*font_struct;
d1516 1
d1518 1
a1518 7
	int		*line_spacing	= &nLineSpacing;
	Arg		arglist [1];
	Widget		widget_buffer;
	char		*color_index	= &cTextColorIndex;
	char		*slant_index	= &cFontSlantIndex;
	char		*weight_index	= &cFontWeightIndex;
	char		*orient_index	= &cFontOrientIndex;
d1625 1
d1673 1
a1673 1
			GetLabelDim (FontStruct, szTextString, nLineSpacing, orient, 
d1681 1
a1681 1
			XDrawRectangle (display, window, xorgc, xstart, ystart,
d1727 1
d1778 3
a1780 2
				XDrawRectangle (display, window, xorgc, xstart, ystart,
					graphics_data->label_width, graphics_data->label_height);
d1787 3
a1789 2
				XDrawRectangle (display, window, xorgc, xstart, ystart,
					graphics_data->label_width, graphics_data->label_height);
d1849 1
d2079 1
a2079 1
				XDrawRectangle (display, window, xorgc, x, y,
d2088 1
a2088 1
					pixelTextColor, FontStruct, text_string, 
d2150 1
@


1.49
log
@Added proicessing for dMaximumDistance.
@
text
@d2 3
d65 1
a65 1
/*$Header: /home/petsun4/ty7777/src/view25d/RCS/view25d.callbacks,v 1.48 1993/12/13 15:20:37 ty7777 Exp ty7777 $*/
a1611 1
	static char	*function	= "ButtonDownEventHandler";
d1613 1
a1614 2
	Window		window		= graphics_data->draw_data->window;
	Window		root_window	= DefaultRootWindow (display);
a1616 1
	char		*text_string	= szTextString;
d1618 2
d1621 8
a1628 1
	int		type, format, nitems, left;
d1631 1
d1659 1
a1659 1
			DrawRectangle (display, window, xorgc, 
d1662 2
a1663 2
					graphics_data->start_x + wClipboard, 
					graphics_data->start_y + hClipboard);
d1667 2
a1668 5
			DrawLabel (display, window, gc, 
				graphics_data->start_x, graphics_data->start_y, 
				graphics_data->last_x, graphics_data->last_y, 
				pixelTextColor, FontStruct, text_string, 
				cAlignment, nLineSpacing, cFontOrientIndex);
d1670 4
a1673 1
			XtFree (text_string);
d1675 4
a1678 1
			*pointer_state	= NoState; 
d1687 1
a1687 1
			DrawRectangle (display, window, xorgc, 
d1690 2
a1691 2
					graphics_data->start_x + *legend_width, 
					graphics_data->start_y + *legend_height);
d1717 1
d1719 1
d1721 4
a1724 1
	GC		xorgc		= graphics_data->xorgc;
d1727 1
a1728 1
	unsigned int	*clipboard_h	= &hClipboard;
d1749 1
a1749 1
				DrawRectangle (display, window, xorgc, 
d1752 2
a1753 2
					graphics_data->start_x + *clipboard_w, 
					graphics_data->start_y + *clipboard_h);
d1758 1
a1758 1
				DrawRectangle (display, window, xorgc, 
d1761 2
a1762 2
					graphics_data->start_x + *clipboard_w, 
					graphics_data->start_y + *clipboard_h);
d1765 18
d1790 1
a1790 1
				DrawRectangle (display, window, xorgc, 
d1793 2
a1794 2
					graphics_data->start_x + *legend_width, 
					graphics_data->start_y + *legend_height);
d1796 2
a1797 2
				graphics_data->start_x	= event->xbutton.x,
				graphics_data->start_y	= event->xbutton.y,
d1799 1
a1799 1
				DrawRectangle (display, window, xorgc, 
d1802 2
a1803 2
					graphics_data->start_x + *legend_width, 
					graphics_data->start_y + *legend_height);
d1829 14
a1842 18
	GRAPHICS_DATA	*graphics_data	= (GRAPHICS_DATA *) clientData;
	Display		*display	= graphics_data->draw_data->display;
	Window		window		= graphics_data->draw_data->window;
	Window		root_window	= DefaultRootWindow (display);
	GC		gc		= graphics_data->draw_data->gc;
	GC		xorgc		= graphics_data->xorgc;
	PointerStatus	*pointer_state;
	int		x;
	int		y;
	int		x2;
	int		y2;
	unsigned int	*clipboard_w	= &wClipboard;
	unsigned int	*clipboard_h	= &hClipboard;
	int		result;
	long		itemid, dataid;
	int		length, id;
	XmString	clip_label;
	static int	cnt;
d1844 26
a1869 12
	XImage		*image;
	XImage		*retimage;
	char		*image_data;
	char		*retimage_data;
	int		i;
	XColor		*colors;
	XColor		*retcolors;
	int		ncolors;
	int		*retncolors;
	unsigned int	buffer_size;
	int		type, format, nitems, left;
	Colormap	colormap;
d1982 1
a1982 1
				DrawRectangle (display, window, xorgc, 
d1985 2
a1986 2
					graphics_data->start_x + *clipboard_w, 
					graphics_data->start_y + *clipboard_h);
d2063 28
d2092 1
a2092 1
				DrawRectangle (display, window, xorgc, 
d2095 2
a2096 2
					graphics_data->start_x + nAF3DLegendWidth,
					graphics_data->start_y + nAF3DLegendHeight);
d2141 6
d2150 4
a2153 1
	if (text_edit_data->node_flag != CANCEL)
d2155 8
a2163 1
		szTextString	= XmTextGetString (text_edit_data->text);
d2166 1
d2168 33
@


1.48
log
@After adding view25d.
@
text
@d2 3
d62 1
a62 1
/*$Header: /home/petsun4/ty7777/src/view25d/RCS/view25d.callbacks,v 1.47 1993/12/08 21:01:57 ty7777 Exp ty7777 $*/
d2557 2
a2558 3
	SYMBOL_DATA	*symbol_data		= (SYMBOL_DATA *) clientData;
	SYMBOL_MENU	*symbol_menu		= symbol_data->symbol_menu;
	Screen		*screen;
d2560 3
a2562 4
	char		*symbol_type		= cSymbolType;
	char		*dynamic_symbol_type	= cDynamicSymbolType;
	char		*symbol_color		= cSymbolColor;
	char		*dynamic_symbol_color	= cDynamicSymbolColor;
a2563 2
	Pixel		foreground;
	Pixel		background;
d2565 3
a2567 2
	unsigned short	*symbol_size		= nSymbolSize;
	int 		*outline_width		= &nOutlineWidth;
d2569 3
a2571 3
	int		n;
	Arg		arglist [3];
	int		i;
d2574 7
a2580 3
	char		alter_index		= cOldActiveAF3DSet;
	BOOLEAN		*all_planes		= &bAllPlanes;
	BOOLEAN		filled;
d2623 6
d2694 3
@


1.47
log
@Fixed default symbol type and color problem.
@
text
@d2 3
d59 1
a59 1
/*$Header: /home/petsun4/ty7777/src/view25d/RCS/view25d.callbacks,v 1.46 1993/11/02 16:53:31 ty7777 Exp ty7777 $*/
d1617 2
d1668 9
d1704 2
d1750 16
d2013 21
@


1.46
log
@Same as the last version.
@
text
@d2 3
d56 1
a56 1
/*$Header: /home/petsun4/ty7777/src/view25d/RCS/view25d.callbacks,v 1.45 1993/10/22 20:05:40 ty7777 Exp ty7777 $*/
d2547 1
a2547 1
			*(symbol_type + i)		= *(dynamic_symbol_type + i);
@


1.45
log
@Change calling for RegularMinMax.
@
text
@d2 3
d53 1
a53 1
/*$Header: /home/petsun4/ty7777/src/view25d/RCS/view25d.callbacks,v 1.44 1993/09/27 19:02:36 ty7777 Exp ty7777 $*/
@


1.44
log
@Added processing for gray color button.
@
text
@d2 3
d50 1
a50 1
/*$Header: /home/petsun4/ty7777/src/view25d/RCS/view25d.callbacks,v 1.43 1993/09/24 18:09:42 ty7777 Exp $*/
d1376 1
a1376 1
			ColorBarText (display, window, gc, minimum, maximum, font_struct, 
d1411 1
a1411 1
			ColorBarText (display, window, gc, minimum, maximum, font_struct, 
@


1.43
log
@Added search function.
@
text
@d2 3
d47 1
a47 1
/*$Header: /home/petsun4/ty7777/src/view25d/RCS/view25d.callbacks,v 1.42 1993/09/23 20:43:26 ty7777 Exp ty7777 $*/
d519 1
a519 1
					MAX_NONIMAGE_COLOR);
@


1.42
log
@View and Log Coordinates File.
@
text
@d2 3
d44 1
a44 1
/*$Header: /home/petsun4/ty7777/src/view25d/RCS/view25d.callbacks,v 1.41 1993/07/13 15:08:16 ty7777 Exp ty7777 $*/
d3129 1
a3129 1
	extern void search_pushed ();
d3138 1
a3147 1
		{"Search",	search_pushed,	NULL},
d3167 1
a3167 1
	action_items [3].data	= (caddr_t) dialog;
d3197 1
a3197 2
	search_w = XtVaCreateManagedWidget ("search-text", xmTextFieldWidgetClass, rowcol_h, NULL);

d3200 8
d3234 3
d3238 1
a3245 1
	action_items [2].data		= (caddr_t) text_w;
d3330 4
a3333 3
static void search_pushed (w, text_w, cbs)
Widget w, text_w;         /* the text widget is the client data */
XmAnyCallbackStruct *cbs;
d3335 8
a3342 1
    char *text = XmTextGetString (text_w);
d3344 55
a3398 2
    printf ("Search: String = %s\n", text);
    XtFree (text);
d3431 2
a3432 1
	if (XtIsSubclass (widget, xmTextFieldWidgetClass)) 
d3434 4
a3437 1
		filename	= XmTextFieldGetString (widget);
@


1.41
log
@Dynamicaly displaying point coordinates.
@
text
@d2 3
d41 1
a41 1
/*$Header: /home/petsun4/ty7777/src/view25d/RCS/view25d.callbacks,v 1.40 1993/07/06 16:52:01 ty7777 Exp ty7777 $*/
d43 1
d1147 1
a1147 1
		if (file_state == OpenAF3D)
d1156 1
a1156 1
			if (path_len < 0 || path_len > bytes - sizeof (RawGammaZPoint))
d2920 1
a2927 1
	int		fd	= 2;
a2935 4
	float		max;
	float		zscore;
	float		sig;
	RawGammaZPoint	gammaz_point;
a2936 5
	short		path_len;
	char		path [MAXLINE];
	short		desc_len;
	char		desc [MAXLINE];
	int		af3d_id;
d2987 1
a2987 1
			fprintf (stderr, "Error: There is no AF3D points.\n"); 
d2994 5
a2998 1
		fd	= open (file_name, O_WRONLY | O_CREAT, PERMS);
d3000 2
a3001 4
		memcpy ( (char *) path, "Path is not known", sizeof ("Path is not known"));
		path_len	= strlen (path);
		write (fd, &path_len, sizeof (path_len));
		write (fd, path, path_len);
d3003 1
a3003 5
		memcpy ((char *) desc, "Description is not available", 
				sizeof ("Description is not available"));
		desc_len	= strlen (desc);
		write (fd, &desc_len, sizeof (desc_len));
		write (fd, desc, desc_len);
d3005 3
a3007 3
		af3d_id	= 6;
		write (fd, &af3d_id, sizeof(af3d_id));
		write (fd, &num_points, sizeof (num_points));
d3009 3
a3011 3
		max	= 0.0;
		zscore	= 0.0;
		sig	= 0.0;
d3013 57
a3069 2
		i		= 0;
		while (i < text_length)
d3071 3
a3073 6
			j	= 0;
			strncpy (string_buffer, "\0", text_length);
			do
			{
				string_buffer [j++] = data_string [i++];
			} while (i < text_length && data_string [i] != '\n');
d3075 9
a3083 1
			string_buffer [j++] = data_string [i++];
d3085 8
a3092 11
			if (sscanf (string_buffer, "%f %f %f", &z, &x, &y) == 3 ||
				sscanf (string_buffer, "%f %f %f %s", &z, &x, &y, buffer) == 4) 
			{
				gammaz_point.x		= x;
				gammaz_point.y		= y;
				gammaz_point.z		= z;
				gammaz_point.sig	= sig;
				gammaz_point.mag	= max;
				gammaz_point.z_score	= zscore;
				write (fd, &gammaz_point.x, sizeof (gammaz_point));
			}
d3094 1
d3096 1
a3096 1
		close (fd);
d3098 121
a3218 2
		XtFree (file_name);
		XtFree (data_string);
d3221 207
a3427 2
	XtUnmanageChild (*addpoints_data->frame);
	XtManageChild (*addpoints_data->parent);
@


1.40
log
@Before working on Dr.Raichle's problem.
@
text
@d2 3
d38 1
a38 1
/*$Header: /home/petsun4/ty7777/src/view25d/RCS/view25d.callbacks,v 1.39 1993/06/02 17:18:07 ty7777 Exp ty7777 $*/
d694 5
d1192 1
a1192 1
			strcpy (szBuffer, "     Pet Image: ");
d1262 9
a1602 11
		case	LabelState:
			DrawLabel (display, window, gc, 
				graphics_data->start_x, graphics_data->start_y, 
				graphics_data->last_x, graphics_data->last_y, 
				pixelTextColor, FontStruct, text_string, 
				cAlignment, nLineSpacing, cFontOrientIndex);

			XtFree (text_string);

			*pointer_state	= NoState; 
			break;
d1629 15
d1709 6
d1957 5
@


1.39
log
@After multiple regions display worked.
@
text
@d2 3
d35 1
a35 1
/*$Header: /home/petsun4/ty7777/src/view25d/RCS/view25d.callbacks,v 1.38 1993/05/07 21:58:19 ty7777 Exp ty7777 $*/
d2091 41
d2154 1
d2168 1
d2195 2
d2242 11
@


1.38
log
@Add Processing for mask pet image.
@
text
@d2 3
d32 1
a32 1
/*$Header: /home/petsun4/ty7777/src/view25d/RCS/view25d.callbacks,v 1.37 1993/05/07 20:29:29 ty7777 Exp ty7777 $*/
a643 1
	char			alter_index	= cActiveAF3DSet;
d667 1
a667 1
			strcpy (file_name, szRegionFileName);
d675 1
a675 1
			strcpy (file_name, szAF3DFileNames [alter_index]);
a801 1
	Boolean			*display_region	= &bDisplayRegion;
a815 1
		*display_region	= XmToggleButtonGetState (*data_type_menu->region);
a861 1
		SetSelectData (*data_type_menu->region, *display_region);
d1058 1
a1058 1
	char			alter_index	= cActiveAF3DSet;
d1191 1
d1193 11
a1203 2
			strcpy (szRegionFileName, szBuffer2);
			bRegionImageSelected	= TRUE;
d1210 1
d2061 300
a2392 1
	Display		*display;
a2416 2
		display	= symbol_data->draw_data->display;

@


1.37
log
@Before mask processing.
@
text
@d2 3
d29 1
a29 1
/*$Header: /home/petsun4/ty7777/src/view25d/RCS/view25d.callbacks,v 1.36 1993/04/05 17:34:49 ty7777 Exp ty7777 $*/
d797 1
d814 1
d861 1
@


1.36
log
@After add AF3D points works.
@
text
@d2 3
d26 1
a26 1
/*$Header: /home/petsun4/ty7777/src/view25d/RCS/view25d.callbacks,v 1.35 1993/02/18 16:19:51 ty7777 Exp ty7777 $*/
d992 28
@


1.35
log
@Before changing defaults.
@
text
@d2 3
d23 1
a23 1
/*$Header: /home/petsun4/ty7777/src/view25d/RCS/view25d.callbacks,v 1.34 1993/01/28 15:45:51 ty7777 Exp $*/
d668 3
a1025 1
	XmString		item;
d1028 6
d1057 3
d1062 6
a1067 1
		fprintf (stderr, "Directory %s does not exist\n", szBuffer1);
a1070 1
		XtUnmanageChild (dialog);
d1076 48
d1209 2
a1325 4
			/*
			RedrawPortals (colorBarData->draw_data, atlas, plist, data_sets);
			*/

d2402 1
a2402 1
Widget RefreshCallback (w, clientData, callData)
d2433 185
@


1.34
log
@Before changing libcti.a.
@
text
@d2 3
d20 1
a20 1
/*$Header: /home/petsun4/ty7777/src/view25d/RCS/view25d.callbacks,v 1.33 1993/01/11 15:52:20 ty7777 Exp ty7777 $*/
d105 1
a105 1
	float			new_scale;
d2161 1
@


1.33
log
@Add atlas trim processing.
@
text
@d2 3
d17 1
a17 1
/*$Header: /home/petsun4/ty7777/src/view25d/RCS/view25d.callbacks,v 1.32 1992/12/03 20:26:39 ty7777 Exp ty7777 $*/
d1198 1
a1199 2
	short		min_pet_value;
	short		max_pet_value;
d1201 5
d1215 14
d1255 1
d1257 9
d1345 1
d1371 1
a1371 1
		XmScaleGetValue (*font_menu->line_spacing, &nLineSpacing);
d1426 1
a1426 1
		XmScaleSetValue (*font_menu->line_spacing, nLineSpacing);
d1991 1
d2043 2
d2103 1
d2109 2
a2110 1
		SetSelectData (*symbol_menu->all_planes, *all_planes);
@


1.32
log
@Before testing the libcti.a library function.
@
text
@d2 3
d14 1
a14 1
/*$Header: /home/petsun4/ty7777/src/view25d/RCS/view25d.callbacks,v 1.31 1992/09/28 16:50:10 ty7777 Exp ty7777 $*/
d219 1
d302 1
@


1.31
log
@After adding "xlabel" button.
@
text
@d2 3
d11 1
a11 1
/*$Header: /home/petsun4/ty7777/src/view25d/RCS/view25d.callbacks,v 1.30 1992/09/23 19:33:05 ty7777 Exp ty7777 $*/
a151 2
			if (bClearSliceArea)
				ClearPortals (display, window, mag_scale_data->draw_data->gc, plist);
a300 2
			if (bClearSliceArea)
				ClearPortals (display, window, gc, plist);
a730 2
	if (bClearSliceArea)
		ClearPortals (display, window, draw_data->gc, plist);
a828 2
			if (bClearSliceArea)
				ClearPortals (display, window, selectSliceOKData->draw_data->gc, plist);
a1228 2
			if (bClearSliceArea)
				ClearPortals (display, window, gc, plist);
a2006 3
			if (bClearSliceArea)
				ClearPortals (display, symbol_data->draw_data->window, 
					symbol_data->draw_data->gc, plist);
@


1.30
log
@AF3D files have the same path.
@
text
@d2 3
d8 1
a8 1
/*$Header: /home/petsun4/ty7777/src/view25d.d/RCS/view25d.callbacks,v 1.29 1992/08/26 21:31:18 ty7777 Exp ty7777 $*/
d2311 22
@


1.29
log
@Fixing font bug (reported by Julie Fiez) anf testing RCS checking in mechanism.
@
text
@d1 5
a5 2
/*$Log$*/
/*$Header$*/
a647 1
printf ("file_name = %s\n", file_name);
d650 1
a650 1
			strcpy (path_name, szAF3DPathNames [alter_index]);
d1089 1
a1089 1
			strcpy (szAF3DPathNames [alter_index], szBuffer1);
@


1.28
log
@Fixing font bug (reported by Julie Fiez).
@
text
@d1 3
a3 2
/*Log*/
/*Header*/
@


1.27
log
@After default masking file worked.
@
text
@d1 2
a1189 1
	XFontStruct	*font_struct	= FontStruct;
d1344 3
a1346 1
		/* Free Old Font and Load New Font */
@


1.26
log
@After Mask File Selection Menu Worked.
@
text
@d642 1
d1053 1
a1056 1
			bAtlasImageSelected	= TRUE;
@


1.25
log
@Before adding mask menu.
@
text
@d639 4
d1077 4
@


1.24
log
@After Fixing 0 length for Cut and Copy Bug.
@
text
@d524 1
a524 1
		strcpy (color_table_name, COLOR_TABLE_PATH);
d628 1
a628 1
			strcpy (path_name, "/usr/local/lib/VIEW25D");
@


1.23
log
@After AF3D All Planes Worked.
@
text
@d1600 2
@


1.22
log
@After AF3D menu works.
@
text
@d1948 1
d1990 2
a2022 3
			/*
			XtSetArg (arglist [n], XmNuserData, pixmap_symbol); n++;
			*/
d2057 2
a2127 3
	/*
	XtSetArg (arglist [n], XmNuserData, pixmap_symbol); n++;
	*/
a2253 3
		/*
		XtSetArg (arglist [n], XmNuserData, pixmap_symbol); n++;
		*/
@


1.21
log
@After AF3D menu works.
@
text
@a2291 3
	Display		*display	= draw_data->display;
	Window		window		= draw_data->window;
	GC		gc		= draw_data->gc;
d2293 2
a2294 1
	UpdatePortals (display, window, gc, rCurrentScaleHeader, plist);
@


1.20
log
@After AF3D menu cancel button works.
@
text
@d1090 2
a1091 1
				file_name, selectFileData->default_parameters);
d1948 1
a1948 1
	BOOLEAN		filled			= False;
d2020 1
d2022 1
d2046 5
d2126 1
d2128 1
d2255 1
d2257 1
@


1.19
log
@Before AF3D menu cancel button works.
@
text
@d1896 11
d1929 1
d1936 3
d1942 1
a1942 1
	Arg		arglist [1];
d1945 3
d1998 51
@


1.18
log
@Before size label works.
@
text
@a1076 1
			bAF3DImageSelected	= TRUE;
d1915 2
a1916 2
	SYMBOL_DATA	*symbol_data			= (SYMBOL_DATA *) clientData;
	SYMBOL_MENU	*symbol_menu			= symbol_data->symbol_menu;
d1918 8
a1925 7
	BOOLEAN		*display_symbol			= bDisplaySymbol;
	char		*symbol_type			= cSymbolType;
	char		*dynamic_symbol_type		= cDynamicSymbolType;
	char		*symbol_color			= cSymbolColor;
	char		*dynamic_symbol_color		= cDynamicSymbolColor;
	Pixel		*pixel_symbol_color		= pixelAF3DColor;
	unsigned short	*symbol_size			= &nSymbolSize;
a1927 2
	XmString	xmstring;
	char 		*string;
d1929 1
a1955 1
		}
d1957 7
a1963 1
		string	= XmTextGetString (*symbol_menu->size_text);
d1965 3
a1967 3
		if (strlen (string) > 0)
		{
			*symbol_size	= atoi (string);
a1969 2
		XtFree (string);

d2014 2
a2015 2
	char	alter_index		= cActiveAF3DSet;
	char	active_symbol		= cActiveSymbolType;
d2058 37
d2115 14
a2128 10
	int	n = 0;
	Arg	arglist [3];
	Pixel	background;
	Pixel	foreground;
	Pixmap	pixmap_symbol;
	char	*alter_index	= &cActiveAF3DSet;
	char	*active_symbol	= &cActiveSymbolType;
	char	*symbol_type	= cSymbolType;
	char	shape_type;
	Widget	*color_widget	= &wActiveAF3DColor;
d2132 1
d2178 11
@


1.17
log
@After AF3D menu works.
@
text
@@


1.16
log
@Before Building AF3D Queue.
@
text
@a766 1
	Boolean			*display_loci	= &bDisplayAF3D;
a780 1
		*display_loci	= XmToggleButtonGetState (*data_type_menu->AF3D);
a828 1
		SetSelectData (*data_type_menu->AF3D, *display_loci);
d1898 1
a1898 1
/*_________________________________________________________________________________	
d1909 1
a1909 1
_________________________________________________________________________________*/
d1916 2
a1917 2
	SYMBOL_DATA	*symbol_data	= (SYMBOL_DATA *) clientData;
	SYMBOL_MENU	*symbol_menu	= symbol_data->symbol_menu;
d1919 7
a1925 6
	BOOLEAN		*display_symbol	= bDisplaySymbol;
	char		*symbol_type	= cSymbolType;
	char		*symbol_color	= cSymbolColor;
	Pixel		*pixel_color	= pixelAF3DColor;
	unsigned short	*width		= &nSymbolWidth;
	unsigned short	*height		= &nSymbolHeight;
d1929 1
a1929 2
	char 		*str1;
	char 		*str2;
d1947 1
a1947 4
			n = 0;
			XtSetArg (arglist [n], XmNlabelString, &xmstring); n++;
			XtGetValues (symbol_menu->color_code_set [i], arglist, n);
			str1	= xmstr2str (xmstring);
a1948 3
			*(symbol_color + i)	= atoi (str1);
			XtFree (str1);

d1953 2
a1954 4
			XtSetArg (arglist [n], XtNforeground, pixel_color + i); n++;
			XtSetArg (arglist [n], XmNlabelString, &xmstring); n++;
			XtGetValues (symbol_menu->label_code_set [i], arglist, n);
			str1	= xmstr2str (xmstring);
d1956 1
a1956 2
			*(symbol_type + i)	= atoi (str1);
			XtFree (str1);
d1959 1
a1959 2
		str1	= XmTextGetString (*symbol_menu->width_text);
		str2	= XmTextGetString (*symbol_menu->height_text);
d1961 1
a1961 1
		if (strlen (str1) > 0 && strlen (str2) > 0)
d1963 1
a1963 2
			*width	= atoi (str1);
	 		*height	= atoi (str2);
d1966 1
a1966 2
		XtFree (str1);
		XtFree (str2);
d2012 2
a2013 3
	char	alter_index	= cActiveAF3DSet;
	char	active_symbol	= cActiveSymbolType;
	char	szBuffer [MAXLINE];
d2021 1
d2050 1
a2050 13
	if (symbol_show_data->color_flag != FAIL) 
	{
		n = 0;
		XtSetArg (arglist [n], XmNforeground, foreground); n++;
		XtSetArg (arglist [n], XmNlabelString, 
			xmStrSymbolCodeName [symbol_show_data->color_flag]); n++;
		XtSetValues (symbol_basic_data->color_code_label [alter_index], arglist, n);
	}

	n = 0;
	XtSetArg (arglist [n], XmNforeground, foreground); n++;
	XtSetArg (arglist [n], XmNlabelString, xmStrSymbolCodeName [active_symbol]); n++;
	XtSetValues (symbol_basic_data->symbol_code_label [alter_index], arglist, n);
d2077 1
a2077 1
	Arg	arglist [1];
a2133 11

		n = 0;
		XtSetArg (arglist [n], XmNforeground, foreground); n++;
		XtSetArg (arglist [n], XmNlabelString, 
			xmStrSymbolCodeName [cSymbolColor [*alter_index]]); n++;
		XtSetValues (symbol_basic_data->color_code_label [*alter_index], arglist, n);

		n = 0;
		XtSetArg (arglist [n], XmNforeground, foreground); n++;
		XtSetArg (arglist [n], XmNlabelString, xmStrSymbolCodeName [shape_type]); n++;
		XtSetValues (symbol_basic_data->symbol_code_label [*alter_index], arglist, n);
@


1.15
log
@Before AF3D menu works.
@
text
@d1922 1
d1924 2
a1925 1
	Pixel		*symbol_color	= pixelAF3DColor;
d1944 3
d1948 11
d1962 1
a1962 1
			XtSetArg (arglist [n], XtNforeground, symbol_color + i); n++;
d2023 1
a2023 1
	Arg	arglist [4];
d2027 1
a2027 1
	char	*alter_index	= &cActiveAF3DSet;
d2034 1
a2034 1
	if (symbol_show_data->color_flag) 
d2055 1
a2055 1
	pixmap_symbol	= XmGetPixmap (XtScreen (symbol_basic_data->symbol_label [*alter_index]),  
d2063 1
a2063 1
	XtSetValues (symbol_basic_data->symbol_label [*alter_index], arglist, n);
d2065 9
d2077 1
a2077 1
	XtSetValues (symbol_basic_data->symbol_code_label [*alter_index], arglist, n);
d2101 2
d2105 8
d2119 53
a2171 1
		cActiveAF3DSet	= alter_symbol_data->set_index;
@


1.14
log
@Before AF3D menu works.
@
text
@d1901 1
a1901 1
/*______________________________________________________________________________________	
d1912 1
a1912 1
______________________________________________________________________________________*/
d1922 2
a1923 1
	char		*symbol_type	= &cSymbolType;
d1928 1
a1928 2
	Pixel		selected_color_pixel;
	char		szBuffer [MAXLINE];
d1937 4
a1940 1
		for (i = 0; i < MAX_NONIMAGE_COLOR; i++)
d1942 8
a1949 6
			if (XmToggleButtonGetState (symbol_menu->toggle_color_set [i]))
			{
				n	= 0;
				XtSetArg (arglist [n], XtNbackground, &selected_color_pixel); n++;
				XtGetValues (symbol_menu->toggle_color_set [i], arglist, n);
				wActiveAF3DColor	= symbol_menu->toggle_color_set [i];
d1951 2
a1952 2
				strcpy (szBuffer, nonImageColorList [i]);
			}
a1954 11
		pixelAF3DColor	= selected_color_pixel;

		for (i = 0; i < MAX_SYMBOL_NUM; i++)
		{
			if (XmToggleButtonGetState (symbol_menu->toggle_symbol_set [i]))
				*symbol_type	= i;
		}

		if (XmToggleButtonGetState (*symbol_menu->filled))
			*symbol_type	+= FILLED_SYMBOL_START;

d2001 4
a2004 1
	SYMBOL_SHOW_DATA	*symbol_show_data	= (SYMBOL_SHOW_DATA *) clientData;
d2013 1
d2015 1
a2015 1
	if (XmToggleButtonGetState (symbol_show_data->toggle_filled))
d2037 1
a2037 1
	XtGetValues (symbol_show_data->symbol_shape [0], arglist, n);
d2039 2
a2040 2
	pixmap_symbol	= XmGetPixmap (XtScreen (symbol_show_data->symbol_label [*alter_index]),  
						symbol_show_data->symbol_name [active_symbol], 
d2047 39
a2085 1
	XtSetValues (symbol_show_data->symbol_label [*alter_index], arglist, n);
@


1.13
log
@Before AF3D menu works.
@
text
@d1920 1
d1939 1
a1939 1
			if (XmToggleButtonGetState (symbol_data->toggle_color [i]))
d1943 2
a1944 2
				XtGetValues (symbol_data->toggle_color [i], arglist, n);
				wActiveAF3DColor	= symbol_data->toggle_color [i];
d1954 1
a1954 1
			if (XmToggleButtonGetState (symbol_data->toggle_symbol [i]))
d1958 1
a1958 1
		if (XmToggleButtonGetState (symbol_data->filled))
d1961 2
a1962 2
		str1	= XmTextGetString (symbol_data->width_text);
		str2	= XmTextGetString (symbol_data->height_text);
@


1.12
log
@Before AF3D menu works.
@
text
@d613 1
d640 2
a641 2
			strcpy (path_name, szAF3DPathName);
			strcpy (file_name, szAF3DFileName);
d1078 2
a1079 3
			strcpy (szAF3DPathName, szBuffer1);
			strcpy (szAF3DFileName, szBuffer2);
			strcpy (szAF3DFileNames [alter_index], file_name);
d2033 1
a2033 1
	XtSetArg (arglist[n], XtNforeground, &foreground); n++;
d2037 1
a2037 1
	XtSetArg (arglist[n], XtNbackground, &background); n++;
d2041 2
a2042 1
				symbol_show_data->symbol_name [active_symbol], foreground, background);
d2045 3
a2047 3
	XtSetArg (arglist[n], XmNlabelType, XmPIXMAP); n++;
	XtSetArg (arglist[n], XmNlabelPixmap, pixmap_symbol); n++;
	XtSetArg (arglist[n], XmNuserData, pixmap_symbol); n++;
@


1.11
log
@Before AF3D Change.
@
text
@d1980 3
@


1.10
log
@Before AF3D Change.
@
text
@d660 2
a661 1
	XtSetArg (arglist [n], XmNfilterLabelString, fileSelectionData->label_path); n++;
d1974 2
a1975 1
			ClearPortals (display, symbol_data->draw_data->window, 
d1977 1
a1977 3
			UpdatePortals (display, symbol_data->draw_data->window, 
					symbol_data->draw_data->gc, 
					rCurrentScaleHeader, plist);
@


1.9
log
@Before testing center.
@
text
@a769 1
	char			atlas_name [MAXLINE];
d784 1
a784 17
		strcpy (szBuffer, szAtlasFileName);
		strcpy (atlas_name, szBuffer);

		if (*atlas_orient == TRANSVERSE && strstr (szBuffer, "transverse") == NULL)
			strcpy (atlas_name, "/usr/local/lib/VIEW25D/HD6_transverse.atl");
		else if (*atlas_orient == CORONAL && strstr (szBuffer, "coronal") == NULL)
			strcpy (atlas_name, "/usr/local/lib/VIEW25D/Talairach_coronal.atl");
		else if ((*atlas_orient == FACING_LEFT || *atlas_orient == FACING_RIGHT) 
						&& strstr (szBuffer, "sagittal") == NULL)
			strcpy (atlas_name, "/usr/local/lib/VIEW25D/Talairach_sagittal.atl");

		if (strcmp (szBuffer, atlas_name) != 0)
		{
			strcpy (szAtlasFileName, atlas_name);
			bAtlasChanged	= TRUE;
			ReadAtlasHeader (atlas_name);
		}
@


1.8
log
@Before coronal and sagittal functions are added.
@
text
@d291 3
a293 2
			ClearPortals (display, window, gc, plist);
			UpdatePortals (display, window, gc, rCurrentScaleHeader, plist);
a1195 2
	int		color_bar_w;
	int		color_bar_h;
d1205 5
a1209 5
		if (node == REDRAW)
		{
			color_bar_w	= *length;
			color_bar_h	= *width;
			GetPetMinMax (bAutoPetValueFlag, &min_pet_value, &max_pet_value);
a1210 11
			if (!(*horizontal_flag))
				Swap (&color_bar_w, &color_bar_h);
			XClearArea (display, window, *x, *y, color_bar_w, color_bar_h, FALSE);

			/* Set Font */
			XSetFont (display, gc, font_struct->fid);

			ColorBarText (display, window, gc, min_pet_value, max_pet_value, font_struct, 
				*horizontal_flag, *x, *y, *length, *width, TRUE, pet_value_flag);
		}

d1237 3
a1239 6
			DrawColorBar (display, window, gc, *x, *y, *length, *width,
					*horizontal_flag, pet_value_flag); 

			XSetForeground (display, gc, LABEL_CELL);
			ColorBarText (display, window, gc, min_pet_value, max_pet_value, font_struct, 
				*horizontal_flag, *x, *y, *length, *width, FALSE, pet_value_flag);
@


1.7
log
@Display Coronal and Sagittal Slices.
@
text
@d767 1
a767 1
	char			*orient_flag	= &cAtlasOrientation;
d769 1
d783 3
a785 1
		*orient_flag	= GetActiveIndex (data_type_menu->orientation_set, ORIENTATION_NUM);
d787 15
d812 2
a813 10
				if (*orient_flag == TRANSVERSE)
				{
					*first_slice	= ZtoSlice (*first_slice);
					*last_slice	= ZtoSlice (*last_slice);
				}
				else
				{
					*first_slice	= XYtoSlice (*first_slice);
					*last_slice	= XYtoSlice (*last_slice);
				}
d850 1
a850 1
		else if (*orient_flag == TRANSVERSE)
d852 1
a852 1
		else if (*orient_flag == CORONAL)
d864 1
a864 1
		SetSelectData (data_type_menu->orientation_set [*orient_flag], True);
d875 2
a876 2
		first	= GetSliceCoord (first, *orient_flag);
		last	= GetSliceCoord (last, *orient_flag);
d1875 1
a1875 1
	char				orient_flag;
d1877 1
a1877 1
	orient_flag	= GetActiveIndex (select_slices_data->orientation_set, ORIENTATION_NUM);
d1882 1
a1882 1
	else if (orient_flag == TRANSVERSE)
d1884 1
a1884 1
	else if (orient_flag == CORONAL)
d1892 2
a1893 2
		first_value	= GetSliceCoord (first_value, orient_flag);
		last_value	= GetSliceCoord (last_value, orient_flag);
@


1.6
log
@Atlas Change.
@
text
@d865 2
a866 10
		if (*orient_flag == TRANSVERSE)
		{
			first	= SliceZ (first);
			last	= SliceZ (last);
		}
		else
		{
			first	= SliceXY (first);
			last	= SliceXY (last);
		}
d1882 2
a1883 10
		if (orient_flag == TRANSVERSE)
		{
			first_value	= SliceZ (first_value);
			last_value	= SliceZ (last_value);
		}
		else
		{
			first_value	= SliceXY (first_value);
			last_value	= SliceXY (last_value);
		}
@


1.5
log
@Save and get defaults for atlas orientations.
@
text
@d621 1
a621 1
	cFileState = fileSelectionData->file_state;
d1059 5
a1063 1
			strcpy (szAtlasFileName, szBuffer2);
@


1.4
log
@Atlas Orientation Menu.
@
text
@d758 3
d767 1
d782 1
d794 10
a803 2
				*first_slice	= ZtoSlice (*first_slice);
				*last_slice	= ZtoSlice (*last_slice);
d840 1
a840 1
		else
d842 5
d853 3
d857 21
a877 1
	sprintf (szBuffer, "%d", (*slice_num_flag)? *first_slice: SliceZ (*first_slice));
d879 1
a879 1
	sprintf (szBuffer, "%d", (*slice_num_flag)? *last_slice: SliceZ (*last_slice));
d881 1
a881 1
	sprintf (szBuffer, "%d", (*slice_num_flag)? *spacing: 2 * *spacing);
d1869 1
d1871 1
d1876 1
a1876 1
	else
d1878 20
d1902 1
a1902 1
	sprintf (szBuffer, "%d", (status)? first_value: SliceZ (first_value));
d1905 1
a1905 1
	sprintf (szBuffer, "%d", (status)? last_value: SliceZ (last_value));
d1908 1
a1908 1
	sprintf (szBuffer, "%d", (status)? spacing_value: 2 * spacing_value);
@


1.3
log
@Error checking for first slice, last slice, and spacing.
@
text
@d1027 11
@


1.2
log
@Error checking for spacing. Reported by Dr. Raichle.
@
text
@d806 2
a807 2
		if (*spacing <= 0)
			*spacing	= 2;
a834 6
		sprintf (szBuffer, "%d", (*slice_num_flag)? *first_slice: SliceZ (*first_slice));
		XmTextSetString (*data_type_menu->first_slice, szBuffer); 
		sprintf (szBuffer, "%d", (*slice_num_flag)? *last_slice: SliceZ (*last_slice));
		XmTextSetString (*data_type_menu->last_slice, szBuffer); 
		sprintf (szBuffer, "%d", (*slice_num_flag)? *spacing: SliceZ (*spacing));
		XmTextSetString (*data_type_menu->spacing, szBuffer); 
d836 6
@


1.1
log
@Initial revision
@
text
@a800 2
		if (*spacing == 0)
			*spacing = 2;
d805 3
@
