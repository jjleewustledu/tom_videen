head	1.5;
access;
symbols;
locks; strict;
comment	@ * @;


1.5
date	99.12.13.22.02.19;	author tom;	state Exp;
branches;
next	1.4;

1.4
date	96.09.25.16.28.32;	author tom;	state Exp;
branches;
next	1.3;

1.3
date	94.03.03.17.32.54;	author ty7777;	state Exp;
branches;
next	1.2;

1.2
date	93.09.13.19.44.45;	author ty7777;	state Exp;
branches;
next	1.1;

1.1
date	93.03.04.19.48.59;	author ty7777;	state Exp;
branches;
next	;


desc
@Working version, modified by Tom Yang to get rid of sunview related library functions.
@


1.5
log
@partially cleaned up with lint
@
text
@/*$Id: mcs.c,v 1.4 1996/09/25 16:28:32 tom Exp tom $*/
/*$Log: mcs.c,v $
 * Revision 1.4  1996/09/25  16:28:32  tom
 * build in Solaris 2
 *
 * Revision 1.3  1994/03/03  17:32:54  ty7777
 * Change from if to header.
 *
 * Revision 1.2  1993/09/13  19:44:45  ty7777
 * Introduce rcsid.
 *
 * Revision 1.1  1993/03/04  19:48:59  ty7777
 * Initial revision
 **/

/*    @@(#)mcs.c	2.10 6/8/92    */
#include <stdio.h>
#include <string.h>
#include <strings.h>
#include <unistd.h>
#include <rpc/rpc.h>
#include "ecatMcs.h"

#ifndef lint
static char     rcsid[] = "$Header: /home/npggw/tom/src/libcti/RCS/mcs.c,v 1.4 1996/09/25 16:28:32 tom Exp tom $";
#endif

/*
#define EcatModel defaults_get_integer ("/Ecat/EcatModel", 951, 0)
*/
#define EcatModel 951
#define EcatMcsRpcTimeout -2
#define GANTRY_TILT_SCALE       0.123
#define GANTRY_ROTATE_SCALE     0.09
#define HORIZONTAL_SCALE        0.082447
#define VERTICAL_SCALE          0.16667
#define CTI_HORIZONTAL_SCALE    0.8
#define CTI_VERTICAL_SCALE      0.33
#define DETECTOR_ORBIT_SCALE    0.351563
#define SOURCE_ROTATE_SCALE     0.02
#define WOBBLE_SPEED_SCALE      60.0
#define ROTATE_SPEED_SCALE      24.0

/*
 * twjansto		24 may 1990
 */

static MCS_STATUS mcsStatus;

int             moveHorizontalBed (moveToHere)
	float           moveToHere;
{
	int             resp;
	float           encoderValue, currentBedEncoder, refBedEncoder;
	bool_t          doAcsMcsCommand ();

	if (!(doAcsMcsCommand (REPORT_MOTIONS, xdr_void, (char *) NULL, xdr_MCS_STATUS, &mcsStatus)))
		return (EcatMcsRpcTimeout);
	currentBedEncoder = mcsStatus.hb_encoder;
	refBedEncoder = mcsStatus.bed_ref_encoder;
	encoderValue = (moveToHere / ((EcatModel == 921 || EcatModel == 961) ?
				      1.0 : HORIZONTAL_SCALE)) + refBedEncoder;
	if (encoderValue == currentBedEncoder)
		return (0);
	if (!(doAcsMcsCommand (MOVE_HORIZONTAL_BED, xdr_float, &encoderValue, xdr_int, &resp)))
		return (EcatMcsRpcTimeout);
	return (resp);
}

int             moveHorizontalBedAbs (moveToHere)
	float           moveToHere;
{
	int             resp;
	float           encoderValue;
	bool_t          doAcsMcsCommand ();

	encoderValue = moveToHere / ((EcatModel == 921 || EcatModel == 961) ? 1.0 : HORIZONTAL_SCALE);
	if (!(doAcsMcsCommand (MOVE_HORIZONTAL_BED, xdr_float, &encoderValue, xdr_int, &resp)))
		return (EcatMcsRpcTimeout);
	return (resp);
}

int             moveVerticalBed (moveToHere)
	float           moveToHere;
{

	/*
	 * Tom Yang on 2/3/93 int resp, encoderValue; bool_t doAcsMcsCommand();
	 * 
	 * encoderValue = nint(moveToHere / VERTICAL_SCALE); if (!(doAcsMcsCommand(MOVE_VERTICAL_BED,
	 * xdr_int, &encoderValue, xdr_int, &resp))) return (EcatMcsRpcTimeout); return (resp);
	 */
	return (1);
}

int             moveWobble (moveToHere)
	float           moveToHere;
{

	/*
	 * Tom Yang on 2/3/93. int resp, encoderValue; bool_t doAcsMcsCommand();
	 * 
	 * encoderValue = nint(moveToHere / DETECTOR_ORBIT_SCALE); if (!(doAcsMcsCommand(MOVE_WOBBLE,
	 * xdr_int, &encoderValue, xdr_int, &resp))) return (EcatMcsRpcTimeout); return (resp);
	 */
	return (1);
}

int             moveRotatingSource (moveToHere)
	float           moveToHere;
{
/*
	int resp,
	    encoderValue;
	bool_t doAcsMcsCommand();

	if (strncmp(defaults_get_string("/Ecat/EcatTransmissionSource", "None", 0),
			"Rod", strlen("Rod")) == NULL)
		return (1001);
	encoderValue = nint(moveToHere / SOURCE_ROTATE_SCALE);
	if (!(doAcsMcsCommand(MOVE_ROTATING_SOURCE, xdr_int, &encoderValue, xdr_int, &resp)))
		return (EcatMcsRpcTimeout);
	return (resp);
*/
	return (1);
}

int             wobbleGantry (wobbleSpeed)
	float           wobbleSpeed;
{
	int             resp, encoderValue;

	bool_t          doAcsMcsCommand ();

	encoderValue = (wobbleSpeed / WOBBLE_SPEED_SCALE) * 127.0;
	if (!(doAcsMcsCommand (ROTATE_WOBBLE, xdr_int, &encoderValue, xdr_int, &resp)))
		return (EcatMcsRpcTimeout);
	return (resp);
}

int             rotateSource (rotateSpeed)
	float           rotateSpeed;
{
	int             resp, encoderValue;

	bool_t          doAcsMcsCommand ();

	printf ("Use defaults_get_string\n");
/*
	if (strncmp(defaults_get_string("/Ecat/EcatTransmissionSource", "None", 0),
			"Rod", strlen("Rod")) == NULL)
		return (1001);
*/
	encoderValue = (rotateSpeed / ROTATE_SPEED_SCALE) * 127.0;
	if (!(doAcsMcsCommand (ROTATE_SOURCE, xdr_int, &encoderValue, xdr_int, &resp)))
		return (EcatMcsRpcTimeout);
	return (resp);
}

int             extendRingsOnly ()
{
	int             resp, extend = TRUE;

	bool_t          doAcsMcsCommand ();

	printf ("Use defaults_get_string\n");
/*
	if (strncmp(defaults_get_string("/Ecat/EcatTransmissionSource", "None", 0),
			"None", strlen("None")) == NULL)
		return (1002);
*/
	changeMcsTimeoutValue (300);
	if (!(doAcsMcsCommand (MOVE_TR_SOURCE, xdr_int, &extend, xdr_int, &resp)))
		resp = EcatMcsRpcTimeout;
	changeMcsTimeoutValue (60);
	return (resp);
}

int             retractRingsOnly ()
{
	int             resp, retract = FALSE;

	bool_t          doAcsMcsCommand ();

	printf ("Use defaults_get_string\n");
/*
	if (strncmp(defaults_get_string("/Ecat/EcatTransmissionSource", "None", 0),
			"None", strlen("None")) == NULL)
		return (1002);
*/
	changeMcsTimeoutValue (300);
	if (!(doAcsMcsCommand (MOVE_TR_SOURCE, xdr_int, &retract, xdr_int, &resp)))
		resp = EcatMcsRpcTimeout;
	changeMcsTimeoutValue (60);
	return (resp);
}

int             extendRings ()
{
	int             resp, extend = TRUE;

	bool_t          doAcsMcsCommand ();

	printf ("Use defaults_get_string\n");
/*
	if (strncmp(defaults_get_string("/Ecat/EcatTransmissionSource", "None", 0),
			"None", strlen("None")) == NULL)
		return (1002);
*/
	changeMcsTimeoutValue (300);
	if (!(doAcsMcsCommand (MOVE_TR_SOURCE, xdr_int, &extend, xdr_int, &resp)))
		resp = EcatMcsRpcTimeout;
	changeMcsTimeoutValue (60);
	printf ("Use defaults_get_integer\n");
/*
	if (setULDValue((int) defaults_get_integer("/Ecat/EcatNumBuckets", 32, 0), 650) >= 0)
		return (FALSE);
*/
	return (resp);
}

int             retractRings ()
{
	int             resp, retract = FALSE;

	bool_t          doAcsMcsCommand ();

	printf ("Use defaults_get_integer\n");
/*
	if (setULDValue((int) defaults_get_integer("/Ecat/EcatNumBuckets", 32, 0), 850) >= 0)
		return (FALSE);
*/
	printf ("Use defaults_get_string\n");
/*
	if (strncmp(defaults_get_string("/Ecat/EcatTransmissionSource", "None", 0),
			"None", strlen("None")) == NULL)
		return (1002);
*/
	changeMcsTimeoutValue (300);
	if (!(doAcsMcsCommand (MOVE_TR_SOURCE, xdr_int, &retract, xdr_int, &resp)))
		resp = EcatMcsRpcTimeout;
	changeMcsTimeoutValue (60);
	return (resp);
}

#define IsLost  0x0
#define IsExtended  0x1
#define IsRetracted 0x2
#define ExtendFailed 0x4
#define LastComandCompletedOK 0x8
#define BedPositionUnknownOnA921 0x8
#define RelaysStuck 0x8
#define RetractFailed 0x10
#define IsExtending 0x20
#define IsRetracting 0x40
#define IsExtendingOnA921 0x10
#define IsRetractingOnA921 0x20
#define ExtendedKillSwitchHit 0x40
#define RetractedKillSwitchHit 0x80
#define MoveCommandActiveOnA921 0x80
#define SeptaMotionWait 150

int             extendSepta ()
{
	int             resp, extend = TRUE;
	bool_t          doAcsMcsCommand ();

	if (EcatModel == 921 || EcatModel == 961) {	/* for 921 scanners, use ACS MOVE_SEPTA
							 * command */
		changeMcsTimeoutValue (SeptaMotionWait);
		if (!(doAcsMcsCommand (MOVE_SEPTA, xdr_int, &extend, xdr_int, &resp))) {
			changeMcsTimeoutValue (60);
			return (EcatMcsRpcTimeout);
		} else {
			changeMcsTimeoutValue (60);
			return (resp);
		}
	} else					 /* for 950 series scanners, ACS passes through
						  * commands */
		return (extendSeptaSerially ());
}

int             retractSepta ()
{
	int             resp, retract = FALSE;

	bool_t          doAcsMcsCommand ();

	if (EcatModel == 921 || EcatModel == 961) {	/* for 921 scanners, use ACS MOVE_SEPTA
							 * command */
		changeMcsTimeoutValue (SeptaMotionWait);
		if (!(doAcsMcsCommand (MOVE_SEPTA, xdr_int, &retract, xdr_int, &resp))) {
			changeMcsTimeoutValue (60);
			return (EcatMcsRpcTimeout);
		} else {
			changeMcsTimeoutValue (60);
			return (resp);
		}
	} else					 /* for 950 series scanners, ACS passes through
						  * commands */
		return (retractSeptaSerially ());
}

int             extendSeptaSerially ()
{
	int             status, waitTillSeptaFinishes ();

	char            resp[8];

	resp[0] = '\0';
	mcsSerialBus ("246X", resp);
	if (resp[0] == '\0')
		return (990);
	if ((strcmp ("N 1", resp) != 0) && (strcmp ("N 0", resp) != 0))
		return (250);
	sleep (2);				 /* wait till it gets started */
	status = waitTillSeptaFinishes (SeptaMotionWait);
	if (!status)
		return (990);
	if (status > SeptaMotionWait)
		return (250);
	return (0);
}


int             retractSeptaSerially ()
{
	int             status, waitTillSeptaFinishes ();

	char            resp[8];

	resp[0] = '\0';
	mcsSerialBus ("246R", resp);
	if (resp[0] == '\0')
		return (990);
	if ((strcmp ("N 1", resp) != 0) && (strcmp ("N 0", resp) != 0))
		return (250);
	sleep (2);				 /* wait till it gets started */
	status = waitTillSeptaFinishes (SeptaMotionWait);
	if (!status)
		return (990);
	if (status > SeptaMotionWait)
		return (250);
	return (0);
}

int             waitTillSeptaFinishes (numberOfLoops)
	int             numberOfLoops;
{
	int             retcode, mcsSerialBus (), i;

	char            resp[8], hdr[2];

	for (i = 1; i <= numberOfLoops; i++) {
		resp[0] = '\0';
		mcsSerialBus ("246S", resp);	 /* get status of septa */
		if (resp[0] == '\0')
			return (EcatMcsRpcTimeout);
		sscanf (resp, "%c%c%d", &hdr[0], &hdr[1], &retcode);
		if (((retcode & IsExtended) == IsExtended) ||
		    ((retcode & IsRetracted) == IsRetracted))
			break;
		sleep (1);
	}
	return (i);
}

int             reportGantryTilt (tiltPosition)
	float          *tiltPosition;
{
	bool_t          doAcsMcsCommand ();

	if (!(doAcsMcsCommand (REPORT_MOTIONS, xdr_void, (char *) NULL, xdr_MCS_STATUS, &mcsStatus)))
		return (EcatMcsRpcTimeout);
	if (mcsStatus.tilt_encoder > 767)
		mcsStatus.tilt_encoder -= 1024;
	*tiltPosition = mcsStatus.tilt_encoder * GANTRY_TILT_SCALE;
	return (TRUE);
}

int             reportGantryRotation (rotatePosition)
	float          *rotatePosition;
{
	bool_t          doAcsMcsCommand ();

	if (!(doAcsMcsCommand (REPORT_MOTIONS, xdr_void, (char *) NULL, xdr_MCS_STATUS, &mcsStatus)))
		return (EcatMcsRpcTimeout);
	if (mcsStatus.rot_encoder > 512)
		mcsStatus.rot_encoder -= 1024;
	*rotatePosition = mcsStatus.rot_encoder * GANTRY_ROTATE_SCALE;
	return (TRUE);

}

int             reportHorizontalBed (bedPosition)
	float          *bedPosition;
{
	bool_t          doAcsMcsCommand ();

	if (!(doAcsMcsCommand (REPORT_MOTIONS, xdr_void, (char *) NULL, xdr_MCS_STATUS, &mcsStatus)))
		return (EcatMcsRpcTimeout);
	*bedPosition = (mcsStatus.hb_encoder - mcsStatus.bed_ref_encoder) *
		((EcatModel == 921 || EcatModel == 961) ? 1.0 : HORIZONTAL_SCALE);
	return (TRUE);

}

int             reportVerticalBed (bedPosition)
	float          *bedPosition;
{
	bool_t          doAcsMcsCommand ();

	if (!(doAcsMcsCommand (REPORT_MOTIONS, xdr_void, (char *) NULL, xdr_MCS_STATUS, &mcsStatus)))
		return (EcatMcsRpcTimeout);
	*bedPosition = mcsStatus.vb_encoder * VERTICAL_SCALE;
	return (TRUE);

}

int             reportWobble (wobblePosition)
	float          *wobblePosition;
{
	bool_t          doAcsMcsCommand ();

	if (!(doAcsMcsCommand (REPORT_MOTIONS, xdr_void, (char *) NULL, xdr_MCS_STATUS, &mcsStatus)))
		return (EcatMcsRpcTimeout);
	*wobblePosition = mcsStatus.wob_encoder * DETECTOR_ORBIT_SCALE;
	return (TRUE);

}

int             reportSource (sourcePosition)
	float          *sourcePosition;
{
	bool_t          doAcsMcsCommand ();

	printf ("Use defaults_get_string\n");
/*
	if (strncmp(defaults_get_string("/Ecat/EcatTransmissionSource", "None", 0),
			"Rod", strlen("Rod")) == NULL)
		return (1001);
*/
	if (!(doAcsMcsCommand (REPORT_MOTIONS, xdr_void, (char *) NULL, xdr_MCS_STATUS, &mcsStatus)))
		return (EcatMcsRpcTimeout);
	*sourcePosition = mcsStatus.ps_encoder * SOURCE_ROTATE_SCALE;
	return (TRUE);

}

int             wobbleSpeedIs (wobbleSpeed)
	float          *wobbleSpeed;
{
	bool_t          doAcsMcsCommand ();

	if (!(doAcsMcsCommand (REPORT_MOTIONS, xdr_void, (char *) NULL, xdr_MCS_STATUS, &mcsStatus)))
		return (EcatMcsRpcTimeout);
	*wobbleSpeed = (mcsStatus.wob_speed * WOBBLE_SPEED_SCALE) / 127.0;
	return (TRUE);

}

int             sourceSpeedIs (sourceSpeed)
	float          *sourceSpeed;
{
	bool_t          doAcsMcsCommand ();

	printf ("Use defaults_get_string\n");
/*
	if (strncmp(defaults_get_string("/Ecat/EcatTransmissionSource", "None", 0),
			"Rod", strlen("Rod")) == NULL)
		return (1001);
*/
	if (!(doAcsMcsCommand (REPORT_MOTIONS, xdr_void, (char *) NULL, xdr_MCS_STATUS, &mcsStatus)))
		return (EcatMcsRpcTimeout);
	*sourceSpeed = (mcsStatus.ps_speed * ROTATE_SPEED_SCALE) / 127.0;
	return (TRUE);

}

int             reportRings (ringStatus)
	int            *ringStatus;
{
	bool_t          doAcsMcsCommand ();

	printf ("Use defaults_get_string\n");
/*
	if (strncmp(defaults_get_string("/Ecat/EcatTransmissionSource", "None", 0),
			"None", strlen("None")) == NULL)
		return (1002);
*/
	if (!(doAcsMcsCommand (REPORT_MOTIONS, xdr_void, (char *) NULL, xdr_MCS_STATUS, &mcsStatus)))
		return (EcatMcsRpcTimeout);
	*ringStatus = mcsStatus.rs_status;
	return (TRUE);

}

int             reportSwitchStatus (switchStatus)
	int            *switchStatus;
{
	bool_t          doAcsMcsCommand ();

	if (!(doAcsMcsCommand (REPORT_MOTIONS, xdr_void, (char *) NULL, xdr_MCS_STATUS, &mcsStatus)))
		return (EcatMcsRpcTimeout);
	*switchStatus = mcsStatus.mcs_inp;
	return (TRUE);

}

int             reportSeptaStatus (respString)
	char           *respString;
{
	bool_t          doAcsMcsCommand ();

	int             decodeSeptaStatusCode ();

	if (!(doAcsMcsCommand (REPORT_MOTIONS, xdr_void, (char *) NULL, xdr_MCS_STATUS, &mcsStatus)))
		return (EcatMcsRpcTimeout);
	if (EcatModel == 921 || EcatModel == 961) {
		if ((mcsStatus.septa_status & LastComandCompletedOK) == LastComandCompletedOK)
			mcsStatus.septa_status &= (IsExtended | IsRetracted |
						   IsExtendingOnA921 | IsRetractingOnA921);
		if ((mcsStatus.septa_status & IsExtendingOnA921) == IsExtendingOnA921)
			mcsStatus.septa_status = IsExtending;
		else if ((mcsStatus.septa_status & IsRetractingOnA921) == IsRetractingOnA921)
			mcsStatus.septa_status = IsRetracting;
	}
	decodeSeptaStatusCode (mcsStatus.septa_status, respString);
	return (mcsStatus.septa_status);

}

int             reportSeptaStatusSerially (respString)
	char           *respString;
{
	int             retcode, mcsSerialBus (), decodeSeptaStatusCode ();
	char            resp[80], hdr[2];

	resp[0] = '\0';
	retcode = mcsSerialBus ("246S", resp);
	if (resp[0] == '\0')
		return (EcatMcsRpcTimeout);
	sscanf (resp, "%c%c%d", &hdr[0], &hdr[1], &retcode);
	strcpy (respString, "unknown");
	if (EcatModel == 921 || EcatModel == 961) {
		if ((retcode & LastComandCompletedOK) == LastComandCompletedOK)
			retcode -= LastComandCompletedOK;
	}
	decodeSeptaStatusCode (retcode, respString);
	return (TRUE);
}

int             decodeSeptaStatusCode (septaStatus, respString)
	int             septaStatus;

	char           *respString;
{
	switch (septaStatus) {
	case IsExtended:
		strcpy (respString, "is extended");
		break;
	case IsRetracted:
		strcpy (respString, "is retracted");
		break;
	case IsExtending:
		strcpy (respString, "is extending");
		break;
	case IsRetracting:
		strcpy (respString, "is retracting");
		break;
	case 300:
		strcpy (respString, "is not present");
		break;
	case 990:
		strcpy (respString, "is not present");
		break;
	case 0:
		strcpy (respString, "is not retractable");
		break;
	}
	return (0);
}

int             initMcs ()
{
	int             resp;

	bool_t          doAcsMcsCommand ();

	if (!(doAcsMcsCommand (MCS_INIT, xdr_void, (char *) NULL, xdr_int, &resp)))
		return (EcatMcsRpcTimeout);
	return (resp);

}

int             powerOnMotions (motion)
	int             motion;
{
	int             resp, hack;

	bool_t          doAcsMcsCommand ();

	hack = motion;
	if (!(doAcsMcsCommand (MCS_PON, xdr_int, &hack, xdr_int, &resp)))
		return (EcatMcsRpcTimeout);
	return (resp);

}

int             powerOffMotions (motion)
	int             motion;
{
	int             resp, hack;

	bool_t          doAcsMcsCommand ();

	hack = motion;
	if (!(doAcsMcsCommand (MCS_POFF, xdr_int, &hack, xdr_int, &resp)))
		return (EcatMcsRpcTimeout);
	return (resp);

}

int             zeroMcs (zeroParms)
	MCS_ZEROES     *zeroParms;
{
	int             resp;

	bool_t          doAcsMcsCommand ();

	if (!(doAcsMcsCommand (MOTION_ZEROES, xdr_MCS_ZEROES, zeroParms, xdr_int, &resp)))
		return (EcatMcsRpcTimeout);
	return (resp);
}

int             mcsSerialBus (command, resp)
	char           *command, *resp;
{
	bool_t          doAcsMcsCommand ();

	return (doAcsMcsCommand (MCS_SERIAL, xdr_wrapstring, &command, xdr_wrapstring, &resp));
}

int             trSourcePoll (isItHere)
	int             isItHere;
{
	int             resp, trPresent = FALSE;

	bool_t          doAcsMcsCommand ();

	if (isItHere)
		trPresent = TRUE;
	if (!(doAcsMcsCommand (MCS_RING, xdr_int, &trPresent, xdr_int, &resp)))
		return (EcatMcsRpcTimeout);
	return (resp);
}

int             toggleMcsUpdate (toggleState)
	int             toggleState;
{
	int             resp, updateOn = FALSE;

	bool_t          doAcsMcsCommand ();

	if (toggleState)
		updateOn = TRUE;
	if (!(doAcsMcsCommand (MCS_UPDATE, xdr_int, &updateOn, xdr_int, &resp)))
		return (EcatMcsRpcTimeout);
	return (resp);
}

static char     temp[64];

char           *
                decode_ring_status (parm_1)
	int             parm_1;
{
	char           *decode921TransmissionStatus ();

	bzero (temp, 64);
	if (EcatModel == 921 || EcatModel == 961)
		return (decode921TransmissionStatus (parm_1));
	switch (parm_1) {
	default:
		sprintf (temp, "returned a status of %x\n", parm_1);
		return (temp);
	case IsLost:
		return ("does not know its present status\n");
	case IsExtended:
		return ("is in the extended position\n");
	case IsRetracted:
		return ("is in the retracted position\n");
	case ExtendFailed:
		return ("failed to extend\n");
	case RelaysStuck:
		return ("relays are stuck\n");
	case RetractFailed:
		return ("failed to retract\n");
	case IsExtending:
		return ("is extending\n");
	case IsRetracting:
		return ("is retracting\n");
	case 1002:
		return ("is non-existant\n");
	}
}

char           *
                decode921TransmissionStatus (transmissionSourceStatus)
	int             transmissionSourceStatus;
{
	if (transmissionSourceStatus == IsLost)
		strcat (temp, "does not know its present status\n");
	else {
		if ((transmissionSourceStatus & LastComandCompletedOK) == LastComandCompletedOK)
			strcat (temp, "completed its last command, ");
		if ((transmissionSourceStatus & IsExtended) == IsExtended)
			strcat (temp, "is in the extended position ");
		if ((transmissionSourceStatus & IsRetracted) == IsRetracted)
			strcat (temp, "is in the retracted position ");
		if ((transmissionSourceStatus & ExtendFailed) == ExtendFailed)
			strcat (temp, "failed to extend ");
		if ((transmissionSourceStatus & IsExtendingOnA921) == IsExtendingOnA921)
			strcat (temp, "is extending ");
		if ((transmissionSourceStatus & IsRetractingOnA921) == IsRetractingOnA921)
			strcat (temp, "is retracting ");
		if ((transmissionSourceStatus & RetractedKillSwitchHit) == RetractedKillSwitchHit)
			strcat (temp, "is on the retract limit switch ");
		strcat (temp, "\n");
	}
	return (temp);
}

char           *
                mcs_error (mcsErrorFlag)
	int             mcsErrorFlag;
{
	switch (mcsErrorFlag) {
	default:
		return ("MCS Error... requested could not be performed\n");
	case EcatMcsRpcTimeout:
		return ("MCS Error... call to talk to the ACS failed\n");
	case 1:
		return ("MCS Error...invalid command\n");
	case -1:
	case 15:
		return ("MCS Error...MCS communications timeout\n");
	case 10:
	case -4:
		return ("MCS Error...ECAT system in ESTOP\n");
	case 20:
		return ("MCS Error...Requested horizontal bed target position out of range\n");
	case 21:
		return ("MCS Error...Requested move rejected, previous move in progress\n");
	case 22:
		return ("MCS Error...Requested move rejected, bed is jogging\n");
	case 23:
		return ("MCS Error...Bed can not be extended, safety check\n");
	case 24:
		return ("MCS Error...Bed can not be extended, neuro limit reached\n");
	case 25:
		return ("MCS Error...Requested jog rejected, previous move in progress\n");
	case 26:
		return ("MCS Error...Bed can not be retracted, retract limit switch set\n");
	case 27:
		return ("MCS Error...Bed can not be extended, extend limit switch set\n");
	case 28:
		return ("MCS Error...Requested jog rejected, bed is jogging\n");
	case 29:
		return ("MCS Error...Move bed refused due to jog condition\n");
	case 30:
		return ("MCS Error...Requested vertical bed target position out of range\n");
	case 31:
		return ("MCS Error...Bed can not be lowered, lower limit switch set\n");
	case 32:
		return ("MCS Error...Requested move rejected, previous move in progress\n");
	case 33:
		return ("MCS Error...Requested lower rejected, bed not in safe move position\n");
	case 34:
		return ("MCS Error...Requested move rejected, tilt > 5 degrees\n");
	case 35:
		return ("MCS Error...Requested move rejected, tilt more than +/- 15 degrees\n");
	case 36:
		return ("MCS Error...Requested jog up rejected, bed is jogging down\n");
	case 37:
		return ("MCS Error...Requested jog down rejected, bed is jogging down\n");
	case 38:
		return ("MCS Error...Bed can not be raised, neuro limit reached\n");
	case 39:
		return ("MCS Error...Bed can not be raised, upper limit switch set\n");
	case 40:
		return ("MCS Error...Detector orbit is being jogged\n");
	case 41:
		return ("MCS Error...Detector orbit encoder lost\n");
	case 42:
		return ("MCS Error...Detector orbit not wobbling\n");
	case 43:
		return ("MCS Error...Detector orbit being moved to absolute position\n");
	case 44:
		return ("MCS Error...Wobble power is disabled\n");
	case 50:
		return ("MCS Error...Rotating source is being jogged\n");
	case 51:
		return ("MCS Error...Rotating source encoder lost\n");
	case 52:
		return ("MCS Error...Rotating source encoder is not changing\n");
	case 53:
		return ("MCS Error...Rotating source is being moved to absolute\n");
	case 54:
		return ("MCS Error...Rotating source power is disabled\n");
	case 55:
		return ("MCS Error...Source move command refused, source not zeroed\n");
	case 60:
		return ("MCS Error...Gantry tilt motion error\n");
	case 70:
		return ("MCS Error...Gantry rotate motion error\n");
	case 80:
		return ("MCS Error...Rotate wobble command refused due to prior motion\n");
	case 91:
		return ("MCS Error...Transmission source not extended\n");
	case 92:
		return ("MCS Error...Transmission source extend in progress\n");
	case 94:
		return ("MCS Error...Transmission source relays active\n");
	case 96:
		return ("MCS Error...Transmission source not retracted, can't extend\n");
	case 97:
		return ("MCS Error...Transmission source illegal jog \n");
	case 98:
		return ("MCS Error...Transmission source switch not disabled\n");
	case 99:
		return ("MCS Error...Transmission source in maintenance mode\n");
	case 100:
		return ("MCS Error...Transmission source not extending\n");
	case 101:
		return ("MCS Error...Transmission source not retracting\n");
	case 102:
		return ("MCS Error...Transmission source failed to extend\n");
	case 103:
		return ("MCS Error...Transmission source failed to retract\n");
	case 104:
		return ("MCS Error...Transmission source failed to move\n");
	case 200:
		return ("MCS Error...Illegal motion axis specified\n");
	case 201:
		return ("MCS Error...Illegal encoder specified\n");
	case 202:
		return ("MCS Error...Illegal speed requested\n");
	case 220:
		return ("MCS Error...Invalid move parameter specified\n");
	case 230:
		return ("MCS Error...Detector move refused due to a limit switch setting\n");
	case 250:
		return ("MCS Error...Septa move did not complete\n");
	case 300:
		return ("MCS Error...Communications timeout with the serial bus\n");
	case 301:
		return ("MCS Error...Communications timeout with the transmission source\n");
	case 302:
		return ("MCS Error...Communications timeout with the bed\n");
	case 330:
		return ("MCS Error...Move command stopped by ESTOP condition\n");
	case 400:
		return ("MCS Error...Invalid parameter for display switch\n");
	case 470:
		return ("MCS Error...Move terminated due to a limit switch setting\n");
	case 500:
		return ("MCS Error...Invalid parameter for display encoder\n");
	case 550:
		return ("MCS Error...Rotate command refused due to ESTOP condition\n");
	case 560:
		return ("MCS Error...Move command refused due to ESTOP condition\n");
	case 600:
		return ("MCS Error...Invalid parameter for report command\n");
	case 610:
		return ("MCS Error...Move command on collimator refused, jog in progress\n");
	case 620:
		return ("MCS Error...Move command on wobble refused due to jog condition\n");
	case 630:
		return ("MCS Error...Source rotate command refused due to prior motion\n");
	case 650:
		return ("MCS Error...Source move command refused due to jog condition\n");
	case 660:
		return ("MCS Error...Invalid parameter for zero command\n");
	case 680:
		return ("MCS Error...Cannot zero bed encoder while bed is moving\n");
	case 670:
		return ("MCS Error...Cannot zero encoder while motion axis is moving\n");
	case 720:
		return ("MCS Error...Invalid parameter for move bed\n");
	case 730:
		return ("MCS Error...Invalid parameter for move wobble\n");
	case 750:
		return ("MCS Error...Move bed refused due to minimum height requirement\n");
	case 760:
		return ("MCS Error...Invalid parameter for collimator move command\n");
	case 980:
		return ("MCS Error...Move bed refused, bed going into a set limit switch\n");
	case 990:
		return ("MCS Error...The motion did not respond to the firmware and timed out\n");
	case 1000:
		return ("MCS Error...MCS allocation error\n");
	case 1001:
		return ("MCS Error...machine does not have a plane source\n");
	case 1002:
		return ("MCS Error...machine does not have a retractible transmission source\n");
	}
}
@


1.4
log
@build in Solaris 2
@
text
@d1 1
a1 1
/*$Id: mcs.c,v 1.3 1994/03/03 17:32:54 ty7777 Exp tom $*/
d3 3
d18 3
a21 3
/* Tom Yang on 1/28/93.
#include <sunwindow/defaults.h>
*/
d25 1
a25 2
static char     sccsid[] = "@@(#)mcs.c	2.10 6/8/92  Copyright 1989-1992 CTI PET Systems, Inc.";
static char     rcsid[] = "$Header: /home/npggw/tom/src/libcti/RCS/mcs.c,v 1.3 1994/03/03 17:32:54 ty7777 Exp tom $";
a53 1

a54 1

a73 1

a74 1

a265 1

d536 1
a536 2
	int             retcode, mcsSerialBus (), i, decodeSeptaStatusCode ();

@


1.3
log
@Change from if to header.
@
text
@d1 1
a1 1
/*$Id: mcs.c,v 1.2 1993/09/13 19:44:45 ty7777 Exp ty7777 $*/
d3 3
d22 2
a23 1
static char sccsid[] = "@@(#)mcs.c	2.10 6/8/92  Copyright 1989-1992 CTI PET Systems, Inc.";
a25 2
static char rcsid [] = "$Header$";

d48 2
a49 3
int 
moveHorizontalBed(moveToHere)
float moveToHere;
d51 1
a51 5
	int resp;
	float encoderValue,
	      currentBedEncoder,
	      refBedEncoder;
	bool_t doAcsMcsCommand();
d53 5
a57 1
	if (!(doAcsMcsCommand(REPORT_MOTIONS, xdr_void, (char *) NULL, xdr_MCS_STATUS, &mcsStatus)))
d62 1
a62 1
			1.0 : HORIZONTAL_SCALE)) + refBedEncoder;
d65 1
a65 1
	if (!(doAcsMcsCommand(MOVE_HORIZONTAL_BED, xdr_float, &encoderValue, xdr_int, &resp)))
d70 2
a71 3
int 
moveHorizontalBedAbs(moveToHere)
float moveToHere;
d73 1
a73 3
	int resp;
	float encoderValue;
	bool_t doAcsMcsCommand();
d75 4
d80 1
a80 1
	if (!(doAcsMcsCommand(MOVE_HORIZONTAL_BED, xdr_float, &encoderValue, xdr_int, &resp)))
d85 2
a86 3
int 
moveVerticalBed(moveToHere)
float moveToHere;
a87 4
	/* Tom Yang on 2/3/93
	int resp,
	    encoderValue;
	bool_t doAcsMcsCommand();
d89 6
a94 5
	encoderValue = nint(moveToHere / VERTICAL_SCALE);
	if (!(doAcsMcsCommand(MOVE_VERTICAL_BED, xdr_int, &encoderValue, xdr_int, &resp)))
		return (EcatMcsRpcTimeout);
	return (resp);
	*/
d98 2
a99 3
int 
moveWobble(moveToHere)
float moveToHere;
a100 4
	/* Tom Yang on 2/3/93.
	int resp,
	    encoderValue;
	bool_t doAcsMcsCommand();
d102 6
a107 5
	encoderValue = nint(moveToHere / DETECTOR_ORBIT_SCALE);
	if (!(doAcsMcsCommand(MOVE_WOBBLE, xdr_int, &encoderValue, xdr_int, &resp)))
		return (EcatMcsRpcTimeout);
	return (resp);
	*/
d111 2
a112 3
int 
moveRotatingSource(moveToHere)
float moveToHere;
d130 2
a131 3
int 
wobbleGantry(wobbleSpeed)
float wobbleSpeed;
d133 1
a133 3
	int resp,
	    encoderValue;
	bool_t doAcsMcsCommand();
d135 2
d138 1
a138 1
	if (!(doAcsMcsCommand(ROTATE_WOBBLE, xdr_int, &encoderValue, xdr_int, &resp)))
d143 2
a144 3
int 
rotateSource(rotateSpeed)
float rotateSpeed;
d146 1
a146 3
	int resp,
	    encoderValue;
	bool_t doAcsMcsCommand();
d148 3
a150 1
printf ("Use defaults_get_string\n");
d157 1
a157 1
	if (!(doAcsMcsCommand(ROTATE_SOURCE, xdr_int, &encoderValue, xdr_int, &resp)))
d162 1
a162 2
int 
extendRingsOnly()
d164 1
a164 3
	int resp,
	    extend = TRUE;
	bool_t doAcsMcsCommand();
d166 3
a168 1
printf ("Use defaults_get_string\n");
d174 2
a175 2
	changeMcsTimeoutValue(300);
	if (!(doAcsMcsCommand(MOVE_TR_SOURCE, xdr_int, &extend, xdr_int, &resp)))
d177 1
a177 1
	changeMcsTimeoutValue(60);
d181 1
a181 2
int 
retractRingsOnly()
d183 1
a183 3
	int resp,
	    retract = FALSE;
	bool_t doAcsMcsCommand();
d185 3
a187 1
printf ("Use defaults_get_string\n");
d193 2
a194 2
	changeMcsTimeoutValue(300);
	if (!(doAcsMcsCommand(MOVE_TR_SOURCE, xdr_int, &retract, xdr_int, &resp)))
d196 1
a196 1
	changeMcsTimeoutValue(60);
d200 1
a200 2
int 
extendRings()
d202 1
a202 3
	int resp,
	    extend = TRUE;
	bool_t doAcsMcsCommand();
d204 3
a206 1
printf ("Use defaults_get_string\n");
d212 2
a213 2
	changeMcsTimeoutValue(300);
	if (!(doAcsMcsCommand(MOVE_TR_SOURCE, xdr_int, &extend, xdr_int, &resp)))
d215 2
a216 2
	changeMcsTimeoutValue(60);
printf ("Use defaults_get_integer\n");
d224 1
a224 2
int 
retractRings()
d226 1
a226 3
	int resp,
	    retract = FALSE;
	bool_t doAcsMcsCommand();
d228 3
a230 1
printf ("Use defaults_get_integer\n");
d235 1
a235 1
printf ("Use defaults_get_string\n");
d241 2
a242 2
	changeMcsTimeoutValue(300);
	if (!(doAcsMcsCommand(MOVE_TR_SOURCE, xdr_int, &retract, xdr_int, &resp)))
d244 1
a244 1
	changeMcsTimeoutValue(60);
d265 1
a265 2
int 
extendSepta()
d267 1
a267 3
	int resp,
	    extend = TRUE;
	bool_t doAcsMcsCommand();
d269 7
a275 8
	if (EcatModel == 921 || EcatModel == 961)
	{	/* for 921 scanners, use
		 * ACS MOVE_SEPTA
		 * command */
		changeMcsTimeoutValue(SeptaMotionWait);
		if (!(doAcsMcsCommand(MOVE_SEPTA, xdr_int, &extend, xdr_int, &resp)))
		{
			changeMcsTimeoutValue(60);
d277 2
a278 3
		} else
		{
			changeMcsTimeoutValue(60);
d281 3
a283 4
	} else	/* for 950 series
		 * scanners, ACS passes
		 * through commands */
		return (extendSeptaSerially());
d286 1
a286 2
int 
retractSepta()
d288 1
a288 3
	int resp,
	    retract = FALSE;
	bool_t doAcsMcsCommand();
d290 7
a296 8
	if (EcatModel == 921 || EcatModel == 961)
	{	/* for 921 scanners, use
		 * ACS MOVE_SEPTA
		 * command */
		changeMcsTimeoutValue(SeptaMotionWait);
		if (!(doAcsMcsCommand(MOVE_SEPTA, xdr_int, &retract, xdr_int, &resp)))
		{
			changeMcsTimeoutValue(60);
d298 2
a299 3
		} else
		{
			changeMcsTimeoutValue(60);
d302 3
a304 4
	} else	/* for 950 series
		 * scanners, ACS passes
		 * through commands */
		return (retractSeptaSerially());
d307 1
a307 2
int 
extendSeptaSerially()
d309 1
a309 3
	int status,
	    waitTillSeptaFinishes();
	char resp[8];
d311 2
d314 1
a314 1
	mcsSerialBus("246X", resp);
d317 1
a317 1
	if ((strcmp("N 1", resp) != 0) && (strcmp("N 0", resp) != 0))
d319 2
a320 3
	sleep(2);	/* wait till it gets
			 * started */
	status = waitTillSeptaFinishes(SeptaMotionWait);
d329 1
a329 2
int 
retractSeptaSerially()
d331 1
a331 3
	int status,
	    waitTillSeptaFinishes();
	char resp[8];
d333 2
d336 1
a336 1
	mcsSerialBus("246R", resp);
d339 1
a339 1
	if ((strcmp("N 1", resp) != 0) && (strcmp("N 0", resp) != 0))
d341 2
a342 3
	sleep(2);	/* wait till it gets
			 * started */
	status = waitTillSeptaFinishes(SeptaMotionWait);
d350 2
a351 3
int 
waitTillSeptaFinishes(numberOfLoops)
int numberOfLoops;
d353 1
a353 5
	int retcode,
	    mcsSerialBus(),
	    i;
	char resp[8],
	     hdr[2];
d355 3
a357 2
	for (i = 1; i <= numberOfLoops; i++)
	{
d359 1
a359 1
		mcsSerialBus("246S", resp);	/* get status of septa */
d362 1
a362 1
		sscanf(resp, "%c%c%d", &hdr[0], &hdr[1], &retcode);
d364 1
a364 1
			((retcode & IsRetracted) == IsRetracted))
d366 1
a366 1
		sleep(1);
d371 2
a372 3
int 
reportGantryTilt(tiltPosition)
float *tiltPosition;
d374 1
a374 1
	bool_t doAcsMcsCommand();
d376 1
a376 1
	if (!(doAcsMcsCommand(REPORT_MOTIONS, xdr_void, (char *) NULL, xdr_MCS_STATUS, &mcsStatus)))
d384 2
a385 3
int 
reportGantryRotation(rotatePosition)
float *rotatePosition;
d387 1
a387 1
	bool_t doAcsMcsCommand();
d389 1
a389 1
	if (!(doAcsMcsCommand(REPORT_MOTIONS, xdr_void, (char *) NULL, xdr_MCS_STATUS, &mcsStatus)))
d398 2
a399 3
int 
reportHorizontalBed(bedPosition)
float *bedPosition;
d401 1
a401 1
	bool_t doAcsMcsCommand();
d403 1
a403 1
	if (!(doAcsMcsCommand(REPORT_MOTIONS, xdr_void, (char *) NULL, xdr_MCS_STATUS, &mcsStatus)))
d411 2
a412 3
int 
reportVerticalBed(bedPosition)
float *bedPosition;
d414 1
a414 1
	bool_t doAcsMcsCommand();
d416 1
a416 1
	if (!(doAcsMcsCommand(REPORT_MOTIONS, xdr_void, (char *) NULL, xdr_MCS_STATUS, &mcsStatus)))
d423 2
a424 3
int 
reportWobble(wobblePosition)
float *wobblePosition;
d426 1
a426 1
	bool_t doAcsMcsCommand();
d428 1
a428 1
	if (!(doAcsMcsCommand(REPORT_MOTIONS, xdr_void, (char *) NULL, xdr_MCS_STATUS, &mcsStatus)))
d435 2
a436 3
int 
reportSource(sourcePosition)
float *sourcePosition;
d438 1
a438 1
	bool_t doAcsMcsCommand();
d440 1
a440 1
printf ("Use defaults_get_string\n");
d446 1
a446 1
	if (!(doAcsMcsCommand(REPORT_MOTIONS, xdr_void, (char *) NULL, xdr_MCS_STATUS, &mcsStatus)))
d453 2
a454 3
int 
wobbleSpeedIs(wobbleSpeed)
float *wobbleSpeed;
d456 1
a456 1
	bool_t doAcsMcsCommand();
d458 1
a458 1
	if (!(doAcsMcsCommand(REPORT_MOTIONS, xdr_void, (char *) NULL, xdr_MCS_STATUS, &mcsStatus)))
d465 2
a466 3
int 
sourceSpeedIs(sourceSpeed)
float *sourceSpeed;
d468 1
a468 1
	bool_t doAcsMcsCommand();
d470 1
a470 1
printf ("Use defaults_get_string\n");
d476 1
a476 1
	if (!(doAcsMcsCommand(REPORT_MOTIONS, xdr_void, (char *) NULL, xdr_MCS_STATUS, &mcsStatus)))
d483 2
a484 3
int 
reportRings(ringStatus)
int *ringStatus;
d486 1
a486 1
	bool_t doAcsMcsCommand();
d488 1
a488 1
printf ("Use defaults_get_string\n");
d494 1
a494 1
	if (!(doAcsMcsCommand(REPORT_MOTIONS, xdr_void, (char *) NULL, xdr_MCS_STATUS, &mcsStatus)))
d501 2
a502 3
int 
reportSwitchStatus(switchStatus)
int *switchStatus;
d504 1
a504 1
	bool_t doAcsMcsCommand();
d506 1
a506 1
	if (!(doAcsMcsCommand(REPORT_MOTIONS, xdr_void, (char *) NULL, xdr_MCS_STATUS, &mcsStatus)))
d513 2
a514 3
int 
reportSeptaStatus(respString)
char *respString;
d516 1
a516 2
	bool_t doAcsMcsCommand();
	int decodeSeptaStatusCode();
d518 3
a520 1
	if (!(doAcsMcsCommand(REPORT_MOTIONS, xdr_void, (char *) NULL, xdr_MCS_STATUS, &mcsStatus)))
d522 1
a522 2
	if (EcatModel == 921 || EcatModel == 961)
	{
d525 1
a525 1
				IsExtendingOnA921 | IsRetractingOnA921);
d531 1
a531 1
	decodeSeptaStatusCode(mcsStatus.septa_status, respString);
d536 2
a537 3
int 
reportSeptaStatusSerially(respString)
char *respString;
d539 1
a539 6
	int retcode,
	    mcsSerialBus(),
	    i,
	    decodeSeptaStatusCode();
	char resp[80],
	     hdr[2];
d541 2
d544 1
a544 1
	retcode = mcsSerialBus("246S", resp);
d547 3
a549 4
	sscanf(resp, "%c%c%d", &hdr[0], &hdr[1], &retcode);
	strcpy(respString, "unknown");
	if (EcatModel == 921 || EcatModel == 961)
	{
d553 1
a553 1
	decodeSeptaStatusCode(retcode, respString);
d557 4
a560 4
int 
decodeSeptaStatusCode(septaStatus, respString)
int septaStatus;
char *respString;
d562 3
a564 4
	switch (septaStatus)
	{
	    case IsExtended:
		strcpy(respString, "is extended");
d566 2
a567 2
	    case IsRetracted:
		strcpy(respString, "is retracted");
d569 2
a570 2
	    case IsExtending:
		strcpy(respString, "is extending");
d572 2
a573 2
	    case IsRetracting:
		strcpy(respString, "is retracting");
d575 2
a576 2
	    case 300:
		strcpy(respString, "is not present");
d578 2
a579 2
	    case 990:
		strcpy(respString, "is not present");
d581 2
a582 2
	    case 0:
		strcpy(respString, "is not retractable");
d588 1
a588 2
int 
initMcs()
d590 1
a590 2
	int resp;
	bool_t doAcsMcsCommand();
d592 3
a594 1
	if (!(doAcsMcsCommand(MCS_INIT, xdr_void, (char *) NULL, xdr_int, &resp)))
d600 2
a601 3
int 
powerOnMotions(motion)
int motion;
d603 1
a603 3
	int resp,
	    hack;
	bool_t doAcsMcsCommand();
d605 2
d608 1
a608 1
	if (!(doAcsMcsCommand(MCS_PON, xdr_int, &hack, xdr_int, &resp)))
d614 2
a615 3
int 
powerOffMotions(motion)
int motion;
d617 1
a617 3
	int resp,
	    hack;
	bool_t doAcsMcsCommand();
d619 2
d622 1
a622 1
	if (!(doAcsMcsCommand(MCS_POFF, xdr_int, &hack, xdr_int, &resp)))
d628 2
a629 3
int 
zeroMcs(zeroParms)
MCS_ZEROES *zeroParms;
d631 1
a631 2
	int resp;
	bool_t doAcsMcsCommand();
d633 3
a635 1
	if (!(doAcsMcsCommand(MOTION_ZEROES, xdr_MCS_ZEROES, zeroParms, xdr_int, &resp)))
d640 2
a641 4
int 
mcsSerialBus(command, resp)
char *command,
    *resp;
d643 1
a643 1
	bool_t doAcsMcsCommand();
d645 1
a645 1
	return (doAcsMcsCommand(MCS_SERIAL, xdr_wrapstring, &command, xdr_wrapstring, &resp));
d648 2
a649 3
int 
trSourcePoll(isItHere)
int isItHere;
d651 1
a651 3
	int resp,
	    trPresent = FALSE;
	bool_t doAcsMcsCommand();
d653 2
d657 1
a657 1
	if (!(doAcsMcsCommand(MCS_RING, xdr_int, &trPresent, xdr_int, &resp)))
d662 2
a663 3
int 
toggleMcsUpdate(toggleState)
int toggleState;
d665 1
a665 3
	int resp,
	    updateOn = FALSE;
	bool_t doAcsMcsCommand();
d667 2
d671 1
a671 1
	if (!(doAcsMcsCommand(MCS_UPDATE, xdr_int, &updateOn, xdr_int, &resp)))
d676 1
a676 1
static char temp[64];
d678 3
a680 3
char *
decode_ring_status(parm_1)
int parm_1;
d682 1
a682 1
	char *decode921TransmissionStatus();
d684 1
a684 1
	bzero(temp, 64);
d686 4
a689 5
		return (decode921TransmissionStatus(parm_1));
	switch (parm_1)
	{
	    default:
		sprintf(temp, "returned a status of %x\n", parm_1);
d691 1
a691 1
	    case IsLost:
d693 1
a693 1
	    case IsExtended:
d695 1
a695 1
	    case IsRetracted:
d697 1
a697 1
	    case ExtendFailed:
d699 1
a699 1
	    case RelaysStuck:
d701 1
a701 1
	    case RetractFailed:
d703 1
a703 1
	    case IsExtending:
d705 1
a705 1
	    case IsRetracting:
d707 1
a707 1
	    case 1002:
d712 3
a714 3
char *
decode921TransmissionStatus(transmissionSourceStatus)
int transmissionSourceStatus;
d717 2
a718 3
		strcat(temp, "does not know its present status\n");
	else
	{
d720 1
a720 1
			strcat(temp, "completed its last command, ");
d722 1
a722 1
			strcat(temp, "is in the extended position ");
d724 1
a724 1
			strcat(temp, "is in the retracted position ");
d726 1
a726 1
			strcat(temp, "failed to extend ");
d728 1
a728 1
			strcat(temp, "is extending ");
d730 1
a730 1
			strcat(temp, "is retracting ");
d732 2
a733 2
			strcat(temp, "is on the retract limit switch ");
		strcat(temp, "\n");
d738 3
a740 3
char *
mcs_error(mcsErrorFlag)
int mcsErrorFlag;
d742 2
a743 3
	switch (mcsErrorFlag)
	{
	    default:
d745 1
a745 1
	    case EcatMcsRpcTimeout:
d747 1
a747 1
	    case 1:
d749 2
a750 2
	    case -1:
	    case 15:
d752 2
a753 2
	    case 10:
	    case -4:
d755 1
a755 1
	    case 20:
d757 1
a757 1
	    case 21:
d759 1
a759 1
	    case 22:
d761 1
a761 1
	    case 23:
d763 1
a763 1
	    case 24:
d765 1
a765 1
	    case 25:
d767 1
a767 1
	    case 26:
d769 1
a769 1
	    case 27:
d771 1
a771 1
	    case 28:
d773 1
a773 1
	    case 29:
d775 1
a775 1
	    case 30:
d777 1
a777 1
	    case 31:
d779 1
a779 1
	    case 32:
d781 1
a781 1
	    case 33:
d783 1
a783 1
	    case 34:
d785 1
a785 1
	    case 35:
d787 1
a787 1
	    case 36:
d789 1
a789 1
	    case 37:
d791 1
a791 1
	    case 38:
d793 1
a793 1
	    case 39:
d795 1
a795 1
	    case 40:
d797 1
a797 1
	    case 41:
d799 1
a799 1
	    case 42:
d801 1
a801 1
	    case 43:
d803 1
a803 1
	    case 44:
d805 1
a805 1
	    case 50:
d807 1
a807 1
	    case 51:
d809 1
a809 1
	    case 52:
d811 1
a811 1
	    case 53:
d813 1
a813 1
	    case 54:
d815 1
a815 1
	    case 55:
d817 1
a817 1
	    case 60:
d819 1
a819 1
	    case 70:
d821 1
a821 1
	    case 80:
d823 1
a823 1
	    case 91:
d825 1
a825 1
	    case 92:
d827 1
a827 1
	    case 94:
d829 1
a829 1
	    case 96:
d831 1
a831 1
	    case 97:
d833 1
a833 1
	    case 98:
d835 1
a835 1
	    case 99:
d837 1
a837 1
	    case 100:
d839 1
a839 1
	    case 101:
d841 1
a841 1
	    case 102:
d843 1
a843 1
	    case 103:
d845 1
a845 1
	    case 104:
d847 1
a847 1
	    case 200:
d849 1
a849 1
	    case 201:
d851 1
a851 1
	    case 202:
d853 1
a853 1
	    case 220:
d855 1
a855 1
	    case 230:
d857 1
a857 1
	    case 250:
d859 1
a859 1
	    case 300:
d861 1
a861 1
	    case 301:
d863 1
a863 1
	    case 302:
d865 1
a865 1
	    case 330:
d867 1
a867 1
	    case 400:
d869 1
a869 1
	    case 470:
d871 1
a871 1
	    case 500:
d873 1
a873 1
	    case 550:
d875 1
a875 1
	    case 560:
d877 1
a877 1
	    case 600:
d879 1
a879 1
	    case 610:
d881 1
a881 1
	    case 620:
d883 1
a883 1
	    case 630:
d885 1
a885 1
	    case 650:
d887 1
a887 1
	    case 660:
d889 1
a889 1
	    case 680:
d891 1
a891 1
	    case 670:
d893 1
a893 1
	    case 720:
d895 1
a895 1
	    case 730:
d897 1
a897 1
	    case 750:
d899 1
a899 1
	    case 760:
d901 1
a901 1
	    case 980:
d903 1
a903 1
	    case 990:
d905 1
a905 1
	    case 1000:
d907 1
a907 1
	    case 1001:
d909 1
a909 1
	    case 1002:
@


1.2
log
@Introduce rcsid.
@
text
@d1 1
a1 1
/*$Id: mcs.c,v 1.1 1993/03/04 19:48:59 ty7777 Exp ty7777 $*/
d3 3
d22 1
a22 1
static char rcsid [] = "$Id$";
@


1.1
log
@Initial revision
@
text
@d1 5
a5 2
/*$Id$*/
/*$Log$*/
d18 2
@
