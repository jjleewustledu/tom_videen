head	1.7;
access;
symbols;
locks; strict;
comment	@ * @;


1.7
date	2002.11.27.20.08.37;	author tom;	state Exp;
branches;
next	1.6;

1.6
date	99.12.13.22.02.19;	author tom;	state Exp;
branches;
next	1.5;

1.5
date	96.09.25.16.28.32;	author tom;	state Exp;
branches;
next	1.4;

1.4
date	95.10.30.16.54.44;	author tom;	state Exp;
branches;
next	1.3;

1.3
date	94.03.03.17.37.48;	author ty7777;	state Exp;
branches;
next	1.2;

1.2
date	93.09.13.18.58.21;	author ty7777;	state Exp;
branches;
next	1.1;

1.1
date	93.03.04.19.57.39;	author ty7777;	state Exp;
branches;
next	;


desc
@ Workin version, modified by Tom Yang to get rid of sunview related library functions.
@


1.7
log
@*** empty log message ***
@
text
@/*$Id: rts.c,v 1.6 1999/12/13 22:02:19 tom Exp tom $*/
/*$Log: rts.c,v $
 * Revision 1.6  1999/12/13  22:02:19  tom
 * partially cleaned up with lint
 *
 * Revision 1.5  1996/09/25  16:28:32  tom
 * build in Solaris 2
 *
 * Revision 1.4  1995/10/30  16:54:44  tom
 * changed petutil/matrix.h to matrix.h
 *
 * Revision 1.3  1994/03/03  17:37:48  ty7777
 * Change from id to header.
 *
 * Revision 1.2  1993/09/13  18:58:21  ty7777
 * Introduce acsid and change matrix.h to petutil/matrix.h.
 *
 * Revision 1.1  1993/03/04  19:57:39  ty7777
 * Initial revision
 **/

/*    @@(#)rts.c	2.14    6/16/92    */
/* rts.c
* collection of modules to allow rts commands to be issued to the acquisition
* server as defined in the defaults database /Ecat/EcatAcqServer
*
* rts_conf (parm_1), rts_dpln (parm_1, parm_2, parm_3), rts_dfrm (parm_1, parm_2, parm_3, parm_4),
* rts_strt (parm_1, parm_2), rts_gantry (command, response), rts_rgan (response),
* rts_xfer (parm_1, parm_2, buffer), rts_wait (), check_rts_status (), rts_error (parm_1),
* rts_cont (), rts_ecom (parm_1), rts_sinm (parm_1), rts_reso (parm_1), rts_stop (),
* rts_fclr (parm_1) rts_dseg (parm_1, parm_2, parm_3, parm_4), rtsinfo (rtsInfoData),
* rts_modl (model, numberOfRings), rts_dfov (parm_1), rts_comp (parm_1), rts_rems (parm_1, parm_2),
* rts_cfrm (parm_1, parm_2, parm_3), rts_blim (parm_1, parm_2, parm_3),
* rts_sing (parm_1, parm_2, parm_3, parm_4, parm_5), rts_rsin (parm_1, cor_sing, uncor_sing),
* rts_beat (parm_1, beat_data), rts_gimi (parm_1, parm_2, parm_3, parm_4, gimidata),
* rts_rect (parm_1, parm_2, parm_3, parm_4, parm_5, parm_6, gimidata),
* rtsGetem (fileName, frame, gate, plane, datatype, matrix_number), rtsFileName (fileToCreate, fileSize),
* rtsRblk (fileName, blockNumber, buffer), rtsWblk (fileName, blockNumber, buffer), rts_acqm (acqMode),
* rts_dpln6 (logPlane, phyPlane0, phyPlane1, phyPlane2, phyPlane3, phyPlane4, phyPlane5, phyPlane6)
* rts_rrdb (enableOrDisable), rts_rwin (enableOrDisable)
* t.w. jansto		29 nov 1990
*/

#ifndef lint
static char     rcsid[] = "$Header: /home/npggw/tom/src/libcti/RCS/rts.c,v 1.6 1999/12/13 22:02:19 tom Exp tom $";
#endif

#define ErrorIssuingRpcCall -2

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <rpc/rpc.h>
#include "ecatRts.h"
#include "ecatAcs.h"
#include <matrix.h>

int             rtsMagpie (squawk)
	int             squawk;
{
	int             resp;

	bool_t          doAcsAcqCommand ();

	if (!(doAcsAcqCommand (DBUG, xdr_int, &squawk, xdr_int, &resp)))
		resp = ErrorIssuingRpcCall;
	return (resp);
}

int             rts_conf (clearOrConfig)
	int             clearOrConfig;
{
/*
	int resp;
	float strtod ();
	bool_t doAcsAcqCommand();
	CONF_args confArgs;

	confArgs.config = clearOrConfig;
	confArgs.pile_up_factor = strtod(
		(char *) defaults_get_string("/Ecat/EcatPu", "8.6e-8", 0), (char *) NULL);
	confArgs.plane_factor = strtod(
		(char *) defaults_get_string("/Ecat/EcatPl", "1.0", 0), (char *) NULL);
	if (!(doAcsAcqCommand(CONF, xdr_CONF_args, &confArgs, xdr_int, &resp)))
		resp = ErrorIssuingRpcCall;
	if (!clearOrConfig)
		resetFrameTransferred();
	return (resp);
*/
	return (1);
}

int             rts_acqm (acquisitionMode)
	int             acquisitionMode;
{
	int             resp;

	bool_t          doAcsAcqCommand ();

	if (!(doAcsAcqCommand (ACQM, xdr_int, &acquisitionMode, xdr_int, &resp)))
		resp = ErrorIssuingRpcCall;
	return (resp);
}

int             rts_dpln (logPlane, phyPlane0, phyPlane1, phyPlane2, phyPlane3, phyPlane4, phyPlane5)
	int             logPlane, phyPlane0, phyPlane1, phyPlane2, phyPlane3, phyPlane4, phyPlane5;
{
	int             resp;

	DPLN_args       dplnCmd;

	bool_t          doAcsAcqCommand ();

	dplnCmd.log_plane = logPlane;
	dplnCmd.phy_plane[0] = phyPlane0;
	dplnCmd.phy_plane[1] = phyPlane1;
	dplnCmd.phy_plane[2] = phyPlane2;
	dplnCmd.phy_plane[3] = phyPlane3;
	dplnCmd.phy_plane[4] = phyPlane4;
	dplnCmd.phy_plane[5] = phyPlane5;
	if (!(doAcsAcqCommand (DPLN, xdr_DPLN_args, &dplnCmd, xdr_int, &resp)))
		resp = ErrorIssuingRpcCall;
	return (resp);
}

int             rts_dfrm (nFrames, delay, duration, nsegs)
	int             nFrames, delay, duration, nsegs;
{
	int             resp;

	DFRM_args       dfrmCmd;

	bool_t          doAcsAcqCommand ();

	dfrmCmd.nframes = nFrames;
	dfrmCmd.delay = delay;
	dfrmCmd.duration = duration;
	dfrmCmd.nsegs = nsegs;
	if (!(doAcsAcqCommand (DFRM, xdr_DFRM_args, &dfrmCmd, xdr_int, &resp)))
		resp = ErrorIssuingRpcCall;
	return (resp);
}

int             rts_strt (framesToDo, acqType)
	int             framesToDo, acqType;
{
	int             resp;

	STRT_args       strtCmd;

	bool_t          doAcsAcqCommand ();

	strtCmd.numberFrames = framesToDo;
	strtCmd.acqType = acqType;
	if (!(doAcsAcqCommand (STRT, xdr_STRT_args, &strtCmd, xdr_int, &resp)))
		resp = ErrorIssuingRpcCall;
	return (resp);
}

int             rts_gantry (command, response)
	char           *command, *response;
{
	bool_t          doAcsAcqCommand (), status;

	char            temp_response[80], *temp;

	temp = temp_response;
	if (getenv ("NoSerialBus") == (char *) NULL) {	/* bypass all serial bus activity */
		status = doAcsAcqCommand (GANT, xdr_wrapstring, &command, xdr_wrapstring, &temp);
		sprintf (response, "%s", temp);
	} else {
		status = 1;
		strcpy (response, "N 0");
	}
	return (status);
}

int             rts_rgan (response)
	char           *response;
{
	bool_t          doAcsAcqCommand ();

	if (getenv ("NoSerialBus") == (char *) NULL)	/* bypass all serial bus activity */
		return (doAcsAcqCommand (RGAN, xdr_void, (char *) NULL, xdr_wrapstring, &response));
	else {
		strcpy (response, "0, 0, 0, 0, 0, 0, 0, 0");
		return (1);
	}
}

int             rts_gantry_controller (command, response)
	char           *command, *response;
{
	bool_t          doAcsAcqCommand ();

	if (getenv ("NoSerialBus") == (char *) NULL)	/* bypass all serial bus activity */
		return (doAcsAcqCommand (GCTL, xdr_wrapstring, &command, xdr_wrapstring, &response));
	else {
		strcpy (response, "N 0");
		return (1);
	}
}

int             rts_stop ()
{
	int             resp;

	bool_t          doAcsAcqCommand ();

	if (!(doAcsAcqCommand (STOP, xdr_void, (char *) NULL, xdr_int, &resp)))
		resp = ErrorIssuingRpcCall;
	return (resp);
}

int             rts_sinm (sinoMode)
	int             sinoMode;
{
	int             resp;

	bool_t          doAcsAcqCommand ();

	if (!(doAcsAcqCommand (SINM, xdr_int, &sinoMode, xdr_int, &resp)))
		resp = ErrorIssuingRpcCall;
	return (resp);
}

int             rts_reso (stationaryOrWobbled)
	int             stationaryOrWobbled;
{
	int             resp;

	bool_t          doAcsAcqCommand ();

	if (!(doAcsAcqCommand (RESO, xdr_int, &stationaryOrWobbled, xdr_int, &resp)))
		resp = ErrorIssuingRpcCall;
	return (resp);
}

int             rts_fclr (clearThisLogicalFrame)
	int             clearThisLogicalFrame;
{
	int             resp;

	bool_t          doAcsAcqCommand ();

	if (!(doAcsAcqCommand (FCLR, xdr_int, &clearThisLogicalFrame, xdr_int, &resp)))
		resp = ErrorIssuingRpcCall;
	return (resp);
}

int             createAMatrixFile (fileName, main, dFOV)
	char           *fileName;

	Main_header    *main;

	int             dFOV;
{
	int             resp, determineDataSize ();

	bool_t          doAcsAcqCommand ();

	CREF_args       makeMe;

	bcopy (main, &makeMe.mhead, sizeof (XMAIN_HEAD));
	makeMe.file_name = (char *) calloc (1, 64);
	sprintf (makeMe.file_name, "%s", fileName);
	printf ("Use defaults_get_integer\n");
/*
	makeMe.mhead.system_type = (int) defaults_get_integer("/Ecat/EcatModel", 951, 0);
*/
	if ((makeMe.data_size = determineDataSize (makeMe.mhead.system_type, dFOV,
					 makeMe.mhead.compression_code, makeMe.mhead.wobble_speed,
						   makeMe.mhead.data_type)) == 0) {
		cfree (makeMe.file_name);
		return (1);
	}
	if (!(doAcsAcqCommand (CREF, xdr_CREF_args, &makeMe, xdr_int, &resp)))
		resp = ErrorIssuingRpcCall;
	cfree (makeMe.file_name);
	return (resp);
}

MatrixFile     *createMatrixFile (fileName, main, dFOV)
	char           *fileName;
	Main_header    *main;
	int             dFOV;
{
	MatrixFile     *mFile, *matrix_open (), *matrix_create ();

	if (isThisAnACSFile (fileName)) {
		if (createAMatrixFile (fileName, main, dFOV) != OK)
			return ((MatrixFile *) NULL);
		if ((mFile = matrix_open (fileName, "r+")) == NULL) {
			fprintf (stderr,
				 "createMatrixFile:ERROR...could not open file %s for writing\n",
				 fileName);
			return ((MatrixFile *) NULL);
		}
	} else {				 /* creating a NFS file, so mat_enter will create
						  * only the directories needed */
		printf ("Use defaults_get_integer\n");
/*
		main->system_type = (int) defaults_get_integer("/Ecat/EcatModel", 951, 0);
*/
		if ((mFile = matrix_create (fileName, main)) == (MatrixFile *) NULL) {
			fprintf (stderr,
			    "createMatrixFile:ERROR... Unable to create new file %s\n", fileName);
			return ((MatrixFile *) NULL);
		}
	}
	return (mFile);
}

int             determineDataSize (model, dFOV, mashValue, wobbleFlag, dataType)
	int             model, dFOV, mashValue, wobbleFlag, dataType;
{
	int             power (), dataSize, defaultFOVWidth, defaultAngles;

	switch (model) {			 /* check if mashed or field of view is not
						  * standard */
	case 931:
	case 951:
		defaultFOVWidth = 192;
		defaultAngles = 256;
		break;
	case 933:
	case 953:
	case 921:
		defaultFOVWidth = 160;
		defaultAngles = 192;
		break;
	case 961:
		defaultFOVWidth = 336;
		defaultAngles = 392;
		break;
	}
	dataSize = ((dFOV == 0) ? defaultFOVWidth : dFOV) *
		(defaultAngles / power (2, mashValue)) * 2;
	dataSize /= 512;
	if (wobbleFlag)				 /* check for wobble */
		dataSize *= 4;
	if (dataType == VAX_R4 || dataType == IEEE_R4 ||	/* check if float data */
	    dataType == M68K_I4 || dataType == VAX_I4)
		dataSize *= 2;
	return (dataSize);
}

int             preallocateFileSpace (fileName, main, fileSize)
	char           *fileName;

	Main_header    *main;

	int             fileSize;
{
	FILE           *mPtr, *mat_create ();

	if ((mPtr = mat_create (fileName, main)) == NULL)
		return (1);
	mat_close (mPtr);

	if (truncate (fileName, fileSize < 0))
		return (1);
	return (0);
}

int             rtsGetem (frame, gate, plane, data, bed, gimiData)
	int             frame, plane, gate, data, bed;

	GIMI_resp      *gimiData;
{
	int             resp;

	GIMI_args       gimiCmd;

	bool_t          doAcsAcqCommand ();

	gimiCmd.frame = frame;
	gimiCmd.segment = gate;
	gimiCmd.plane = plane;
	gimiCmd.data = data;
	gimiCmd.bed = bed;
	resp = doAcsAcqCommand (GIMI, xdr_GIMI_args, &gimiCmd, xdr_GIMI_resp, gimiData);
	if (!resp)
		return (TRUE);
	else
		return (gimiData->status);
}

int             rtsGlog (scan, frame, gate, plane, data, bed, glogData)
	char           *scan;

	int             frame, plane, gate, data, bed;

	GLOG_resp      *glogData;
{
	int             resp;

	GLOG_args       glogCmd;

	bool_t          doAcsAcqCommand ();

	glogCmd.filename = scan;
	glogCmd.frame = frame;
	glogCmd.segment = gate;
	glogCmd.plane = plane;
	glogCmd.data = data;
	glogCmd.bed = bed;
	resp = doAcsAcqCommand (GLOG, xdr_GLOG_args, &glogCmd, xdr_GLOG_resp, glogData);
	if (resp == 0 || glogData->status != 0)
		return (TRUE);
	return (FALSE);
}

int             rts_stor (frame, matFrame, bed, scan)
	int             frame, matFrame, bed;

	char           *scan;
{
	int             resp;

	STOR_args       storCmd;

	bool_t          doAcsAcqCommand ();

	storCmd.frame = frame;
	storCmd.matframe = matFrame;
	storCmd.bed = bed;
	storCmd.filename = scan;
	if (!(doAcsAcqCommand (STOR, xdr_STOR_args, &storCmd, xdr_int, &resp)))
		resp = ErrorIssuingRpcCall;
	return (resp);
}

rts_sing (startBucket, endBucket, pollInterval, timeOut, numIpcs)
	int             startBucket, endBucket, pollInterval, timeOut, numIpcs;
{
	int             resp;

	SNGL_args       singCmd;

	bool_t          doAcsAcqCommand ();

	singCmd.start_bucket = startBucket;
	singCmd.end_bucket = endBucket;
	singCmd.frequency = pollInterval;
	singCmd.timeout = timeOut;
	singCmd.num_ipcs = numIpcs;
	if (getenv ("NoSerialBus") == (char *) NULL)
		if (!(doAcsAcqCommand (SNGL, xdr_SNGL_args, &singCmd, xdr_int, &resp)))
			resp = ErrorIssuingRpcCall;
		else
			resp = 0;		 /* bypass all serial bus activity */
	return (resp);
}


int             rts_modl (modelType, numberOfRings)
	int             modelType, numberOfRings;
{
	int             resp;

	MODL_args       modelArgs;

	bool_t          doAcsAcqCommand ();

	modelArgs.model = modelType;
	modelArgs.number_of_rings = numberOfRings;
	if (!(doAcsAcqCommand (MODL, xdr_MODL_args, &modelArgs, xdr_int, &resp)))
		resp = ErrorIssuingRpcCall;
	return (resp);
}

int             rts_rems (numberOfFrames, acqType)
	int             numberOfFrames, acqType;
{
	int             resp;

	STRT_args       remsCmd;

	bool_t          doAcsAcqCommand ();

	remsCmd.numberFrames = numberOfFrames;
	remsCmd.acqType = acqType;
	if (!(doAcsAcqCommand (REMS, xdr_STRT_args, &remsCmd, xdr_int, &resp)))
		resp = ErrorIssuingRpcCall;
	return (resp);
}

int             rts_astr (storeFile, storeIt)
	char           *storeFile;

	int             storeIt;
{
	int             resp;

	bool_t          doAcsAcqCommand ();

	ASTR_args       astrArgs;

	astrArgs.file_name = storeFile;
	astrArgs.auto_store = storeIt;
	if (!(doAcsAcqCommand (ASTR, xdr_ASTR_args, &astrArgs, xdr_int, &resp)))
		resp = ErrorIssuingRpcCall;
	return (resp);
}

int             rts_thrt (throttleValue)
	int             throttleValue;
{
	int             resp;

	bool_t          doAcsAcqCommand ();

	if (!(doAcsAcqCommand (THRT, xdr_int, &throttleValue, xdr_int, &resp)))
		resp = ErrorIssuingRpcCall;
	return (resp);
}

int             rtsinfo (rtsInfo)
	INFO_resp      *rtsInfo;
{
	bool_t          doAcsAcqCommand ();

	return (doAcsAcqCommand (INFO, xdr_void, (char *) NULL, xdr_INFO_resp, rtsInfo));
}

bool_t
whatTimeYaGot (now)
	TIMEX_resp     *now;
{
	bool_t          doAcsAcsCommand ();

	return (doAcsAcsCommand (ACS_WHAT_TIME_IS_IT, xdr_void, (char *) NULL, xdr_TIMEX_resp, now));
}

int             check_rts_status ()
{
	INFO_resp       rtsInfo;
	bool_t          doAcsAcqCommand ();

	if (!(doAcsAcqCommand (INFO, xdr_void, (char *) NULL, xdr_INFO_resp, rtsInfo)))
		rtsInfo.acq_status = FALSE;
	return (rtsInfo.acq_status);
}

int             rts_cont ()
{
	int             resp;
	bool_t          doAcsAcqCommand ();

	if (!(doAcsAcqCommand (CONT, xdr_void, (char *) NULL, xdr_int, &resp)))
		resp = ErrorIssuingRpcCall;
	return (resp);
}

int             rts_mash (mashValue)
	int             mashValue;
{
	int             resp;

	bool_t          doAcsAcqCommand ();

	if (!(doAcsAcqCommand (MASH, xdr_int, &mashValue, xdr_int, &resp)))
		resp = ErrorIssuingRpcCall;
	return (resp);
}

int             rts_dfov (nElems)
	int             nElems;
{
	int             resp;

	bool_t          doAcsAcqCommand ();

	if (!(doAcsAcqCommand (DFOV, xdr_int, &nElems, xdr_int, &resp)))
		resp = ErrorIssuingRpcCall;
	return (resp);
}

int             rts_rwin (enableOrDisable)
	int             enableOrDisable;
{
	int             resp;

	bool_t          doAcsAcqCommand ();

	if (!(doAcsAcqCommand (RWIN, xdr_int, &enableOrDisable, xdr_int, &resp)))
		resp = ErrorIssuingRpcCall;
	return (resp);
}

int             rts_rrdb (enableOrDisable)
	int             enableOrDisable;
{
	int             resp;

	bool_t          doAcsAcqCommand ();

	if (!(doAcsAcqCommand (RRDB, xdr_int, &enableOrDisable, xdr_int, &resp)))
		resp = ErrorIssuingRpcCall;
	return (resp);
}

int             rts_fdel (fileName)
	char           *fileName;
{
	int             resp;

	bool_t          doAcsAcqCommand ();

	if (!(doAcsAcqCommand (FDEL, xdr_wrapstring, &fileName, xdr_int, &resp)))
		resp = ErrorIssuingRpcCall;
	return (resp);
}

int             rts_rect (file, frame, plane, gate, data, startView, endView, rectData)
	char           *file;

	int             frame, plane, gate, data, startView, endView;

	short int      *rectData;
{
	bool_t          doAcsAcqCommand ();

	RDAT_args       rdArgs;

	RDAT_resp       rdResp;

	char            sinoHeader[512];

	Scan_subheader  sH;

	int             i, j, index, matnum, mat_numcod ();

	matnum = mat_numcod (frame, plane, gate, data, 0);
	if (rts_rshd (file, matnum, sinoHeader) < 0)
		return (-1);
	convertScanHeaderFromVax (sinoHeader, &sH);
	rdArgs.file_name = file;
	rdArgs.matnum = matnum;
	rdResp.rdat.rdat_val = (char *) calloc (1, sH.dimension_1 * sH.dimension_2 * sizeof (short));
	if (!(doAcsAcqCommand (RDAT, xdr_RDAT_args, &rdArgs, xdr_RDAT_resp, &rdResp))) {
		cfree (rdResp.rdat.rdat_val);
		return (-1);
	}
	for (i = 0; i < sH.dimension_2; i++) {
		for (j = 0; j < sH.dimension_1; j++) {
			index = j * sH.dimension_2 + i;
			if (i > startView && i <= endView)
				rectData[index] = (short int) rdResp.rdat.rdat_val[2 * index];
			else
				rectData[index] = 0;
		}
	}
	cfree (rdResp.rdat.rdat_val);
	return (rdResp.status);
}

int             rts_rmhd (file, mh)
	char           *file;

	Main_header    *mh;
{
	RMHD_resp       rdResp;

	struct stat     fStats;

	FILE           *fptr, *mat_open ();

	int             mat_read_main_header ();

	if (!stat (file, &fStats)) {
		if ((fptr = mat_open (file, "r")) == (FILE *) NULL) {
			fprintf (stderr, "rts_rmhd:ERROR...Unable to mat_open file %s\n", file);
			return (-1);
		}
		if (mat_read_main_header (fptr, mh)) {
			fprintf (stderr, "rts_rmhd:ERROR...Unable to read main header of file %s\n", file);
			mat_close (fptr);
			return (-1);
		}
		mat_close (fptr);
		return (0);
	} else {
		if (!(doAcsAcqCommand (RMHD, xdr_wrapstring, &file, xdr_RMHD_resp, &rdResp)))
			return (-1);
		bcopy (&rdResp.xmain_head, mh, sizeof (XMAIN_HEAD));
		return (rdResp.status);
	}
}

int             rts_wmhd (file, mh)
	char           *file;

	XMAIN_HEAD     *mh;
{
	WMHD_args       wrArgs;

	int             resp, mat_write_main_header ();

	struct stat     fStats;

	FILE           *fptr, *mat_open ();

	if (!stat (file, &fStats)) {
		if ((fptr = mat_open (file, "r+")) == (FILE *) NULL) {
			fprintf (stderr, "rts_wmhd:ERROR...Unable to mat_open file %s\n", file);
			return (-1);
		}
		if (mat_write_main_header (fptr, mh)) {
			fprintf (stderr,
			       "rts_wmhd:ERROR...Unable to write main header of file %s\n", file);
			mat_close (fptr);
			return (-1);
		}
		mat_close (fptr);
		return (0);
	} else {
		wrArgs.file_name = file;
		bcopy (mh, &wrArgs.xmain_head, sizeof (XMAIN_HEAD));
		if (!(doAcsAcqCommand (WMHD, xdr_WMHD_args, &wrArgs, xdr_int, &resp)))
			resp = -1;
		return (resp);
	}
}

int             rts_rshd (file, matnum, buffer)
	char           *file;

	int             matnum;

	caddr_t         buffer;
{
	RSHD_args       rdArgs;

	RSHD_resp       rdResp;

	int             mat_read_main_header (), mat_lookup (), mat_read_norm_subheader ();

	int             mat_read_scan_subheader (), mat_read_image_subheader (), mat_read_attn_subheader ();

	struct stat     fStats;

	FILE           *fptr, *mat_open ();

	Main_header     mH;

	Scan_subheader  scan;

	Image_subheader image;

	Attn_subheader  attn;

	Norm_subheader  norm;

	struct MatDir   dirEntry;

	if (!stat (file, &fStats)) {
		if ((fptr = mat_open (file, "r")) == (FILE *) NULL) {
			fprintf (stderr, "rts_rshd:ERROR...Unable to mat_open file %s\n", file);
			return (-1);
		}
		if (mat_read_main_header (fptr, &mH)) {
			fprintf (stderr,
				 "rts_rshd:ERROR...Unable to read main header of file %s\n", file);
			mat_close (fptr);
			return (-1);
		}
		if (!mat_lookup (fptr, matnum, &dirEntry)) {
			fprintf (stderr,
				 "rts_rshd:ERROR...Unable to lookup matrix 0x%08x of file %s\n",
				 matnum, file);
			mat_close (fptr);
			return (-1);
		}
		switch (mH.file_type) {
		case RAW_DATA:
			if (mat_read_scan_subheader (fptr, dirEntry.strtblk, &scan)) {
				fprintf (stderr,
				   "rts_rshd:ERROR...Unable to read scan subheader for file %s\n",
					 file);
				mat_close (fptr);
				return (-1);
			}
			convertScanHeaderToVax (buffer, &scan);
			break;
		case IMAGE_DATA:
			if (mat_read_image_subheader (fptr, dirEntry.strtblk, &image)) {
				fprintf (stderr,
				  "rts_rshd:ERROR...Unable to read image subheader for file %s\n",
					 file);
				mat_close (fptr);
				return (-1);
			}
			convertImageHeaderToVax (buffer, &image);
			break;
		case ATTN_DATA:
			if (mat_read_attn_subheader (fptr, dirEntry.strtblk, &attn)) {
				fprintf (stderr,
				   "rts_rshd:ERROR...Unable to read attn subheader for file %s\n",
					 file);
				mat_close (fptr);
				return (-1);
			}
			convertAttnHeaderToVax (buffer, &attn);
			break;
		case NORM_DATA:
			if (mat_read_norm_subheader (fptr, dirEntry.strtblk, &norm)) {
				fprintf (stderr,
				   "rts_rshd:ERROR...Unable to read norm subheader for file %s\n",
					 file);
				mat_close (fptr);
				return (-1);
			}
			convertNormHeaderToVax (buffer, &norm);
			break;
		}
		mat_close (fptr);
		return (0);
	} else {
		rdArgs.file_name = file;
		rdArgs.matnum = matnum;
		if (!(doAcsAcqCommand (RSHD, xdr_RSHD_args, &rdArgs, xdr_RSHD_resp, &rdResp)))
			return (-1);
		bcopy (rdResp.rhdat, buffer, 512);
		return (rdResp.status);
	}
}

int             rts_wshd (file, matnum, buffer)
	char           *file;

	int             matnum;

	caddr_t         buffer;
{
	WSHD_args       wrArgs;

	int             resp, mat_read_main_header (), mat_lookup (), mat_write_norm_subheader ();

	int             mat_write_scan_subheader (), mat_write_image_subheader (), mat_write_attn_subheader ();

	struct stat     fStats;

	FILE           *fptr, *mat_open ();

	Main_header     mH;

	Scan_subheader  scan;

	Image_subheader image;

	Attn_subheader  attn;

	Norm_subheader  norm;

	struct MatDir   dirEntry;

	if (!stat (file, &fStats)) {
		if ((fptr = mat_open (file, "r+")) == (FILE *) NULL) {
			fprintf (stderr, "rts_rshd:ERROR...Unable to mat_open file %s\n", file);
			return (-1);
		}
		if (mat_read_main_header (fptr, &mH)) {
			fprintf (stderr, "rts_rshd:ERROR...Unable to read main header of file %s\n", file);
			mat_close (fptr);
			return (-1);
		}
		if (!mat_lookup (fptr, matnum, &dirEntry)) {
			fprintf (stderr, "rts_rshd:ERROR...Unable to lookup matrix 0x%08x of file %s\n",
				 matnum, file);
			mat_close (fptr);
			return (-1);
		}
		switch (mH.file_type) {
		case RAW_DATA:
			convertScanHeaderFromVax (buffer, &scan);
			if (mat_write_scan_subheader (fptr, dirEntry.strtblk, &scan)) {
				fprintf (stderr,
				  "rts_rshd:ERROR...Unable to write scan subheader for file %s\n",
					 file);
				mat_close (fptr);
				return (-1);
			}
			break;
		case IMAGE_DATA:
			convertImageHeaderFromVax (buffer, &image);
			if (mat_write_image_subheader (fptr, dirEntry.strtblk, &image)) {
				fprintf (stderr,
				"rts_rshd:ERROR... Unable to write image subheader for file %s\n",
					 file);
				mat_close (fptr);
				return (-1);
			}
			break;
		case ATTN_DATA:
			convertAttnHeaderFromVax (buffer, &attn);
			if (mat_write_attn_subheader (fptr, dirEntry.strtblk, &attn)) {
				fprintf (stderr,
				 "rts_rshd:ERROR... Unable to write attn subheader for file %s\n",
					 file);
				mat_close (fptr);
				return (-1);
			}
			break;
		case NORM_DATA:
			convertNormHeaderFromVax (buffer, &norm);
			if (mat_write_norm_subheader (fptr, dirEntry.strtblk, &norm)) {
				fprintf (stderr,
				 "rts_rshd:ERROR... Unable to write norm subheader for file %s\n",
					 file);
				mat_close (fptr);
				return (-1);
			}
			break;
		}
		mat_close (fptr);
		return (0);
	} else {
		wrArgs.file_name = file;
		wrArgs.matnum = matnum;
		bcopy (buffer, wrArgs.whdat, 512);
		if (!(doAcsAcqCommand (WSHD, xdr_WSHD_args, &wrArgs, xdr_int, &resp)))
			return (-1);
		return (resp);
	}
}

int             rts_rdat (file, matnum, buffer, bufferSize)
	char           *file;

	int             matnum, *bufferSize;

	caddr_t         buffer;
{
	RDAT_args       rdArgs;

	RDAT_resp       rdResp;

	int             mat_read_main_header (), mat_lookup (), mat_read_mat_data ();

	struct stat     fStats;

	FILE           *fptr, *mat_open ();

	Main_header     mH;

	struct MatDir   dirEntry;

	if (!stat (file, &fStats)) {
		if ((fptr = mat_open (file, "r")) == (FILE *) NULL) {
			fprintf (stderr, "rts_rdat:ERROR... Unable to mat_open file %s\n", file);
			return (-1);
		}
		if (mat_read_main_header (fptr, &mH)) {
			fprintf (stderr, "rts_rdat:ERROR... Unable to read main header of file %s\n",
				 file);
			mat_close (fptr);
			return (-1);
		}
		if (!mat_lookup (fptr, matnum, &dirEntry)) {
			fprintf (stderr, "rts_rdat:ERROR... Unable to lookup matrix 0x%08x of file %s\n",
				 matnum, file);
			mat_close (fptr);
			return (-1);
		}
		if (mat_read_mat_data (fptr, dirEntry.strtblk + 1,
				       dirEntry.endblk - dirEntry.strtblk, buffer, mH.data_type)) {
			fprintf (stderr, "rts_rdat:ERROR... Unable to read matrix data for file %s\n",
				 file);
			mat_close (fptr);
			return (-1);
		}
		*bufferSize = (dirEntry.endblk - dirEntry.strtblk) * MatBLKSIZE;
		mat_close (fptr);
		return (0);
	} else {
		rdArgs.file_name = file;
		rdArgs.matnum = matnum;
		rdResp.rdat.rdat_val = (char *) buffer;
		if (!(doAcsAcqCommand (RDAT, xdr_RDAT_args, &rdArgs, xdr_RDAT_resp, &rdResp)))
			return (-1);
		*bufferSize = rdResp.rdat.rdat_len;
		return (rdResp.status);
	}
}

int             rts_wdat (file, matnum, dataType, buffer, bufferSize)
	char           *file;
	int             matnum, dataType, bufferSize;
	caddr_t         buffer;
{
	WDAT_args       wrArgs;
	int             mat_read_main_header (), mat_lookup (), resp;
	struct stat     fStats;
	FILE           *fptr, *mat_open ();
	Main_header     mH;
	struct MatDir   dirEntry;

	if (!stat (file, &fStats)) {
		if ((fptr = mat_open (file, "r+")) == (FILE *) NULL) {
			fprintf (stderr, "rts_wdat:ERROR... Unable to mat_open file %s\n", file);
			return (-1);
		}
		if (mat_read_main_header (fptr, &mH)) {
			fprintf (stderr, "rts_wdat:ERROR...Unable to read main header of file %s\n", file);
			mat_close (fptr);
			return (-1);
		}
		if (!mat_lookup (fptr, matnum, &dirEntry)) {
			fprintf (stderr, "rts_wdat:ERROR...Unable to lookup matrix 0x%08x of file %s\n",
				 matnum, file);
			mat_close (fptr);
			return (-1);
		}
		if (write_matrix_data (fptr, dirEntry.strtblk + 1,
				       dirEntry.endblk - dirEntry.strtblk, buffer, mH.data_type)) {
			fprintf (stderr, "rts_wdat:ERROR...Unable to write matrix data for file %s\n",
				 file);
			mat_close (fptr);
			return (-1);
		}
		mat_close (fptr);
		return (0);
	} else {
		wrArgs.file_name = file;
		wrArgs.matnum = matnum;
		wrArgs.data_type = dataType;
		wrArgs.wdat.wdat_len = bufferSize;
		wrArgs.wdat.wdat_val = buffer;
		if (!(doAcsAcqCommand (WDAT, xdr_WDAT_args, &wrArgs, xdr_int, &resp)))
			resp = -1;
		return (resp);
	}
}

int             rtsRblk (file, blockNumber, buffer)
	char           *file;

	int             blockNumber;

	caddr_t         buffer;
{
	RBLK_args       rbArgs;

	RBLK_resp       rbResp;

	rbArgs.filename = file;
	rbArgs.block_number = blockNumber;
	if (!(doAcsAcqCommand (RBLK, xdr_RBLK_args, &rbArgs, xdr_RBLK_resp, &rbResp)))
		return (-1);
	bcopy (rbResp.rblk, buffer, 512);
	return (rbResp.status);
}

int             rtsWblk (file, blockNumber, buffer)
	char           *file;

	int             blockNumber;

	caddr_t         buffer;
{
	WBLK_args       wbArgs;

	int             resp;

	wbArgs.filename = file;
	wbArgs.block_number = blockNumber;
	bcopy (buffer, wbArgs.wblk, 512);
	if (!(doAcsAcqCommand (WBLK, xdr_WBLK_args, &wbArgs, xdr_int, &resp)))
		return (-1);
	return (resp);
}

void            fillInMainHeader (mh, name)
	Main_header    *mh;

	char           *name;
{
/* Tom Yang on 1/28/93.
	char *acqServer;

	acqServer = defaults_get_string("/Ecat/EcatRTSCpu", "Mizar", 0);
	mh->file_type = 1;
	mh->system_type = (int) defaults_get_integer("/Ecat/EcatModel", 951, 0);
	mh->data_type = strcmp(acqServer, "ACS") ? VAX_I2 : M68K_I2;
	sprintf(mh->original_file_name, "%s", name);
	mh->original_file_name[19] = 0;
	sprintf(mh->node_id, "%s", "dummy");
	strcpy(mh->isotope_code, "Ge-68");
	mh->isotope_halflife = 23760000.0;
	sprintf(mh->radiopharmaceutical, "%s", "dummy");
	sprintf(mh->study_name, "%s", "dummy");
	sprintf(mh->patient_id, "%s", " ");
	sprintf(mh->patient_name, "%s", "dummy");
	mh->patient_sex = 'm';
	sprintf(mh->patient_age, "%s", "0");
	sprintf(mh->patient_weight, "%s", "0");
	sprintf(mh->patient_height, "%s", "0");
	mh->patient_dexterity = 'l';
	sprintf(mh->physician_name, "%s", "Dr. No");
	sprintf(mh->operator_name, "%s", "dummy");
	sprintf(mh->study_description, "%s", "dummy");
	sprintf(mh->facility_name, "%s", "dummy");
	sprintf(mh->user_process_code, "%s", " ");
*/
	return;
}

int             singlesOn ()
{
/*
	int numBuckets,
	    numIPCs = 1;

	numBuckets = defaults_get_integer("/Ecat/EcatNumBuckets", 32, 0) - 1;
	if (defaults_get_integer("/Ecat/EcatNumRings", 2, 0) == 1)
	if (1)
		numIPCs = 1;
	else
		numIPCs = 4;
	if (defaults_get_integer("/Ecat/EcatModel", 951, 0) == 921 ||
		defaults_get_integer("/Ecat/EcatModel", 951, 0) == 961)
		numIPCs = 1;
	return (rts_sing(0, numBuckets, 1000, 2000, numIPCs));
*/
	return (1);
}

int             singlesOff ()
{
	return (rts_sing (0, 0, 0, 2000, 0));
}

int             talkToRtsInfo (infoCommand)
	int             infoCommand;
{

	/*
	 * Tom Yang on 1/28/93. struct sockaddr_in addr; struct hostent *hp; int sock, result, i =
	 * 0, pid, retVal; struct timeval timeout; CLIENT *client;
	 * 
	 * bzero((char *) &addr, sizeof(addr)); if ((hp = gethostbyname("localhost")) == NULL) {
	 * fprintf(stderr, "gethostbyname failed\n"); return (-1); } for (pid = 0, i = 0; i < 2;
	 * i++) { bcopy(hp->h_addr, (caddr_t) & addr.sin_addr, hp->h_length); addr.sin_family =
	 * AF_INET; addr.sin_port = 0; sock = RPC_ANYSOCK; if ((client = clnttcp_create(&addr,
	 * RTS_INFO_SERVER, RTS_INFO_VERSION, &sock, 0, 0)) == NULL) { if (!(pid = vfork()))
	 * execlp("rtsinfo", "rtsinfo", 0); sleep(5); } } timeout.tv_sec = 10; timeout.tv_usec = 0;
	 * if ((int) clnt_call(client, infoCommand, xdr_void, NULL, xdr_void, (char *) NULL,
	 * timeout) != (int) RPC_SUCCESS) { fprintf(stderr, "startRtsInfo: Cannot communicate with
	 * rtsinfo\n"); clnt_perror(client, "clnt_call"); return (-1); } clnt_destroy(client);
	 * return (pid);
	 */
	return (1);
}

char           *
                rts_error (parm_1)
	int             parm_1;
{
	char            problem[64];

	switch (parm_1) {
	case ErrorIssuingRpcCall:
		return ("RTS Error... call to talk to the ACS failed\n");
	case -1:
		return ("RTS Error... shut 'er down, chauncy, we're suckin mud\n");
	case 0:
		return ("");
	case 1:
		return ("RTS Error...invalid command\n");
	case 2:
		return ("RTS Error...invalid parameter\n");
	case 8:
		return ("RTS Error...unexpected bus/address error\n");
	case 10:
		return ("RTS Error...rts database is not initialized\n");
	case 11:
		return ("RTS Error...acquisition is already configured\n");
	case 12:
		return ("RTS Error...acquisition is not configured\n");
	case 13:
		return ("RTS Error...maximum number of planes already defined\n");
	case 14:
		return ("RTS Error...maximum number of frames already defined\n");
	case 15:
		return ("RTS Error...unknown model specified\n");
	case 16:
		return ("RTS Error...no planes defined for acquisition\n");
	case 17:
		return ("RTS Error...no frames defined for acquisition\n");
	case 18:
		return ("RTS Error...not enough memory for defined acquisition\n");
	case 19:
		return ("RTS Error...specified sinogram does not exist\n");
	case 50:
		return ("RTS Error...no gantry initialization\n");
	case 51:
		return ("RTS Error...polling timeout is too short\n");
	case 100:
		return ("RTS Error...out of memory value\n");
	case 102:
		return ("RTS Error...memory size mismatch during configure\n");
	case 104:
		return ("RTS Error...memory failure during configure\n");
	case 106:
		return ("RTS Error...definition missing for configure\n");
	case 110:
		return ("RTS Error...bus error during configure -1\n");
	case 112:
		return ("RTS Error...formatter bus error\n");
	case 114:
		return ("RTS Error...sorter bus error\n");
	case 116:
		return ("RTS Error...tally bus error\n");
	case 118:
		return ("RTS Error...dr11-w bus error\n");
	case 120:
		return ("RTS Error...no wobble gate csr response\n");
	case 122:
		return ("RTS Error...no wobble gate\n");
	case 124:
		return ("RTS Error...frame / segment mismatch\n");
	case 126:
		return ("RTS Error...memory not configured for 'strt' command\n");
	case 200:
		return ("RTS Error...no sinogram available for 'gimi' command\n");
	case 210:
		return ("RTS Error...no gated windows defined\n");
	case 212:
		return ("RTS Error...max windows defined\n");
	case 300:
		return ("RTS Error...no planes defined for 'repo' command\n");
	case 333:
		return ("RTS Error...invalid rts unit number\n");
	case 334:
		return ("RTS Error...rts serial communication timeout\n");
	case 335:
		return ("RTS Error...rts dr11w  communication timeout\n");
	case 400:
		return ("RTS Error...no record for 'rgan' command\n");
	case 402:
		return ("RTS Error...gantry polling\n");
	case 500:
		return ("RTS Error...disk format error\n");
	case 502:
		return ("RTS Error...block pointer table over flow (> 32)\n");
	case 504:
		return ("RTS Error...disk busy\n");
	default:
		sprintf (problem, "RTS Error...not sure, passed a %d", parm_1);
		return ("RTS Error...not sure\n");
	}
}

/*****************************************************************************************************
int rts_wait (waitThisLong)
int waitThisLong;
{
    int check_rts_status ();
    bool_t doAcsAcqCommand ();

    sleep (waitThisLong);
    while ((check_rts_status ()) != NULL);
    return (TRUE);
}
*****************************************************************************************************/

/*****************************************************************************************************
rts_dseg (nsegs, direction, offset, duration)
int nsegs, direction, offset, duration;
{
    int resp;
    DSEG_args dsegCmd;
    bool_t doAcsAcqCommand ();

    dsegCmd.nseg = nsegs;
    dsegCmd.dir = direction;
    dsegCmd.offset = offset;
    dsegCmd.duration = duration;
    if (!(doAcsAcqCommand (DSEG, xdr_DSEG_args, dsegCmd, xdr_int, &resp)))
	resp = ErrorIssuingRpcCall;
    return (resp);
}
*****************************************************************************************************/

/*****************************************************************************************************
int rts_blim (frame, lowLimit, highLimit)
int frame, lowLimit, highLimit;
{
    int resp;
    BLIM_args blimCmd;
    bool_t doAcsAcqCommand ();

    blimCmd.frame = frame;
    blimCmd.minBeat = lowLimit;
    blimCmd.maxBeat = highLimit;
    if (!(doAcsAcqCommand (BLIM, xdr_BLIM_args, &blimCmd, xdr_int, &resp)))
	resp = ErrorIssuingRpcCall;
    return (resp);
}
*****************************************************************************************************/

/*****************************************************************************************************
rts_rsin (bucket, cor_sing, uncor_sing)
int bucket, *cor_sing, *uncor_sing;
{
    int resp;
    SNGL_resp singData;
    bool_t doAcsAcqCommand ();

    resp = doAcsAcqCommand (RSIN, xdr_int, &bucket, xdr_SNGL_resp, &singData);
    *cor_sing = singData.corrected_singles;
    *uncor_sing = singData.uncorrected_singles;
    return (resp);
}
*****************************************************************************************************/

/*****************************************************************************************************
int rts_beat (frame, beatData)
int frame;
BEAT_resp *beatData;
{
    bool_t doAcsAcqCommand ();

    doAcsAcqCommand (BEAT, xdr_int, &frame, xdr_BEAT_resp, beatData);
    return (beatData->beat_result);
}
*****************************************************************************************************/
@


1.6
log
@partially cleaned up with lint
@
text
@d1 1
a1 1
/*$Id: rts.c,v 1.5 1996/09/25 16:28:32 tom Exp tom $*/
d3 3
d45 1
a45 1
static char     rcsid[] = "$Header: /home/npggw/tom/src/libcti/RCS/rts.c,v 1.5 1996/09/25 16:28:32 tom Exp tom $";
d1255 1
a1255 1
		return (problem);
@


1.5
log
@build in Solaris 2
@
text
@d1 1
a1 1
/*$Id: rts.c,v 1.4 1995/10/30 16:54:44 tom Exp tom $*/
d3 3
d42 1
a42 2
static char     sccsid[] = "@@(#)rts.c	2.14  6/16/92 Copyright 1989-1992 CTI PET Systems, Inc.";
static char     rcsid[] = "$Header: /home/npggw/tom/src/libcti/RCS/rts.c,v 1.4 1995/10/30 16:54:44 tom Exp tom $";
d49 2
a53 3
/* Tom Yang on 1/28/93.
#include <sunwindow/defaults.h>
*/
d283 1
a283 2
MatrixFile     *
                createMatrixFile (fileName, main, dFOV)
a284 1

a285 1

a287 2
	int             dataSize, wordSize, determineDataSize ();

a537 2
	int             resp;

a538 1

a548 1

a989 1

a990 1

d994 1
a994 3

	int             mat_read_main_header (), mat_lookup (), mat_write_mat_data (), resp;

a995 1

a996 1

a997 1

a1134 3
#include <netdb.h>
#include <sys/socket.h>

@


1.4
log
@changed petutil/matrix.h to matrix.h
@
text
@d1 1
a1 1
/*$Id: rts.c,v 1.3 1994/03/03 17:37:48 ty7777 Exp tom $*/
d3 3
d39 2
a40 1
static char sccsid[] = "@@(#)rts.c	2.14  6/16/92 Copyright 1989-1992 CTI PET Systems, Inc.";
a41 1
static char rcsid [] = "$Header: /home/npggw/tom/src/libcti/RCS/rts.c,v 1.3 1994/03/03 17:37:48 ty7777 Exp tom $";
d57 2
a58 3
int 
rtsMagpie(squawk)
int squawk;
d60 1
a60 2
	int resp;
	bool_t doAcsAcqCommand();
d62 3
a64 1
	if (!(doAcsAcqCommand(DBUG, xdr_int, &squawk, xdr_int, &resp)))
d69 2
a70 3
int 
rts_conf(clearOrConfig)
int clearOrConfig;
d92 2
a93 3
int 
rts_acqm(acquisitionMode)
int acquisitionMode;
d95 1
a95 2
	int resp;
	bool_t doAcsAcqCommand();
d97 3
a99 1
	if (!(doAcsAcqCommand(ACQM, xdr_int, &acquisitionMode, xdr_int, &resp)))
d104 2
a105 9
int 
rts_dpln(logPlane, phyPlane0, phyPlane1, phyPlane2, phyPlane3, phyPlane4, phyPlane5)
int logPlane,
    phyPlane0,
    phyPlane1,
    phyPlane2,
    phyPlane3,
    phyPlane4,
    phyPlane5;
d107 1
a107 3
	int resp;
	DPLN_args dplnCmd;
	bool_t doAcsAcqCommand();
d109 4
d120 1
a120 1
	if (!(doAcsAcqCommand(DPLN, xdr_DPLN_args, &dplnCmd, xdr_int, &resp)))
d125 2
a126 6
int 
rts_dfrm(nFrames, delay, duration, nsegs)
int nFrames,
    delay,
    duration,
    nsegs;
d128 1
a128 3
	int resp;
	DFRM_args dfrmCmd;
	bool_t doAcsAcqCommand();
d130 4
d138 1
a138 1
	if (!(doAcsAcqCommand(DFRM, xdr_DFRM_args, &dfrmCmd, xdr_int, &resp)))
d143 2
a144 4
int 
rts_strt(framesToDo, acqType)
int framesToDo,
    acqType;
d146 1
a146 3
	int resp;
	STRT_args strtCmd;
	bool_t doAcsAcqCommand();
d148 4
d154 1
a154 1
	if (!(doAcsAcqCommand(STRT, xdr_STRT_args, &strtCmd, xdr_int, &resp)))
d159 2
a160 4
int 
rts_gantry(command, response)
char *command,
    *response;
d162 1
a162 4
	bool_t doAcsAcqCommand(),
	       status;
	char temp_response[80],
	    *temp;
d164 2
d167 4
a170 7
	if (getenv("NoSerialBus") == (char *) NULL)	/* bypass all serial bus
							 * activity */
	{
		status = doAcsAcqCommand(GANT, xdr_wrapstring, &command, xdr_wrapstring, &temp);
		sprintf(response, "%s", temp);
	} else
	{
d172 1
a172 1
		strcpy(response, "N 0");
d177 2
a178 3
int 
rts_rgan(response)
char *response;
d180 1
a180 1
	bool_t doAcsAcqCommand();
d182 4
a185 6
	if (getenv("NoSerialBus") == (char *) NULL)	/* bypass all serial bus
							 * activity */
		return (doAcsAcqCommand(RGAN, xdr_void, (char *) NULL, xdr_wrapstring, &response));
	else
	{
		strcpy(response, "0, 0, 0, 0, 0, 0, 0, 0");
d190 2
a191 4
int 
rts_gantry_controller(command, response)
char *command,
    *response;
d193 1
a193 1
	bool_t doAcsAcqCommand();
d195 4
a198 6
	if (getenv("NoSerialBus") == (char *) NULL)	/* bypass all serial bus
							 * activity */
		return (doAcsAcqCommand(GCTL, xdr_wrapstring, &command, xdr_wrapstring, &response));
	else
	{
		strcpy(response, "N 0");
d203 1
a203 2
int 
rts_stop()
d205 1
a205 2
	int resp;
	bool_t doAcsAcqCommand();
d207 3
a209 1
	if (!(doAcsAcqCommand(STOP, xdr_void, (char *) NULL, xdr_int, &resp)))
d214 2
a215 3
int 
rts_sinm(sinoMode)
int sinoMode;
d217 1
a217 2
	int resp;
	bool_t doAcsAcqCommand();
d219 3
a221 1
	if (!(doAcsAcqCommand(SINM, xdr_int, &sinoMode, xdr_int, &resp)))
d226 2
a227 3
int 
rts_reso(stationaryOrWobbled)
int stationaryOrWobbled;
d229 1
a229 2
	int resp;
	bool_t doAcsAcqCommand();
d231 3
a233 1
	if (!(doAcsAcqCommand(RESO, xdr_int, &stationaryOrWobbled, xdr_int, &resp)))
d238 2
a239 3
int 
rts_fclr(clearThisLogicalFrame)
int clearThisLogicalFrame;
d241 1
a241 2
	int resp;
	bool_t doAcsAcqCommand();
d243 3
a245 1
	if (!(doAcsAcqCommand(FCLR, xdr_int, &clearThisLogicalFrame, xdr_int, &resp)))
d250 6
a255 5
int 
createAMatrixFile(fileName, main, dFOV)
char *fileName;
Main_header *main;
int dFOV;
d257 1
a257 4
	int resp,
	    determineDataSize();
	bool_t doAcsAcqCommand();
	CREF_args makeMe;
d259 8
a266 4
	bcopy(main, &makeMe.mhead, sizeof(XMAIN_HEAD));
	makeMe.file_name = (char *) calloc(1, 64);
	sprintf(makeMe.file_name, "%s", fileName);
printf ("Use defaults_get_integer\n");
d270 4
a273 5
	if ((makeMe.data_size = determineDataSize(makeMe.mhead.system_type, dFOV,
				makeMe.mhead.compression_code, makeMe.mhead.wobble_speed,
				makeMe.mhead.data_type)) == 0)
	{
		cfree(makeMe.file_name);
d276 1
a276 1
	if (!(doAcsAcqCommand(CREF, xdr_CREF_args, &makeMe, xdr_int, &resp)))
d278 1
a278 1
	cfree(makeMe.file_name);
d282 7
a288 5
MatrixFile *
createMatrixFile(fileName, main, dFOV)
char *fileName;
Main_header *main;
int dFOV;
d290 1
a290 6
	int dataSize,
	    wordSize,
	    determineDataSize();
	MatrixFile *mFile,
	          *matrix_open(),
	          *matrix_create();
d292 4
a295 3
	if (isThisAnACSFile(fileName))
	{
		if (createAMatrixFile(fileName, main, dFOV) != OK)
d297 4
a300 5
		if ((mFile = matrix_open(fileName, "r+")) == NULL)
		{
			fprintf(stderr, 
				"createMatrixFile:ERROR...could not open file %s for writing\n", 
					fileName);
d303 3
a305 6
	} else
	{	/* creating a NFS file,
		 * so mat_enter will
		 * create only the
		 * directories needed */
printf ("Use defaults_get_integer\n");
d309 3
a311 4
		if ((mFile = matrix_create(fileName, main)) == (MatrixFile *) NULL)
		{
			fprintf(stderr, 
				"createMatrixFile:ERROR... Unable to create new file %s\n", fileName);
d318 2
a319 7
int 
determineDataSize(model, dFOV, mashValue, wobbleFlag, dataType)
int model,
    dFOV,
    mashValue,
    wobbleFlag,
    dataType;
d321 1
a321 4
	int power(),
	    dataSize,
	    defaultFOVWidth,
	    defaultAngles;
d323 4
a326 6
	switch (model)	/* check if mashed or
			 * field of view is not
			 * standard */
	{
	    case 931:
	    case 951:
d330 3
a332 3
	    case 933:
	    case 953:
	    case 921:
d336 1
a336 1
	    case 961:
d342 1
a342 1
		(defaultAngles / power(2, mashValue)) * 2;
d344 1
a344 1
	if (wobbleFlag)	/* check for wobble */
d347 1
a347 1
		dataType == M68K_I4 || dataType == VAX_I4)
d352 6
a357 5
int 
preallocateFileSpace(fileName, main, fileSize)
char *fileName;
Main_header *main;
int fileSize;
d359 1
a359 2
	FILE *mPtr,
	    *mat_create();
d361 1
a361 1
	if ((mPtr = mat_create(fileName, main)) == NULL)
d363 1
a363 1
	mat_close(mPtr);
d365 1
a365 1
	if (truncate(fileName, fileSize < 0))
d370 4
a373 8
int 
rtsGetem(frame, gate, plane, data, bed, gimiData)
int frame,
    plane,
    gate,
    data,
    bed;
GIMI_resp *gimiData;
d375 1
a375 3
	int resp;
	GIMI_args gimiCmd;
	bool_t doAcsAcqCommand();
d377 4
d386 1
a386 1
	resp = doAcsAcqCommand(GIMI, xdr_GIMI_args, &gimiCmd, xdr_GIMI_resp, gimiData);
d393 6
a398 9
int 
rtsGlog(scan, frame, gate, plane, data, bed, glogData)
char *scan;
int frame,
    plane,
    gate,
    data,
    bed;
GLOG_resp *glogData;
d400 1
a400 3
	int resp;
	GLOG_args glogCmd;
	bool_t doAcsAcqCommand();
d402 4
d412 1
a412 1
	resp = doAcsAcqCommand(GLOG, xdr_GLOG_args, &glogCmd, xdr_GLOG_resp, glogData);
d418 4
a421 6
int 
rts_stor(frame, matFrame, bed, scan)
int frame,
    matFrame,
    bed;
char *scan;
d423 1
a423 3
	int resp;
	STOR_args storCmd;
	bool_t doAcsAcqCommand();
d425 4
d433 1
a433 1
	if (!(doAcsAcqCommand(STOR, xdr_STOR_args, &storCmd, xdr_int, &resp)))
d438 2
a439 6
rts_sing(startBucket, endBucket, pollInterval, timeOut, numIpcs)
int startBucket,
    endBucket,
    pollInterval,
    timeOut,
    numIpcs;
d441 1
a441 3
	int resp;
	SNGL_args singCmd;
	bool_t doAcsAcqCommand();
d443 4
d452 2
a453 2
	if (getenv("NoSerialBus") == (char *) NULL)
		if (!(doAcsAcqCommand(SNGL, xdr_SNGL_args, &singCmd, xdr_int, &resp)))
d456 1
a456 2
			resp = 0;	/* bypass all serial bus
					 * activity */
d461 2
a462 4
int 
rts_modl(modelType, numberOfRings)
int modelType,
    numberOfRings;
d464 1
a464 3
	int resp;
	MODL_args modelArgs;
	bool_t doAcsAcqCommand();
d466 4
d472 1
a472 1
	if (!(doAcsAcqCommand(MODL, xdr_MODL_args, &modelArgs, xdr_int, &resp)))
d477 2
a478 4
int 
rts_rems(numberOfFrames, acqType)
int numberOfFrames,
    acqType;
d480 1
a480 3
	int resp;
	STRT_args remsCmd;
	bool_t doAcsAcqCommand();
d482 4
d488 1
a488 1
	if (!(doAcsAcqCommand(REMS, xdr_STRT_args, &remsCmd, xdr_int, &resp)))
d493 4
a496 4
int 
rts_astr(storeFile, storeIt)
char *storeFile;
int storeIt;
d498 1
a498 3
	int resp;
	bool_t doAcsAcqCommand();
	ASTR_args astrArgs;
d500 4
d506 1
a506 1
	if (!(doAcsAcqCommand(ASTR, xdr_ASTR_args, &astrArgs, xdr_int, &resp)))
d511 2
a512 3
int 
rts_thrt(throttleValue)
int throttleValue;
d514 1
a514 2
	int resp;
	bool_t doAcsAcqCommand();
d516 3
a518 1
	if (!(doAcsAcqCommand(THRT, xdr_int, &throttleValue, xdr_int, &resp)))
d523 2
a524 3
int 
rtsinfo(rtsInfo)
INFO_resp *rtsInfo;
d526 1
a526 1
	bool_t doAcsAcqCommand();
d528 1
a528 1
	return (doAcsAcqCommand(INFO, xdr_void, (char *) NULL, xdr_INFO_resp, rtsInfo));
d531 3
a533 3
bool_t 
whatTimeYaGot(now)
TIMEX_resp *now;
d535 1
a535 1
	bool_t doAcsAcsCommand();
d537 1
a537 1
	return (doAcsAcsCommand(ACS_WHAT_TIME_IS_IT, xdr_void, (char *) NULL, xdr_TIMEX_resp, now));
d540 1
a540 2
int 
check_rts_status()
d542 1
a542 3
	int resp;
	INFO_resp rtsInfo;
	bool_t doAcsAcqCommand();
d544 5
a548 1
	if (!(doAcsAcqCommand(INFO, xdr_void, (char *) NULL, xdr_INFO_resp, rtsInfo)))
d553 1
a553 2
int 
rts_cont()
d555 1
a555 2
	int resp;
	bool_t doAcsAcqCommand();
d557 3
a559 1
	if (!(doAcsAcqCommand(CONT, xdr_void, (char *) NULL, xdr_int, &resp)))
d564 2
a565 3
int 
rts_mash(mashValue)
int mashValue;
d567 1
a567 2
	int resp;
	bool_t doAcsAcqCommand();
d569 3
a571 1
	if (!(doAcsAcqCommand(MASH, xdr_int, &mashValue, xdr_int, &resp)))
d576 2
a577 3
int 
rts_dfov(nElems)
int nElems;
d579 1
a579 2
	int resp;
	bool_t doAcsAcqCommand();
d581 3
a583 1
	if (!(doAcsAcqCommand(DFOV, xdr_int, &nElems, xdr_int, &resp)))
d588 2
a589 3
int 
rts_rwin(enableOrDisable)
int enableOrDisable;
d591 1
a591 2
	int resp;
	bool_t doAcsAcqCommand();
d593 3
a595 1
	if (!(doAcsAcqCommand(RWIN, xdr_int, &enableOrDisable, xdr_int, &resp)))
d600 2
a601 3
int 
rts_rrdb(enableOrDisable)
int enableOrDisable;
d603 1
a603 2
	int resp;
	bool_t doAcsAcqCommand();
d605 3
a607 1
	if (!(doAcsAcqCommand(RRDB, xdr_int, &enableOrDisable, xdr_int, &resp)))
d612 2
a613 3
int 
rts_fdel(fileName)
char *fileName;
d615 1
a615 2
	int resp;
	bool_t doAcsAcqCommand();
d617 3
a619 1
	if (!(doAcsAcqCommand(FDEL, xdr_wrapstring, &fileName, xdr_int, &resp)))
d624 6
a629 10
int 
rts_rect(file, frame, plane, gate, data, startView, endView, rectData)
char *file;
int frame,
    plane,
    gate,
    data,
    startView,
    endView;
short int *rectData;
d631 1
a631 10
	bool_t doAcsAcqCommand();
	RDAT_args rdArgs;
	RDAT_resp rdResp;
	char sinoHeader[512];
	Scan_subheader sH;
	int i,
	    j,
	    index,
	    matnum,
	    mat_numcod();
d633 12
a644 2
	matnum = mat_numcod(frame, plane, gate, data, 0);
	if (rts_rshd(file, matnum, sinoHeader) < 0)
d646 1
a646 1
	convertScanHeaderFromVax(sinoHeader, &sH);
d649 3
a651 4
	rdResp.rdat.rdat_val = (char *) calloc(1, sH.dimension_1 * sH.dimension_2 * sizeof(short));
	if (!(doAcsAcqCommand(RDAT, xdr_RDAT_args, &rdArgs, xdr_RDAT_resp, &rdResp)))
	{
		cfree(rdResp.rdat.rdat_val);
d654 2
a655 4
	for (i = 0; i < sH.dimension_2; i++)
	{
		for (j = 0; j < sH.dimension_1; j++)
		{
d663 1
a663 1
	cfree(rdResp.rdat.rdat_val);
d667 4
a670 4
int 
rts_rmhd(file, mh)
char *file;
Main_header *mh;
d672 1
a672 5
	RMHD_resp rdResp;
	struct stat fStats;
	FILE *fptr,
	    *mat_open();
	int mat_read_main_header();
d674 9
a682 5
	if (!stat(file, &fStats))
	{
		if ((fptr = mat_open(file, "r")) == (FILE *) NULL)
		{
			fprintf(stderr, "rts_rmhd:ERROR...Unable to mat_open file %s\n", file);
d685 3
a687 4
		if (mat_read_main_header(fptr, mh))
		{
			fprintf(stderr, "rts_rmhd:ERROR...Unable to read main header of file %s\n", file);
			mat_close(fptr);
d690 1
a690 1
		mat_close(fptr);
d692 2
a693 3
	} else
	{
		if (!(doAcsAcqCommand(RMHD, xdr_wrapstring, &file, xdr_RMHD_resp, &rdResp)))
d695 1
a695 1
		bcopy(&rdResp.xmain_head, mh, sizeof(XMAIN_HEAD));
d700 4
a703 4
int 
rts_wmhd(file, mh)
char *file;
XMAIN_HEAD *mh;
d705 1
a705 6
	WMHD_args wrArgs;
	int resp,
	    mat_write_main_header();
	struct stat fStats;
	FILE *fptr,
	    *mat_open();
d707 9
a715 5
	if (!stat(file, &fStats))
	{
		if ((fptr = mat_open(file, "r+")) == (FILE *) NULL)
		{
			fprintf(stderr, "rts_wmhd:ERROR...Unable to mat_open file %s\n", file);
d718 4
a721 5
		if (mat_write_main_header(fptr, mh))
		{
			fprintf(stderr, 
				"rts_wmhd:ERROR...Unable to write main header of file %s\n", file);
			mat_close(fptr);
d724 1
a724 1
		mat_close(fptr);
d726 1
a726 2
	} else
	{
d728 2
a729 2
		bcopy(mh, &wrArgs.xmain_head, sizeof(XMAIN_HEAD));
		if (!(doAcsAcqCommand(WMHD, xdr_WMHD_args, &wrArgs, xdr_int, &resp)))
d735 6
a740 5
int 
rts_rshd(file, matnum, buffer)
char *file;
int matnum;
caddr_t buffer;
d742 16
a757 13
	RSHD_args rdArgs;
	RSHD_resp rdResp;
	int mat_read_main_header(),
	    mat_lookup(),
	    mat_read_norm_subheader();
	int mat_read_scan_subheader(),
	    mat_read_image_subheader(),
	    mat_read_attn_subheader();
	struct stat fStats;
	FILE *fptr,
	    *mat_open();
	Main_header mH;
	Scan_subheader scan;
a758 3
	Attn_subheader attn;
	Norm_subheader norm;
	struct MatDir dirEntry;
d760 9
a768 5
	if (!stat(file, &fStats))
	{
		if ((fptr = mat_open(file, "r")) == (FILE *) NULL)
		{
			fprintf(stderr, "rts_rshd:ERROR...Unable to mat_open file %s\n", file);
d771 4
a774 5
		if (mat_read_main_header(fptr, &mH))
		{
			fprintf(stderr, 
				"rts_rshd:ERROR...Unable to read main header of file %s\n", file);
			mat_close(fptr);
d777 5
a781 6
		if (!mat_lookup(fptr, matnum, &dirEntry))
		{
			fprintf(stderr, 
				"rts_rshd:ERROR...Unable to lookup matrix 0x%08x of file %s\n", 
					matnum, file);
			mat_close(fptr);
d784 7
a790 9
		switch (mH.file_type)
		{
		    case RAW_DATA:
			if (mat_read_scan_subheader(fptr, dirEntry.strtblk, &scan))
			{
				fprintf(stderr, 
					"rts_rshd:ERROR...Unable to read scan subheader for file %s\n", 
						file);
				mat_close(fptr);
d793 1
a793 1
			convertScanHeaderToVax(buffer, &scan);
d795 6
a800 7
		    case IMAGE_DATA:
			if (mat_read_image_subheader(fptr, dirEntry.strtblk, &image))
			{
				fprintf(stderr, 
					"rts_rshd:ERROR...Unable to read image subheader for file %s\n", 
						file);
				mat_close(fptr);
d803 1
a803 1
			convertImageHeaderToVax(buffer, &image);
d805 6
a810 7
		    case ATTN_DATA:
			if (mat_read_attn_subheader(fptr, dirEntry.strtblk, &attn))
			{
				fprintf(stderr, 
					"rts_rshd:ERROR...Unable to read attn subheader for file %s\n", 
						file);
				mat_close(fptr);
d813 1
a813 1
			convertAttnHeaderToVax(buffer, &attn);
d815 6
a820 7
		    case NORM_DATA:
			if (mat_read_norm_subheader(fptr, dirEntry.strtblk, &norm))
			{
				fprintf(stderr, 
					"rts_rshd:ERROR...Unable to read norm subheader for file %s\n", 
						file);
				mat_close(fptr);
d823 1
a823 1
			convertNormHeaderToVax(buffer, &norm);
d826 1
a826 1
		mat_close(fptr);
d828 1
a828 2
	} else
	{
d831 1
a831 1
		if (!(doAcsAcqCommand(RSHD, xdr_RSHD_args, &rdArgs, xdr_RSHD_resp, &rdResp)))
d833 1
a833 1
		bcopy(rdResp.rhdat, buffer, 512);
d838 6
a843 5
int 
rts_wshd(file, matnum, buffer)
char *file;
int matnum;
caddr_t buffer;
d845 14
a858 13
	WSHD_args wrArgs;
	int resp,
	    mat_read_main_header(),
	    mat_lookup(),
	    mat_write_norm_subheader();
	int mat_write_scan_subheader(),
	    mat_write_image_subheader(),
	    mat_write_attn_subheader();
	struct stat fStats;
	FILE *fptr,
	    *mat_open();
	Main_header mH;
	Scan_subheader scan;
a859 3
	Attn_subheader attn;
	Norm_subheader norm;
	struct MatDir dirEntry;
d861 9
a869 5
	if (!stat(file, &fStats))
	{
		if ((fptr = mat_open(file, "r+")) == (FILE *) NULL)
		{
			fprintf(stderr, "rts_rshd:ERROR...Unable to mat_open file %s\n", file);
d872 3
a874 4
		if (mat_read_main_header(fptr, &mH))
		{
			fprintf(stderr, "rts_rshd:ERROR...Unable to read main header of file %s\n", file);
			mat_close(fptr);
d877 4
a880 5
		if (!mat_lookup(fptr, matnum, &dirEntry))
		{
			fprintf(stderr, "rts_rshd:ERROR...Unable to lookup matrix 0x%08x of file %s\n", 
				matnum, file);
			mat_close(fptr);
d883 8
a890 10
		switch (mH.file_type)
		{
		    case RAW_DATA:
			convertScanHeaderFromVax(buffer, &scan);
			if (mat_write_scan_subheader(fptr, dirEntry.strtblk, &scan))
			{
				fprintf(stderr, 
					"rts_rshd:ERROR...Unable to write scan subheader for file %s\n", 
						file);
				mat_close(fptr);
d894 7
a900 8
		    case IMAGE_DATA:
			convertImageHeaderFromVax(buffer, &image);
			if (mat_write_image_subheader(fptr, dirEntry.strtblk, &image))
			{
				fprintf(stderr, 
					"rts_rshd:ERROR... Unable to write image subheader for file %s\n", 
						file);
				mat_close(fptr);
d904 7
a910 8
		    case ATTN_DATA:
			convertAttnHeaderFromVax(buffer, &attn);
			if (mat_write_attn_subheader(fptr, dirEntry.strtblk, &attn))
			{
				fprintf(stderr, 
					"rts_rshd:ERROR... Unable to write attn subheader for file %s\n", 
						file);
				mat_close(fptr);
d914 7
a920 8
		    case NORM_DATA:
			convertNormHeaderFromVax(buffer, &norm);
			if (mat_write_norm_subheader(fptr, dirEntry.strtblk, &norm))
			{
				fprintf(stderr, 
					"rts_rshd:ERROR... Unable to write norm subheader for file %s\n", 
						file);
				mat_close(fptr);
d925 1
a925 1
		mat_close(fptr);
d927 1
a927 2
	} else
	{
d930 2
a931 2
		bcopy(buffer, wrArgs.whdat, 512);
		if (!(doAcsAcqCommand(WSHD, xdr_WSHD_args, &wrArgs, xdr_int, &resp)))
d937 6
a942 6
int 
rts_rdat(file, matnum, buffer, bufferSize)
char *file;
int matnum,
   *bufferSize;
caddr_t buffer;
d944 1
a944 10
	RDAT_args rdArgs;
	RDAT_resp rdResp;
	int mat_read_main_header(),
	    mat_lookup(),
	    mat_read_mat_data();
	struct stat fStats;
	FILE *fptr,
	    *mat_open();
	Main_header mH;
	struct MatDir dirEntry;
d946 15
a960 5
	if (!stat(file, &fStats))
	{
		if ((fptr = mat_open(file, "r")) == (FILE *) NULL)
		{
			fprintf(stderr, "rts_rdat:ERROR... Unable to mat_open file %s\n", file);
d963 4
a966 5
		if (mat_read_main_header(fptr, &mH))
		{
			fprintf(stderr, "rts_rdat:ERROR... Unable to read main header of file %s\n", 
				file);
			mat_close(fptr);
d969 4
a972 5
		if (!mat_lookup(fptr, matnum, &dirEntry))
		{
			fprintf(stderr, "rts_rdat:ERROR... Unable to lookup matrix 0x%08x of file %s\n", 
				matnum, file);
			mat_close(fptr);
d975 5
a979 6
		if (mat_read_mat_data(fptr, dirEntry.strtblk + 1,
				dirEntry.endblk - dirEntry.strtblk, buffer, mH.data_type))
		{
			fprintf(stderr, "rts_rdat:ERROR... Unable to read matrix data for file %s\n",
				file);
			mat_close(fptr);
d983 1
a983 1
		mat_close(fptr);
d985 1
a985 2
	} else
	{
d989 1
a989 1
		if (!(doAcsAcqCommand(RDAT, xdr_RDAT_args, &rdArgs, xdr_RDAT_resp, &rdResp)))
d996 6
a1001 7
int 
rts_wdat(file, matnum, dataType, buffer, bufferSize)
char *file;
int matnum,
    dataType,
    bufferSize;
caddr_t buffer;
d1003 1
a1003 10
	WDAT_args wrArgs;
	int mat_read_main_header(),
	    mat_lookup(),
	    mat_write_mat_data(),
	    resp;
	struct stat fStats;
	FILE *fptr,
	    *mat_open();
	Main_header mH;
	struct MatDir dirEntry;
d1005 13
a1017 5
	if (!stat(file, &fStats))
	{
		if ((fptr = mat_open(file, "r+")) == (FILE *) NULL)
		{
			fprintf(stderr, "rts_wdat:ERROR... Unable to mat_open file %s\n", file);
d1020 3
a1022 4
		if (mat_read_main_header(fptr, &mH))
		{
			fprintf(stderr, "rts_wdat:ERROR...Unable to read main header of file %s\n", file);
			mat_close(fptr);
d1025 4
a1028 5
		if (!mat_lookup(fptr, matnum, &dirEntry))
		{
			fprintf(stderr, "rts_wdat:ERROR...Unable to lookup matrix 0x%08x of file %s\n", 
				matnum, file);
			mat_close(fptr);
d1031 5
a1035 6
		if (write_matrix_data(fptr, dirEntry.strtblk + 1,
				dirEntry.endblk - dirEntry.strtblk, buffer, mH.data_type))
		{
			fprintf(stderr, "rts_wdat:ERROR...Unable to write matrix data for file %s\n", 
				file);
			mat_close(fptr);
d1038 1
a1038 1
		mat_close(fptr);
d1040 1
a1040 2
	} else
	{
d1046 1
a1046 1
		if (!(doAcsAcqCommand(WDAT, xdr_WDAT_args, &wrArgs, xdr_int, &resp)))
d1052 6
a1057 5
int 
rtsRblk(file, blockNumber, buffer)
char *file;
int blockNumber;
caddr_t buffer;
d1059 1
a1059 2
	RBLK_args rbArgs;
	RBLK_resp rbResp;
d1061 2
d1065 1
a1065 1
	if (!(doAcsAcqCommand(RBLK, xdr_RBLK_args, &rbArgs, xdr_RBLK_resp, &rbResp)))
d1067 1
a1067 1
	bcopy(rbResp.rblk, buffer, 512);
d1071 6
a1076 5
int 
rtsWblk(file, blockNumber, buffer)
char *file;
int blockNumber;
caddr_t buffer;
d1078 1
a1078 2
	WBLK_args wbArgs;
	int resp;
d1080 2
d1084 2
a1085 2
	bcopy(buffer, wbArgs.wblk, 512);
	if (!(doAcsAcqCommand(WBLK, xdr_WBLK_args, &wbArgs, xdr_int, &resp)))
d1090 4
a1093 4
void 
fillInMainHeader(mh, name)
Main_header *mh;
char *name;
d1125 1
a1125 2
int 
singlesOn()
d1145 1
a1145 2
int 
singlesOff()
d1147 1
a1147 1
	return (rts_sing(0, 0, 0, 2000, 0));
d1153 2
a1154 3
int 
talkToRtsInfo(infoCommand)
int infoCommand;
a1155 10
	/* Tom Yang on 1/28/93.
	struct sockaddr_in addr;
	struct hostent *hp;
	int sock,
	    result,
	    i = 0,
	    pid,
	    retVal;
	struct timeval timeout;
	CLIENT *client;
d1157 15
a1171 32
	bzero((char *) &addr, sizeof(addr));
	if ((hp = gethostbyname("localhost")) == NULL)
	{
		fprintf(stderr, "gethostbyname failed\n");
		return (-1);
	}
	for (pid = 0, i = 0; i < 2; i++)
	{
		bcopy(hp->h_addr, (caddr_t) & addr.sin_addr, hp->h_length);
		addr.sin_family = AF_INET;
		addr.sin_port = 0;
		sock = RPC_ANYSOCK;
		if ((client = clnttcp_create(&addr, RTS_INFO_SERVER, RTS_INFO_VERSION, 
				&sock, 0, 0)) == NULL)
		{
			if (!(pid = vfork()))
				execlp("rtsinfo", "rtsinfo", 0);
			sleep(5);
		}
	}
	timeout.tv_sec = 10;
	timeout.tv_usec = 0;
	if ((int) clnt_call(client, infoCommand, xdr_void, NULL, xdr_void, (char *) NULL, timeout)
		!= (int) RPC_SUCCESS)
	{
		fprintf(stderr, "startRtsInfo: Cannot communicate with rtsinfo\n");
		clnt_perror(client, "clnt_call");
		return (-1);
	}
	clnt_destroy(client);
	return (pid);
	*/
d1175 3
a1177 3
char *
rts_error(parm_1)
int parm_1;
d1179 1
a1179 1
	char problem[64];
d1181 2
a1182 3
	switch (parm_1)
	{
	    case ErrorIssuingRpcCall:
d1184 1
a1184 1
	    case -1:
d1186 1
a1186 1
	    case 0:
d1188 1
a1188 1
	    case 1:
d1190 1
a1190 1
	    case 2:
d1192 1
a1192 1
	    case 8:
d1194 1
a1194 1
	    case 10:
d1196 1
a1196 1
	    case 11:
d1198 1
a1198 1
	    case 12:
d1200 1
a1200 1
	    case 13:
d1202 1
a1202 1
	    case 14:
d1204 1
a1204 1
	    case 15:
d1206 1
a1206 1
	    case 16:
d1208 1
a1208 1
	    case 17:
d1210 1
a1210 1
	    case 18:
d1212 1
a1212 1
	    case 19:
d1214 1
a1214 1
	    case 50:
d1216 1
a1216 1
	    case 51:
d1218 1
a1218 1
	    case 100:
d1220 1
a1220 1
	    case 102:
d1222 1
a1222 1
	    case 104:
d1224 1
a1224 1
	    case 106:
d1226 1
a1226 1
	    case 110:
d1228 1
a1228 1
	    case 112:
d1230 1
a1230 1
	    case 114:
d1232 1
a1232 1
	    case 116:
d1234 1
a1234 1
	    case 118:
d1236 1
a1236 1
	    case 120:
d1238 1
a1238 1
	    case 122:
d1240 1
a1240 1
	    case 124:
d1242 1
a1242 1
	    case 126:
d1244 1
a1244 1
	    case 200:
d1246 1
a1246 1
	    case 210:
d1248 1
a1248 1
	    case 212:
d1250 1
a1250 1
	    case 300:
d1252 1
a1252 1
	    case 333:
d1254 1
a1254 1
	    case 334:
d1256 1
a1256 1
	    case 335:
d1258 1
a1258 1
	    case 400:
d1260 1
a1260 1
	    case 402:
d1262 1
a1262 1
	    case 500:
d1264 1
a1264 1
	    case 502:
d1266 1
a1266 1
	    case 504:
d1268 2
a1269 2
	    default:
		sprintf(problem, "RTS Error...not sure, passed a %d", parm_1);
@


1.3
log
@Change from id to header.
@
text
@d1 1
a1 1
/*$Id: rts.c,v 1.2 1993/09/13 18:58:21 ty7777 Exp ty7777 $*/
d3 3
d38 1
a38 1
static char rcsid [] = "$Header$";
d52 1
a52 1
#include <petutil/matrix.h>
@


1.2
log
@Introduce acsid and change matrix.h to petutil/matrix.h.
@
text
@d1 1
a1 1
/*$Id: rts.c,v 1.1 1993/03/04 19:57:39 ty7777 Exp ty7777 $*/
d3 3
d35 1
a35 1
static char rcsid [] = "$Id$";
@


1.1
log
@Initial revision
@
text
@d1 5
a5 2
/*$Id$*/
/*$Log$*/
d32 1
d46 1
a46 1
#include "matrix.h"
@
