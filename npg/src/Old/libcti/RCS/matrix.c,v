head	2.1;
access;
symbols;
locks; strict;
comment	@ * @;


2.1
date	2003.03.10.22.35.51;	author tom;	state Exp;
branches;
next	2.0;

2.0
date	2002.12.26.20.35.13;	author tom;	state Exp;
branches;
next	1.8;

1.8
date	99.12.13.22.02.19;	author tom;	state Exp;
branches;
next	1.7;

1.7
date	96.09.25.16.28.32;	author tom;	state Exp;
branches;
next	1.6;

1.6
date	95.11.30.19.42.02;	author tom;	state Exp;
branches;
next	1.5;

1.5
date	95.10.30.16.54.44;	author tom;	state Exp;
branches;
next	1.4;

1.4
date	94.03.03.17.29.43;	author ty7777;	state Exp;
branches;
next	1.3;

1.3
date	93.09.13.18.55.37;	author ty7777;	state Exp;
branches;
next	1.2;

1.2
date	93.06.17.17.29.55;	author ty7777;	state Exp;
branches;
next	1.1;

1.1
date	93.03.04.19.46.55;	author ty7777;	state Exp;
branches;
next	;


desc
@Working version, modified by Tom Yang to get rid of sunview related library functions.
@


2.1
log
@*** empty log message ***
@
text
@/*$Id: matrix.c,v 2.0 2002/12/26 20:35:13 tom Exp tom $
 *$Log: matrix.c,v $
 * Revision 2.0  2002/12/26  20:35:13  tom
 * remove unused functions
 * lint and splint cleaning
 *
 *Revision 1.8  1999/12/13 22:02:19  tom
 *partially cleaned up with lint
 *
 * Revision 1.7  1996/09/25  16:28:32  tom
 * build in Solaris 2
 *
 * Revision 1.6  1995/11/30  19:42:02  tom
 * TOV mod
 *
 * Revision 1.5  1995/10/30  16:54:44  tom
 * changed petutil/matrix.h to matrix.h
 *
 * Revision 1.4  1994/03/03  17:29:43  ty7777
 * Change from id to header.
 *
 * Revision 1.3  1993/09/13  18:55:37  ty7777
 * Introduce acsid and change matrix.h to petutil/matrix.h.
 *
 * Revision 1.2  1993/06/17  17:29:55  ty7777
 * Checking in.
 *
 * Revision 1.1  1993/03/04  19:46:55  ty7777
 * Initial revision
 **/

/* @@(#)matrix.c	2.4 4/24/92  */

#include <stdio.h>
#include <stdlib.h>
#include <endian.h>
#include <string.h>
#include <strings.h>
#include <matrix.h>

#ifndef lint
static char     rcsid[] = "$Header: /home/npggw/tom/src/libcti/RCS/matrix.c,v 2.0 2002/12/26 20:35:13 tom Exp tom $";
#endif

void            swaw (from, to, length)
	short int      *from, *to;
	int             length;
{
	short int       temp;
	int             i;

	for (i = 0; i < length; i += 2) {
		temp = from[i + 1];
		to[i + 1] = from[i];
		to[i] = temp;
	}
	return;
}

void            swap_byte (from, to, length)
	char           *from, *to;
	int             length;
{
	char            temp;
	int             i;

	for (i = 0; i < length; i += 2) {
		temp = from[i + 1];
		to[i + 1] = from[i];
		to[i] = temp;
	}
	return;
}

int             get_vax_long (bufr, off)
	unsigned short *bufr;
	int             off;
{
	return ((bufr[off + 1] << 16) + bufr[off]);
}

float           get_vax_float (bufr, off)
	unsigned short  bufr[];
	int             off;
{
	unsigned short  t1, t2;
	union {
		unsigned long   t3;
		float           t4;
	}               test;

	if (bufr[off] == 0 && bufr[off + 1] == 0)
		return (0.0);
	t1 = bufr[off] & 0x80ff;
	t2 = (((bufr[off]) & 0x7f00) + 0xff00) & 0x7f00;
	test.t3 = (t1 + t2) << 16;
	test.t3 = test.t3 + bufr[off + 1];
	return (test.t4);
}

void            sunftovaxf (orig, number)
	float           orig;
	unsigned short  number[2];
{
	union {
		unsigned short  t[2];
		float           t4;
	}               test;
	unsigned short int exp;

	number[0] = 0;
	number[1] = 0;
	test.t4 = orig;
	if (test.t4 == 0.0)
		return;
	number[1] = test.t[1];
	exp = ((test.t[0] & 0x7f00) + 0x0100) & 0x7f00;
	test.t[0] = (test.t[0] & 0x80ff) + exp;
	number[0] = test.t[0];
	return;
}

void            sunltovaxl (in, out)
	int             in;
	unsigned short int out[2];
{
	out[0] = (in & 0x0000FFFF);
	out[1] = (in & 0xFFFF0000) >> 16;
	return;
}

int             str_find (s1, s2)
	char           *s1, *s2;
{
	int             i, j, k;

	for (i = 0; s1[i] != 0; i++) {
		for (j = i, k = 0; s2[k] != '\0' && s1[j] == s2[k]; j++, k++)
			if (s2[k] == '\0')
				return (i);
	} return (-1);
}

int             str_replace (s1, s2, s3, s4)
	char           *s1, *s2, *s3, *s4;
{
	int             nf = 0, n;
	int             busy = 1;

	*s1 = '\0';
	while (busy == 1) {
		if ((n = str_find (s2, s3)) == -1) {
			strcat (s1, s2);
			return (nf);
		} else {
			strncat (s1, s2, n);
			strcat (s1, s4);
			s2 += n + strlen (s3);
			nf++;
		}
	}
	return (0);
}

FILE           *mat_create (fname, mhead)
	char           *fname;
	Main_header    *mhead;
{
	FILE           *fptr;
	int            *bufr;
	int             stat;

	fptr = mat_open (fname, "w+");
	if (fptr == NULL)
		return (fptr);
	stat = mat_write_main_header (fptr, mhead);
	if (stat != 0) {
		(void) fclose (fptr);
		return (fptr);
	}
	bufr = (int *) calloc (MatBLKSIZE, sizeof (int));
	bufr[0] = 31;
	bufr[1] = 2;
	swaw (bufr, bufr, 256);
	swap_byte (bufr, bufr, 512);
	stat = mat_wblk (fptr, MatFirstDirBlk, bufr, 1);
	if (stat != 0)
		(void) fclose (fptr);
	free (bufr);
	return (fptr);
}

FILE           *mat_open (fname, fmode)
	char           *fname, *fmode;
{
	FILE           *fptr;

	fptr = fopen (fname, fmode);
	return (fptr);
}

int             mat_close (fptr)
	FILE           *fptr;
{
	return (fclose (fptr));
}

int             mat_numcod (frame, plane, gate, data, bed)
	int             frame, plane, gate, data, bed;
{
/*	Version supporting 512 planes, 1024 planes, 8 data types	*/
	int             matnum8data16bed64gate1024plane512frame;
	int             loPlane, hiPlane, loData, hiData;

	hiPlane = (plane & 0x300);
	loPlane = (plane & 0xFF);
	loData = (data & 0x3);
	hiData = (data & 0x4);
	matnum8data16bed64gate1024plane512frame = ((frame & 0x1FF) | ((bed & 0xF) << 12) |
						   ((loPlane << 16) | (hiPlane << 1)) | ((gate & 0x3F) << 24) | ((loData << 30) | (hiData << 9)));
	return (matnum8data16bed64gate1024plane512frame);
}

int             mat_lookup (fptr, matnum, entry)
	FILE           *fptr;
	int             matnum;
	struct MatDir  *entry;
{
	int             blk, i, stat;
	int             nxtblk, matnbr, strtblk, endblk, matstat;
	int             dirbufr[MatBLKSIZE / 4];
	char            bytebufr[MatBLKSIZE];
	int             busy = 1;

	blk = MatFirstDirBlk;
	while (busy == 1) {
		stat = mat_rblk (fptr, blk, bytebufr, 1);
		if (stat != 0)
			return (stat);
		swap_byte (bytebufr, dirbufr, MatBLKSIZE);
		swaw (dirbufr, dirbufr, MatBLKSIZE / 2);
		nxtblk = dirbufr[1];
		for (i = 4; i < MatBLKSIZE / 4; i += 4) {
			matnbr = dirbufr[i];
			strtblk = dirbufr[i + 1];
			endblk = dirbufr[i + 2];
			matstat = dirbufr[i + 3];
			if (matnum == matnbr) {
				entry->matnum = matnbr;
				entry->strtblk = strtblk;
				entry->endblk = endblk;
				entry->matstat = matstat;
				return (-1);
			}
		}
		blk = nxtblk;
		if (blk == MatFirstDirBlk)
			break;
	}
	return (0);
}

int             mat_rblk (fptr, blkno, bufr, nblks)
	FILE           *fptr;
	int             blkno, nblks;
	char           *bufr;
{
	int             stat;

	stat = fseek (fptr, (blkno - 1) * MatBLKSIZE, 0);
	if (stat != 0) {
		fprintf (stderr, "ERROR [mat_rblk]: fseek\n");
		return (stat);
	}
	stat = fread (bufr, 1, nblks * MatBLKSIZE, fptr);
	if (stat != nblks * MatBLKSIZE) {
		fprintf (stderr, "ERROR [mat_rblk]: fread\n");
		return (stat);
	}
	return (0);
}

int             mat_wblk (fptr, blkno, bufr, nblks)
	FILE           *fptr;
	int             blkno, nblks;
	char           *bufr;
{
	int             stat;

	stat = fseek (fptr, (blkno - 1) * MatBLKSIZE, 0);
	if (stat != 0) {
		fprintf (stderr, "ERROR [mat_wblk]: fseek\n");
		return (stat);
	}
	stat = fwrite (bufr, 1, nblks * MatBLKSIZE, fptr);
	if (stat != nblks * MatBLKSIZE) {
		fprintf (stderr, "ERROR [mat_wblk]: fwrite\n");
		return (-1);
	}
	return (0);
}

int             mat_enter (fptr, matnum, nblks)
	FILE           *fptr;
	int             matnum, nblks;
{
	int             stat, dirblk, dirbufr[128], oldsize;
	int             nxtblk = 0;
	int             i = 0;
	int             busy = 1;

	dirblk = MatFirstDirBlk;
	stat = mat_rblk (fptr, dirblk, dirbufr, 1);
	if (stat != 0)
		return (stat);
	swap_byte (dirbufr, dirbufr, 512);
	swaw (dirbufr, dirbufr, 256);
	while (busy == 1) {
		nxtblk = dirblk + 1;
		for (i = 4; i < 128; i += 4) {
			if (dirbufr[i] == 0) {
				busy = 0;
				break;
			} else if (dirbufr[i] == matnum) {
				oldsize = dirbufr[i + 2] - dirbufr[i + 1] + 1;
				if (oldsize < nblks) {
					dirbufr[i] = 0xFFFFFFFF;
					swaw (dirbufr, dirbufr, 256);
					swap_byte (dirbufr, dirbufr, 512);
					stat = mat_wblk (fptr, dirblk, dirbufr, 1);
					if (stat != 0)
						return (stat);
					swap_byte (dirbufr, dirbufr, 512);
					swaw (dirbufr, dirbufr, 256);
					nxtblk = dirbufr[i + 2] + 1;
				} else {
					nxtblk = dirbufr[i + 1];
					dirbufr[0]++;
					dirbufr[3]--;
					busy = 0;
					break;
				}
			} else
				nxtblk = dirbufr[i + 2] + 1;
		}
		if (busy == 0)
			break;
		if (dirbufr[1] != MatFirstDirBlk) {
			dirblk = dirbufr[1];
			stat = mat_rblk (fptr, dirblk, dirbufr, 1);
			if (stat != 0)
				return (stat);
			swap_byte (dirbufr, dirbufr, 512);
			swaw (dirbufr, dirbufr, 256);
		} else {
			dirbufr[1] = nxtblk;
			swaw (dirbufr, dirbufr, 256);
			swap_byte (dirbufr, dirbufr, 512);
			stat = mat_wblk (fptr, dirblk, dirbufr, 1);
			if (stat != 0)
				return (stat);
			dirbufr[0] = 31;
			dirbufr[1] = MatFirstDirBlk;
			dirbufr[2] = dirblk;
			dirbufr[3] = 0;
			dirblk = nxtblk;
			for (i = 4; i < 128; i++)
				dirbufr[i] = 0;
		}
	}
	dirbufr[i] = matnum;
	dirbufr[i + 1] = nxtblk;
	dirbufr[i + 2] = nxtblk + nblks;
	dirbufr[i + 3] = 1;
	dirbufr[0]--;
	dirbufr[3]++;
	swaw (dirbufr, dirbufr, 256);
	swap_byte (dirbufr, dirbufr, 512);
	stat = mat_wblk (fptr, dirblk, dirbufr, 1);
	if (stat != 0)
		return (stat);
	return (nxtblk);
}

int             mat_read_main_header (fptr, h)
	FILE           *fptr;
	Main_header    *h;
{
	short int       b[256];
	char           *bb;
	int             stat, i;

	stat = mat_rblk (fptr, 1, b, 1);
	if (stat != 0) {
		fprintf (stderr, "ERROR [mat_read_main_header]\n");
		return (stat);
	}
	bb = (char *) b;
	strncpy (h->original_file_name, bb + 28, 20);
	strncpy (h->node_id, bb + 56, 10);
	strncpy (h->isotope_code, bb + 78, 8);
	strncpy (h->radiopharmaceutical, bb + 90, 32);
	strncpy (h->study_name, bb + 162, 12);
	strncpy (h->patient_id, bb + 174, 16);
	strncpy (h->patient_name, bb + 190, 32);
	h->patient_sex = bb[222];
	strncpy (h->patient_age, bb + 223, 10);
	strncpy (h->patient_height, bb + 233, 10);
	strncpy (h->patient_weight, bb + 243, 10);
	h->patient_dexterity = bb[253];
	strncpy (h->physician_name, bb + 254, 32);
	strncpy (h->operator_name, bb + 286, 32);
	strncpy (h->study_description, bb + 318, 32);
	strncpy (h->facility_name, bb + 356, 20);
	strncpy (h->user_process_code, bb + 462, 10);

	swap_byte (b, b, MatBLKSIZE);
	h->sw_version = b[24];
	h->data_type = b[25];
	h->system_type = b[26];
	h->file_type = b[27];
	h->scan_start_day = b[33];
	h->scan_start_month = b[34];
	h->scan_start_year = b[35];
	h->scan_start_hour = b[36];
	h->scan_start_minute = b[37];
	h->scan_start_second = b[38];
	h->isotope_halflife = get_vax_float (b, 43);
	h->gantry_tilt = get_vax_float (b, 61);
	h->gantry_rotation = get_vax_float (b, 63);
	h->bed_elevation = get_vax_float (b, 65);
	h->rot_source_speed = b[67];
	h->wobble_speed = b[68];
	h->transm_source_type = b[69];
	h->axial_fov = get_vax_float (b, 70);
	h->transaxial_fov = get_vax_float (b, 72);
	h->transaxial_samp_mode = b[74];
	h->coin_samp_mode = b[75];
	h->axial_samp_mode = b[76];
	h->calibration_factor = get_vax_float (b, 77);
	h->calibration_units = b[79];
	h->compression_code = b[80];
	h->acquisition_type = b[175];
	h->bed_type = b[176];
	h->septa_type = b[177];
	h->num_planes = b[188];
	h->num_frames = b[189];
	h->num_gates = b[190];
	h->num_bed_pos = b[191];
	h->init_bed_position = get_vax_float (b, 192);
	for (i = 0; i < 15; i++)
		h->bed_offset[i] = get_vax_float (b, 194 + 2 * i);
	h->plane_separation = get_vax_float (b, 224);
	h->lwr_sctr_thres = b[226];
	h->lwr_true_thres = b[227];
	h->upr_true_thres = b[228];
	h->collimator = get_vax_float (b, 229);
	h->acquisition_mode = b[236];
	return (0);
}

int             mat_read_image_subheader (fptr, blknum, h)
	FILE           *fptr;
	int             blknum;
	Image_subheader *h;
{
	short int       b[256];
	int             i, stat;
	char           *bb;

	stat = mat_rblk (fptr, blknum, b, 1);
	if (stat != 0) {
		fprintf (stderr, "ERROR [mat_read_image_subheader]\n");
		return (stat);
	}
	bb = (char *) b;

	strncpy (h->annotation, bb + 420, 40);
	swap_byte (b, b, MatBLKSIZE);
	h->data_type = b[63];
	h->num_dimensions = b[64];
	h->dimension_1 = b[66];
	h->dimension_2 = b[67];
	h->x_origin = get_vax_float (b, 80);
	h->y_origin = get_vax_float (b, 82);
	h->recon_scale = get_vax_float (b, 84);
	h->quant_scale = get_vax_float (b, 86);
	h->image_min = b[88];
	h->image_max = b[89];
	h->pixel_size = get_vax_float (b, 92);
	h->slice_width = get_vax_float (b, 94);
	h->frame_duration = get_vax_long (b, 96);
	h->frame_start_time = get_vax_long (b, 98);
	h->slice_location = b[100];
	h->recon_start_hour = b[101];
	h->recon_start_minute = b[102];
	h->recon_start_sec = b[103];
	h->recon_duration = get_vax_long (b, 104);
	h->filter_code = b[118];
	h->scan_matrix_num = get_vax_long (b, 119);
	h->norm_matrix_num = get_vax_long (b, 121);
	h->atten_cor_matrix_num = get_vax_long (b, 123);
	h->image_rotation = get_vax_float (b, 148);
	h->plane_eff_corr_fctr = get_vax_float (b, 150);
	h->decay_corr_fctr = get_vax_float (b, 152);
	h->loss_corr_fctr = get_vax_float (b, 154);
	h->intrinsic_tilt = get_vax_float (b, 156);
	h->processing_code = b[188];
	h->quant_units = b[190];
	h->recon_start_day = b[191];
	h->recon_start_month = b[192];
	h->recon_start_year = b[193];
	h->ecat_calibration_fctr = get_vax_float (b, 194);
	h->well_counter_cal_fctr = get_vax_float (b, 196);
	for (i = 0; i < 6; i++)
		h->filter_params[i] = get_vax_float (b, 198 + 2 * i);
	return (0);
}

int             mat_read_scan_subheader (fptr, blknum, h)
	FILE           *fptr;
	int             blknum;
	Scan_subheader *h;
{
	short int       b[256];
	int             i, stat;

	stat = mat_rblk (fptr, blknum, b, 1);
	if (stat != 0) {
		fprintf (stderr, "ERROR [mat_read_scan_subheader]\n");
		return (stat);
	}
	swap_byte (b, b, MatBLKSIZE);
	h->data_type = b[63];
	h->dimension_1 = b[66];
	h->dimension_2 = b[67];
	h->smoothing = b[68];
	h->processing_code = b[69];
	h->sample_distance = get_vax_float (b, 73);
	h->isotope_halflife = get_vax_float (b, 83);
	h->frame_duration_sec = b[85];
	h->gate_duration = get_vax_long (b, 86);
	h->r_wave_offset = get_vax_long (b, 88);
	h->scale_factor = get_vax_float (b, 91);
	h->scan_min = b[96];
	h->scan_max = b[97];
	h->prompts = get_vax_long (b, 98);
	h->delayed = get_vax_long (b, 100);
	h->multiples = get_vax_long (b, 102);
	h->net_trues = get_vax_long (b, 104);
	for (i = 0; i < 16; i++) {
		h->cor_singles[i] = get_vax_float (b, 158 + 2 * i);
		h->uncor_singles[i] = get_vax_float (b, 190 + 2 * i);
	}
	h->tot_avg_cor = get_vax_float (b, 222);
	h->tot_avg_uncor = get_vax_float (b, 224);
	h->total_coin_rate = get_vax_long (b, 226);
	h->frame_start_time = get_vax_long (b, 228);
	h->frame_duration = get_vax_long (b, 230);
	h->loss_correction_fctr = get_vax_float (b, 232);
	for (i = 0; i < 8; i++)
		h->phy_planes[i] = get_vax_long (b, 234 + (2 * i));
	return (0);
}

int             mat_read_attn_subheader (fptr, blknum, header)
	FILE           *fptr;
	int             blknum;
	Attn_subheader *header;
{
	short int       bufr[256];
	int             stat;

	stat = mat_rblk (fptr, blknum, bufr, 1);
	if (stat != 0) {
		fprintf (stderr, "ERROR [mat_read_attn_subheader]\n");
		return (stat);
	}
	swap_byte (bufr, bufr, MatBLKSIZE);

	header->data_type = bufr[63];
	header->attenuation_type = bufr[64];
	header->dimension_1 = bufr[66];
	header->dimension_2 = bufr[67];
	header->scale_factor = get_vax_float (bufr, 91);
	header->x_origin = get_vax_float (bufr, 93);
	header->y_origin = get_vax_float (bufr, 95);
	header->x_radius = get_vax_float (bufr, 97);
	header->y_radius = get_vax_float (bufr, 99);
	header->tilt_angle = get_vax_float (bufr, 101);
	header->attenuation_coeff = get_vax_float (bufr, 103);
	header->sample_distance = get_vax_float (bufr, 105);
	return (0);
}

int             mat_read_norm_subheader (fptr, blknum, header)
	FILE           *fptr;
	int             blknum;
	Norm_subheader *header;
{
	short int       bufr[256];
	int             stat;

	stat = mat_rblk (fptr, blknum, bufr, 1);
	if (stat != 0) {
		fprintf (stderr, "ERROR [mat_read_norm_subheader]\n");
		return (stat);
	}
	swap_byte (bufr, bufr, MatBLKSIZE);

	header->data_type = bufr[63];
	header->dimension_1 = bufr[66];
	header->dimension_2 = bufr[67];
	header->scale_factor = get_vax_float (bufr, 91);
	header->norm_hour = bufr[93];
	header->norm_minute = bufr[94];
	header->norm_second = bufr[95];
	header->norm_day = bufr[96];
	header->norm_month = bufr[97];
	header->norm_year = bufr[98];
	header->fov_source_width = get_vax_float (bufr, 99);
	header->ecat_calib_factor = get_vax_float (bufr, 101);
	return (0);
}

int             mat_write_main_header (fptr, header)
	FILE           *fptr;
	Main_header    *header;
{
	char           *bbufr;
	short int       bufr[256];
	int             stat, i;

	for (i = 0; i < 256; i++)
		bufr[i] = 0;
	bbufr = (char *) bufr;

	bufr[24] = header->sw_version;
	bufr[25] = header->data_type;
	bufr[26] = header->system_type;
	bufr[27] = header->file_type;
	bufr[33] = header->scan_start_day;
	bufr[34] = header->scan_start_month;
	bufr[35] = header->scan_start_year;
	bufr[36] = header->scan_start_hour;
	bufr[37] = header->scan_start_minute;
	bufr[38] = header->scan_start_second;
	sunftovaxf (header->isotope_halflife, &bufr[43]);
	sunftovaxf (header->gantry_tilt, &bufr[61]);
	sunftovaxf (header->gantry_rotation, &bufr[63]);
	sunftovaxf (header->bed_elevation, &bufr[65]);
	bufr[67] = header->rot_source_speed;
	bufr[68] = header->wobble_speed;
	bufr[69] = header->transm_source_type;
	sunftovaxf (header->axial_fov, &bufr[70]);
	sunftovaxf (header->transaxial_fov, &bufr[72]);
	bufr[74] = header->transaxial_samp_mode;
	bufr[75] = header->coin_samp_mode;
	bufr[76] = header->axial_samp_mode;
	sunftovaxf (header->calibration_factor, &bufr[77]);
	bufr[79] = header->calibration_units;
	bufr[80] = header->compression_code;
	bufr[175] = header->acquisition_type;
	bufr[176] = header->bed_type;
	bufr[177] = header->septa_type;
	bufr[188] = header->num_planes;
	bufr[189] = header->num_frames;
	bufr[190] = header->num_gates;
	bufr[191] = header->num_bed_pos;
	sunftovaxf (header->init_bed_position, &bufr[192]);
	for (i = 0; i < 15; i++) {
		sunftovaxf (header->bed_offset[i], &bufr[194 + 2 * i]);
	}
	sunftovaxf (header->plane_separation, &bufr[224]);
	bufr[226] = header->lwr_sctr_thres;
	bufr[227] = header->lwr_true_thres;
	bufr[228] = header->upr_true_thres;
	sunftovaxf (header->collimator, &bufr[229]);
	bufr[236] = header->acquisition_mode;

	swap_byte (bufr, bufr, MatBLKSIZE);

	bcopy (header->original_file_name, bbufr + 28, 20);
	bcopy (header->node_id, bbufr + 56, 10);
	bcopy (header->isotope_code, bbufr + 78, 8);
	bcopy (header->radiopharmaceutical, bbufr + 90, 32);
	bcopy (header->study_name, bbufr + 162, 12);
	bcopy (header->patient_id, bbufr + 174, 16);
	bcopy (header->patient_name, bbufr + 190, 32);
	bbufr[222] = header->patient_sex;
	bcopy (header->patient_age, bbufr + 223, 10);
	bcopy (header->patient_height, bbufr + 233, 10);
	bcopy (header->patient_weight, bbufr + 243, 10);
	bbufr[253] = header->patient_dexterity;
	bcopy (header->physician_name, bbufr + 254, 32);
	bcopy (header->operator_name, bbufr + 286, 32);
	bcopy (header->study_description, bbufr + 318, 32);
	bcopy (header->facility_name, bbufr + 356, 20);
	bcopy (header->user_process_code, bbufr + 462, 10);

	stat = mat_wblk (fptr, 1, bufr, 1);
	if (stat != 0) {
		fprintf (stderr, "ERROR [mat_write_main_header]\n");
		return (stat);
	}
	return (0);
}

int             mat_write_idata (fptr, blk, data, size)
	FILE           *fptr;
	int             blk, size;
	char           *data;
{
	char            bufr[512];
	int             i, nbytes, nblks;
	int             stat;

	nblks = (size + 511) / 512;
	for (i = 0; i < nblks; i++) {
		nbytes = (size < 512) ? size : 512;
		bcopy (data, bufr, nbytes);
		swap_byte (bufr, bufr, 512);
		stat = mat_wblk (fptr, blk + i, bufr, 1);
		if (stat != 0)
			return (stat);
		data += nbytes;
		size -= nbytes;
	}
	return (0);
}

int             mat_write_fdata (fptr, blk, data, size)
	FILE           *fptr;
	int             blk, size;
	float          *data;
{
	float           bufr[128];
	int             i, j, nvals, nblks;
	int             stat;

	nblks = (size + 511) / 512;
	for (i = 0; i < nblks; i++) {
		nvals = (size < 512) ? size / 4 : 512 / 4;
		for (j = 0; j < nvals; j++)
			sunftovaxf (*data++, &bufr[j]);
		swap_byte (bufr, bufr, 512);
		stat = mat_wblk (fptr, blk + i, bufr, 1);
		if (stat != 0)
			return (stat);
		size -= 4 * nvals;
	}
	return (0);
}

int             mat_write_image_subheader (fptr, blknum, header)
	FILE           *fptr;
	int             blknum;
	Image_subheader *header;
{
	char           *bbufr;
	short int       bufr[256];
	int             i, stat;

	for (i = 0; i < 256; i++)
		bufr[i] = 0;
	bbufr = (char *) bufr;

	bufr[63] = header->data_type;
	bufr[64] = header->num_dimensions;
	bufr[66] = header->dimension_1;
	bufr[67] = header->dimension_2;
	sunftovaxf (header->x_origin, &bufr[80]);
	sunftovaxf (header->y_origin, &bufr[82]);
	sunftovaxf (header->recon_scale, &bufr[84]);
	sunftovaxf (header->quant_scale, &bufr[86]);
	bufr[88] = header->image_min;
	bufr[89] = header->image_max;
	sunftovaxf (header->pixel_size, &bufr[92]);
	sunftovaxf (header->slice_width, &bufr[94]);
	sunltovaxl (header->frame_duration, &bufr[96]);
	sunltovaxl (header->frame_start_time, &bufr[98]);
	bufr[100] = header->slice_location;
	bufr[101] = header->recon_start_hour;
	bufr[102] = header->recon_start_minute;
	bufr[103] = header->recon_start_sec;
	sunltovaxl (header->recon_duration, &bufr[104]);
	bufr[118] = header->filter_code;
	sunltovaxl (header->scan_matrix_num, &bufr[119]);
	sunltovaxl (header->norm_matrix_num, &bufr[121]);
	sunltovaxl (header->atten_cor_matrix_num, &bufr[123]);
	sunftovaxf (header->image_rotation, &bufr[148]);
	sunftovaxf (header->plane_eff_corr_fctr, &bufr[150]);
	sunftovaxf (header->decay_corr_fctr, &bufr[152]);
	sunftovaxf (header->loss_corr_fctr, &bufr[154]);
	sunftovaxf (header->intrinsic_tilt, &bufr[156]);
	bufr[188] = header->processing_code;
	bufr[190] = header->quant_units;
	bufr[191] = header->recon_start_day;
	bufr[192] = header->recon_start_month;
	bufr[193] = header->recon_start_year;
	sunftovaxf (header->ecat_calibration_fctr, &bufr[194]);
	sunftovaxf (header->well_counter_cal_fctr, &bufr[196]);

	for (i = 0; i < 6; i++)
		sunftovaxf (header->filter_params[i], &bufr[198 + 2 * i]);

	swap_byte (bufr, bufr, MatBLKSIZE);
	strcpy (bbufr + 420, header->annotation);

	stat = mat_wblk (fptr, blknum, bbufr, 1);
	if (stat != 0) {
		fprintf (stderr, "ERROR [mat_write_image_subheader]\n");
		return (stat);
	}
	return (0);
}

int             mat_write_scan_subheader (fptr, blknum, header)
	FILE           *fptr;
	int             blknum;
	Scan_subheader *header;
{
	short int       bufr[256];
	int             i, stat;

	for (i = 0; i < 256; i++)
		bufr[i] = 0;
	bufr[0] = 256;
	bufr[1] = 1;
	bufr[2] = 22;
	bufr[3] = -1;
	bufr[4] = 25;
	bufr[5] = 62;
	bufr[6] = 79;
	bufr[7] = 106;
	bufr[24] = 37;
	bufr[25] = -1;
	bufr[61] = 17;
	bufr[62] = -1;
	bufr[78] = 27;
	bufr[79] = -1;
	bufr[105] = 52;
	bufr[106] = -1;
	bufr[63] = header->data_type;
	bufr[66] = header->dimension_1;		 /* x dimension */
	bufr[67] = header->dimension_2;		 /* y_dimension */
	bufr[68] = header->smoothing;
	bufr[69] = header->processing_code;
	sunftovaxf (header->sample_distance, &bufr[73]);
	sunftovaxf (header->isotope_halflife, &bufr[83]);
	bufr[85] = header->frame_duration_sec;
	sunltovaxl (header->gate_duration, &bufr[86]);
	sunltovaxl (header->r_wave_offset, &bufr[88]);
	sunftovaxf (header->scale_factor, &bufr[91]);
	bufr[96] = header->scan_min;
	bufr[97] = header->scan_max;
	sunltovaxl (header->prompts, &bufr[98]);
	sunltovaxl (header->delayed, &bufr[100]);
	sunltovaxl (header->multiples, &bufr[102]);
	sunltovaxl (header->net_trues, &bufr[104]);
	for (i = 0; i < 16; i++) {
		sunftovaxf (header->cor_singles[i], &bufr[158 + 2 * i]);
		sunftovaxf (header->uncor_singles[i], &bufr[190 + 2 * i]);
	}
	sunftovaxf (header->tot_avg_cor, &bufr[222]);
	sunftovaxf (header->tot_avg_uncor, &bufr[224]);
	sunltovaxl (header->total_coin_rate, &bufr[226]);	/* total coin rate */
	sunltovaxl (header->frame_start_time, &bufr[228]);
	sunltovaxl (header->frame_duration, &bufr[230]);
	sunftovaxf (header->loss_correction_fctr, &bufr[232]);
	for (i = 0; i < 8; i++)
		sunltovaxl (header->phy_planes[i], &bufr[234 + 2 * i]);
	swap_byte (bufr, bufr, MatBLKSIZE);
	stat = mat_wblk (fptr, blknum, bufr, 1);
	return (stat);
}

int             mat_write_attn_subheader (fptr, blknum, header)
	FILE           *fptr;

	int             blknum;

	Attn_subheader *header;
{
	short int       bufr[256];

	int             i, stat;

	for (i = 0; i < 256; i++)
		bufr[i] = 0;
	bufr[0] = 256;
	bufr[1] = 1;
	bufr[2] = 22;
	bufr[3] = -1;
	bufr[4] = 25;
	bufr[5] = 62;
	bufr[6] = 79;
	bufr[7] = 106;
	bufr[24] = 37;
	bufr[25] = -1;
	bufr[61] = 17;
	bufr[62] = -1;
	bufr[78] = 27;
	bufr[79] = -1;
	bufr[105] = 52;
	bufr[106] = -1;
	bufr[63] = header->data_type;
	bufr[64] = header->attenuation_type;
	bufr[66] = header->dimension_1;
	bufr[67] = header->dimension_2;
	sunftovaxf (header->scale_factor, &bufr[91]);
	sunftovaxf (header->x_origin, &bufr[93]);
	sunftovaxf (header->y_origin, &bufr[95]);
	sunftovaxf (header->x_radius, &bufr[97]);
	sunftovaxf (header->y_radius, &bufr[99]);
	sunftovaxf (header->tilt_angle, &bufr[101]);
	sunftovaxf (header->attenuation_coeff, &bufr[103]);
	sunftovaxf (header->sample_distance, &bufr[105]);
	swap_byte (bufr, bufr, 512);
	stat = mat_wblk (fptr, blknum, bufr, 1);
	return (stat);
}

int             mat_write_norm_subheader (fptr, blknum, header)
	FILE           *fptr;
	int             blknum;
	Norm_subheader *header;
{
	short int       bufr[256];
	int             i, stat;

	for (i = 0; i < 256; i++)
		bufr[i] = 0;
	bufr[0] = 256;
	bufr[1] = 1;
	bufr[2] = 22;
	bufr[3] = -1;
	bufr[4] = 25;
	bufr[5] = 62;
	bufr[6] = 79;
	bufr[7] = 106;
	bufr[24] = 37;
	bufr[25] = -1;
	bufr[61] = 17;
	bufr[62] = -1;
	bufr[78] = 27;
	bufr[79] = -1;
	bufr[105] = 52;
	bufr[106] = -1;
	bufr[63] = header->data_type;
	bufr[66] = header->dimension_1;
	bufr[67] = header->dimension_2;
	sunftovaxf (header->scale_factor, &bufr[91]);
	bufr[93] = header->norm_hour;
	bufr[94] = header->norm_minute;
	bufr[95] = header->norm_second;
	bufr[96] = header->norm_day;
	bufr[97] = header->norm_month;
	bufr[98] = header->norm_year;
	sunftovaxf (header->fov_source_width, &bufr[99]);
	sunftovaxf (header->ecat_calib_factor, &bufr[101]);
	swap_byte (bufr, bufr, 512);
	stat = mat_wblk (fptr, blknum, bufr, 1);
	return (stat);
}

@


2.0
log
@remove unused functions
lint and splint cleaning
@
text
@d1 1
a1 1
/*$Id: matrix.c,v 1.8 1999/12/13 22:02:19 tom Exp tom $
d3 4
d36 1
d42 1
a42 1
static char     rcsid[] = "$Header: /home/npggw/tom/src/libcti/RCS/matrix.c,v 1.8 1999/12/13 22:02:19 tom Exp tom $";
d46 1
a46 1
	short int       *from, *to;
d61 1
a61 1
	char            *from, *to;
d76 1
a76 1
	unsigned short  *bufr;
d82 19
d108 1
a108 1
	} test;
d132 61
a207 21
int             mat_rblk (fptr, blkno, bufr, nblks)
	FILE           *fptr;
	int             blkno, nblks;
	char           *bufr;
{
	int             stat;

	stat = fseek (fptr, (blkno - 1) * MatBLKSIZE, 0);
	if (stat != 0) {
		fprintf (stderr, "ERROR [mat_rblk]: fseek\n");
		return (ERROR);
	}
	stat = fread (bufr, 1, nblks * MatBLKSIZE, fptr);
	if (stat != nblks * MatBLKSIZE) {
		fprintf (stderr, "ERROR [mat_rblk]: fread\n");
		return (ERROR);
	}
	return (0);
}

/* Version supporting 512 planes, 1024 planes, 8 data types */
d211 3
a213 2
	int		matnum8data16bed64gate1024plane512frame;
	int		loPlane, hiPlane, loData, hiData;
d253 1
a253 1
				return (1);
d263 122
a461 102
int          mat_read_mat_data (fptr, strtblk, nblks, dptr, dtype)
	FILE           *fptr;
	int             strtblk, nblks, dtype;
	char           *dptr;
{
	int             stat, i;

	stat = mat_rblk (fptr, strtblk, dptr, nblks);
	if (stat != 0)
		return (stat);
	switch (dtype) {
	case 1:				 /* byte format...no translation necessary */
		break;
	case 2:				 /* Vax I*2 */
		swap_byte (dptr, dptr, 512 * nblks);
		break;
	case 3:				 /* Vax I*4 */
		swap_byte (dptr, dptr, 512 * nblks);
		swaw (dptr, dptr, 256 * nblks);
		break;
	case 4:				 /* Vax R*4 */
		swap_byte (dptr, dptr, 512 * nblks);
		for (i = 0; i < nblks * 128; i++)
			((float *) dptr)[i] = get_vax_float (dptr, i / 2);
		break;
	case 5:				 /* IEEE R*4 */
		break;
	case 6:				 /* 68K I*2 */
		break;
	case 7:				 /* 68K I*4 */
		break;
	default:				 /* something else...treat as Vax I*2 */
		swap_byte (dptr, dptr, 512 * nblks);
		break;
	}
	return 0;
}

int             mat_read_matrix_data (fptr, blk, nblks, bufr)
	FILE           *fptr;
	int             blk, nblks;
	short           bufr[];
{
	int             stat;
	Main_header     h;

	stat = mat_read_main_header (fptr, &h);
	if (stat != 0) {
		fprintf (stderr, "ERROR [mat_read_matrix_data]\n");
		return (stat);
	}
	stat = mat_read_mat_data (fptr, blk, nblks, (char *) bufr, h.data_type);
	return (stat);
}


int             mat_read_scan_subheader (fptr, blknum, h)
	FILE           *fptr;
	int             blknum;
	Scan_subheader *h;
{
	short int       b[256];
	int             i, stat;

	stat = mat_rblk (fptr, blknum, b, 1);
	if (stat != 0) {
		fprintf (stderr, "ERROR [mat_read_scan_subheader]\n");
		return (stat);
	}
	swap_byte (b, b, MatBLKSIZE);
	h->data_type = b[63];
	h->dimension_1 = b[66];
	h->dimension_2 = b[67];
	h->smoothing = b[68];
	h->processing_code = b[69];
	h->sample_distance = get_vax_float (b, 73);
	h->isotope_halflife = get_vax_float (b, 83);
	h->frame_duration_sec = b[85];
	h->gate_duration = get_vax_long (b, 86);
	h->r_wave_offset = get_vax_long (b, 88);
	h->scale_factor = get_vax_float (b, 91);
	h->scan_min = b[96];
	h->scan_max = b[97];
	h->prompts = get_vax_long (b, 98);
	h->delayed = get_vax_long (b, 100);
	h->multiples = get_vax_long (b, 102);
	h->net_trues = get_vax_long (b, 104);
	for (i = 0; i < 16; i++) {
		h->cor_singles[i] = get_vax_float (b, 158 + 2 * i);
		h->uncor_singles[i] = get_vax_float (b, 190 + 2 * i);
	}
	h->tot_avg_cor = get_vax_float (b, 222);
	h->tot_avg_uncor = get_vax_float (b, 224);
	h->total_coin_rate = get_vax_long (b, 226);
	h->frame_start_time = get_vax_long (b, 228);
	h->frame_duration = get_vax_long (b, 230);
	h->loss_correction_fctr = get_vax_float (b, 232);
	for (i = 0; i < 8; i++)
		h->phy_planes[i] = get_vax_long (b, 234 + (2 * i));
	return (0);
}

d520 1
a520 20
float           get_vax_float (bufr, off)
	unsigned short  bufr[];
	int             off;
{
	unsigned short  t1, t2;
	union {
		unsigned long   t3;
		float           t4;
	} test;

	if (bufr[off] == 0 && bufr[off + 1] == 0)
		return (0.0);
	t1 = bufr[off] & 0x80ff;
	t2 = (((bufr[off]) & 0x7f00) + 0xff00) & 0x7f00;
	test.t3 = (t1 + t2) << 16;
	test.t3 = test.t3 + bufr[off + 1];
	return (test.t4);
}

Mat_dir         mat_read_dir (fptr)
d522 2
d525 2
a526 2
	int             stat, i, n, blk, nxtblk, ndblks, bufr[128];
	Mat_dir         dir;
d528 1
a528 45
	blk = MatFirstDirBlk;
	nxtblk = 0;
	for (ndblks = 0; nxtblk != MatFirstDirBlk; ndblks++) {
		stat = mat_rblk (fptr, blk, bufr, 1);
		if (stat != 0)
			return (NULL);
		swap_byte (bufr, bufr, 8);
		swaw (bufr, bufr, 4);
		nxtblk = bufr[1];
		blk = nxtblk;
	}
	dir = (Mat_dir) calloc (1, sizeof (struct matdir));
	dir->nmats = 0;
	dir->nmax = 31 * ndblks;
	dir->entry = (struct MatDir *) calloc (31 * ndblks, sizeof (struct MatDir));
	for (n = 0, nxtblk = 0, blk = MatFirstDirBlk; nxtblk != MatFirstDirBlk; blk = nxtblk) {
		stat = mat_rblk (fptr, blk, bufr, 1);
		if (stat != 0) {
			free (dir);
			return (NULL);
		}
		swap_byte (bufr, bufr, 512);
		swaw (bufr, bufr, 256);
		nxtblk = bufr[1];
		for (i = 4; i < MatBLKSIZE / 4; n++) {
			dir->entry[n].matnum = bufr[i++];
			dir->entry[n].strtblk = bufr[i++];
			dir->entry[n].endblk = bufr[i++];
			dir->entry[n].matstat = bufr[i++];
			if (dir->entry[n].matnum != 0)
				dir->nmats++;
		}
	}
	return dir;
}


int             mat_wblk (fptr, blkno, bufr, nblks)
	FILE           *fptr;
	int             blkno, nblks;
	char           *bufr;
{
	int             stat;

	stat = fseek (fptr, (blkno - 1) * MatBLKSIZE, 0);
d530 1
a530 1
		fprintf (stderr, "ERROR [mat_wblk]: fseek\n");
d533 21
a553 4
	stat = fwrite (bufr, 1, nblks * MatBLKSIZE, fptr);
	if (stat != nblks * MatBLKSIZE) {
		fprintf (stderr, "ERROR [mat_wblk]: fwrite\n");
		return (ERROR);
d555 8
d566 4
a569 3
FILE           *mat_create (fname, mhead)
	char           *fname;
	Main_header    *mhead;
d571 1
a571 2
	FILE           *fptr;
	int            *bufr;
d574 1
a574 4
	fptr = mat_open (fname, "w+");
	if (fptr == NULL)
		return (fptr);
	stat = mat_write_main_header (fptr, mhead);
d576 1
a576 27
		(void) fclose (fptr);
		return (fptr);
	}
	bufr = (int *) calloc (MatBLKSIZE, sizeof(int));
	bufr[0] = 31;
	bufr[1] = 2;
	swaw (bufr, bufr, 256);
	swap_byte (bufr, bufr, 512);
	stat = mat_wblk (fptr, MatFirstDirBlk, bufr, 1);
	if (stat != 0)
		(void) fclose (fptr);
	free (bufr);
	return (fptr);
}

int             mat_enter (fptr, matnum, nblks)
	FILE           *fptr;
	int             matnum, nblks;
{
	int             stat, dirblk, dirbufr[128], oldsize;
	int             nxtblk = 0;
	int             i = 0;
	int             busy = 1;

	dirblk = MatFirstDirBlk;
	stat = mat_rblk (fptr, dirblk, dirbufr, 1);
	if (stat != 0)
a577 54
	swap_byte (dirbufr, dirbufr, 512);
	swaw (dirbufr, dirbufr, 256);
	while (busy == 1) {
		nxtblk = dirblk + 1;
		for (i = 4; i < 128; i += 4) {
			if (dirbufr[i] == 0) {
				busy = 0;
				break;
			} else if (dirbufr[i] == matnum) {
				oldsize = dirbufr[i + 2] - dirbufr[i + 1] + 1;
				if (oldsize < nblks) {
					dirbufr[i] = 0xFFFFFFFF;
					swaw (dirbufr, dirbufr, 256);
					swap_byte (dirbufr, dirbufr, 512);
					stat = mat_wblk (fptr, dirblk, dirbufr, 1);
					if (stat != 0)
						return (ERROR);
					swap_byte (dirbufr, dirbufr, 512);
					swaw (dirbufr, dirbufr, 256);
					nxtblk = dirbufr[i + 2] + 1;
				} else {
					nxtblk = dirbufr[i + 1];
					dirbufr[0]++;
					dirbufr[3]--;
					busy = 0;
					break;
				}
			} else
				nxtblk = dirbufr[i + 2] + 1;
		}
		if (busy == 0)
			break;
		if (dirbufr[1] != MatFirstDirBlk) {
			dirblk = dirbufr[1];
			stat = mat_rblk (fptr, dirblk, dirbufr, 1);
			if (stat != 0)
				return (stat);
			swap_byte (dirbufr, dirbufr, 512);
			swaw (dirbufr, dirbufr, 256);
		} else {
			dirbufr[1] = nxtblk;
			swaw (dirbufr, dirbufr, 256);
			swap_byte (dirbufr, dirbufr, 512);
			stat = mat_wblk (fptr, dirblk, dirbufr, 1);
			if (stat != 0)
				return (ERROR);
			dirbufr[0] = 31;
			dirbufr[1] = MatFirstDirBlk;
			dirbufr[2] = dirblk;
			dirbufr[3] = 0;
			dirblk = nxtblk;
			for (i = 4; i < 128; i++)
				dirbufr[i] = 0;
		}
d579 1
a579 13
	dirbufr[i] = matnum;
	dirbufr[i + 1] = nxtblk;
	dirbufr[i + 2] = nxtblk + nblks;
	dirbufr[i + 3] = 1;
	dirbufr[0]--;
	dirbufr[3]++;
	swaw (dirbufr, dirbufr, 256);
	swap_byte (dirbufr, dirbufr, 512);
	stat = mat_wblk (fptr, dirblk, dirbufr, 1);
	if (stat != 0)
		return (ERROR);
	return (nxtblk);
}
d581 13
a593 16
int             mat_write_image (fptr, matnum, header, data, data_size)
	FILE           *fptr;
	int             matnum;
	Image_subheader *header;
	unsigned short int *data;
	int             data_size;
{
	int             nxtblk, size, stat;

	size = (data_size + 511) / 512;
	nxtblk = mat_enter (fptr, matnum, size);
	stat = mat_write_image_subheader (fptr, nxtblk, header);
	if (stat != 0)
		return (stat);
	stat = write_matrix_data (fptr, nxtblk + 1, size, (char *) data, header->data_type);
	return (stat);
d596 1
a596 1
int             mat_write_scan (fptr, matnum, header, data, data_size)
d598 1
a598 37
	int             matnum;
	Scan_subheader *header;
	unsigned short int *data;
	int             data_size;
{
	int             nxtblk, size, stat;

	size = (data_size + 511) / 512;
	nxtblk = mat_enter (fptr, matnum, size);
	stat = mat_write_scan_subheader (fptr, nxtblk, header);
	if (stat != 0)
		return (stat);
	stat = write_matrix_data (fptr, nxtblk + 1, size, (char *) data, header->data_type);
	return (stat);
}

int             mat_write_attn (fptr, matnum, header, data, data_size)
	FILE           *fptr;
	int             matnum;
	Attn_subheader *header;
	float          *data;
	int             data_size;
{
	int             nxtblk, size, stat;

	size = (data_size + 511) / 512;
	nxtblk = mat_enter (fptr, matnum, size);
	stat = mat_write_attn_subheader (fptr, nxtblk, header);
	if (stat != 0)
		return (stat);
	stat = write_matrix_data (fptr, nxtblk + 1, size, (char *) data, header->data_type);
	return (stat);
}

int             mat_write_norm (fptr, matnum, header, data, data_size)
	FILE           *fptr;
	int             matnum;
a599 2
	float          *data;
	int             data_size;
d601 2
a602 1
	int             nxtblk, size, stat;
d604 3
a606 4
	size = (data_size + 511) / 512;
	nxtblk = mat_enter (fptr, matnum, size);
	stat = mat_write_norm_subheader (fptr, nxtblk, header);
	if (stat != 0)
a607 23
	stat = write_matrix_data (fptr, nxtblk + 1, size, (char *) data, header->data_type);
	return (stat);
}

int             mat_write_idata (fptr, blk, data, size)
	FILE           *fptr;
	int             blk, size;
	char  		   *data;
{
	char   			bufr[512];
	int             i, nbytes, nblks;
	int             stat;

	nblks = (size + 511) / 512;
	for (i = 0; i < nblks; i++) {
		nbytes = (size < 512) ? size : 512;
		bcopy (data, bufr, nbytes);
		swap_byte (bufr, bufr, 512);
		stat = mat_wblk (fptr, blk + i, bufr, 1);
		if (stat != 0)
			return (ERROR);
		data += nbytes;
		size -= nbytes;
d609 1
a609 2
	return 0;
}
d611 13
a623 21
int             mat_write_fdata (fptr, blk, data, size)
	FILE           *fptr;
	int             blk, size;
	float          *data;
{
	float           bufr[128];
	int             i, j, nvals, nblks;
	int             stat;

	nblks = (size + 511) / 512;
	for (i = 0; i < nblks; i++) {
		nvals = (size < 512) ? size / 4 : 512 / 4;
		for (j = 0; j < nvals; j++)
			sunftovaxf (*data++, &bufr[j]);
		swap_byte (bufr, bufr, 512);
		stat = mat_wblk (fptr, blk + i, bufr, 1);
		if (stat != 0)
			return (ERROR);
		size -= 4 * nvals;
	}
	return 0;
a625 34
int	str_find (s1, s2)
	char           *s1, *s2;
{
	int             i, j, k;

	for (i = 0; s1[i] != 0; i++) {
		for (j = i, k = 0; s2[k] != '\0' && s1[j] == s2[k]; j++, k++)
			if (s2[k] == '\0')
				return (i);
	} return (-1);
}

int	str_replace (s1, s2, s3, s4)
	char           *s1, *s2, *s3, *s4;
{
	int             nf = 0, n;
	int             busy=1;

	*s1 = '\0';
	while (busy == 1) {
		if ((n = str_find (s2, s3)) == -1) {
			strcat (s1, s2);
			return (nf);
		} else {
			strncat (s1, s2, n);
			strcat (s1, s4);
			s2 += n + strlen (s3);
			nf++;
		}
	}
	return 0;
}


d709 8
d718 37
a966 59
int             mat_read_attn_subheader (fptr, blknum, header)
	FILE           *fptr;
	int             blknum;
	Attn_subheader *header;
{
	short int       bufr[256];
	int             stat;

	stat = mat_rblk (fptr, blknum, bufr, 1);
	if (stat != 0) {
		fprintf (stderr, "ERROR [mat_read_attn_subheader]\n");
		return (stat);
	}
	swap_byte (bufr, bufr, MatBLKSIZE);

	header->data_type = bufr[63];
	header->attenuation_type = bufr[64];
	header->dimension_1 = bufr[66];
	header->dimension_2 = bufr[67];
	header->scale_factor = get_vax_float (bufr, 91);
	header->x_origin = get_vax_float (bufr, 93);
	header->y_origin = get_vax_float (bufr, 95);
	header->x_radius = get_vax_float (bufr, 97);
	header->y_radius = get_vax_float (bufr, 99);
	header->tilt_angle = get_vax_float (bufr, 101);
	header->attenuation_coeff = get_vax_float (bufr, 103);
	header->sample_distance = get_vax_float (bufr, 105);
	return (0);
}

int             mat_read_norm_subheader (fptr, blknum, header)
	FILE           *fptr;
	int             blknum;
	Norm_subheader *header;
{
	short int       bufr[256];
	int             stat;

	stat = mat_rblk (fptr, blknum, bufr, 1);
	if (stat != 0) {
		fprintf (stderr, "ERROR [mat_read_norm_subheader]\n");
		return (stat);
	}
	swap_byte (bufr, bufr, MatBLKSIZE);

	header->data_type = bufr[63];
	header->dimension_1 = bufr[66];
	header->dimension_2 = bufr[67];
	header->scale_factor = get_vax_float (bufr, 91);
	header->norm_hour = bufr[93];
	header->norm_minute = bufr[94];
	header->norm_second = bufr[95];
	header->norm_day = bufr[96];
	header->norm_month = bufr[97];
	header->norm_year = bufr[98];
	header->fov_source_width = get_vax_float (bufr, 99);
	header->ecat_calib_factor = get_vax_float (bufr, 101);
	return (0);
}
@


1.8
log
@partially cleaned up with lint
@
text
@d1 5
a5 2
/*$Id: matrix.c,v 1.7 1996/09/25 16:28:32 tom Exp tom $*/
/*$Log: matrix.c,v $
d33 1
d37 1
a37 1
static char     rcsid[] = "$Header: /home/npggw/tom/src/libcti/RCS/matrix.c,v 1.7 1996/09/25 16:28:32 tom Exp tom $";
d40 2
a41 86
/*********************************************************/
FILE           *mat_open (fname, fmode)
	char           *fname, *fmode;
{
	FILE           *fptr;

	fptr = fopen (fname, fmode);
	return (fptr);
}

/*********************************************************/
mat_close (fptr)
	FILE           *fptr;
{
	return (fclose (fptr));
}

/*********************************************************/
int             mat_rblk (fptr, blkno, bufr, nblks)
	FILE           *fptr;
	int             blkno, nblks;
	char           *bufr;
{
	int             err;

	err = fseek (fptr, (blkno - 1) * MatBLKSIZE, 0);
	if (err) {
		fprintf (stderr, "ERROR [mat_rblk]: fseek\n");
		return (err);
	}
	err = fread (bufr, 1, nblks * MatBLKSIZE, fptr);
	if (err != nblks * MatBLKSIZE)
		return (-1);
	return (0);
}

/*********************************************************/

int             mat_list (fptr, mlist, lmax)
	FILE           *fptr;
	struct MatDir   mlist[];
	int             lmax;
{
	int             blk, num_entry, num_stored, i, err, mat_rblk ();
	int             nfree, nxtblk, prvblk, nused, matnum, strtblk, endblk, matstat;
	int             dirbufr[MatBLKSIZE / 4];

	char            bytebufr[MatBLKSIZE];

	blk = MatFirstDirBlk;
	num_entry = 0;
	num_stored = 0;
	while (1) {
		err = mat_rblk (fptr, blk, bytebufr, 1);
		swap_byte (bytebufr, dirbufr, MatBLKSIZE);
		swaw (dirbufr, dirbufr, MatBLKSIZE / 2);
		nfree = dirbufr[0];
		nxtblk = dirbufr[1];
		prvblk = dirbufr[2];
		nused = dirbufr[3];
		for (i = 4; i < MatBLKSIZE / 4; i += 4) {
			matnum = dirbufr[i];
			strtblk = dirbufr[i + 1];
			endblk = dirbufr[i + 2];
			matstat = dirbufr[i + 3];
			if (matnum && num_stored < lmax) {
				mlist[num_stored].matnum = matnum;
				mlist[num_stored].strtblk = strtblk;
				mlist[num_stored].endblk = endblk;
				mlist[num_stored].matstat = matstat;
				num_stored++;
			}
			if (matnum)
				num_entry++;
		}
		blk = nxtblk;
		if (blk == MatFirstDirBlk)
			break;
	}

	return (num_entry);
}

/*********************************************************/
swaw (from, to, length)
	short int       from[], to[];
d52 1
a52 1
	return 0;
d55 2
a56 3
/*********************************************************/
swap_byte (from, to, length)
	char            from[], to[];
d67 1
a67 1
	return 0;
d70 3
a72 4
/********************************************************
old version supporting 4096 planes, 256 planes, 4 data types
 int mat_numcod( frame, plane, gate, data, bed)
   int frame, plane, gate, data, bed;
d74 1
a74 2
 return ((frame&0xFFF)|((bed&0xF)<<12)|((plane&0xFF)<<16)|
        ((gate&0x3F)<<24)|((data&0x3)<<30));
d76 4
a79 5
*/
/********************************************************
old version supporting 4096 planes, 256 planes, 4 data types
 mat_numdoc( matnum, matval)
   int matnum; struct Matval *matval;
d81 16
a96 6
 matval->frame = matnum&0xFFF;
 matval->plane = (matnum>>16)&0xFF;
 matval->gate  = (matnum>>24)&0x3F;
 matval->data  = (matnum>>30)&0x3;
 matval->bed   = (matnum>>12)&0xF;
 return 0;
d98 46
a143 3
*/
/********************************************************
new version supporting 512 planes, 1024 planes, 8 data types */
d147 2
a148 1
	int             matnum8data16bed64gate1024plane512frame, loPlane, hiPlane = 0, loData, hiData = 0;
a158 22
/********************************************************
new version supporting 512 planes, 1024 planes, 8 data types */
mat_numdoc (matnum, matval)
	int             matnum;

	struct Matval  *matval;
{
	int             loPlane, hiPlane = 0, loData, hiData = 0;

	matval->frame = matnum & 0x1FF;
	loPlane = (matnum >> 16) & 0xFF;
	hiPlane = (matnum >> 1) & 0x300;
	matval->plane = loPlane | hiPlane;
	matval->gate = (matnum >> 24) & 0x3F;
	loData = (matnum >> 30) & 0x3;
	hiData = (matnum >> 9) & 0x4;
	matval->data = loData | hiData;
	matval->bed = (matnum >> 12) & 0xF;
	return 0;
}

/*********************************************************/
d164 2
a165 2
	int             blk, i, err, mat_rblk ();
	int             nfree, nxtblk, prvblk, nused, matnbr, strtblk, endblk, matstat;
d168 1
d171 4
a174 2
	while (1) {
		err = mat_rblk (fptr, blk, bytebufr, 1);
a176 1
		nfree = dirbufr[0];
a177 2
		prvblk = dirbufr[2];
		nused = dirbufr[3];
a197 1
/*********************************************************/
d204 1
a204 2
	int             err, i;
	float           get_vax_float ();
d206 2
a207 2
	err = mat_rblk (fptr, 1, b, 1);		 /* read main header at block 1 */
	if (err) {
d209 1
a209 1
		return (err);
a271 1

d275 1
a275 2
/*********************************************************/
int             mat_read_matrix_data (fptr, blk, nblks, bufr)
a276 21
	int             blk, nblks;
	short           bufr[];
{
	int             error;
	Main_header     h;

	error = mat_read_main_header (fptr, &h);
	if (error) {
		fprintf (stderr, "ERROR [mat_read_matrix_data]\n");
		return (error);
	}
	error = mat_read_mat_data (fptr, blk, nblks,
				   (char *) bufr, h.data_type);
	return (error);
}

/*******************************************************************/
/*	May 90, PLuk - Now reads VAX or Sun matrix files.	   */

mat_read_mat_data (fptr, strtblk, nblks, dptr, dtype)
	FILE           *fptr;
d280 1
a280 2
	float           get_vax_float ();
	int             i;
d282 3
a284 1
	mat_rblk (fptr, strtblk, dptr, nblks);
d313 18
a330 1
/*********************************************************/
d337 1
a337 2
	int             i, err, get_vax_long ();
	float           get_vax_float ();
d339 2
a340 2
	err = mat_rblk (fptr, blknum, b, 1);
	if (err) {
d342 1
a342 1
		return (err);
a376 1
/*********************************************************/
a378 1

a379 1

d383 1
a383 5

	int             i, err;

	float           get_vax_float ();

d386 2
a387 2
	err = mat_rblk (fptr, blknum, b, 1);
	if (err) {
d389 1
a389 1
		return (err);
a392 3
	/*
	 * strncpy( h->annotation, b+420, 40);
	 */
a434 1
/*********************************************************/
a436 1

a439 1

d443 1
a443 1
	}               test;
d454 1
a454 11
/*********************************************************/
int             get_vax_long (bufr, off)
	unsigned short  bufr[];

	int             off;
{
	return ((bufr[off + 1] << 16) + bufr[off]);
}

Mat_dir
mat_read_dir (fptr, selector)
a455 2

	char           *selector;
d457 1
a457 2
	int             i, n, blk, nxtblk, ndblks, bufr[128];

d463 3
a465 1
		mat_rblk (fptr, blk, bufr, 1);
d471 1
a471 1
	dir = (Mat_dir) malloc (sizeof (struct matdir));
d474 1
a474 1
	dir->entry = (struct MatDir *) malloc (31 * ndblks * sizeof (struct MatDir));
d476 5
a480 1
		mat_rblk (fptr, blk, bufr, 1);
a495 1
/*********************************************************/
d502 1
a502 1
	int             err;
d504 2
a505 3
	/* seek to position in file */
	err = fseek (fptr, (blkno - 1) * MatBLKSIZE, 0);
	if (err) {
d507 1
a507 1
		return (err);
d509 2
a510 3
	/* write matrix data */
	err = fwrite (bufr, 1, nblks * MatBLKSIZE, fptr);
	if (err != nblks * MatBLKSIZE) {
d512 1
a512 1
		return (-1);
a518 1

d522 2
a524 2
	int             i, *bufr;

d526 8
a533 6
	if (!fptr)
		return fptr;
	mat_write_main_header (fptr, mhead);
	bufr = (int *) malloc (MatBLKSIZE);
	for (i = 0; i < 128; i++)
		bufr[i] = 0;
d538 3
a540 1
	mat_wblk (fptr, MatFirstDirBlk, bufr, 1);
d549 4
a552 1
	int             dirblk, dirbufr[128], i, nxtblk, busy, oldsize;
d555 3
a557 1
	mat_rblk (fptr, dirblk, dirbufr, 1);
d560 1
a560 2
	busy = 1;
	while (busy) {
d572 3
a574 1
					mat_wblk (fptr, dirblk, dirbufr, 1);
d588 1
a588 1
		if (!busy)
d592 3
a594 1
			mat_rblk (fptr, dirblk, dirbufr, 1);
d601 3
a603 1
			mat_wblk (fptr, dirblk, dirbufr, 1);
d621 3
a623 1
	mat_wblk (fptr, dirblk, dirbufr, 1);
d627 1
a627 1
mat_write_image (fptr, matnum, header, data, data_size)
a628 1

a629 1

a630 1

a631 1

d634 1
a634 1
	int             nxtblk, size, error;
d638 5
a642 5
	mat_write_image_subheader (fptr, nxtblk, header);
	error = write_matrix_data (fptr, nxtblk + 1, size,
				   (char *) data,
				   header->data_type);
	return (error);
d645 1
a645 1
mat_write_scan (fptr, matnum, header, data, data_size)
a646 1

a647 1

a648 1

a649 1

d652 1
a652 1
	int             nxtblk, size, error;
d656 5
a660 5
	mat_write_scan_subheader (fptr, nxtblk, header);
	error = write_matrix_data (fptr, nxtblk + 1, size,
				   (char *) data,
				   header->data_type);
	return (error);
d663 1
a663 1
mat_write_attn (fptr, matnum, header, data, data_size)
a664 1

a665 1

a666 1

a667 1

d670 1
a670 1
	int             nxtblk, size, error;
d674 5
a678 5
	mat_write_attn_subheader (fptr, nxtblk, header);
	error = write_matrix_data (fptr, nxtblk + 1, size,
				   (char *) data,
				   header->data_type);
	return (error);
d681 1
a681 1
mat_write_norm (fptr, matnum, header, data, data_size)
a682 1

a683 1

a684 1

a685 1

d688 1
a688 1
	int             nxtblk, size, error;
d692 5
a696 5
	mat_write_norm_subheader (fptr, nxtblk, header);
	error = write_matrix_data (fptr, nxtblk + 1, size,
				   (char *) data,
				   header->data_type);
	return (error);
d699 1
a699 1
mat_write_idata (fptr, blk, data, size)
a700 1

d702 1
a702 2

	unsigned char  *data;
d704 1
a704 2
	unsigned char   bufr[512];

d706 1
d713 3
a715 1
		mat_wblk (fptr, blk + i, bufr, 1);
d722 1
a722 1
mat_write_fdata (fptr, blk, data, size)
a723 1

a724 1

a727 1

d729 1
d737 3
a739 1
		mat_wblk (fptr, blk + i, bufr, 1);
d745 1
a745 50
matrix_selector (matnum, ranges)
	int             matnum, ranges[2][5];
{
	struct Matval   m;

	mat_numdoc (matnum, &m);
	if (ranges[0][0] != -1)
		if (m.frame < ranges[0][0] || m.frame > ranges[1][0])
			return (0);
	if (ranges[0][1] != -1)
		if (m.plane < ranges[0][1] || m.plane > ranges[1][1])
			return (0);
	if (ranges[0][2] != -1)
		if (m.gate < ranges[0][2] || m.gate > ranges[1][2])
			return (0);
	if (ranges[0][3] != -1)
		if (m.data < ranges[0][3] || m.data > ranges[1][3])
			return (0);
	if (ranges[0][4] != -1)
		if (m.bed < ranges[0][4] || m.bed > ranges[1][4])
			return (0);
	return (matnum);
}

decode_selector (s1, ranges)
	char           *s1;

	int             ranges[2][5];
{
	char            xword[16], *next_word ();

	int             i;

	fix_selector (s1, s1);
	for (i = 0; i < 5; i++) {		 /* set all ranges to all (-1) */
		ranges[0][i] = ranges[1][i] = -1;
		s1 = next_word (s1, xword);
		if (xword[0] == '*')
			continue;
		else if (strchr (xword, ':'))
			sscanf (xword, "%d:%d", &ranges[0][i], &ranges[1][i]);
		else {
			sscanf (xword, "%d", &ranges[0][i]);
			ranges[1][i] = ranges[0][i];
		};
	}
	return 0;
}

str_find (s1, s2)
d750 4
a753 4
	for (i = 0; s1[i]; i++) {
		for (j = i, k = 0; s2[k] != '\0' && s1[j] == s2[k]; j++, k++);
		if (s2[k] == '\0')
			return (i);
d757 1
a757 1
str_replace (s1, s2, s3, s4)
d761 1
d764 1
a764 1
	while (1) {
a774 10
}

string_replace (s1, s2, s3, s4)
	char           *s1, *s2, *s3, *s4;
{
	char            temp[256];

	strcpy (temp, s2);
	while (str_replace (s1, temp, s3, s4) > 0)
		strcpy (temp, s1);
a777 4
fix_selector (s1, s2)
	char           *s1, *s2;
{
	char            temp[256];
a778 59
	string_replace (temp, s2, ",", " ");
	string_replace (s1, temp, "..", ":");
	string_replace (temp, s1, ".", ":");
	string_replace (s1, temp, "-", ":");
	string_replace (temp, s1, "**", "*");
	string_replace (s1, temp, "  ", " ");
	string_replace (temp, s1, " :", ":");
	string_replace (s1, temp, ": ", ":");
	return 0;
}

char           *next_word (s, w)
	char           *s, *w;
{
	while (*s && *s != ' ')
		*w++ = *s++;
	*w = '\0';
	if (*s)
		s++;
	return (s);
}

/********************************************************/
/*  SUNFTOVAXF                                          */
/********************************************************/

sunftovaxf (orig, number)
	unsigned short  number[2];

	float           orig;
{

	/* convert from sun float to vax float */

	union {
		unsigned short  t[2];
		float           t4;
	}               test;

	unsigned short int exp;

	number[0] = 0;
	number[1] = 0;

	test.t4 = orig;
	if (test.t4 == 0.0)
		return;

	number[1] = test.t[1];

	exp = ((test.t[0] & 0x7f00) + 0x0100) & 0x7f00;
	test.t[0] = (test.t[0] & 0x80ff) + exp;

	number[0] = test.t[0];
	return 0;

}

/*********************************************************/
d785 1
a785 1
	int             err, i;
a836 1
	/* write the node_id - character string */
a837 1
	/* write the isotope code - char string */
a838 1
	/* write the radiopharmaceutical  - char string */
a839 1
	/* study_name - char string */
a840 1
	/* patient_id - char string */
a841 1
	/* patient_name - char string */
a842 1
	/* patient_sex - char */
a843 1
	/* patient_age - char string */
a844 1
	/* patient_height  - char string */
a845 1
	/* patient_weight - char string */
a846 1
	/* patient_dexterity - char */
a847 1
	/* physician_name - char string */
a848 1
	/* operator_name - char string */
a849 1
	/* study_description - char string */
a850 1
	/* facility_name */
a851 1
	/* user_process_code  - char string */
d854 2
a855 2
	err = mat_wblk (fptr, 1, bufr, 1);	 /* write main header at block 1 */
	if (err) {
d857 1
a857 1
		return (err);
a861 1
/*********************************************************/
a864 1

a865 1

a868 1

d870 1
a871 2
	int             i, err;

d875 1
a875 1
	/* transfer subheader information */
a914 1
	/* swap the bytes */
a915 1

d918 2
a919 3
	/* write to matrix file */
	err = mat_wblk (fptr, blknum, bbufr, 1);
	if (err) {
d921 1
a921 1
		return (err);
a925 12
/*********************************************************/
sunltovaxl (in, out)
	int             in;

	unsigned short int out[2];
{
	out[0] = (in & 0x0000FFFF);
	out[1] = (in & 0xFFFF0000) >> 16;
	return 0;
}

/*********************************************************/
a927 1

a928 1

d932 1
d934 2
a935 3
	int             i, err;

	for (i = 0; i < 256; bufr[i++] = 0);
d972 1
a972 1
	};
d982 2
a983 2
	err = mat_wblk (fptr, blknum, bufr, 1);
	return (err);
d995 1
a995 1
	int             i, err;
d997 2
a998 1
	for (i = 0; i < 256; bufr[i++] = 0);
d1028 2
a1029 2
	err = mat_wblk (fptr, blknum, bufr, 1);
	return (err);
a1033 1

a1034 1

d1038 1
d1040 2
a1041 3
	int             i, err;

	for (i = 0; i < 256; bufr[i++] = 0);
d1071 2
a1072 2
	err = mat_wblk (fptr, blknum, bufr, 1);
	return (err);
d1081 1
a1081 2
	int             err;
	float           get_vax_float ();
d1083 2
a1084 2
	err = mat_rblk (fptr, blknum, bufr, 1);
	if (err) {
d1086 1
a1086 1
		return (err);
d1111 1
a1111 2
	int             err;
	float           get_vax_float ();
d1113 2
a1114 2
	err = mat_rblk (fptr, blknum, bufr, 1);
	if (err) {
d1116 1
a1116 1
		return (err);
@


1.7
log
@build in Solaris 2
@
text
@d1 1
a1 1
/*$Id: matrix.c,v 1.6 1995/11/30 19:42:02 tom Exp tom $*/
d3 3
d28 2
d33 1
a33 2
static char     sccsid[] = "@@(#)matrix.c	2.4 4/24/92  Copyright 1989-1992 CTI PET Systems, Inc.";

a35 2
static char     rcsid[] = "$Header: /home/npggw/tom/src/libcti/RCS/matrix.c,v 1.6 1995/11/30 19:42:02 tom Exp tom $";

d40 1
a40 1
	FILE           *fopen (), *fptr;
a43 1

d50 1
a50 1
	fclose (fptr);
a55 1

a56 1

d59 1
a59 1
	int             err, fseek ();
a68 3
/*
		fprintf (stderr, "ERROR [mat_rblk]: fread\n");
*/
a75 1

a76 1

a79 1

a80 1

a121 1

a124 1

a137 1

a140 1

a212 1

a213 1

a215 1

a216 1

a217 1

a218 1

a252 1

a255 1

a256 1

a257 1

a332 1

a333 1

a336 1

a353 1

a354 1

d357 1
a391 1

a392 1

a395 1

a396 1

a579 1

a580 1

d583 1
a583 1
	int             err, fseek ();
a626 1

a628 3

	struct MatDir   entry;

a985 1

a988 1

d990 1
a991 2
	int             err, i, loc;

a1320 1

a1321 1

d1325 1
a1325 3

	int             i, err, get_vax_long ();

a1351 1

a1352 1

d1356 1
a1356 3

	int             i, err, get_vax_long ();

@


1.6
log
@TOV mod
@
text
@d1 1
a1 1
/*$Id: matrix.c,v 1.5 1995/10/30 16:54:44 tom Exp tom $*/
d3 3
a30 1
static char     rcsid[] = "$Header: /home/npggw/tom/src/libcti/RCS/matrix.c,v 1.5 1995/10/30 16:54:44 tom Exp tom $";
d32 2
d55 1
d57 1
d68 1
a68 1
	if (err != nblks * MatBLKSIZE) 
d80 1
d82 1
d86 1
d88 1
d90 1
d130 1
d134 1
d148 1
d152 1
d190 1
a190 2
	int             matnum8data16bed64gate1024plane512frame, loPlane, hiPlane = 0, loData,
	                hiData = 0;
d205 1
d225 1
d227 1
d232 1
d234 1
d236 1
d271 1
d275 1
d277 1
d279 1
d355 1
d357 1
d361 1
d379 1
d381 1
d418 1
d420 1
d424 1
d426 1
d470 1
d472 1
d476 1
d478 1
d480 1
d538 1
d542 1
d560 1
d569 1
d573 1
d610 1
d612 1
a622 1

d634 1
d638 1
d659 1
d664 1
d733 1
d735 1
d737 1
d739 1
d755 1
d757 1
d759 1
d761 1
d777 1
d779 1
d781 1
d783 1
d799 1
d801 1
d803 1
d805 1
d821 1
d823 1
d827 1
d844 1
d846 1
d850 1
d891 1
d895 1
d989 1
d999 1
d1022 1
d1026 1
d1028 1
d1126 1
d1128 1
d1132 1
d1134 1
d1197 1
d1208 1
d1210 1
d1214 1
d1270 1
d1272 1
d1276 1
d1315 1
d1317 1
d1321 1
d1360 1
d1362 1
d1366 1
d1368 1
d1395 1
d1397 1
d1401 1
d1403 1
@


1.5
log
@changed petutil/matrix.h to matrix.h
@
text
@d1 1
a1 1
/*$Id: matrix.c,v 1.4 1994/03/03 17:29:43 ty7777 Exp tom $*/
d3 3
d21 1
d25 2
a26 1
static char sccsid[]="@@(#)matrix.c	2.4 4/24/92  Copyright 1989-1992 CTI PET Systems, Inc.";
d28 1
a28 1
static char rcsid [] = "$Header: /home/npggw/tom/src/libcti/RCS/matrix.c,v 1.4 1994/03/03 17:29:43 ty7777 Exp tom $";
d30 3
a32 3
	/*********************************************************/
	FILE *mat_open( fname, fmode)
	char *fname, *fmode;
d34 1
a34 1
	FILE *fopen(), *fptr;
d36 1
a36 1
	fptr = fopen(fname, fmode);
d40 4
a43 3
	/*********************************************************/
	mat_close( fptr)
	FILE *fptr;
d45 1
a45 1
	fclose( fptr);
d47 6
a52 5
	/*********************************************************/
	int mat_rblk( fptr, blkno, bufr, nblks)
	FILE *fptr;
	int blkno, nblks;
	char *bufr;
d54 1
a54 4
	int err, fseek(); 
	/*
	int fread();
	*/
d56 11
a66 4
	err = fseek( fptr, (blkno-1)*MatBLKSIZE, 0);
	if (err) return (err);
	err = fread( bufr, 1, nblks*MatBLKSIZE, fptr);
	if (err != nblks*MatBLKSIZE) return (-1);
a68 1
	/*********************************************************/
d70 6
a75 4
	int mat_list( fptr, mlist, lmax)
	FILE *fptr;
	struct MatDir mlist[];
	int lmax;
d77 4
a80 4
	int blk, num_entry, num_stored, i, err, mat_rblk();
	int nfree, nxtblk, prvblk, nused, matnum, strtblk, endblk, matstat;
	int dirbufr[MatBLKSIZE/4];
	char bytebufr[MatBLKSIZE];
d85 26
a110 21
	while(1) {
	err=mat_rblk( fptr, blk, bytebufr,1);
	swap_byte (bytebufr, dirbufr, MatBLKSIZE);
	swaw( dirbufr, dirbufr, MatBLKSIZE/2);
	nfree  = dirbufr[0];
	nxtblk = dirbufr[1];
	prvblk = dirbufr[2];
	nused  = dirbufr[3];
	for (i=4; i<MatBLKSIZE/4; i+=4)
	{  matnum = dirbufr[i];
	   strtblk = dirbufr[i+1];
	   endblk  = dirbufr[i+2];
	   matstat = dirbufr[i+3];
	   if (matnum && num_stored < lmax)
	   {  mlist[num_stored].matnum = matnum;
	      mlist[num_stored].strtblk = strtblk;
	      mlist[num_stored].endblk = endblk;
	      mlist[num_stored].matstat = matstat;
	      num_stored++;
	   }
	   if (matnum) num_entry++;
a111 3
	blk = nxtblk;
	if (blk == MatFirstDirBlk) break;
	}
d118 2
a119 2
	short int	from [], to [];
	int		length;
d121 2
a122 2
	short int	temp;
	int		i;
d124 4
a127 5
	for (i = 0; i < length; i += 2)
	{  
		temp		= from [i + 1];
		to [i + 1]	= from [i];
		to [i]		= temp;
d134 2
a135 2
	char	from [], to [];
	int	length;
d137 2
a138 2
	char	temp;
	int	i;
d140 4
a143 5
	for (i = 0; i < length; i += 2)
	{  
		temp		= from [i + 1];
		to [i + 1]	= from [i];
		to [i]		= temp;
d148 1
a148 1
	/********************************************************
d150 2
a151 2
	int mat_numcod( frame, plane, gate, data, bed)
	  int frame, plane, gate, data, bed;
d153 2
a154 2
	return ((frame&0xFFF)|((bed&0xF)<<12)|((plane&0xFF)<<16)|
	       ((gate&0x3F)<<24)|((data&0x3)<<30));
d157 1
a157 1
	/********************************************************
d159 2
a160 2
	mat_numdoc( matnum, matval)
	  int matnum; struct Matval *matval;
d162 6
a167 6
	matval->frame = matnum&0xFFF;
	matval->plane = (matnum>>16)&0xFF;
	matval->gate  = (matnum>>24)&0x3F;
	matval->data  = (matnum>>30)&0x3;
	matval->bed   = (matnum>>12)&0xF;
	return 0;
d170 1
a170 1
	/********************************************************
d172 2
a173 2
	int mat_numcod( frame, plane, gate, data, bed)
	  int frame, plane, gate, data, bed;
d175 2
a176 1
	int matnum8data16bed64gate1024plane512frame, loPlane, hiPlane = 0, loData, hiData = 0;
d183 1
a183 1
   	    ((loPlane << 16) | (hiPlane << 1)) | ((gate & 0x3F) << 24) | ((loData << 30) | (hiData << 9)));
d186 2
a187 1
	/********************************************************
d189 3
a191 2
	mat_numdoc( matnum, matval)
	  int matnum; struct Matval *matval;
d193 1
a193 1
	int loPlane, hiPlane = 0, loData, hiData = 0;
d206 6
a211 3
	/*********************************************************/
	int mat_lookup( fptr, matnum, entry)
	  FILE *fptr; int matnum; struct MatDir *entry;
a212 5
	
	int blk, i, err, mat_rblk();
	int nfree, nxtblk, prvblk, nused, matnbr, strtblk, endblk, matstat;
	int dirbufr[MatBLKSIZE/4];
	char bytebufr[MatBLKSIZE];
d214 5
d220 24
a243 22
	while(1) {
	err=mat_rblk( fptr, blk, bytebufr,1);
	swap_byte (bytebufr, dirbufr, MatBLKSIZE);
	swaw( dirbufr, dirbufr, MatBLKSIZE/2);
	nfree  = dirbufr[0];
	nxtblk = dirbufr[1];
	prvblk = dirbufr[2];
	nused  = dirbufr[3];
	for (i=4; i<MatBLKSIZE/4; i+=4)
	{  matnbr  = dirbufr[i];
	   strtblk = dirbufr[i+1];
	   endblk  = dirbufr[i+2];
	   matstat = dirbufr[i+3];
	   if (matnum == matnbr) {
	      entry->matnum  = matnbr;
	      entry->strtblk = strtblk;
	      entry->endblk  = endblk;
	      entry->matstat = matstat;
	      return (1); }
 	}
	blk = nxtblk;
	if (blk == MatFirstDirBlk) break;
d248 4
a251 3
	/*********************************************************/
	int mat_read_main_header( fptr, h)
	  FILE *fptr; Main_header *h;
d253 4
a256 4
	short int b[256];
	char *bb;
	int err, i;
	float get_vax_float();
d258 13
a270 10
	err = mat_rblk( fptr, 1, b, 1);	   /* read main header at block 1 */
	if (err) return(err);
	bb = (char *)b;
	strncpy( h->original_file_name, bb+28, 20);
	strncpy( h->node_id, bb+56, 10);
	strncpy( h->isotope_code, bb+78, 8);
	strncpy( h->radiopharmaceutical, bb+90, 32);
	strncpy( h->study_name, bb+162, 12);
	strncpy( h->patient_id, bb+174, 16);
	strncpy( h->patient_name, bb+190, 32);
d272 3
a274 3
	strncpy( h->patient_age, bb+223, 10);
	strncpy( h->patient_height, bb+233, 10);
	strncpy( h->patient_weight, bb+243, 10);
d276 5
a280 5
	strncpy( h->physician_name, bb+254, 32);
	strncpy( h->operator_name, bb+286, 32);
	strncpy( h->study_description, bb+318, 32);
	strncpy( h->facility_name, bb+356, 20);
	strncpy( h->user_process_code, bb+462, 10);
d293 4
a296 4
	h->isotope_halflife = get_vax_float(b, 43);
	h->gantry_tilt = get_vax_float(b, 61);
	h->gantry_rotation = get_vax_float(b, 63);
	h->bed_elevation = get_vax_float(b, 65);
d300 2
a301 2
	h->axial_fov = get_vax_float(b, 70);
	h->transaxial_fov = get_vax_float(b, 72);
d305 1
a305 1
	h->calibration_factor = get_vax_float( b, 77);
d315 4
a318 4
	h->init_bed_position = get_vax_float( b, 192);
	for (i=0; i<15; i++)
	  h->bed_offset[i] = get_vax_float( b, 194+2*i);
	h->plane_separation = get_vax_float( b, 224);
d322 1
a322 1
	h->collimator = get_vax_float( b, 229);
d327 6
a332 3
	/*********************************************************/
	int mat_read_matrix_data( fptr, blk, nblks, bufr)
	  FILE *fptr; int blk, nblks; short bufr[];
d334 2
a335 2
	int error ;
	Main_header h ;
d337 7
a343 4
	error = mat_read_main_header(fptr, &h) ;
	if(error)   return(error) ;
	error = mat_read_mat_data(fptr, blk, nblks,
		                  (char*)bufr, h.data_type) ;
d350 4
a353 4
mat_read_mat_data( fptr, strtblk, nblks, dptr, dtype)
  FILE *fptr;
  int strtblk, nblks, dtype;
  char * dptr;
d355 1
a355 1
	int i;
d357 25
a381 26
	mat_rblk( fptr, strtblk, dptr, nblks);
	switch( dtype)
	{
		case 1:		/* byte format...no translation necessary */
		  break;
		case 2:		/* Vax I*2 */
		  swap_byte ( dptr, dptr, 512 * nblks);
		  break;
		case 3:		/* Vax I*4 */
		  swap_byte (dptr, dptr, 512 * nblks);
		  swaw( dptr, dptr, 256*nblks);
		  break;
		case 4:		/* Vax R*4 */
		  swap_byte (dptr, dptr, 512 * nblks);
		  for (i=0; i<nblks*128; i++)
		    ((float *)dptr)[i] = get_vax_float( dptr, i/2);
		  break;
		case 5:		/* IEEE R*4 */
		  break;
		case 6:		/* 68K I*2 */
		  break;
		case 7:		/* 68K I*4 */
		  break;
		default:	/* something else...treat as Vax I*2 */
		  swap_byte ( dptr, dptr, 512*nblks);
		  break;
d386 5
a390 3
	/*********************************************************/
	int mat_read_scan_subheader( fptr, blknum, h)
	  FILE *fptr; int blknum; Scan_subheader *h;
d392 3
a394 3
	short int b[256];
	int i, err, get_vax_long();
	float get_vax_float();
d396 5
a400 2
	err = mat_rblk( fptr, blknum, b, 1);
	if (err) return(err);
d407 2
a408 2
	h->sample_distance = get_vax_float( b, 73);
	h->isotope_halflife = get_vax_float( b, 83);
d410 3
a412 3
	h->gate_duration = get_vax_long( b, 86);
	h->r_wave_offset = get_vax_long( b, 88);
	h->scale_factor = get_vax_float( b, 91);
d415 16
a430 15
	h->prompts = get_vax_long( b, 98);
	h->delayed = get_vax_long( b, 100);
	h->multiples = get_vax_long( b, 102);
	h->net_trues = get_vax_long( b, 104);
	for (i=0; i<16; i++)
	{ h->cor_singles[i] = get_vax_float( b, 158+2*i);
	  h->uncor_singles[i] = get_vax_float( b, 190+2*i);}
	h->tot_avg_cor = get_vax_float( b, 222);
	h->tot_avg_uncor = get_vax_float( b, 224);
	h->total_coin_rate = get_vax_long( b, 226);
	h->frame_start_time = get_vax_long( b, 228);
	h->frame_duration = get_vax_long( b, 230);
	h->loss_correction_fctr = get_vax_float( b, 232);
	for (i=0; i<8; i++)
	  h->phy_planes[i] = get_vax_long( b, 234+(2*i));
d433 6
a438 3
	/*********************************************************/
	int mat_read_image_subheader( fptr, blknum, h)
	  FILE *fptr; int blknum; Image_subheader *h;
d440 4
a443 4
	short int b[256];
	int i, err;
	float get_vax_float();
	char *bb;
d445 7
a451 3
	err = mat_rblk( fptr, blknum, b, 1);
	if (err) return(err);
	bb = (char *)b;
d453 3
a455 3
	strncpy( h->annotation, b+420, 40);
	*/
	strncpy( h->annotation, bb+420, 40);
d461 4
a464 4
	h->x_origin = get_vax_float( b, 80);
	h->y_origin = get_vax_float( b, 82);
	h->recon_scale = get_vax_float( b, 84);
	h->quant_scale = get_vax_float( b, 86);
d467 4
a470 4
	h->pixel_size = get_vax_float( b, 92);
	h->slice_width = get_vax_float( b, 94);
	h->frame_duration = get_vax_long( b, 96);
	h->frame_start_time = get_vax_long( b, 98);
d475 1
a475 1
	h->recon_duration = get_vax_long( b, 104);
d477 8
a484 8
	h->scan_matrix_num = get_vax_long( b, 119);
	h->norm_matrix_num = get_vax_long( b, 121);
	h->atten_cor_matrix_num = get_vax_long( b, 123);
	h->image_rotation = get_vax_float( b, 148);
	h->plane_eff_corr_fctr = get_vax_float( b, 150);
	h->decay_corr_fctr = get_vax_float( b, 152);
	h->loss_corr_fctr = get_vax_float( b, 154);
	h->intrinsic_tilt = get_vax_float( b, 156);
d490 4
a493 4
	h->ecat_calibration_fctr = get_vax_float( b, 194);
	h->well_counter_cal_fctr = get_vax_float( b, 196);
	for (i=0; i<6; i++)
	  h->filter_params[i] = get_vax_float( b, 198+2*i);
d497 4
a500 3
	/*********************************************************/
	float get_vax_float( bufr, off)
	  unsigned short bufr[]; int off;
d502 5
a506 2
	unsigned short t1, t2;
	union {unsigned long t3; float t4;} test;
d508 2
a509 1
	if (bufr[off]==0 && bufr[off+1]==0) return(0.0);
d511 4
a514 4
	t2=(((bufr[off])&0x7f00)+0xff00)&0x7f00;
	test.t3 = (t1+t2)<<16;
	test.t3 =test.t3+bufr[off+1];
	return(test.t4);
d517 4
a520 3
	/*********************************************************/
	int get_vax_long( bufr, off)
	  unsigned short bufr[]; int off;
d522 1
a522 1
	return ((bufr[off+1]<<16)+bufr[off]);
d524 1
a524 1
  
d526 6
a531 5
mat_read_dir( fptr, selector)
  FILE *fptr;
  char *selector;
{	int i, n, blk, nxtblk, ndblks, bufr[128];
	Mat_dir dir;
d535 6
a540 7
	for (ndblks=0; nxtblk != MatFirstDirBlk; ndblks++)
	{
	  mat_rblk( fptr, blk, bufr, 1);
	  swap_byte (bufr, bufr, 8);
	  swaw( bufr, bufr, 4);
	  nxtblk = bufr[1];
	  blk = nxtblk;
d542 1
a542 1
	dir = (Mat_dir) malloc( sizeof(struct matdir));
d545 14
a558 14
	dir->entry = (struct MatDir *) malloc( 31*ndblks*sizeof( struct MatDir));
	for (n=0, nxtblk=0, blk=MatFirstDirBlk; nxtblk != MatFirstDirBlk; blk = nxtblk)
	{
	  mat_rblk( fptr, blk, bufr, 1);
	  swap_byte (bufr, bufr, 512);
	  swaw (bufr, bufr, 256);
	  nxtblk = bufr[1];
	  for (i=4; i<MatBLKSIZE/4; n++)
	  { dir->entry[n].matnum = bufr[i++];
	    dir->entry[n].strtblk = bufr[i++];
	    dir->entry[n].endblk = bufr[i++];
	    dir->entry[n].matstat = bufr[i++];
	    if (dir->entry[n].matnum != 0) dir->nmats++;
	  }
d565 4
a568 4
int mat_wblk( fptr, blkno, bufr, nblks)
FILE *fptr;
int blkno, nblks;
char *bufr;
d570 1
a570 4
  int err, fseek(); 
  /*
  int fread();
  */
d572 6
a577 3
  /* seek to position in file */
  err = fseek( fptr, (blkno-1)*MatBLKSIZE, 0);
  if (err) return (err);
d579 7
a585 4
  /* write matrix data */
  err = fwrite( bufr, 1, nblks*MatBLKSIZE, fptr);
  if (err != nblks*MatBLKSIZE) return (-1);
  return (0);
d588 3
a590 3
FILE *mat_create( fname, mhead)
  char *fname;
  Main_header *mhead;
d592 2
a593 2
	FILE *fptr;
	int i, *bufr;
d595 7
a601 6
	fptr = mat_open( fname, "w+");
	if (!fptr) return fptr;
	mat_write_main_header( fptr, mhead);
	bufr = (int*) malloc( MatBLKSIZE);
	for (i=0; i<128; i++)
	  bufr[i] = 0;
d604 1
a604 1
	swaw( bufr, bufr, 256);
d606 2
a607 2
	mat_wblk( fptr, MatFirstDirBlk, bufr, 1);
	free( bufr);
d611 3
a613 2
int mat_enter( fptr, matnum, nblks)
  FILE *fptr; int matnum, nblks;
d616 2
a617 2
	struct MatDir entry;
	int dirblk, dirbufr[128], i, nxtblk, busy, oldsize;
d620 1
a620 1
	mat_rblk( fptr, dirblk, dirbufr, 1);
d622 1
a622 1
	swaw( dirbufr, dirbufr, 256);
d625 45
a669 27
	nxtblk = dirblk+1;
	for (i=4; i<128; i+=4)
	{
	  if (dirbufr[i] == 0) 
	  { busy = 0;
	    break;
	  }
	  else if (dirbufr[i] == matnum)
	  { oldsize = dirbufr[i+2]-dirbufr[i+1]+1;
	    if (oldsize < nblks)
	    { dirbufr[i] = 0xFFFFFFFF;
	      swaw( dirbufr, dirbufr, 256);
	      swap_byte (dirbufr, dirbufr, 512);
	      mat_wblk( fptr, dirblk, dirbufr, 1);
	      swap_byte (dirbufr, dirbufr, 512);
	      swaw( dirbufr, dirbufr, 256);
	      nxtblk = dirbufr[i+2]+1;
	    }
	    else
	    { nxtblk = dirbufr[i+1];
	      dirbufr[0]++;
	      dirbufr[3]--;
	      busy = 0;
	      break;
	    }
	  }
	  else nxtblk = dirbufr[i+2]+1;
a670 19
	if (!busy) break;
	if (dirbufr[1] != MatFirstDirBlk)
	{ dirblk = dirbufr[1];
	  mat_rblk( fptr, dirblk, dirbufr, 1);
	  swap_byte (dirbufr, dirbufr, 512);
	  swaw( dirbufr, dirbufr, 256);
	} else
	{ dirbufr[1] = nxtblk;
	  swaw( dirbufr, dirbufr, 256);
	  swap_byte (dirbufr, dirbufr, 512);
	  mat_wblk( fptr, dirblk, dirbufr, 1);
	  dirbufr[0] = 31;
	  dirbufr[1] = MatFirstDirBlk;
	  dirbufr[2] = dirblk;
	  dirbufr[3] = 0;
	  dirblk = nxtblk;
	  for (i=4; i<128; i++) dirbufr[i] = 0;
	 }
	}
d672 3
a674 3
	dirbufr[i+1] = nxtblk;
	dirbufr[i+2] = nxtblk + nblks;
	dirbufr[i+3] = 1;
d677 1
a677 1
	swaw( dirbufr, dirbufr, 256);
d679 1
a679 1
	mat_wblk( fptr, dirblk, dirbufr, 1);
d683 6
a688 6
mat_write_image( fptr, matnum, header, data, data_size)
  FILE *fptr;
  int matnum;
  Image_subheader *header;
  unsigned short int *data;
  int data_size;
d690 1
a690 1
	int nxtblk, size, error ;
d692 7
a698 7
	size = (data_size+511)/512;
	nxtblk = mat_enter( fptr, matnum, size);
	mat_write_image_subheader( fptr, nxtblk, header);
        error = write_matrix_data(fptr, nxtblk+1, size,
		                  (char*)data,
	                          header->data_type) ;	
	return(error) ;
d701 6
a706 6
mat_write_scan( fptr, matnum, header, data, data_size)
  FILE *fptr;
  int matnum;
  Scan_subheader *header;
  unsigned short int *data;
  int data_size;
d708 1
a708 1
	int nxtblk, size, error ;
d710 7
a716 7
	size = (data_size+511)/512;
	nxtblk = mat_enter( fptr, matnum, size);
	mat_write_scan_subheader( fptr, nxtblk, header);
        error = write_matrix_data(fptr, nxtblk+1, size,
		                  (char*)data,
	                          header->data_type) ;	
	return(error) ;
d719 6
a724 6
mat_write_attn( fptr, matnum, header, data, data_size)
  FILE *fptr;
  int matnum;
  Attn_subheader *header;
  float *data;
  int data_size;
d726 1
a726 1
	int nxtblk, size, error ;
d728 7
a734 7
	size = (data_size+511)/512;
	nxtblk = mat_enter( fptr, matnum, size);
	mat_write_attn_subheader( fptr, nxtblk, header);
        error = write_matrix_data (fptr, nxtblk+1, size,
		                   (char*)data,
	                           header->data_type) ;	
	return(error) ;
d737 6
a742 6
mat_write_norm( fptr, matnum, header, data, data_size)
  FILE *fptr;
  int matnum;
  Norm_subheader *header;
  float *data;
  int data_size;
d744 1
a744 1
	int nxtblk, size, error ;
d746 7
a752 7
	size = (data_size+511)/512;
	nxtblk = mat_enter( fptr, matnum, size);
	mat_write_norm_subheader( fptr, nxtblk, header);
        error = write_matrix_data(fptr, nxtblk+1, size,
		                  (char*)data,
	                          header->data_type) ;	
	return(error) ;
d755 4
a758 4
mat_write_idata( fptr, blk, data, size)
  FILE *fptr;
  int blk, size;
  unsigned char *data;
d760 2
a761 2
	unsigned char bufr[512];
	int i, nbytes, nblks;
d763 8
a770 9
	nblks = (size+511)/512;
	for (i=0; i<nblks; i++)
	{
	  nbytes = (size < 512) ? size: 512;
	  bcopy( data, bufr, nbytes);
	  swap_byte (bufr, bufr, 512);
	  mat_wblk( fptr, blk+i, bufr, 1);
	  data += nbytes;
	  size -= nbytes;
d775 4
a778 4
mat_write_fdata( fptr, blk, data, size)
  FILE *fptr;
  int blk, size;
  float *data;
d780 2
a781 2
	float bufr[128];
	int i, j, nvals, nblks;
d783 8
a790 9
	nblks = (size+511)/512;
	for (i=0; i<nblks; i++)
	{
	  nvals = (size < 512) ? size/4: 512/4;
	  for (j=0; j<nvals; j++)
	    sunftovaxf( *data++, &bufr[j]);
	  swap_byte (bufr, bufr, 512);
	  mat_wblk( fptr, blk+i, bufr, 1);
	  size -= 4*nvals;
d794 3
a796 2
matrix_selector( matnum, ranges)
  int matnum, ranges[2][5];
d798 1
a798 1
	struct Matval m;
d800 1
a800 1
	mat_numdoc( matnum, &m);
d802 2
a803 1
	  if (m.frame < ranges[0][0] || m.frame > ranges[1][0]) return (0);
d805 2
a806 1
	  if (m.plane < ranges[0][1] || m.plane > ranges[1][1]) return (0);
d808 2
a809 1
	  if (m.gate  < ranges[0][2] || m.gate  > ranges[1][2]) return (0);
d811 2
a812 1
	  if (m.data  < ranges[0][3] || m.data  > ranges[1][3]) return (0);
d814 2
a815 1
	  if (m.bed   < ranges[0][4] || m.bed   > ranges[1][4]) return (0);
d819 6
a824 4
decode_selector( s1, ranges)
  char *s1; int ranges[2][5];
{	char xword[16], *next_word();
	int i;
d826 12
a837 11
	fix_selector( s1, s1);
	for (i=0;i<5;i++)	/* set all ranges to all (-1) */
	{ ranges[0][i]=ranges[1][i]=-1;
	  s1 = next_word( s1, xword);
	  if (xword[0] == '*') continue;
	  else if (strchr(xword,':'))
	    sscanf(xword,"%d:%d",&ranges[0][i],&ranges[1][i]);
	  else
	  { sscanf(xword,"%d",&ranges[0][i]);
	    ranges[1][i]=ranges[0][i];
	  };
d842 2
a843 2
str_find( s1, s2)
  char *s1, *s2;
d845 1
a845 1
	int i, j, k;
d847 4
a850 3
	for (i=0;s1[i];i++) {
	  for (j=i,k=0; s2[k]!='\0' && s1[j]==s2[k]; j++, k++) ;
	  if (s2[k]=='\0') return (i);
d854 2
a855 2
str_replace( s1, s2, s3, s4)
  char *s1, *s2, *s3, *s4;
d857 1
a857 1
	int nf=0, n;
d860 10
a869 10
	while (1)
	{ if ((n=str_find(s2, s3))==-1)
	  { strcat(s1, s2);
	    return (nf);
	  } else
	  { strncat(s1, s2, n);
	    strcat(s1, s4);
	    s2+= n+strlen(s3);
	    nf++;
	  }
d873 2
a874 2
string_replace( s1, s2, s3, s4)
  char *s1, *s2, *s3, *s4;
d876 1
a876 1
	char temp[256];
d878 3
a880 3
	strcpy(temp, s2);
	while (str_replace(s1, temp, s3, s4) > 0)
	  strcpy(temp, s1);
d882 1
a882 1
}	
d884 2
a885 2
fix_selector( s1, s2)
  char *s1, *s2;
d887 10
a896 9
	char temp[256];
	string_replace(temp, s2, "," , " ");
	string_replace(s1, temp, "..", ":");
	string_replace(temp, s1, ".", ":");
	string_replace(s1, temp, "-", ":");
	string_replace(temp, s1, "**", "*");
	string_replace(s1, temp, "  ", " ");
	string_replace(temp, s1, " :", ":");
	string_replace(s1, temp, ": ", ":");
d900 2
a901 2
char* next_word(s, w)
  char *s, *w;
d903 5
a907 3
	while (*s && *s!=' ') *w++=*s++;
	*w='\0';
	if (*s) s++;
d915 3
a917 4
sunftovaxf(orig,number)

unsigned short number[2];
float orig;
d920 1
a920 1
  /* convert from sun float to vax float */
d922 5
a926 5
  union {
 	  unsigned short t[2]; 
	  float t4;
        } test ;
  unsigned short int exp;
d928 2
a929 2
  number[0] = 0;
  number[1] = 0;
d931 3
a933 3
  test.t4 = orig;
  if (test.t4 == 0.0)
    return;
d935 1
a935 1
  number[1] = test.t[1];
d937 2
a938 2
  exp = ((test.t[0] & 0x7f00) + 0x0100) & 0x7f00;
  test.t[0] = (test.t[0] & 0x80ff) + exp;
d940 2
a941 2
  number[0] = test.t[0];
  return 0;
d946 3
a948 2
int mat_write_main_header( fptr, header)
FILE *fptr; Main_header *header;
d950 3
a952 3
  char *bbufr;
  short int bufr[256];
  int err,i, loc;
d954 3
a956 3
  for (i=0; i<256; i++)
    bufr[i] = 0;
  bbufr = (char *) bufr;
d958 42
a999 43
  bufr[24] = header->sw_version;
  bufr[25] = header->data_type;
  bufr[26] = header->system_type;
  bufr[27] = header->file_type;
  bufr[33] = header->scan_start_day;
  bufr[34] = header->scan_start_month;
  bufr[35] = header->scan_start_year;
  bufr[36] = header->scan_start_hour;
  bufr[37] = header->scan_start_minute;
  bufr[38] = header->scan_start_second;
  sunftovaxf (header->isotope_halflife, &bufr[43]);
  sunftovaxf (header->gantry_tilt, &bufr[61]);
  sunftovaxf (header->gantry_rotation, &bufr[63]);
  sunftovaxf (header->bed_elevation, &bufr[65]);
  bufr[67] = header->rot_source_speed;
  bufr[68] = header->wobble_speed;
  bufr[69] = header->transm_source_type;
  sunftovaxf (header->axial_fov, &bufr[70]);
  sunftovaxf (header->transaxial_fov, &bufr[72]);
  bufr[74] = header->transaxial_samp_mode;
  bufr[75] = header->coin_samp_mode;
  bufr[76] = header->axial_samp_mode;
  sunftovaxf (header->calibration_factor, &bufr[77]);
  bufr[79] = header->calibration_units;
  bufr[80] = header->compression_code;
  bufr[175] = header->acquisition_type;
  bufr[176] = header->bed_type;
  bufr[177] = header->septa_type;
  bufr[188] = header->num_planes;
  bufr[189] = header->num_frames;
  bufr[190] = header->num_gates;
  bufr[191] = header->num_bed_pos;
  sunftovaxf (header->init_bed_position, &bufr[192]);
  for (i=0; i<15; i++)
  {
    sunftovaxf (header->bed_offset[i], &bufr[194+2*i]);
  }
  sunftovaxf (header->plane_separation, &bufr[224]);
  bufr[226] = header->lwr_sctr_thres;
  bufr[227] = header->lwr_true_thres;
  bufr[228] = header->upr_true_thres;
  sunftovaxf (header->collimator, &bufr[229]);
  bufr[236] = header->acquisition_mode;
d1001 1
a1001 1
  swap_byte (bufr, bufr, MatBLKSIZE);
d1003 33
a1035 33
  bcopy( header->original_file_name, bbufr+28, 20);
  /* write the node_id - character string */
  bcopy( header->node_id, bbufr+56, 10);
  /* write the isotope code - char string */
  bcopy( header->isotope_code, bbufr+78, 8);
  /* write the radiopharmaceutical  - char string */
  bcopy( header->radiopharmaceutical, bbufr+90, 32);
  /* study_name - char string */
  bcopy( header->study_name, bbufr+162, 12);
  /* patient_id - char string */
  bcopy( header->patient_id, bbufr+174, 16);
  /* patient_name - char string */
  bcopy( header->patient_name, bbufr+190, 32);
  /* patient_sex - char */
  bbufr[222] = header->patient_sex;
  /* patient_age - char string */
  bcopy( header->patient_age, bbufr+223, 10);
  /* patient_height  - char string */
  bcopy( header->patient_height, bbufr+233, 10);
  /* patient_weight - char string */
  bcopy( header->patient_weight, bbufr+243, 10);
  /* patient_dexterity - char */
  bbufr[253] = header->patient_dexterity;
  /* physician_name - char string */
  bcopy( header->physician_name, bbufr+254, 32);
  /* operator_name - char string */
  bcopy( header->operator_name, bbufr+286, 32);
  /* study_description - char string */
  bcopy( header->study_description, bbufr+318, 32);
  /* facility_name */ 
  bcopy( header->facility_name, bbufr+356, 20);
  /* user_process_code  - char string */
  bcopy( header->user_process_code, bbufr+462, 10);
d1037 6
a1042 4
  err = mat_wblk( fptr, 1, bufr, 1);	/* write main header at block 1 */
  if (err) return(err);

  return (0);
d1047 4
a1050 2
int mat_write_image_subheader( fptr, blknum, header)
FILE *fptr; int blknum; Image_subheader *header;
d1052 3
a1054 3
  char *bbufr;
  short int bufr[256];
  int i, err;
d1056 39
a1094 39
  for (i=0; i<256; i++)
    bufr[i] = 0;
  bbufr = (char *) bufr;
  /* transfer subheader information */
  bufr[63] = header->data_type;
  bufr[64] = header->num_dimensions;
  bufr[66] = header->dimension_1;
  bufr[67] = header->dimension_2;
  sunftovaxf(header->x_origin, &bufr[80]);
  sunftovaxf(header->y_origin, &bufr[82]);
  sunftovaxf(header->recon_scale, &bufr[84]);
  sunftovaxf(header->quant_scale, &bufr[86]);
  bufr[88] = header->image_min;
  bufr[89] = header->image_max;
  sunftovaxf(header->pixel_size, &bufr[92]);
  sunftovaxf(header->slice_width, &bufr[94]);
  sunltovaxl(header->frame_duration, &bufr[96]);
  sunltovaxl(header->frame_start_time, &bufr[98]);
  bufr[100] = header->slice_location;
  bufr[101] = header->recon_start_hour;
  bufr[102] = header->recon_start_minute;
  bufr[103] = header->recon_start_sec;
  sunltovaxl(header->recon_duration, &bufr[104]);
  bufr[118] = header->filter_code;
  sunltovaxl(header->scan_matrix_num, &bufr[119]);
  sunltovaxl(header->norm_matrix_num, &bufr[121]);
  sunltovaxl(header->atten_cor_matrix_num, &bufr[123]);
  sunftovaxf(header->image_rotation, &bufr[148]);
  sunftovaxf(header->plane_eff_corr_fctr, &bufr[150]);
  sunftovaxf(header->decay_corr_fctr, &bufr[152]);
  sunftovaxf(header->loss_corr_fctr, &bufr[154]);
  sunftovaxf(header->intrinsic_tilt, &bufr[156]);
  bufr[188] = header->processing_code;
  bufr[190] = header->quant_units;
  bufr[191] = header->recon_start_day;
  bufr[192] = header->recon_start_month;
  bufr[193] = header->recon_start_year;
  sunftovaxf(header->ecat_calibration_fctr, &bufr[194]);
  sunftovaxf(header->well_counter_cal_fctr, &bufr[196]);
d1096 2
a1097 2
  for (i=0; i<6; i++)
    sunftovaxf(header->filter_params[i], &bufr[198+2*i]);
d1099 2
a1100 2
  /* swap the bytes */
  swap_byte ( bufr, bufr, MatBLKSIZE);
d1102 1
a1102 1
  strcpy (bbufr+420, header->annotation);
d1104 7
a1110 5
  /* write to matrix file */
  err = mat_wblk( fptr, blknum, bbufr, 1);
  if (err) return(err);

  return(0);
d1114 3
a1116 3
sunltovaxl( in, out)
  int in;
  unsigned short int out[2];
d1118 2
a1119 2
	out[0]=(in&0x0000FFFF);
	out[1]=(in&0xFFFF0000)>>16;
d1124 4
a1127 4
int mat_write_scan_subheader( fptr, blknum, header)
  FILE *fptr; 
  int blknum; 
  Scan_subheader *header;
d1129 4
a1132 4
  	short int bufr[256];
  	int i, err;
  
  	for (i=0; i<256; bufr[i++]=0);
d1145 1
a1145 1
 	bufr[78] = 27;
d1149 31
a1179 35
 	bufr[63] = header->data_type;
  	bufr[66] = header->dimension_1;			/* x dimension */
  	bufr[67] = header->dimension_2;			/* y_dimension */
  	bufr[68] = header->smoothing;			
  	bufr[69] = header->processing_code;			
  	sunftovaxf(header->sample_distance, &bufr[73]);
  	sunftovaxf(header->isotope_halflife, &bufr[83]);
  	bufr[85] = header->frame_duration_sec;
  	sunltovaxl(header->gate_duration, &bufr[86]);
  	sunltovaxl(header->r_wave_offset, &bufr[88]);
  	sunftovaxf(header->scale_factor, &bufr[91]);
  	bufr[96] = header->scan_min;
  	bufr[97] = header->scan_max;
  	sunltovaxl(header->prompts, &bufr[98]);
  	sunltovaxl(header->delayed, &bufr[100]);
  	sunltovaxl(header->multiples, &bufr[102]);
  	sunltovaxl(header->net_trues, &bufr[104]);
  	for (i=0; i<16; i++)
  	{
    	  sunftovaxf(header->cor_singles[i], &bufr[158+2*i]);
  	  sunftovaxf(header->uncor_singles[i], &bufr[190+2*i]);
 	};
  	sunftovaxf(header->tot_avg_cor, &bufr[222]);
  	sunftovaxf(header->tot_avg_uncor, &bufr[224]);
  	sunltovaxl(header->total_coin_rate, &bufr[226]);		/* total coin rate */
  	sunltovaxl(header->frame_start_time, &bufr[228]);
  	sunltovaxl(header->frame_duration, &bufr[230]);
  	sunftovaxf(header->loss_correction_fctr, &bufr[232]);
  	for (i=0; i<8; i++)
    	  sunltovaxl(header->phy_planes[i], &bufr[234+2*i]);


  	swap_byte (bufr, bufr, MatBLKSIZE);

  	err = mat_wblk( fptr, blknum, bufr, 1);
d1183 4
a1186 4
int mat_write_attn_subheader( fptr, blknum, header)
  FILE *fptr;
  int blknum;
  Attn_subheader *header;
d1188 4
a1191 4
	short int bufr[256];
	int i,err;
	
	for (i=0; i<256; bufr[i++]=0);
d1204 1
a1204 1
 	bufr[78] = 27;
d1212 8
a1219 8
	sunftovaxf( header->scale_factor, &bufr[91]);
	sunftovaxf( header->x_origin, &bufr[93]);
	sunftovaxf( header->y_origin, &bufr[95]);
	sunftovaxf( header->x_radius, &bufr[97]);
	sunftovaxf( header->y_radius, &bufr[99]);
	sunftovaxf( header->tilt_angle, &bufr[101]);
	sunftovaxf( header->attenuation_coeff, &bufr[103]);
	sunftovaxf( header->sample_distance, &bufr[105]);
d1221 1
a1221 1
	err = mat_wblk( fptr, blknum, bufr, 1);
d1225 4
a1228 4
int mat_write_norm_subheader( fptr, blknum, header)
  FILE *fptr;
  int blknum;
  Norm_subheader *header;
d1230 2
a1231 2
	short int bufr[256];
	int i,err;
d1233 1
a1233 1
	for (i=0; i<256; bufr[i++]=0);
d1246 1
a1246 1
 	bufr[78] = 27;
d1253 1
a1253 1
	sunftovaxf( header->scale_factor, &bufr[91]);
d1260 2
a1261 2
	sunftovaxf( header->fov_source_width, &bufr[99]);
	sunftovaxf( header->ecat_calib_factor, &bufr[101]);
d1263 1
a1263 1
	err = mat_wblk( fptr, blknum, bufr, 1);
d1267 4
a1270 4
int mat_read_attn_subheader( fptr, blknum, header)
FILE *fptr; 
int blknum; 
Attn_subheader *header;
d1272 3
a1274 3
	short int bufr[256];
	int i, err, get_vax_long();
	float get_vax_float();
d1276 5
a1280 2
	err = mat_rblk( fptr, blknum, bufr, 1);
	if (err) return(err);
d1287 8
a1294 8
	header->scale_factor = get_vax_float(bufr, 91);
	header->x_origin = get_vax_float(bufr, 93);
	header->y_origin = get_vax_float(bufr, 95);
	header->x_radius = get_vax_float(bufr, 97);
	header->y_radius = get_vax_float(bufr, 99);
	header->tilt_angle = get_vax_float(bufr, 101);
	header->attenuation_coeff = get_vax_float(bufr, 103);
	header->sample_distance = get_vax_float(bufr, 105);
d1298 4
a1301 2
	int mat_read_norm_subheader( fptr, blknum, header)
	  FILE *fptr; int blknum; Norm_subheader *header;
d1303 3
a1305 3
	short int bufr[256];
	int i, err, get_vax_long();
	float get_vax_float();
d1307 5
a1311 2
	err = mat_rblk( fptr, blknum, bufr, 1);
	if (err) return(err);
d1317 1
a1317 1
	header->scale_factor = get_vax_float(bufr, 91);
d1324 2
a1325 2
	header->fov_source_width = get_vax_float(bufr, 99);
	header->ecat_calib_factor = get_vax_float(bufr, 101);
@


1.4
log
@Change from id to header.
@
text
@d1 1
a1 1
/*$Id: matrix.c,v 1.3 1993/09/13 18:55:37 ty7777 Exp ty7777 $*/
d3 3
d18 1
a18 1
#include <petutil/matrix.h>
d23 1
a23 1
static char rcsid [] = "$Header$";
@


1.3
log
@Introduce acsid and change matrix.h to petutil/matrix.h.
@
text
@d1 1
a1 1
/*$Id: matrix.c,v 1.2 1993/06/17 17:29:55 ty7777 Exp ty7777 $*/
d3 3
d20 1
a20 1
static char rcsid [] = "$Id$";
@


1.2
log
@Checking in.
@
text
@d1 1
a1 1
/*$Id: matrix.c,v 1.1 1993/03/04 19:46:55 ty7777 Exp $*/
d3 3
d12 1
a12 1
#include	"matrix.h"
d17 1
@


1.1
log
@Initial revision
@
text
@d1 5
a5 2
/*$Id$*/
/*$Log$*/
d400 1
d402 2
@
