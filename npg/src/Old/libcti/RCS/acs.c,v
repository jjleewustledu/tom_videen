head	1.7;
access;
symbols;
locks; strict;
comment	@ * @;


1.7
date	99.12.13.22.02.19;	author tom;	state Exp;
branches;
next	1.6;

1.6
date	96.09.25.16.28.32;	author tom;	state Exp;
branches;
next	1.5;

1.5
date	95.10.30.16.49.06;	author tom;	state Exp;
branches;
next	1.4;

1.4
date	94.03.03.17.13.26;	author ty7777;	state Exp;
branches;
next	1.3;

1.3
date	93.09.13.18.50.29;	author ty7777;	state Exp;
branches;
next	1.2;

1.2
date	93.03.04.19.38.27;	author ty7777;	state Exp;
branches;
next	1.1;

1.1
date	93.01.28.15.27.09;	author ty7777;	state Exp;
branches;
next	;


desc
@Working version.
@


1.7
log
@partially cleaned up with lint
@
text
@/*$Id: acs.c,v 1.6 1996/09/25 16:28:32 tom Exp tom $*/
/*$Log: acs.c,v $
 * Revision 1.6  1996/09/25  16:28:32  tom
 * build in Solaris 2
 *
 * Revision 1.5  1995/10/30  16:49:06  tom
 * changed petutil/matrix.h to matrix.h
 *
 * Revision 1.4  1994/03/03  17:13:26  ty7777
 * Changed id to header.
 *
 * Revision 1.3  1993/09/13  18:50:29  ty7777
 * Introduce acsid and change matrix.h to petutil/matrix.h.
 *
 * Revision 1.2  1993/03/04  19:38:27  ty7777
 * Working version of acs.c, Modified to get rid of sunview libraries.
 **/


/*    @@(#)acs.c	2.9    4/24/92    */

/* acs.c	twjansto	09 jun 1990 */

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <rpc/rpc.h>
#include <signal.h>
#include <errno.h>
#include <sys/time.h>
#include <sys/types.h>
#include <sys/stat.h>
#include "ecatAcs.h"
#include <matrix.h>

#ifndef lint
static char     rcsid[] = "$Header: /home/npggw/tom/src/libcti/RCS/acs.c,v 1.6 1996/09/25 16:28:32 tom Exp tom $";
#endif

#define RECON_PROGRAM ((u_long)600000002)

void            ecatQuitHandler ();

int             rts_allocate ()
{
	int             resp;

	/*
	 * int getpid ();
	 */
	enum clnt_stat  rpcStatus;

	ButtonId        acsButton;

	acsButton.requestorPid = getpid ();
	acsButton.requestedNode = (char *) malloc (32);
	printf ("Use defaults_get_string\n");
/*
    strcpy (acsButton.requestedNode,
	defaults_get_string ("/Ecat/EcatAcqServer", "localhost", 0));
*/
	rpcStatus = callrpc ("localhost", ECAT_ACS_SERVER, ECAT_ACS_VERSION,
			     ACS_ALLOCATE, xdr_ButtonId, &acsButton, xdr_int, &resp);
	if (rpcStatus != (int) RPC_SUCCESS && rpcStatus != RPC_TIMEDOUT) {
		fprintf (stderr, "rts_allocate: callrpc failed\n");
		clnt_perrno (rpcStatus);
		free (acsButton.requestedNode);
		return (FALSE);
	}
	if (resp) {
		if (isatty (STDIN_FILENO)) {	 /* check if this is a background process */
			signal (SIGINT, ecatQuitHandler);
			signal (SIGQUIT, ecatQuitHandler);
		}
	}
	free (acsButton.requestedNode);
	return (resp);
}

int             rts_deallocate ()
{

	/*
	 * int getpid ();
	 */
	enum clnt_stat  rpcStatus;

	ButtonId        acsButton;

	acsButton.requestorPid = getpid ();
	acsButton.requestedNode = (char *) malloc (32);
	printf ("Use defaults_get_string\n");
/*
    strcpy (acsButton.requestedNode,
	defaults_get_string ("/Ecat/EcatAcqServer", "localhost", 0));
*/
	rpcStatus = callrpc ("localhost", ECAT_ACS_SERVER, ECAT_ACS_VERSION,
			     ACS_DEALLOCATE, xdr_ButtonId, &acsButton, xdr_void, (char *) NULL);
	if (rpcStatus != (int) RPC_SUCCESS && rpcStatus != RPC_TIMEDOUT) {
		fprintf (stderr, "rts_deallocate: callrpc failed\n");
		clnt_perrno (rpcStatus);
		free (acsButton.requestedNode);
		return (FALSE);
	}
	free (acsButton.requestedNode);
	return (TRUE);
}

int             mcs_allocate ()
{
	int             resp;

	/*
	 * int getpid ();
	 */
	enum clnt_stat  rpcStatus;

	ButtonId        mcsButton;

	mcsButton.requestorPid = getpid ();
	mcsButton.requestedNode = (char *) malloc (32);
	printf ("Use defaults_get_string\n");
/*
    strcpy (mcsButton.requestedNode,
	defaults_get_string ("/Ecat/EcatAcqServer", "localhost", 0));
*/
	rpcStatus = callrpc ("localhost", ECAT_ACS_SERVER, ECAT_ACS_VERSION,
			     MCS_ALLOCATE, xdr_ButtonId, &mcsButton, xdr_int, &resp);
	if (rpcStatus != (int) RPC_SUCCESS && rpcStatus != RPC_TIMEDOUT) {
		fprintf (stderr, "mcs_allocate: callrpc failed\n");
		clnt_perrno (rpcStatus);
		free (mcsButton.requestedNode);
		return (FALSE);
	}
	if (resp) {
		if (isatty (STDIN_FILENO)) {	 /* check if this is a background process */
			signal (SIGINT, ecatQuitHandler);
			signal (SIGQUIT, ecatQuitHandler);
		}
	}
	free (mcsButton.requestedNode);
	return (resp);
}

int             mcs_deallocate ()
{

	/*
	 * int getpid ();
	 */
	enum clnt_stat  rpcStatus;

	ButtonId        mcsButton;

	mcsButton.requestorPid = getpid ();
	mcsButton.requestedNode = (char *) malloc (32);
	printf ("Use defaults_get_string\n");
/*
    strcpy (mcsButton.requestedNode,
	defaults_get_string ("/Ecat/EcatAcqServer", "localhost", 0));
*/
	rpcStatus = callrpc ("localhost", ECAT_ACS_SERVER, ECAT_ACS_VERSION,
			     MCS_DEALLOCATE, xdr_ButtonId, &mcsButton, xdr_void, (char *) NULL);
	if (rpcStatus != (int) RPC_SUCCESS && rpcStatus != RPC_TIMEDOUT) {
		fprintf (stderr, "mcs_deallocate: callrpc failed\n");
		clnt_perrno (rpcStatus);
		free (mcsButton.requestedNode);
		return (FALSE);
	}
	free (mcsButton.requestedNode);
	return (TRUE);
}

void            ecatQuitHandler (signal, code, scp)
	int             signal, code;
	struct sigcontext *scp;
{
	printf ("\nIn ecatQuitHandler, caught a quit!!!\n");
	rts_deallocate ();
	mcs_deallocate ();
	exit (0);
}

int             isFrameTransferred (frame)
	int             frame;
{
	int             resp, checkFrame = frame;

	enum clnt_stat  rpcStatus;

	ButtonId        acsButton;


	acsButton.requestorPid = frame;
	acsButton.requestedNode = (char *) malloc (32);
	printf ("Use defaults_get_string\n");
/*
    strcpy (acsButton.requestedNode,
	defaults_get_string ("/Ecat/EcatAcqServer", "localhost", 0));
*/
	rpcStatus = callrpc ("localhost", ECAT_ACS_SERVER, ECAT_ACS_VERSION,
			     IS_THIS_FRAME_TRANSFERRED, xdr_ButtonId, &acsButton, xdr_int, &resp);
	if (rpcStatus != (int) RPC_SUCCESS && rpcStatus != RPC_TIMEDOUT) {
		fprintf (stderr, "frame_transferred: callrpc failed\n");
		clnt_perrno (rpcStatus);
		free (acsButton.requestedNode);
		return (FALSE);
	}
	if (!resp)
		sleep (7);
	free (acsButton.requestedNode);
	return (resp);
}

int             isFrameAcquired (frame)
	int             frame;
{
	int             resp, checkFrame = frame;

	enum clnt_stat  rpcStatus;

	ButtonId        acsButton;

	acsButton.requestorPid = frame;
	acsButton.requestedNode = (char *) malloc (32);
	printf ("Use defaults_get_string\n");
/*
    strcpy (acsButton.requestedNode,
	defaults_get_string ("/Ecat/EcatAcqServer", "localhost", 0));
*/
	rpcStatus = callrpc ("localhost", ECAT_ACS_SERVER, ECAT_ACS_VERSION,
			     IS_THIS_FRAME_COMPLETE, xdr_ButtonId, &acsButton, xdr_int, &resp);
	if (rpcStatus != (int) RPC_SUCCESS && rpcStatus != RPC_TIMEDOUT) {
		fprintf (stderr, "frameComplete: callrpc failed\n");
		clnt_perrno (rpcStatus);
		free (acsButton.requestedNode);
		return (FALSE);
	}
	if (!resp)
		sleep (7);
	free (acsButton.requestedNode);
	return (resp);
}

int             resetFrameTransferred ()
{
	int             resp;

	enum clnt_stat  rpcStatus;

	ButtonId        acsButton;

	acsButton.requestorPid = 0;
	acsButton.requestedNode = (char *) malloc (32);
	printf ("Use defaults_get_string\n");
/*
    strcpy (acsButton.requestedNode,
	defaults_get_string ("/Ecat/EcatAcqServer", "localhost", 0));
*/
	rpcStatus = callrpc ("localhost", ECAT_ACS_SERVER, ECAT_ACS_VERSION,
		      RESET_FRAME_TRANSFERRED, xdr_ButtonId, &acsButton, xdr_void, (char *) NULL);
	if (rpcStatus != (int) RPC_SUCCESS && rpcStatus != RPC_TIMEDOUT) {
		fprintf (stderr, "resetFrame: callrpc failed\n");
		clnt_perrno (rpcStatus);
		free (acsButton.requestedNode);
		return (FALSE);
	}
	free (acsButton.requestedNode);
	return (TRUE);
}

int             setupLogFileMaker (scanFile, frame, matframe, bed, append)
	char           *scanFile;

	int             frame, matframe, bed, append;
{
	int             resp = TRUE;

	enum clnt_stat  rpcStatus;

	GEN_LOG_FILE_args logArgs;

	logArgs.file = scanFile;
	logArgs.frame = frame;
	logArgs.matframe = matframe;
	logArgs.bed = bed;
	logArgs.append = append;
	rpcStatus = callrpc ("localhost", ECAT_ACS_SERVER, ECAT_ACS_VERSION,
			  GEN_LOG_FILE, xdr_GEN_LOG_FILE_args, &logArgs, xdr_void, (char *) NULL);
	if (rpcStatus != (int) RPC_SUCCESS && rpcStatus != RPC_TIMEDOUT) {
		fprintf (stderr, "setupLogFileMaker: callrpc failed\n");
		clnt_perrno (rpcStatus);
		resp = FALSE;
	}
	return (resp);
}

int             disableAutoLogFileGeneration ()
{
	int             resp = TRUE;

	enum clnt_stat  rpcStatus;

	rpcStatus = callrpc ("localhost", ECAT_ACS_SERVER, ECAT_ACS_VERSION,
			     NOGEN_LOG_FILE, xdr_void, (char *) NULL, xdr_void, (char *) NULL);
	if (rpcStatus != (int) RPC_SUCCESS && rpcStatus != RPC_TIMEDOUT) {
		fprintf (stderr, "disableAutoLogFileGeneration: callrpc failed\n");
		clnt_perrno (rpcStatus);
		resp = FALSE;
	}
	return (resp);
}

/*_________________________________________________________________________
 * Marked by Tom Yang on Jan. 28, 1993.
 *________________________________________________________________________*/
/*
int insertLogEntry (scanFile, numFrames, numBeds, append)
char *scanFile;
int numFrames,
    numBeds,
    append;
{
    int i,
        j;
    char *acqServer;

    acqServer = defaults_get_string ("/Ecat/EcatRTSCpu", "Mizar", 0);

    if (!strcmp (acqServer, "ACS"))
    {	* if this is an ACS
	   system, create log
	   files on Sun *
	for (i = 0; i < numFrames; i++)
	    for (j = 0; j <= numBeds; j++)
		setupLogFileMaker (scanFile, i + 1, i + 1, j, append);
    }
    return (0);
}
*/

int             removeLogEntry (scanFile, numFrames, numBeds)
	char           *scanFile;
	int             numFrames, numBeds;
{
	int             i, j;
	enum clnt_stat  rpcStatus;

	DELETE_LOG_ENTRY_args logArgs;

	logArgs.file = scanFile;
	for (i = 0; i < numFrames; i++) {
		for (j = 0; j <= numBeds; j++) {
			logArgs.frame = i + 1;
			logArgs.matframe = i + 1;
			logArgs.bed = j;
			rpcStatus = callrpc ("localhost", ECAT_ACS_SERVER, ECAT_ACS_VERSION,
					     DELETE_LOG_ENTRY, xdr_DELETE_LOG_ENTRY_args, &logArgs, xdr_void, (char *) NULL);
			if (rpcStatus != (int) RPC_SUCCESS && rpcStatus != RPC_TIMEDOUT) {
				fprintf (stderr, "ecatAcs: removing %s %d %d from log que, couldn't talk to myself\n",
					 logArgs.file, logArgs.frame, logArgs.bed);
				clnt_perrno (rpcStatus);
			}
		}
	}
}

char           *(*acqStartedTimerProc) ();
char           *(*frameDoneTimerProc) ();
char           *(*frameStoredTimerProc) ();
char           *(*imageDoneTimerProc) ();
char           *(*archiveOkTimerProc) ();

static int      frameServerVersion, imageServerVersion, archiveNotifyServerVersion;

bool_t          registerFrameNotifications (frameStartedProc, frameStoppedProc, frameTransferredProc,
					                    frameProgram, frameVersion)
	char           *frameStartedProc, *frameStoppedProc, *frameTransferredProc;
	u_long         *frameProgram, *frameVersion;
{
	bool_t          startUpFrameServer ();
	TELL_ME_resp    tellResp;

	sendMeTheStuff (TRUE, frameStartedProc, frameStoppedProc, frameTransferredProc,
			FALSE, (char *) NULL, FALSE, (char *) NULL, &tellResp);
	*frameProgram = tellResp.frameServerProg;
	*frameVersion = tellResp.frameServerVers;
	return (startUpFrameServer ());
}

bool_t          unRegisterFrameNotifications (frameProgram, frameVersion)
	u_long          frameProgram, frameVersion;
{
	bool_t          stopSendingTheStuff ();
	TELL_ME_resp    tellRegistration;

	tellRegistration.frameServerProg = frameProgram;
	tellRegistration.frameServerVers = frameVersion;
	return (stopSendingTheStuff (TRUE, FALSE, FALSE, &tellRegistration));
}

bool_t          startUpFrameServer ()
{
	register SVCXPRT *xprt;
	extern void     frameServerProc ();

	if ((xprt = svctcp_create (RPC_ANYSOCK, 0, 0)) == NULL) {
		fprintf (stderr, "Cannot create tcp service\n");
		return (FALSE);
	}
	if (!svc_register (xprt, FrameServer, frameServerVersion, frameServerProc, IPPROTO_TCP)) {
		fprintf (stderr, "Couldn't register prog=%d ver=%d\n", FrameServer, frameServerVersion);
		return (FALSE);
	}
	return (TRUE);
}

void            frameServerProc (rqstp, xprt)	 /* server for frame complete or stored
						  * notification */
	register struct svc_req *rqstp;
	register SVCXPRT *xprt;
{
	int             frame = 0;

	switch (rqstp->rq_proc) {
	default:
		svcerr_noproc (xprt);
		break;
	case 0:
		svc_sendreply (xprt, xdr_void, NULL);
		return;
	case ACQ_STARTED:
		svc_sendreply (xprt, xdr_void, NULL);
		(*acqStartedTimerProc) ();
		break;
	case ACS_FRAME_COMPLETE:
		svc_getargs (xprt, xdr_int, &frame);
		svc_sendreply (xprt, xdr_void, NULL);
		(*frameDoneTimerProc) (frame);
		svc_freeargs (xprt, xdr_int, &frame);
		break;
	case ACS_FRAME_TRANSFERRED:
		svc_getargs (xprt, xdr_int, &frame);
		svc_sendreply (xprt, xdr_void, NULL);
		(*frameStoredTimerProc) (frame);
		svc_freeargs (xprt, xdr_int, &frame);
		break;
	}
	return;
}

bool_t          registerArchiveNotifications (archiveOkProc, arcProgram, arcVersion)
	char           *archiveOkProc;

	u_long         *arcProgram, *arcVersion;
{
	bool_t          startUpArchiveNotifyServer ();

	TELL_ME_resp    tellMe;

	sendMeTheStuff (FALSE, (char *) NULL, (char *) NULL, (char *) NULL,
			FALSE, (char *) NULL, TRUE, archiveOkProc, &tellMe);
	*arcProgram = tellMe.archiveServerProg;
	*arcVersion = tellMe.archiveServerVers;
	return (startUpArchiveNotifyServer ());
}

bool_t          unRegisterArchiveNotifications (arcProgram, arcVersion)
	u_long          arcProgram, arcVersion;
{
	bool_t          stopSendingTheStuff ();

	TELL_ME_resp    tellRegistration;

	tellRegistration.archiveServerProg = arcProgram;
	tellRegistration.archiveServerVers = arcVersion;
	return (stopSendingTheStuff (FALSE, FALSE, TRUE, &tellRegistration));
}

bool_t          startUpArchiveNotifyServer ()
{
	register SVCXPRT *xprt;

	extern void     archiveNotifyServerProc ();

	if ((xprt = svctcp_create (RPC_ANYSOCK, 0, 0)) == NULL) {
		fprintf (stderr, "Cannot create tcp service\n");
		return (FALSE);
	}
	if (!svc_register (xprt, ArchiveNotifyServer, archiveNotifyServerVersion,
			   archiveNotifyServerProc, IPPROTO_TCP)) {
		fprintf (stderr, "startUpArchiveNotifyServer:ERROR...Couldn't register prog=%d ver=%d\n",
			 ArchiveNotifyServer, archiveNotifyServerVersion);
		return (FALSE);
	}
	return (TRUE);
}

void            archiveNotifyServerProc (rqstp, xprt)	/* server for archive asynchronous events */
	register struct svc_req *rqstp;

	register SVCXPRT *xprt;
{
	ARC_JOB_NOTIFY_args arcNotifyArgs;

	switch (rqstp->rq_proc) {
	default:
		svcerr_noproc (xprt);
		break;
	case 0:
		svc_sendreply (xprt, xdr_void, NULL);
		return;
	case ARC_JOB_NOTIFY:
		bzero (&arcNotifyArgs, sizeof (ARC_JOB_NOTIFY_args));
		svc_getargs (xprt, xdr_ARC_JOB_NOTIFY_args, &arcNotifyArgs);
		svc_sendreply (xprt, xdr_void, NULL);
		(*archiveOkTimerProc) (arcNotifyArgs.study, arcNotifyArgs.filespec,
				       arcNotifyArgs.status, arcNotifyArgs.jobtype,
				       arcNotifyArgs.vol_name, arcNotifyArgs.error_code);
		svc_freeargs (xprt, xdr_ARC_JOB_NOTIFY_args, &arcNotifyArgs);
		break;
	}
	return;
}

bool_t          sendMeTheStuff (frameStuff, acqStartedProc, frameDoneProc, frameStoredProc,
                       imageStuff, imageDoneProc, archiveStuff, archiveOkProc, tellMeRegistration)
	int             frameStuff, imageStuff, archiveStuff;

	char           *acqStartedProc, *frameDoneProc, *frameStoredProc, *imageDoneProc, *archiveOkProc;

	TELL_ME_resp   *tellMeRegistration;
{
	enum clnt_stat  rpcStatus;

	TELL_ME_args    tellMe;

	char            ecatAcsHost[64];

	extern int      errno;

	int             getNextRPCVersion ();

	tellMe.whoIam = (char *) malloc (32);
	if ((gethostname (tellMe.whoIam, 32)) != NULL) {
		fprintf (stderr, "sendMeTheStuff: dont know who i am!!!\n");
		perror (errno);
		return (FALSE);
	}
	tellMe.tellMeAboutFrames = tellMe.tellMeAboutImages = tellMe.tellMeAboutArchives = 0;
	tellMe.frameServerVers = tellMe.frameServerProg = 0;
	tellMe.imageServerVers = tellMe.imageServerProg = 0;
	tellMe.archiveServerVers = tellMe.archiveServerProg = 0;
	if (frameStuff) {
		tellMe.tellMeAboutFrames = frameStuff;
		tellMe.frameServerProg = FrameServer;	/* fixed to the only one that exists, for
							 * now */
		frameServerVersion = getNextRPCVersion (FrameServer);
		tellMe.frameServerVers = frameServerVersion;
	}
	if (imageStuff) {
		tellMe.tellMeAboutImages = imageStuff;
		tellMe.imageServerProg = RECON_PROGRAM;	/* fixed to the only one that exists, for
							 * now */
		imageServerVersion = getNextRPCVersion (RECON_PROGRAM);
		tellMe.imageServerVers = imageServerVersion;
	}
	if (archiveStuff) {
		tellMe.tellMeAboutArchives = archiveStuff;
		tellMe.archiveServerProg = ArchiveNotifyServer;	/* fixed to the only one that
								 * exists, for now */
		archiveNotifyServerVersion = getNextRPCVersion (ArchiveNotifyServer);
		tellMe.archiveServerVers = archiveNotifyServerVersion;
	}
	printf ("Use defaults_get_string\n");
/*
    strcpy (ecatAcsHost, defaults_get_string ("/Ecat/EcatRemoteServer", "localhost", 0));
*/
	rpcStatus = callrpc (ecatAcsHost, ECAT_ACS_SERVER, ECAT_ACS_VERSION,
			 TELL_ME_ABOUT_STUFF, xdr_TELL_ME_args, &tellMe, xdr_void, (char *) NULL);
	if (rpcStatus != (int) RPC_SUCCESS && rpcStatus != RPC_TIMEDOUT) {
		fprintf (stderr, "sendMeTheStuff: callrpc failed\n");
		clnt_perrno (rpcStatus);
		free (tellMe.whoIam);
		return (FALSE);
	}
	if (acqStartedProc != NULL)
		acqStartedTimerProc = (char *(*) ()) acqStartedProc;
	if (frameDoneProc != NULL)
		frameDoneTimerProc = (char *(*) ()) frameDoneProc;
	if (frameStoredProc != NULL)
		frameStoredTimerProc = (char *(*) ()) frameStoredProc;
	if (imageDoneProc != NULL)
		imageDoneTimerProc = (char *(*) ()) imageDoneProc;
	if (archiveOkProc != NULL)
		archiveOkTimerProc = (char *(*) ()) archiveOkProc;
	free (tellMe.whoIam);
	tellMeRegistration->frameServerProg = tellMe.frameServerProg;
	tellMeRegistration->frameServerVers = tellMe.frameServerVers;
	tellMeRegistration->imageServerProg = tellMe.imageServerProg;
	tellMeRegistration->imageServerVers = tellMe.imageServerVers;
	tellMeRegistration->archiveServerProg = tellMe.archiveServerProg;
	tellMeRegistration->archiveServerVers = tellMe.archiveServerVers;
	return (TRUE);
}

bool_t          stopSendingTheStuff (frameStuff, imageStuff, archiveStuff, tellMeRegistration)
	int             frameStuff, imageStuff, archiveStuff;

	TELL_ME_resp   *tellMeRegistration;
{
	enum clnt_stat  rpcStatus;

	STOP_TELLING_ME_args tellMe;

	char            ecatAcsHost[64];

	extern int      errno;

	tellMe.whoIam = (char *) malloc (32);
	if ((gethostname (tellMe.whoIam, 32)) != NULL) {
		fprintf (stderr, "stopSendingTheStuff: dont know who i am!!!\n");
		perror (errno);
		return (FALSE);
	}
	tellMe.tellMeAboutFrames = frameStuff;
	tellMe.tellMeAboutImages = imageStuff;
	tellMe.tellMeAboutArchives = archiveStuff;
	tellMe.frameServerProg = tellMeRegistration->frameServerProg;
	tellMe.frameServerVers = tellMeRegistration->frameServerVers;
	tellMe.imageServerProg = tellMeRegistration->imageServerProg;
	tellMe.imageServerVers = tellMeRegistration->imageServerVers;
	tellMe.archiveServerProg = tellMeRegistration->archiveServerProg;
	tellMe.archiveServerVers = tellMeRegistration->archiveServerVers;
	printf ("Use defaults_get_string\n");
/*
    strcpy (ecatAcsHost, defaults_get_string ("/Ecat/EcatRemoteServer", "localhost", 0));
*/
	rpcStatus = callrpc (ecatAcsHost, ECAT_ACS_SERVER, ECAT_ACS_VERSION,
		     STOP_TELLING_ME, xdr_STOP_TELLING_ME_args, &tellMe, xdr_void, (char *) NULL);
	if (rpcStatus != (int) RPC_SUCCESS && rpcStatus != RPC_TIMEDOUT) {
		fprintf (stderr, "stopSendingTheStuff: callrpc failed\n");
		clnt_perrno (rpcStatus);
		free (tellMe.whoIam);
		return (FALSE);
	}
	if (frameStuff) {
		acqStartedTimerProc = (char *(*) ()) NULL;
		frameDoneTimerProc = (char *(*) ()) NULL;
		frameStoredTimerProc = (char *(*) ()) NULL;
		pmap_unset (tellMe.frameServerProg, tellMe.frameServerVers);
	}
	if (imageStuff) {
		imageDoneTimerProc = (char *(*) ()) NULL;
		pmap_unset (tellMe.imageServerProg, tellMe.imageServerVers);
	}
	if (archiveStuff) {
		archiveOkTimerProc = (char *(*) ()) NULL;
		pmap_unset (tellMe.archiveServerProg, tellMe.archiveServerVers);
	}
	free (tellMe.whoIam);
	return (TRUE);
}

/*______________________________________________________________
 * For sunview based operations having an rpc server registered
 * Marked in comment by Tom Yang to port to HP machines.
 _____________________________________________________________*/

 /*
  * void rpcWindowMainLoop (frame)	Frame frame; { fd_set readFds; int dtblsize = getdtablesize
  * (), atoi (); static struct timeval tt; extern int errno;
  * 
  * window_set (frame, WIN_SHOW, TRUE, 0);
  * 
  * for (;;) { tt.tv_sec = 0; tt.tv_usec = 25000;
  * 
  * (void) notify_dispatch (); readFds = svc_fdset; switch (select (dtblsize, &readFds, (int *) NULL,
  * (int *) NULL, (struct timeval *) & tt)) { case -1: if (errno != EINTR) { perror
  * ("rpcWindowMainLoop: select failed"); return; } case 0: break; default: svc_getreqset
  * (&readFds); break; } } }
  */

void            rpcLoop ()
{						 /* for non-windowed based operations having an rpc
						  * server registered */
	fd_set          readFds;

	int             dtblsize = getdtablesize ();

	static struct timeval tt;

	extern int      errno;

	for (;;) {
		tt.tv_sec = 0;
		tt.tv_usec = 25000;
		readFds = svc_fdset;
		switch (select (dtblsize, &readFds, (int *) NULL,
				(int *) NULL, (struct timeval *) & tt)) {
		case -1:
			if (errno != EINTR) {
				perror ("rpcLoop: select failed");
				return;
			}
		case 0:
			break;
		default:
			svc_getreqset (&readFds);
			break;
		}
	}
}

char           *reconproc_complete_1 (arguement, rqstp)
	int            *arguement;

	struct svc_req *rqstp;
{
	(*imageDoneTimerProc) (arguement);
	return ((char *) NULL);
}

char           *reconproc_null_1 (arguement, rqstp)
	int            *arguement;

	struct svc_req *rqstp;
{
	return ((char *) NULL);
}

int             rfaFormatStarted ()
{
	int             resp;

	enum clnt_stat  rpcStatus;

	ButtonId        acsButton;


	acsButton.requestorPid = 0;
	acsButton.requestedNode = (char *) malloc (32);
	printf ("Use defaults_get_string\n");
/*
    strcpy (acsButton.requestedNode,
	defaults_get_string ("/Ecat/EcatAcqServer", "localhost", 0));
*/
	rpcStatus = callrpc ("localhost", ECAT_ACS_SERVER, ECAT_ACS_VERSION,
			   RFA_FORMAT_STARTED, xdr_ButtonId, &acsButton, xdr_void, (char *) NULL);
	if (rpcStatus != (int) RPC_SUCCESS && rpcStatus != RPC_TIMEDOUT) {
		fprintf (stderr, "formatStarted: callrpc failed\n");
		clnt_perrno (rpcStatus);
		free (acsButton.requestedNode);
		return (FALSE);
	}
	free (acsButton.requestedNode);
	return (TRUE);
}

int             rfaFormatComplete ()
{
	int             resp;

	enum clnt_stat  rpcStatus;

	ButtonId        acsButton;

	acsButton.requestedNode = (char *) malloc (32);
	printf ("Use defaults_get_string\n");
/*
    strcpy (acsButton.requestedNode,
	defaults_get_string ("/Ecat/EcatAcqServer", "localhost", 0));
*/
	rpcStatus = callrpc ("localhost", ECAT_ACS_SERVER, ECAT_ACS_VERSION,
			     IS_FORMAT_COMPLETE, xdr_ButtonId, &acsButton, xdr_int, &resp);
	if (rpcStatus != (int) RPC_SUCCESS && rpcStatus != RPC_TIMEDOUT) {
		fprintf (stderr, "formatComplete: callrpc failed\n");
		clnt_perrno (rpcStatus);
		free (acsButton.requestedNode);
		return (FALSE);
	}
	free (acsButton.requestedNode);
	return (resp);
}

int             setFileModificationTime (fileName, modificationTime)
	char           *fileName;

	unsigned long   modificationTime;
{
	struct timeval  accessTimes[2];

	accessTimes[0].tv_sec = accessTimes[1].tv_sec = modificationTime;
	accessTimes[0].tv_usec = accessTimes[1].tv_usec = 0;
	if (utimes (fileName, accessTimes)) {
		fprintf (stderr,
			 "setFileModificationTime:ERROR...unable to change mtime for \n",
			 fileName);
		perror ("unable to change file times");
		return (ERROR);
	}
	return (OK);
}

int             getFileStats (fileName, fileStats)
	char           *fileName;

	struct stat    *fileStats;
{
	if (stat (fileName, fileStats))
		return (ERROR);
	else
		return (OK);
}
@


1.6
log
@build in Solaris 2
@
text
@d1 1
a1 1
/*$Id: acs.c,v 1.5 1995/10/30 16:49:06 tom Exp tom $*/
d3 3
d25 1
a28 3
/*
#include <suntool/sunview.h>
*/
a29 3
/*
#include <sunwindow/defaults.h>
*/
a33 4
#include "ecatArc.h"
#include "ecatMcs.h"
#include "ecatRts.h"
#include "ecatRecon.h"
d37 1
a37 2
static char     sccsid[] = "@@(#)acs.c	2.9 4/24/92  Copyright 1989-1992 CTI PET Systems, Inc.";

a39 2
static char     rcsid[] = "$Header: /home/npggw/tom/src/libcti/RCS/acs.c,v 1.5 1995/10/30 16:49:06 tom Exp tom $";

a52 2
	bool_t          acqTakeResult ();

a117 2
	bool_t          mcsTakeResult ();

a175 1

a343 1

a346 1

a368 1

a369 1

a370 1

a371 1

a378 1

a381 1

a394 1

a404 1

a420 1

@


1.5
log
@changed petutil/matrix.h to matrix.h
@
text
@d1 1
a1 1
/*$Id: acs.c,v 1.4 1994/03/03 17:13:26 ty7777 Exp tom $*/
d3 3
d43 2
a44 1
static char sccsid[] = "@@(#)acs.c	2.9 4/24/92  Copyright 1989-1992 CTI PET Systems, Inc.";
a45 1
static char rcsid [] = "$Header: /home/npggw/tom/src/libcti/RCS/acs.c,v 1.4 1994/03/03 17:13:26 ty7777 Exp tom $";
d47 2
d51 1
a51 1
void ecatQuitHandler ();
d53 1
a53 1
int rts_allocate ()
d55 1
a55 7
    int resp; 
    /*
    int getpid ();
    */
    enum clnt_stat rpcStatus;
    bool_t acqTakeResult ();
    ButtonId acsButton;
d57 12
a68 3
    acsButton.requestorPid = getpid ();
    acsButton.requestedNode = (char *) malloc (32);
printf ("Use defaults_get_string\n");
d73 14
a86 6
    rpcStatus = callrpc ("localhost", ECAT_ACS_SERVER, ECAT_ACS_VERSION,
	ACS_ALLOCATE, xdr_ButtonId, &acsButton, xdr_int, &resp);
    if (rpcStatus != (int) RPC_SUCCESS && rpcStatus != RPC_TIMEDOUT)
    {
	fprintf (stderr, "rts_allocate: callrpc failed\n");
	clnt_perrno (rpcStatus);
d88 1
a88 13
	return (FALSE);
    }
    if (resp)
    {
	if (isatty (STDIN_FILENO))	/* check if this is a
					   background process */
	{
	    signal (SIGINT, ecatQuitHandler);
	    signal (SIGQUIT, ecatQuitHandler);
	}
    }
    free (acsButton.requestedNode);
    return (resp);
d91 1
a91 1
int rts_deallocate ()
a92 5
    /*
    int getpid ();
    */
    enum clnt_stat rpcStatus;
    ButtonId acsButton;
d94 10
a103 3
    acsButton.requestorPid = getpid ();
    acsButton.requestedNode = (char *) malloc (32);
printf ("Use defaults_get_string\n");
d108 8
a115 6
    rpcStatus = callrpc ("localhost", ECAT_ACS_SERVER, ECAT_ACS_VERSION,
	ACS_DEALLOCATE, xdr_ButtonId, &acsButton, xdr_void, (char *) NULL);
    if (rpcStatus != (int) RPC_SUCCESS && rpcStatus != RPC_TIMEDOUT)
    {
	fprintf (stderr, "rts_deallocate: callrpc failed\n");
	clnt_perrno (rpcStatus);
d117 1
a117 4
	return (FALSE);
    }
    free (acsButton.requestedNode);
    return (TRUE);
d120 1
a120 1
int mcs_allocate ()
d122 1
a122 7
    int resp; 
    /*
    int getpid ();
    */
    enum clnt_stat rpcStatus;
    bool_t mcsTakeResult ();
    ButtonId mcsButton;
d124 12
a135 3
    mcsButton.requestorPid = getpid ();
    mcsButton.requestedNode = (char *) malloc (32);
printf ("Use defaults_get_string\n");
d140 14
a153 6
    rpcStatus = callrpc ("localhost", ECAT_ACS_SERVER, ECAT_ACS_VERSION,
	MCS_ALLOCATE, xdr_ButtonId, &mcsButton, xdr_int, &resp);
    if (rpcStatus != (int) RPC_SUCCESS && rpcStatus != RPC_TIMEDOUT)
    {
	fprintf (stderr, "mcs_allocate: callrpc failed\n");
	clnt_perrno (rpcStatus);
d155 1
a155 13
	return (FALSE);
    }
    if (resp)
    {
	if (isatty (STDIN_FILENO))	/* check if this is a
					   background process */
	{
	    signal (SIGINT, ecatQuitHandler);
	    signal (SIGQUIT, ecatQuitHandler);
	}
    }
    free (mcsButton.requestedNode);
    return (resp);
d158 1
a158 1
int mcs_deallocate ()
a159 5
    /*
    int getpid ();
    */
    enum clnt_stat rpcStatus;
    ButtonId mcsButton;
d161 10
a170 3
    mcsButton.requestorPid = getpid ();
    mcsButton.requestedNode = (char *) malloc (32);
printf ("Use defaults_get_string\n");
d175 8
a182 6
    rpcStatus = callrpc ("localhost", ECAT_ACS_SERVER, ECAT_ACS_VERSION,
	MCS_DEALLOCATE, xdr_ButtonId, &mcsButton, xdr_void, (char *) NULL);
    if (rpcStatus != (int) RPC_SUCCESS && rpcStatus != RPC_TIMEDOUT)
    {
	fprintf (stderr, "mcs_deallocate: callrpc failed\n");
	clnt_perrno (rpcStatus);
d184 1
a184 4
	return (FALSE);
    }
    free (mcsButton.requestedNode);
    return (TRUE);
d187 4
a190 4
void ecatQuitHandler (signal, code, scp)
int signal,
    code;
struct sigcontext *scp;
d192 4
a195 4
    printf ("\nIn ecatQuitHandler, caught a quit!!!\n");
    rts_deallocate ();
    mcs_deallocate ();
    exit (0);
d198 2
a199 2
int isFrameTransferred (frame)
int frame;
d201 1
a201 4
    int resp,
        checkFrame = frame;
    enum clnt_stat rpcStatus;
    ButtonId acsButton;
d203 1
d205 6
a210 3
    acsButton.requestorPid = frame;
    acsButton.requestedNode = (char *) malloc (32);
printf ("Use defaults_get_string\n");
d215 10
a224 6
    rpcStatus = callrpc ("localhost", ECAT_ACS_SERVER, ECAT_ACS_VERSION,
	IS_THIS_FRAME_TRANSFERRED, xdr_ButtonId, &acsButton, xdr_int, &resp);
    if (rpcStatus != (int) RPC_SUCCESS && rpcStatus != RPC_TIMEDOUT)
    {
	fprintf (stderr, "frame_transferred: callrpc failed\n");
	clnt_perrno (rpcStatus);
d226 1
a226 6
	return (FALSE);
    }
    if (!resp)
	sleep (7);
    free (acsButton.requestedNode);
    return (resp);
d229 2
a230 2
int isFrameAcquired (frame)
int frame;
d232 1
a232 4
    int resp,
        checkFrame = frame;
    enum clnt_stat rpcStatus;
    ButtonId acsButton;
d234 7
a240 3
    acsButton.requestorPid = frame;
    acsButton.requestedNode = (char *) malloc (32);
printf ("Use defaults_get_string\n");
d245 10
a254 6
    rpcStatus = callrpc ("localhost", ECAT_ACS_SERVER, ECAT_ACS_VERSION,
	IS_THIS_FRAME_COMPLETE, xdr_ButtonId, &acsButton, xdr_int, &resp);
    if (rpcStatus != (int) RPC_SUCCESS && rpcStatus != RPC_TIMEDOUT)
    {
	fprintf (stderr, "frameComplete: callrpc failed\n");
	clnt_perrno (rpcStatus);
d256 1
a256 6
	return (FALSE);
    }
    if (!resp)
	sleep (7);
    free (acsButton.requestedNode);
    return (resp);
d259 1
a259 1
int resetFrameTransferred ()
d261 1
a261 3
    int resp;
    enum clnt_stat rpcStatus;
    ButtonId acsButton;
d263 7
a269 3
    acsButton.requestorPid = 0;
    acsButton.requestedNode = (char *) malloc (32);
printf ("Use defaults_get_string\n");
d274 8
a281 6
    rpcStatus = callrpc ("localhost", ECAT_ACS_SERVER, ECAT_ACS_VERSION,
	RESET_FRAME_TRANSFERRED, xdr_ButtonId, &acsButton, xdr_void, (char *) NULL);
    if (rpcStatus != (int) RPC_SUCCESS && rpcStatus != RPC_TIMEDOUT)
    {
	fprintf (stderr, "resetFrame: callrpc failed\n");
	clnt_perrno (rpcStatus);
d283 1
a283 4
	return (FALSE);
    }
    free (acsButton.requestedNode);
    return (TRUE);
d286 4
a289 6
int setupLogFileMaker (scanFile, frame, matframe, bed, append)
char *scanFile;
int frame,
    matframe,
    bed,
    append;
d291 1
a291 3
    int resp = TRUE;
    enum clnt_stat rpcStatus;
    GEN_LOG_FILE_args logArgs;
d293 17
a309 14
    logArgs.file = scanFile;
    logArgs.frame = frame;
    logArgs.matframe = matframe;
    logArgs.bed = bed;
    logArgs.append = append;
    rpcStatus = callrpc ("localhost", ECAT_ACS_SERVER, ECAT_ACS_VERSION,
	GEN_LOG_FILE, xdr_GEN_LOG_FILE_args, &logArgs, xdr_void, (char *) NULL);
    if (rpcStatus != (int) RPC_SUCCESS && rpcStatus != RPC_TIMEDOUT)
    {
	fprintf (stderr, "setupLogFileMaker: callrpc failed\n");
	clnt_perrno (rpcStatus);
	resp = FALSE;
    }
    return (resp);
d312 1
a312 1
int disableAutoLogFileGeneration ()
d314 1
a314 2
    int resp = TRUE;
    enum clnt_stat rpcStatus;
d316 10
a325 9
    rpcStatus = callrpc ("localhost", ECAT_ACS_SERVER, ECAT_ACS_VERSION,
	NOGEN_LOG_FILE, xdr_void, (char *) NULL, xdr_void, (char *) NULL);
    if (rpcStatus != (int) RPC_SUCCESS && rpcStatus != RPC_TIMEDOUT)
    {
	fprintf (stderr, "disableAutoLogFileGeneration: callrpc failed\n");
	clnt_perrno (rpcStatus);
	resp = FALSE;
    }
    return (resp);
d356 4
a359 3
int removeLogEntry (scanFile, numFrames, numBeds)
char *scanFile;
int numFrames, numBeds;
d361 1
a361 4
    int i,
        j;
    enum clnt_stat rpcStatus;
    DELETE_LOG_ENTRY_args logArgs;
d363 18
a380 16
    logArgs.file = scanFile;
    for (i = 0; i < numFrames; i++)
    {
	for (j = 0; j <= numBeds; j++)
	{
	    logArgs.frame = i + 1;
	    logArgs.matframe = i + 1;
	    logArgs.bed = j;
	    rpcStatus = callrpc ("localhost", ECAT_ACS_SERVER, ECAT_ACS_VERSION,
		DELETE_LOG_ENTRY, xdr_DELETE_LOG_ENTRY_args, &logArgs, xdr_void, (char *) NULL);
	    if (rpcStatus != (int) RPC_SUCCESS && rpcStatus != RPC_TIMEDOUT)
	    {
		fprintf (stderr, "ecatAcs: removing %s %d %d from log que, couldn't talk to myself\n",
		    logArgs.file, logArgs.frame, logArgs.bed);
		clnt_perrno (rpcStatus);
	    }
a381 1
    }
d384 1
a384 8
char *(*acqStartedTimerProc) ();
char *(*frameDoneTimerProc) ();
char *(*frameStoredTimerProc) ();
char *(*imageDoneTimerProc) ();
char *(*archiveOkTimerProc) ();
static int frameServerVersion,
    imageServerVersion,
    archiveNotifyServerVersion;
d386 15
a400 7
bool_t registerFrameNotifications (frameStartedProc, frameStoppedProc, frameTransferredProc,
           frameProgram, frameVersion)
char *frameStartedProc,
    *frameStoppedProc,
    *frameTransferredProc;
u_long *frameProgram,
      *frameVersion;
d402 1
a402 2
    bool_t startUpFrameServer ();
    TELL_ME_resp tellResp;
d404 7
a410 5
    sendMeTheStuff (TRUE, frameStartedProc, frameStoppedProc, frameTransferredProc,
	FALSE, (char *) NULL, FALSE, (char *) NULL, &tellResp);
    *frameProgram = tellResp.frameServerProg;
    *frameVersion = tellResp.frameServerVers;
    return (startUpFrameServer ());
d413 2
a414 3
bool_t unRegisterFrameNotifications (frameProgram, frameVersion)
u_long frameProgram,
       frameVersion;
d416 1
a416 2
    bool_t stopSendingTheStuff ();
    TELL_ME_resp tellRegistration;
d418 5
a422 3
    tellRegistration.frameServerProg = frameProgram;
    tellRegistration.frameServerVers = frameVersion;
    return (stopSendingTheStuff (TRUE, FALSE, FALSE, &tellRegistration));
d425 1
a425 1
bool_t startUpFrameServer ()
d427 1
a427 2
    register SVCXPRT *xprt;
    extern void frameServerProc ();
d429 11
a439 11
    if ((xprt = svctcp_create (RPC_ANYSOCK, 0, 0)) == NULL)
    {
	fprintf (stderr, "Cannot create tcp service\n");
	return (FALSE);
    }
    if (!svc_register (xprt, FrameServer, frameServerVersion, frameServerProc, IPPROTO_TCP))
    {
	fprintf (stderr, "Couldn't register prog=%d ver=%d\n", FrameServer, frameServerVersion);
	return (FALSE);
    }
    return (TRUE);
d442 5
a446 5
void frameServerProc (rqstp, xprt)	/* server for frame
					   complete or stored
					   notification */
register struct svc_req *rqstp;
register SVCXPRT *xprt;
d448 1
a448 1
    int frame = 0;
d450 24
a473 7
    switch (rqstp->rq_proc)
    {
      default:
	svcerr_noproc (xprt);
	break;
      case 0:
	svc_sendreply (xprt, xdr_void, NULL);
a474 18
      case ACQ_STARTED:
	svc_sendreply (xprt, xdr_void, NULL);
	(*acqStartedTimerProc) ();
	break;
      case ACS_FRAME_COMPLETE:
	svc_getargs (xprt, xdr_int, &frame);
	svc_sendreply (xprt, xdr_void, NULL);
	(*frameDoneTimerProc) (frame);
	svc_freeargs (xprt, xdr_int, &frame);
	break;
      case ACS_FRAME_TRANSFERRED:
	svc_getargs (xprt, xdr_int, &frame);
	svc_sendreply (xprt, xdr_void, NULL);
	(*frameStoredTimerProc) (frame);
	svc_freeargs (xprt, xdr_int, &frame);
	break;
    }
    return;
d477 4
a480 4
bool_t registerArchiveNotifications (archiveOkProc, arcProgram, arcVersion)
char *archiveOkProc;
u_long *arcProgram,
      *arcVersion;
d482 1
a482 2
    bool_t startUpArchiveNotifyServer ();
    TELL_ME_resp tellMe;
d484 7
a490 5
    sendMeTheStuff (FALSE, (char *) NULL, (char *) NULL, (char *) NULL,
	FALSE, (char *) NULL, TRUE, archiveOkProc, &tellMe);
    *arcProgram = tellMe.archiveServerProg;
    *arcVersion = tellMe.archiveServerVers;
    return (startUpArchiveNotifyServer ());
d493 2
a494 3
bool_t unRegisterArchiveNotifications (arcProgram, arcVersion)
u_long arcProgram,
       arcVersion;
d496 1
a496 2
    bool_t stopSendingTheStuff ();
    TELL_ME_resp tellRegistration;
d498 5
a502 3
    tellRegistration.archiveServerProg = arcProgram;
    tellRegistration.archiveServerVers = arcVersion;
    return (stopSendingTheStuff (FALSE, FALSE, TRUE, &tellRegistration));
d505 1
a505 1
bool_t startUpArchiveNotifyServer ()
d507 1
a507 2
    register SVCXPRT *xprt;
    extern void archiveNotifyServerProc ();
d509 13
a521 13
    if ((xprt = svctcp_create (RPC_ANYSOCK, 0, 0)) == NULL)
    {
	fprintf (stderr, "Cannot create tcp service\n");
	return (FALSE);
    }
    if (!svc_register (xprt, ArchiveNotifyServer, archiveNotifyServerVersion,
	    archiveNotifyServerProc, IPPROTO_TCP))
    {
	fprintf (stderr, "startUpArchiveNotifyServer:ERROR...Couldn't register prog=%d ver=%d\n",
	    ArchiveNotifyServer, archiveNotifyServerVersion);
	return (FALSE);
    }
    return (TRUE);
d524 4
a527 4
void archiveNotifyServerProc (rqstp, xprt)	/* server for archive
						   asynchronous events */
register struct svc_req *rqstp;
register SVCXPRT *xprt;
d529 1
a529 1
    ARC_JOB_NOTIFY_args arcNotifyArgs;
d531 17
a547 7
    switch (rqstp->rq_proc)
    {
      default:
	svcerr_noproc (xprt);
	break;
      case 0:
	svc_sendreply (xprt, xdr_void, NULL);
a548 11
      case ARC_JOB_NOTIFY:
	bzero (&arcNotifyArgs, sizeof (ARC_JOB_NOTIFY_args));
	svc_getargs (xprt, xdr_ARC_JOB_NOTIFY_args, &arcNotifyArgs);
	svc_sendreply (xprt, xdr_void, NULL);
	(*archiveOkTimerProc) (arcNotifyArgs.study, arcNotifyArgs.filespec,
	    arcNotifyArgs.status, arcNotifyArgs.jobtype,
	    arcNotifyArgs.vol_name, arcNotifyArgs.error_code);
	svc_freeargs (xprt, xdr_ARC_JOB_NOTIFY_args, &arcNotifyArgs);
	break;
    }
    return;
d551 7
a557 10
bool_t sendMeTheStuff (frameStuff, acqStartedProc, frameDoneProc, frameStoredProc,
           imageStuff, imageDoneProc, archiveStuff, archiveOkProc, tellMeRegistration)
int frameStuff,
    imageStuff,
    archiveStuff;
char *acqStartedProc,
    *frameDoneProc,
    *frameStoredProc, *imageDoneProc,
    *archiveOkProc;
TELL_ME_resp *tellMeRegistration;
d559 1
a559 5
    enum clnt_stat rpcStatus;
    TELL_ME_args tellMe;
    char ecatAcsHost[64];
    extern int errno;
    int getNextRPCVersion ();
d561 40
a600 36
    tellMe.whoIam = (char *) malloc (32);
    if ((gethostname (tellMe.whoIam, 32)) != NULL)
    {
	fprintf (stderr, "sendMeTheStuff: dont know who i am!!!\n");
	perror (errno);
	return (FALSE);
    }
    tellMe.tellMeAboutFrames = tellMe.tellMeAboutImages = tellMe.tellMeAboutArchives = 0;
    tellMe.frameServerVers = tellMe.frameServerProg = 0;
    tellMe.imageServerVers = tellMe.imageServerProg = 0;
    tellMe.archiveServerVers = tellMe.archiveServerProg = 0;
    if (frameStuff)
    {
	tellMe.tellMeAboutFrames = frameStuff;
	tellMe.frameServerProg = FrameServer;	/* fixed to the only one
						   that exists, for now */
	frameServerVersion = getNextRPCVersion (FrameServer);
	tellMe.frameServerVers = frameServerVersion;
    }
    if (imageStuff)
    {
	tellMe.tellMeAboutImages = imageStuff;
	tellMe.imageServerProg = RECON_PROGRAM;	/* fixed to the only one
						   that exists, for now */
	imageServerVersion = getNextRPCVersion (RECON_PROGRAM);
	tellMe.imageServerVers = imageServerVersion;
    }
    if (archiveStuff)
    {
	tellMe.tellMeAboutArchives = archiveStuff;
	tellMe.archiveServerProg = ArchiveNotifyServer;	/* fixed to the only one
							   that exists, for now */
	archiveNotifyServerVersion = getNextRPCVersion (ArchiveNotifyServer);
	tellMe.archiveServerVers = archiveNotifyServerVersion;
    }
printf ("Use defaults_get_string\n");
d604 18
a621 6
    rpcStatus = callrpc (ecatAcsHost, ECAT_ACS_SERVER, ECAT_ACS_VERSION,
	TELL_ME_ABOUT_STUFF, xdr_TELL_ME_args, &tellMe, xdr_void, (char *) NULL);
    if (rpcStatus != (int) RPC_SUCCESS && rpcStatus != RPC_TIMEDOUT)
    {
	fprintf (stderr, "sendMeTheStuff: callrpc failed\n");
	clnt_perrno (rpcStatus);
d623 7
a629 20
	return (FALSE);
    }
    if (acqStartedProc != NULL)
	acqStartedTimerProc = (char *(*) ()) acqStartedProc;
    if (frameDoneProc != NULL)
	frameDoneTimerProc = (char *(*) ()) frameDoneProc;
    if (frameStoredProc != NULL)
	frameStoredTimerProc = (char *(*) ()) frameStoredProc;
    if (imageDoneProc != NULL)
	imageDoneTimerProc = (char *(*) ()) imageDoneProc;
    if (archiveOkProc != NULL)
	archiveOkTimerProc = (char *(*) ()) archiveOkProc;
    free (tellMe.whoIam);
    tellMeRegistration->frameServerProg = tellMe.frameServerProg;
    tellMeRegistration->frameServerVers = tellMe.frameServerVers;
    tellMeRegistration->imageServerProg = tellMe.imageServerProg;
    tellMeRegistration->imageServerVers = tellMe.imageServerVers;
    tellMeRegistration->archiveServerProg = tellMe.archiveServerProg;
    tellMeRegistration->archiveServerVers = tellMe.archiveServerVers;
    return (TRUE);
d632 4
a635 5
bool_t stopSendingTheStuff (frameStuff, imageStuff, archiveStuff, tellMeRegistration)
int frameStuff,
    imageStuff,
    archiveStuff;
TELL_ME_resp *tellMeRegistration;
d637 1
a637 4
    enum clnt_stat rpcStatus;
    STOP_TELLING_ME_args tellMe;
    char ecatAcsHost[64];
    extern int errno;
d639 22
a660 17
    tellMe.whoIam = (char *) malloc (32);
    if ((gethostname (tellMe.whoIam, 32)) != NULL)
    {
	fprintf (stderr, "stopSendingTheStuff: dont know who i am!!!\n");
	perror (errno);
	return (FALSE);
    }
    tellMe.tellMeAboutFrames = frameStuff;
    tellMe.tellMeAboutImages = imageStuff;
    tellMe.tellMeAboutArchives = archiveStuff;
    tellMe.frameServerProg = tellMeRegistration->frameServerProg;
    tellMe.frameServerVers = tellMeRegistration->frameServerVers;
    tellMe.imageServerProg = tellMeRegistration->imageServerProg;
    tellMe.imageServerVers = tellMeRegistration->imageServerVers;
    tellMe.archiveServerProg = tellMeRegistration->archiveServerProg;
    tellMe.archiveServerVers = tellMeRegistration->archiveServerVers;
printf ("Use defaults_get_string\n");
d664 22
a685 6
    rpcStatus = callrpc (ecatAcsHost, ECAT_ACS_SERVER, ECAT_ACS_VERSION,
	STOP_TELLING_ME, xdr_STOP_TELLING_ME_args, &tellMe, xdr_void, (char *) NULL);
    if (rpcStatus != (int) RPC_SUCCESS && rpcStatus != RPC_TIMEDOUT)
    {
	fprintf (stderr, "stopSendingTheStuff: callrpc failed\n");
	clnt_perrno (rpcStatus);
d687 1
a687 21
	return (FALSE);
    }
    if (frameStuff)
    {
	acqStartedTimerProc = (char *(*) ()) NULL;
	frameDoneTimerProc = (char *(*) ()) NULL;
	frameStoredTimerProc = (char *(*) ()) NULL;
	pmap_unset (tellMe.frameServerProg, tellMe.frameServerVers);
    }
    if (imageStuff)
    {
	imageDoneTimerProc = (char *(*) ()) NULL;
	pmap_unset (tellMe.imageServerProg, tellMe.imageServerVers);
    }
    if (archiveStuff)
    {
	archiveOkTimerProc = (char *(*) ()) NULL;
	pmap_unset (tellMe.archiveServerProg, tellMe.archiveServerVers);
    }
    free (tellMe.whoIam);
    return (TRUE);
d690 2
a691 2
/*______________________________________________________________ 
 * For sunview based operations having an rpc server registered 
d694 1
d696 12
a707 8
void rpcWindowMainLoop (frame)	
Frame frame;
{
    fd_set readFds;
    int dtblsize = getdtablesize (),
        atoi ();
    static struct timeval tt;
    extern int errno;
d709 4
a712 1
    window_set (frame, WIN_SHOW, TRUE, 0);
d714 1
a714 4
    for (;;)
    {
	tt.tv_sec = 0;
	tt.tv_usec = 25000;
d716 1
a716 19
	(void) notify_dispatch ();
	readFds = svc_fdset;
	switch (select (dtblsize, &readFds, (int *) NULL, (int *) NULL, (struct timeval *) & tt))
	{
	  case -1:
	    if (errno != EINTR)
	    {
		perror ("rpcWindowMainLoop: select failed");
		return;
	    }
	  case 0:
	    break;
	  default:
	    svc_getreqset (&readFds);
	    break;
	}
    }
}
*/
d718 1
a718 9
void rpcLoop ()	/* for non-windowed
		   based operations
		   having an rpc server
		   registered */
{
    fd_set readFds;
    int dtblsize = getdtablesize ();
    static struct timeval tt;
    extern int errno;
d720 17
a736 19
    for (;;)
    {
	tt.tv_sec = 0;
	tt.tv_usec = 25000;
	readFds = svc_fdset;
	switch (select (dtblsize, &readFds, (int *) NULL,
		(int *) NULL, (struct timeval *) & tt))
	{
	  case -1:
	    if (errno != EINTR)
	    {
		perror ("rpcLoop: select failed");
		return;
	    }
	  case 0:
	    break;
	  default:
	    svc_getreqset (&readFds);
	    break;
a737 1
    }
d740 4
a743 3
char *reconproc_complete_1 (arguement, rqstp)
int *arguement;
struct svc_req *rqstp;
d745 2
a746 2
    (*imageDoneTimerProc) (arguement);
    return ((char *) NULL);
d749 4
a752 3
char *reconproc_null_1 (arguement, rqstp)
int *arguement;
struct svc_req *rqstp;
d754 1
a754 1
    return ((char *) NULL);
d757 1
a757 1
int rfaFormatStarted ()
d759 1
a759 3
    int resp;
    enum clnt_stat rpcStatus;
    ButtonId acsButton;
d761 1
d763 6
a768 3
    acsButton.requestorPid = 0;
    acsButton.requestedNode = (char *) malloc (32);
printf ("Use defaults_get_string\n");
d773 8
a780 6
    rpcStatus = callrpc ("localhost", ECAT_ACS_SERVER, ECAT_ACS_VERSION,
	RFA_FORMAT_STARTED, xdr_ButtonId, &acsButton, xdr_void, (char *) NULL);
    if (rpcStatus != (int) RPC_SUCCESS && rpcStatus != RPC_TIMEDOUT)
    {
	fprintf (stderr, "formatStarted: callrpc failed\n");
	clnt_perrno (rpcStatus);
d782 1
a782 4
	return (FALSE);
    }
    free (acsButton.requestedNode);
    return (TRUE);
d785 1
a785 1
int rfaFormatComplete ()
d787 1
a787 3
    int resp;
    enum clnt_stat rpcStatus;
    ButtonId acsButton;
d789 6
a794 2
    acsButton.requestedNode = (char *) malloc (32);
printf ("Use defaults_get_string\n");
d799 8
a806 6
    rpcStatus = callrpc ("localhost", ECAT_ACS_SERVER, ECAT_ACS_VERSION,
	IS_FORMAT_COMPLETE, xdr_ButtonId, &acsButton, xdr_int, &resp);
    if (rpcStatus != (int) RPC_SUCCESS && rpcStatus != RPC_TIMEDOUT)
    {
	fprintf (stderr, "formatComplete: callrpc failed\n");
	clnt_perrno (rpcStatus);
d808 1
a808 4
	return (FALSE);
    }
    free (acsButton.requestedNode);
    return (resp);
d811 4
a814 3
int setFileModificationTime (fileName, modificationTime)
char *fileName;
unsigned long modificationTime;
d816 1
a816 1
    struct timeval accessTimes[2];
d818 10
a827 11
    accessTimes[0].tv_sec = accessTimes[1].tv_sec = modificationTime;
    accessTimes[0].tv_usec = accessTimes[1].tv_usec = 0;
    if (utimes (fileName, accessTimes))
    {
	fprintf (stderr,
	    "setFileModificationTime:ERROR...unable to change mtime for \n",
	    fileName);
	perror ("unable to change file times");
	return (ERROR);
    }
    return (OK);
d830 4
a833 3
int getFileStats (fileName, fileStats)
char *fileName;
struct stat *fileStats;
d835 4
a838 4
    if (stat (fileName, fileStats))
	return (ERROR);
    else
	return (OK);
@


1.4
log
@Changed id to header.
@
text
@d1 1
a1 1
/*$Id: acs.c,v 1.3 1993/09/13 18:50:29 ty7777 Exp ty7777 $*/
d3 3
d37 1
a37 1
#include <petutil/matrix.h>
d42 1
a42 1
static char rcsid [] = "$Header$";
@


1.3
log
@Introduce acsid and change matrix.h to petutil/matrix.h.
@
text
@d1 1
a1 1
/*$Id: acs.c,v 1.2 1993/03/04 19:38:27 ty7777 Exp ty7777 $*/
d3 3
d39 1
a39 1
static char rcsid[] = "$Id$";
@


1.2
log
@Working version of acs.c, Modified to get rid of sunview libraries.
@
text
@d1 5
a5 2
/*$Id$*/
/*$Log$*/
d31 1
a31 1
#include "matrix.h"
d36 1
@


1.1
log
@Initial revision
@
text
@d1 4
d40 4
a43 1
    int resp, getpid ();
d79 1
d81 1
d107 4
a110 1
    int resp, getpid ();
d146 1
d148 1
d313 4
a326 2
printf ("Use defaults_get_string\n");
/*
d328 1
a328 1
*/
d330 1
a330 1
    {	/* if this is an ACS
d332 1
a332 1
	   files on Sun */
d339 1
d684 6
a689 3
void rpcWindowMainLoop (frame)	/* for sunview based
				   operations having an
				   rpc server registered */
a696 1
printf ("Use window_set ()\n");
a697 1
/*
a698 1
*/
a704 3
printf ("Use notify_dispatch ()\n");

/*
a705 1
*/
d723 1
@
