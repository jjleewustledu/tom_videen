head	1.11;
access;
symbols;
locks; strict;
comment	@ * @;


1.11
date	95.04.28.20.08.36;	author ty7777;	state Exp;
branches;
next	1.10;

1.10
date	95.04.27.20.44.33;	author ty7777;	state Exp;
branches;
next	1.9;

1.9
date	94.05.27.14.33.31;	author ty7777;	state Exp;
branches
	1.9.1.1;
next	1.8;

1.8
date	94.05.26.21.47.44;	author ty7777;	state Exp;
branches;
next	1.7;

1.7
date	94.05.19.20.34.30;	author ty7777;	state Exp;
branches;
next	1.6;

1.6
date	92.09.22.22.39.33;	author ty7777;	state Exp;
branches;
next	1.5;

1.5
date	92.09.17.14.56.20;	author ty7777;	state Exp;
branches;
next	1.4;

1.4
date	92.09.17.14.05.19;	author ty7777;	state Exp;
branches;
next	1.3;

1.3
date	92.09.16.18.29.36;	author ty7777;	state Exp;
branches;
next	1.2;

1.2
date	92.09.16.16.20.27;	author ty7777;	state Exp;
branches;
next	1.1;

1.1
date	92.09.15.16.54.54;	author ty7777;	state Exp;
branches;
next	;

1.9.1.1
date	95.04.28.20.03.42;	author ty7777;	state Exp;
branches;
next	;


desc
@gammaz initial version.
@


1.11
log
@Added .3sp file tail.
@
text
@/*$Id$*/
/*$Log: gammaz.c,v $
 * Revision 1.9  1994/05/27  14:33:31  ty7777
 * Modified by Tom Yang to read the new af3d output file and write the output
 * in x, y, and z format.
 *
 * Revision 1.8  1994/05/26  21:47:44  ty7777
 * Modified to read the new af3d output.
 *
 * Revision 1.7  1994/05/19  20:34:30  ty7777
 * The order of af3d output is changed.
 *
 * Revision 1.6  1992/09/22  22:39:33  ty7777
 * Reading .3sp and .3sn files as input.
 *
 * Revision 1.5  1992/09/17  14:56:20  ty7777
 * gammaz command line input working version.
 *
 * Revision 1.4  1992/09/17  14:05:19  ty7777
 * Command line input, before 3dp and 3dn files worked.
 **/

#define MAXPOINTS		100000	/* maximum data points allowed */
#define ZPOINTS			10000	/* maximum z-test points allowed */
#define MAXFILES		50	/* maximum input files allowed */
#define VERSION			3.0	/* program version */
#define MAXLINE			256	/* maximum number of characters in a line */

typedef struct			/* structure for holding z-test  */
{
	float	z;		/* z value                       */
	float	x;		/* x value                       */
	float	y;		/* y value                       */
	float	max;		/* maximum value                 */
	float	z_score;	/* z score value                 */
	float	significance;	/* significance level            */
} sig_numbers;

#include <stdio.h>
#include <string.h>
#include <math.h>

static char rcsid [] = "$Header$";

/*______________________________________________________________________

 program:	gammaz         H. Rebecca Kimmel           25 January 1989

 Description:	This program is based on the original Gammaz program written
		by Lewis Greer and Peter Fox. The original program was 
		written in Fortran for the Current Computers used by PET.
		GammaZ uses data output from AF3D and calculates the mean,
		standard deviation, gamma 1 and gamma 2 t-statistic, 
		t-statistic, skew, kurtosis, and z-test.

 Calls:		get_info 
		data_analysis
		write_info

 History:	Ported to the Sun Unix environment by Tom Yang on 
		Sep. 14, 1992.
		Changed by Tom Yang on Sep. 16, 1992 to take command
		line arguments.
______________________________________________________________________*/

main (argc, argv)
	int	argc;
	char	**argv;
{
	sig_numbers	z_array [ZPOINTS];		/* array holding z-test results */
	float		p1 [3],				/* .01 significance prob. of leptokurt */
			p2 [3],				/* .05 significance prob. of leptokurt */
			prob [3],			/* probability of leptokurtosis */
			cutoff,				/* cutoff for z-test */
			mean,				/* mean value for data points */
			ar [4][MAXPOINTS],		/* array holding af3d data points */
			qrob,				/* indicates skew */
			q1,				/* .01 signif. level for skew */
			q2,				/* .05 signif. level for skew */
			g2 [3],				/* gamma 2 - bottom, all, top curve */
			t2 [3],				/* tscore 2 - bottom, all, top curve */
			sd [3],				/* standard deviation - bottom, all, top */
			g1, t1;				/* gamma 1 and t-stat. for all points */
	int		zcount,				/* number of values in the z-test array */
			npos, nneg,			/* number of pos/neg data points */
			n [3],				/* number of data points at bottom, all, top */
			nkurt [3],			/* nkurt [1] = sample size nkurt [2] = 1% */
							/* significance nkurt [3] = 5% significance */
			nskew,				/* number of points used for skew */
			filenum,			/* number of input files read in */
			sarp,				/* flag indicating sarp is/not wanted */
			ztest,				/* flag indicating ztest desired */
			output_list [4],		/* array holding types of output wanted */
							/* [0] is console-this happens always */
							/* [1] is to an output file */
							/* [2] is to the printer */
			status,				/* error status */
			midpoint;			/* flag specifying mean or at 0 */
	char		outfile [80],			/* name of output file */
			filenames [MAXFILES][80];	/* array holding input filename*/

	/*
	 * Get command line optional parameters.
	 */
	filenum	= 2;
	strcpy (filenames [0], argv [1]);
	strcpy (filenames [1], argv [2]);
	cutoff	= atof (argv [3]);
	strcpy (outfile, argv [4]);

	/*
	 * Default parameters.
	 */
	sarp		= -1;
	midpoint	= 0;
	output_list [0]	= 1;
	output_list [1]	= 2;
	output_list [3]	= -1;
	ztest		= -1;

	/* 
	 * Initialize data counter array. 
	 */                   
	n[0]	= 0; 
	n[1]	= 0; 
	n[2]	= 0; 

	/* 
	 * Get input information and read in data.
	 */
	status	= get_info (n, ar, filenames, &filenum); 

	if (status != -2) /* if no fatal errors, do data analysis */
	{
		data_analysis (ar, n, &midpoint, &ztest, &sarp, sd, g2, t2, &npos, &nneg,
			&mean, &g1, &t1, &q1, &q2, nkurt, p1, p2, prob, &qrob, &nskew,
			z_array, &cutoff, &zcount);

		write_info (n, npos, nneg, mean, sd, g1, t1, midpoint, qrob, nskew, q1, q2, g2,
			t2, prob, nkurt, p1, p2, filenames, filenum, outfile, output_list, z_array,
			cutoff, ztest, zcount);
	}
}


/*______________________________________________________________________

Function:	get_info    H. Rebecca Kimmel           25 January 1989

Description:	This function reads in data from the .3dp and .3dn files.

Calls:		yes_no
		error_msg
		gets

Called by:	main

History:	Rewritten by Tom Yang. 
		09/16/1992.
______________________________________________________________________*/

get_info (n, ar, filenames, filenum)
	char	filenames [MAXFILES][80];	/* array holding input filenames */
	float	ar [4][MAXPOINTS];		/* array containing af3d data */
	int	*filenum,			/* number of input filenames read in */
		n [3];				/* number of points at bottom, top, all */
{
	int	status;				/* error status */
	int	split;				/* flag indicating files data is in */

	split	= 1;
	status	= rfile (&split, filenames [0], n, ar);

	split	= -1;
	status	= rfile (&split, filenames [1], n, ar);

	return (status);
}


/*_____________________________________________________________________

Function:	yes_no        H. Rebecca Kimmel            25 January 1989

Description:	This routine gets the answer from the user and sets the flag
		to either true or false.

Called by:	get_info

HIstory:
______________________________________________________________________*/

yes_no (q)
	char *q;	/* question */
{
	char	answ,	/* the actual answer from the user */
		ans;	/* the previous answer,since newline is read */
	int	answer;	/* flag returned to calling routine */

	answ	= ' ';
	printf ("\n%s :  ", q);
	while ((ans = getchar ()) != '\n')
		answ	= ans;
	if (answ == 'n'|| answ == 'N')
		answer	=  0; 
	else
		answer	= -1;

	return(answer) ;
}


/*___________________________________________________________________

Function:	rfile         H. Rebecca Kimmel          25 January 1989

Description:	This routine opens a file and reads in the data. If an 
		error is encountered, an error message is sent and the 
		routine terminates. The input file is in SPED format.

Called by:	get_info

History:	Modified by Tom Yang on Sep. 15, 1992 to read new af3d
		output.
____________________________________________________________________*/
rfile (split, filename, n, ar)
	float	ar [4][MAXPOINTS];	/* array containing data points read in */
	char	filename [80];		/* name of file containing data points */
	int	*split,			/* indicates if pos and neg files to be read */
		n [3];			/* number of points:bottom, all, top */
{
	char	header [MAXLINE];	/* header from file */
	int	status,		/* error status flag */
		i,		/* counter */
		xx, yy;		/* counter for rows and columns */
	FILE	*fp,		/* file pointer to input file */
		*fopen();	/* C function for opening files */

	status	= 0;   
	fp	= fopen (filename, "r");
	if (fp == NULL)                /* see if file exists are readable */
	{
		status	= error_msg (0);
		return (status);
	}

	i	= 0;
	fgets (header, MAXLINE, fp);
	fgets (header, MAXLINE, fp);
	sscanf (header, "%d, %d", &xx, &yy);
	/*
	fscanf (fp, "%d, %d", &xx, &yy);
	*/

	if (yy != 4 && yy != 1)
	{
		status	= error_msg (1);
		fclose (fp);
		return (status);
	}

	if ((n[1] + xx) > MAXPOINTS)  /* don't read more than array can hold*/
	{
		status	= error_msg (2);
		fclose (fp);
		return (status);
	}

	fgets (header, MAXLINE, fp);
	fgets (header, MAXLINE, fp);
	fgets (header, MAXLINE, fp);

	for (i = n [1]; i < (n [1] + xx); i++)
	{
		if (yy != 1)
			fscanf (fp, "%f %f %f %f", 
				&ar [1][i], &ar [2][i], &ar [0][i], &ar [3][i]);
		else
		{
			fscanf (fp, "%f", &ar [3][i]);
			ar [0][i]	= 0.0;
			ar [1][i]	= 0.0;
			ar [2][i]	= 0.0;
		}

		if (*split == -1 && ar [3][i] > 0.0) /* negate value in neg file*/
			ar [3][i]	= ar [3][i] * -1.0;
		if (ar [3][i] == 0.0)
		{
			printf ("%f %f %f %f\n", ar [0][i], ar [1][i], ar [2][i], ar [3][i]);
			status	= error_msg (3);
			status	= error_msg (1);
			fclose (fp);
			return (status);
		}
	} 

	n [1]	+= xx;
	fclose (fp);

	return (status);
}        


/*____________________________________________________________________

FUNCTION : DATA ANALYSIS      H. Rebecca Kimmel       25 January 1989

INTENT   : This function performs the different statistical analysis on
           the data.

CALLED BY: MAIN
CALLS    : ZTEST
           ERROR_MSG

HISTORY  :
_____________________________________________________________________*/

data_analysis (ar, n, midpoint, ztest, sarp, sd, g2, t2, npos, nneg, mean, g1, t1,
		q1, q2, nkurt, p1, p2, prob, qrob, nskew, z_array, cutoff, zcount)

	sig_numbers	z_array [ZPOINTS];	/* array to hold ztest results */

	float		ar [4][MAXPOINTS],	/* array holding data points for analysis */
			prob [3],		/* probability of leptokurtosis */
			sd [3],			/* standard deviation-bottom, all, top */
			g2 [3],			/* gamma 2 -bottom, all, top curve */
			t2 [3],			/* tscore 2 - bottom, all, top curve */
			*q1,			/* .01 signif. level for skew */
			*q2,			/* .05 signif. level for skew */
			*g1,			/* gamma 1 for all points */
			*t1,			/* t-stat for all points */
			*mean,			/* mean value for data points */
			*qrob,			/* Indicates skew */
			*cutoff,		/* cutoff for z-test */
			p1 [3],			/* .01 signif.prob of leptokurtosis */
			p2 [3];			/* .05 signif.prob of leptokurt-bot, all, top*/

	int		*midpoint,		/* flag specifying mean or at 0 */
			*npos,			/* number of positive data points */
			*nneg,			/* number of negative data points */
			*nskew,			/* number of points used for skew */
			*ztest,			/* flag indicating z-test determination */
			*sarp,			/* flag indicating sarp transformation */
			*zcount,		/* number of data points in the z-array */
			nkurt[3],		/* sample size,1%sig, 5% significance */
			n[3];			/* number of data points@@bottom, all, top */

{
	/*
	 * KURTOSIS TABLE      SAMPLE   0.1   0.5
	 *                          SIZE     SIG   SIG                      
	 */
	static float kurt [27][3] = {50.0, 4.88, 3.99,
                                75.0, 4.59, 3.87,
                               100.0, 4.39, 3.77,
                               125.0, 4.24, 3.71,
                               150.0, 4.13, 3.65,
          		       200.0, 3.98, 3.57,
                               250.0, 3.87, 3.52,
                               300.0, 3.79, 3.47,
                               350.0, 3.72, 3.44,
                               400.0, 3.67, 3.41,
                               450.0, 3.63, 3.39,
                               500.0, 3.60, 3.37,
                               550.0, 3.57, 3.35,
                               600.0, 3.54, 3.34,
                               650.0, 3.52, 3.33,
                               700.0, 3.50, 3.31,
                               750.0, 3.48, 3.30,
                               800.0, 3.46, 3.29,
                               850.0, 3.45, 3.28,
                               900.0, 3.43, 3.28,
                               950.0, 3.42, 3.27,
                              1000.0, 3.41, 3.26,
                              1200.0, 3.37, 3.24,
                              1400.0, 3.34, 3.22,
                              1600.0, 3.32, 3.21,
                              1800.0, 3.30, 3.20,
                              2000.0, 3.28, 3.18 } ;

	/*
	 * SKEW TABLE        SAMPLE 0.01  0.05
         *                   SIZE  SIG.  SIG.               
	 */
	static float skew[21][3] = {25.,1.061, .711,
                              30., .982, .661,
                              35., .921, .621,
                              40., .869, .587,
                              45., .825, .558,
                              50., .787, .553,
                              60., .723, .492,
                              70., .673, .459,
                              80., .631, .432,
                              90., .596, .409,
                             100., .567, .389,
                             125., .508, .350,
                             150., .464, .321,
                             175., .430, .298,
                             200., .403, .280,
                             250., .360, .251,
                             300., .329, .230,
                             350., .305, .213,
                             400., .285, .200,
                             450., .269, .188,
                             500., .255, .179 };

	float	moment [3][3],	/* moment array */ 
		temp_moment,	/* temporary moment buffer */
		tdiv,		/* temp.divisor for skew diff */
		tmp,		/* temp value */
		s1, s2,		/* place holders for kurt diff */
		nn,		/* number of points */
		jfloat;		/* convert counter to float */
	int	i,		/* counter                      */
		j,		/* counter                      */
		status,		/* error status code            */
		temp;		/* temp value                   */

	/* 
	 * initialize the moment array 
	 */
	for (i = 0; i < 3; i++)
		for (j = 0; j < 3; j++)
			moment [i][j]	= 0;

	/* 
	 * initialize probability array 
	 */
	prob [0]	= -1.0;
	prob [1]	= -1.0;
	prob [2]	= -1.0;

	/*
	 * calculate mean 
	 */
	*mean	= 0;
	*npos	= 0;
	*nneg	= 0;

	for (i = 0; i < n [1]; i++)
	{
		*mean	+= ar[3][i];
		if (ar [3][i] > 0.0)
			++*npos;
		else if (ar [3][i] < 0.0)
			++*nneg;
	}
	*mean	= *mean / n [1];

	/* 
	 * calculate moment  
	 */
	for (i = 0; i < n [1]; i++)
	{
		if ((ar [3][i] - *midpoint * *mean) >= 0.0)
			temp	= 2;
		else
			temp	= 0;
		++n [temp];
		for (j = 0; j < 3; j++)
		{
			jfloat			= j;
			temp_moment		= pow ((ar [3][i] - *midpoint * *mean), (jfloat + 2.0));
			moment [1][j]		+= temp_moment;
			moment [temp][j]	+= temp_moment ;
		}
	}
  
	for (i = 0; i < 3; i++)
	{
		nn	= n [i];
		for (j = 0; j < 3; j++)
			moment [i][j]	= moment [i][j] /nn;
	}
  
	for (i = 0; i < 3; i++)
	{
		sd [i]	= sqrt (moment [i][0]);
		g2 [i]	= (moment [i][2] / (pow (sd [i], 4.0))) - 3.0;
		tmp	= 24.0 * n [i] * pow ((n [i] - 1.0), 2.0);
		tmp	= tmp / ((n [i] - 3.0) * (n [i] - 2.0) * (n [i] + 3.0) * (n [i] + 5.0));
		tmp	= sqrt (tmp);
		t2 [i]	= g2 [i] / tmp;
	}

  *g1 = moment[1][1]/pow(sd[1],3.0) ;
  tmp = sqrt((6.*n[1]*(n[1]-1.))/((n[1]-2.)*(n[1]+1.)*(n[1]+3.))) ;
  *t1 = *g1/tmp ;
  for (j=0;j<3;j++)
    {if (n[j] < 50)
       {status   = error_msg(4) ;   
        nkurt[j] = 50           ;
       }
     else
       nkurt[j] = n[j] ;
     temp = 1 ;
     if (n[j] > 2000) 
       prob[j] = 0.0 ;
    }
  for (j=0;j<3;j++)
    {if (prob[j] != 0)
      {for (i=1;i<27 && kurt[i][0] < nkurt[j];i++) ;
       s2     = kurt[i][0]-nkurt[j]                ;
       s1     = nkurt[j]-kurt[i-1][0]              ;
       p1[j]  = (s1*kurt[i][1]+s2*kurt[i-1][1])/(kurt[i][0]-kurt[i-1][0]);
       p2[j]  = (s1*kurt[i][2]+s2*kurt[i-1][2])/(kurt[i][0]-kurt[i-1][0]);
       p1[j] -= 3 ;
       p2[j] -= 3 ;
       if (g2[j] >= p1[j])
         prob[j] = 1. ;
       else
         if (g2[j] >= p2[j])
           prob[j] = 5. ;
         else
           prob[j] = 100. ;
      }
    }
 if (n[1] < 25)
   *nskew = 25   ;
 else
   *nskew = n[1] ;
 if (n[1] < 500)
   {for (i=1;i<21 && skew[i][0] < *nskew;i++)         ;
    s2   = skew[i][0] - *nskew                        ;
    s1   = *nskew - skew[i-1][0]                      ;
    tdiv = skew[i][0] - skew[i-1][0]                  ;
    *q1  = (s1 * skew[i][1] + s2 * skew[i-1][1])/tdiv ;
    *q2  = (s1 * skew[i][2] + s2 * skew[i-1][2])/tdiv ;
    if (*g1 >= *q1)
      *qrob = 1.0;
    else
      if (*g1 >= *q2)
        *qrob = 5.0  ; 
      else
        *qrob = 100.0;
   }
 else
   *qrob = 0.0 ;

	if (*ztest)
		z_test (z_array, ar, n, mean, midpoint, sd, cutoff, sarp, zcount); 
}

/**********************************************************************

FUNCTION : AGAUSS           H. Rebecca Kimmel        25 January 1989

INTENT   : This function computes the integral of the Gaussian curve 
           from Bevington, "Data Reduction and Error Analysis for the 
           Physical Sciences",p.48.

CALLED BY: Z_TEST         

HISTORY  :
**********************************************************************/

float agauss (x,average,sigma)

float x      ,
      average,
      sigma  ;
{
#define CONSTANT 0.0000000001
 double denom ,
        term  ,
        sum   ,
        y2    ,
        z     ;

 float gauss  ;

 z     = fabs((x-average))/sigma  ;

 if (z <= 0) 
   gauss = 0. ;
 else 
   {term   = 0.7071067812 * z      ; 
    sum    = term                  ; 
    y2     = (z*z)/2.              ;
    denom  = 1.                    ;
    denom  = denom + 2.            ;
    term   = term * (y2*2./denom)  ;
    sum    = sum + term            ;
    while ((term/sum - CONSTANT) > 0)
      { denom = denom + 2.        ;
        term  = term*(y2*2./denom);
        sum   = sum + term        ;
      }
    gauss  = 1.128379167*sum* exp(-y2) ;
   }
 return (gauss) ;
}

/**********************************************************************

FUNCTION : ERROR_MSG      H. Rebecca Kimmel     25 January 1989

INTENT   : This function prints out an error message to the user then
           returns a status code to the calling routine indicating
           whether or not the error was fatal.

CALLED BY: GET_INFO
           GET_DATA
           RFILE
           DATA_ANALYSIS

HISTORY  :

**********************************************************************/

error_msg(number)

int number ;

{
 switch (number)
   {
    case 0: printf ("*** ERROR 0 *** File not found\n") ;
            return(-2) ; 
    case 1: printf ("*** ERROR 1 *** Format of file incorrect! File not read in\n") ;
            return(-1) ;
    case 2: printf ("*** ERROR 2 *** Number of data points exceeds MAXPOINTS %d\n",MAXPOINTS) ;
            return(-1) ;
    case 3: printf ("*** ERROR 3 *** Data contains a peak at 0.0\n") ; 
            return(-1) ;
    case 4: printf ("*** WARNING 4  *** Analysis continued with subminimal points\n") ;
            return (-1) ;
    case 5: printf ("*** ERROR 5 *** No files entered --- Program Terminating\n") ;
            return (-2) ;
    case 6: printf ("*** ERROR 6 *** Need to enter a negative data file ****\n") ;
            return (-2) ;
    case 7: printf ("*** ERROR 7 *** Maximum files (%d) have been entered ****\n");
            return (-1) ;
   }
}


/*____________________________________________________________________

Function:	write_info         H. Rebecca Kimmel    25 January 1989

Description:	This function writes out the results to the output locations
		specified by the user.  This includes the terminal, the line 
		printer and a file on a hard disk.

Called by:	main
Cales:		screen_output
		file_output 

History:
_____________________________________________________________________*/

char tmp_file [80]	= {'t', 'm', 'p', 'f', 'i', 'l', 'e'};	/*tmpfilename */
write_info (n, npos, nneg, mean, sd, g1, t1, midpoint, qrob, nskew, q1, q2, g2, t2,
		prob, nkurt, p1, p2, filenames, filenum, outfile, output_list,
		z_array, cutoff, ztest, zcount)
	sig_numbers	z_array [ZPOINTS];		/* array containing z test values */
	char		filenames [MAXFILES][80],	/* array containing input filenames */
			outfile [80];			/* name of output file-user specified */
	float		sd [3],				/* standard deviations */
			g2 [3],				/* gamma 2 statistics */
			t2 [3],				/* t-statistics */
			p1 [3],				/* 0.01 significance leptokurtosis */
			p2 [3],				/* 0.05 significance leptokurtosis */
			g1,				/* gamma 1 statistic of all points */
			t1,				/* gamma 1 t-statistic of all points */
			q1,				/* 0.01 significance of skew */
			q2,				/* 0.05 significance of skew */
			mean,				/* mean value of all points */
			qrob,				/* indication of skew */
			cutoff,				/* cutoff value used for z test */
			prob [3];			/* indication of kurtosis */
	int		midpoint,			/* flag indicating how mean calc'd */
			npos,				/* number of positive data points */
			nneg,				/* number of negative data points */
			nskew,				/* number of points used for skew */
			ztest,				/* flag indicating z test determin */
			nkurt [3],			/* number of points used for kurtosis */
			output_list [4],		/* types of output desired by user */
			filenum,			/* number of input filenames */
			n [3];				/* number of data points */
{
	int	done,	/* flag indicating done with output */
		output, /* value from output file */
		index;	/* pointer into output array */

	done	= 0;  
	index	= 0;
	output	= output_list [index];
	switch (output)
	{
		case 1:		/* send the output to the terminal console */
			break;

		case 2:		/* send the output to the disk file-user specified */
			file_output (n, npos, nneg, mean, sd, g1, t1, midpoint,
				qrob, nskew, q1, q2, g2, t2, prob, nkurt, p1,
				p2, outfile, z_array, cutoff, ztest, zcount,
				filenames, filenum);
			break;

		case 3:		/* send the output to the printer-user requested */
			file_output (n, npos, nneg, mean, sd, g1, t1, midpoint,
				qrob, nskew, q1, q2, g2, t2, prob, nkurt, p1,
				p2, tmp_file, z_array, cutoff, ztest, zcount,
				filenames, filenum);
				system ("pr tmpfile | lp");
			system ("rm tmpfile");
			break;
		case -1:
			done = -1;
			break ;
	}
	while (!done)
	{
		index++;
		output	= output_list [index];
		switch (output)
		{
			case 1:
				screen_output (n, npos, nneg, mean, sd, g1, t1, midpoint,
						qrob, nskew, q1, q2, g2, t2, prob, nkurt, p1,
						p2, z_array, cutoff, ztest, zcount,
						filenames, filenum);
				break;
			case 2:  
				file_output (n, npos, nneg, mean, sd, g1, t1, midpoint,
						qrob, nskew, q1, q2, g2, t2, prob, nkurt, p1,
						p2, outfile, z_array, cutoff, ztest, zcount,
						filenames, filenum);
				break;
			case 3:  
				file_output (n, npos, nneg, mean, sd, g1, t1, midpoint,
						qrob, nskew, q1, q2, g2, t2, prob, nkurt, p1,
						p2, tmp_file, z_array, cutoff, ztest, zcount,
						filenames, filenum);
				system ("pr tmpfile | lp");
				system ("rm tmpfile");
				break;
			case -1:
				done	= -1;
				break;
		}
	}
} 


/*____________________________________________________________________

FUNCTION  : FILE_OUTPUT     H. Rebecca Kimmel         25 January 1989

INTENT    : This function outputs the results to an output file
            specified by the user.

CALLED BY : WRITE_INFO

HISTORY   : Modified by Tom Yang for Sun Workstation on Sep. 14, 1992.
_____________________________________________________________________*/
file_output (n, npos, nneg, mean, sd, g1, t1, midpoint, qrob, nskew, q1, q2, g2, t2,
	prob, nkurt, p1, p2, outfile, z_array, cutoff, ztest, zcount, filenames, filenum) 
	sig_numbers	z_array [ZPOINTS];	/* ALL VARIABLES DEFN IN WRITE_INFO */
	char		filenames [MAXFILES][80],
			outfile [80];
	float		sd [3],
			g2 [3],
			t2 [3],
			p1 [3],
			p2 [3],
			g1,
			t1,
			q1,
			q2,
			mean,
			qrob,
			cutoff,
			prob [3];
	int		midpoint,
			npos,
			nneg,
			nskew,
			ztest,
			zcount,
			filenum,
			nkurt [3],
			n [3];
{
	int	j;
	FILE	*fp;
	FILE	*af3dfp;
	char	line [MAXLINE];

	fp	= fopen (outfile, "w");

	fprintf (fp, "Input files:\n");
	for (j = 0; j < filenum; j++)
		fprintf (fp, "%s\n", filenames [j]);
	fprintf (fp, "\n\n                           GammaZ v %.1f   09/21/92\n\n", VERSION);
	fprintf (fp, "Number of data points:     %8d\n", n [1]);
	fprintf (fp, "Number of positive points: %8d\n", npos);
	fprintf (fp, "Number of negative points: %8d\n\n", nneg);
	fprintf (fp, "Mean:                      %8.4f\n\n", mean);
	if (midpoint == 1)
	{
		fprintf (fp, "Distribution is split at the mean\n");
		fprintf (fp, "Number of points above the mean: %8d\n", n[2]);
		fprintf (fp, "Number of points below the mean: %8d\n\n", n[0]);
	}
	else
		fprintf (fp, "Distribution is split at 0\n\n");

	fprintf (fp, "Standard deviation of all points:              %8.4f\n", sd [1]);
	fprintf (fp, "SD of the top of the curve:                    %8.4f\n", sd [2]);
	fprintf (fp, "SD of the bottom of the curve:                 %8.4f\n\n", sd [0]);

	fprintf (fp, "Gamma 1 statistic of all points:    %8.4f\n", g1);
	fprintf (fp, "Gamma 1 t-statistic for all points: %8.4f\n\n", t1); 
	if (qrob == 0.0)
		fprintf (fp, "Too many points to test skew\n");
	else
	{
		if (qrob > 5)
			fprintf (fp, "There is no significant skew.\n");
		else
			fprintf (fp, "There is a better than %.2f %% significance of skew.\n", qrob);

		fprintf (fp, " For %d points significance levels are:\n", nskew);

		if (nskew != n[1])
			fprintf (fp, "         Note: %d actual points!\n", n[1]);

		fprintf (fp, "    0.01 : %8.4f     0.05 :   %8.4f\n", q1, q2);
	}

	fprintf (fp, "\nGamma 2 statistic of all points:       %8.4f\n", g2[1]);
	fprintf (fp, "Gamma 2 of the top of the curve:       %8.4f\n", g2 [2]);
	fprintf (fp, "Gamma 2 of the bottom of the curve:    %8.4f\n\n", g2 [0]);
	fprintf (fp, "Gamma 2 t-statistic for all points:    %8.4f\n", t2 [1]);
	fprintf (fp, "t-statistic for the top points:        %8.4f\n", t2 [2]);
	fprintf (fp, "t-statistic for the bottom points:     %8.4f\n", t2 [0]);
	fprintf (fp, "Nota bene: Do NOT use the t-statistic for less than 2000 points.\n\n");
	fprintf (fp, "Kurtosis:\n\n");

	for (j = 0; j < 3; j++)
	{
		if (j == 0)
			fprintf (fp, "Bottom of curve:\n");
		else
			if (j == 1)
				fprintf (fp, "All points:\n");
		else          
			fprintf (fp, "Top of curve:\n") ;

		if (prob[j] == 0.0)
			fprintf (fp, "Too many points to test kurtosis, please use t-statistic\n");
		else
			if (prob[j] > 5.0)
				fprintf (fp, "There is no significant leptokurtosis.\n");
			else
		fprintf (fp, "There is a better than %.1f %% significance of leptokurtosis.\n", prob[j]);

		fprintf (fp, " For %d points, significance levels are:\n", nkurt [j]);

		if (nkurt[j] != n[j])
			fprintf (fp, "(Note: %d actual points!)\n", n[j]);

		fprintf (fp, "0.01 : %8.4f   0.05 : %8.4f\n\n", p1[j], p2[j]);
	}

	if (ztest)
	{
		fprintf (fp, "Cutoff at %.4f\n\n", cutoff) ;
		fprintf (fp, "   x        y        z        max     z-score    significance level\n");
		for (j = 0; j < zcount; j++)
			fprintf (fp, "%6.1f   %6.1f   %6.1f   %7.2f   %7.3f       %9.3f\n",
				z_array[j].x, z_array[j].y, z_array[j].z, z_array[j].max,
				z_array[j].z_score, z_array[j].significance);
	}

	af3dfp	= fopen (filenames [0], "r");
	while (fgets (line, MAXLINE, af3dfp) != NULL)
	{
		if (strstr (line, "af3d_par") != NULL
		|| strstr (line, "Processing Stream") != NULL 
		|| strstr (line, "PROCESSING STREAM") != NULL)
			break;
	}
	fprintf (fp, "\n%s", line);

	while (fgets (line, MAXLINE, af3dfp) != NULL)
	{
		fprintf (fp, "%s", line);
	}

	fclose (af3dfp); 

	fclose (fp); 
}

/***********************************************************************

FUNCTION  : SCREEN_OUTPUT      H. Rebecca Kimmel 25 January 1989

INTENT    : This function outputs the results to the screen if requested
            by the user.  The default is currently set to yes.

CALLED BY : WRITE_INFO

HISTORY   :
***********************************************************************/
screen_output (n,npos,nneg,mean,sd,g1,t1,midpoint,qrob,nskew,q1,q2,g2,
               t2,prob,nkurt,p1,p2,z_array,cutoff,ztest,zcount,
               filenames,filenum) 

char filenames[MAXFILES][80] ; /* ALL VARIABLES DEFINED IN WRITE INFO */
sig_numbers z_array[ZPOINTS] ;

float sd[3]   ,
      g2[3]   ,
      t2[3]   ,
      p1[3]   ,
      p2[3]   ,
      g1      ,
      t1      ,
      q1      ,
      q2      ,
      mean    ,
      qrob    ,
      cutoff  ,
      prob[3] ;

int   midpoint ,
      npos     ,
      nneg     ,
      ztest    ,
      filenum  ,
      zcount   ,
      nskew    ,
      nkurt[3] ,
      n[3]     ;

{
 int j         ;


 fprintf (stdout,"\n\n                           GammaZ  %.1f\n\n\n",VERSION);
 fprintf (stdout,"Input filenames are:\n\n") ;
 for (j=0; j<filenum; j++)
   fprintf (stdout,"   %s\n",filenames[j]) ;
 fprintf (stdout,"\n") ;
 fprintf (stdout,"Number of data points    : %8d\n",n[1]);
 fprintf (stdout,"Number of positive points: %8d\n",npos) ;
 fprintf (stdout,"Number of negative points: %8d\n\n",nneg) ;
 fprintf (stdout,"                     Mean: %8.4f\n\n",mean) ;
 if (midpoint == 1)
   {fprintf (stdout,"Distribution is split at the mean\n") ;
    fprintf (stdout,"Number of points above the mean: %8d\n",n[2]) ;
    fprintf (stdout,"Number of points below the mean: %8d\n\n",n[0]) ;
   }
 else
   fprintf (stdout,"Distribution is split at 0\n\n") ;
 fprintf (stdout,"Standard deviation of all points             : %8.4f\n",sd[1])   ;
 fprintf (stdout,"Standard deviation at the top of the curve   : %8.4f\n",sd[2])   ;
 fprintf (stdout,"Standard deviation at the bottom of the curve: %8.4f\n\n",sd[0]) ;
 fprintf (stdout,"Gamma 1 statistic of all points   : %8.4f\n",g1)                 ;
 fprintf (stdout,"Gamma 1 t-statistic for all points: %8.4f\n\n",t1)               ; 
 if (qrob == 0.0)
   fprintf (stdout,"Too many points to test skew\n") ;
 else
   {if (qrob > 5)
      fprintf (stdout,"There is no significant skew.\n") ;
    else
      fprintf (stdout,"There is a better than %.2f %% significance of skew.\n",qrob) ;
    fprintf (stdout,"For %d points significance levels are:\n",nskew) ;
    if (nskew != n[1])
      fprintf (stdout,"         Note: %d actual points!\n",n[1]) ;
    fprintf (stdout,"    0.01: %8.4f     0.05:   %8.4f\n",q1,q2) ;
   }
 fprintf (stdout,"\nGamma 2 statistic of all points      : %8.4f\n",g2[1]) ;
 fprintf (stdout,"Gamma 2 of the top of the curve      : %8.4f\n",g2[2])   ;
 fprintf (stdout,"Gamma 2 of the bottom of the curve   : %8.4f\n\n",g2[0]) ;
 fprintf (stdout,"Gamma 2 t-statistic for all points   : %8.4f\n",t2[1])   ;
 fprintf (stdout,"Gamma 2 t-statistic for top points   : %8.4f\n",t2[2])   ;
 fprintf (stdout,"Gamma 2 t-statistic for bottom points: %8.4f\n",t2[0])   ;
 fprintf (stdout,"Nota bene: Do NOT use the t-statistic for less than 2000 points.\n\n");
 fprintf (stdout,"Kurtosis:\n\n") ;
 for (j=0;j<3;j++)
   {if (j == 0)
      fprintf (stdout,"Bottom of curve:\n") ;
    else
      if (j == 1)
        fprintf (stdout,"All points:\n") ;
      else          
        fprintf (stdout,"Top of curve:\n") ;
    if (prob[j] == 0.0)
      fprintf (stdout,"Too many points to test kurtosis,please use t-statistic\n") ;
    else
      if (prob[j] > 5.)
        fprintf (stdout,"There is no significant leptokurtosis\n") ;
      else
        fprintf (stdout,"There is a better than %.2f %% significance of leptokurtosis\n",prob[j]) ;
    fprintf (stdout,"For %d points, significance levels are:\n",nkurt[j]) ;
    if (nkurt[j] != n[j])
       fprintf (stdout,"(Note: %d actual points!)\n",n[j]) ;
    fprintf (stdout,"0.01: %8.4f   0.05: %8.4f\n\n",p1[j],p2[j]) ;
   }
	if (ztest)
	{
		fprintf (stdout, "                        Results of Z Test\n\n");
		fprintf (stdout, "Cutoff at: %f\n\n", cutoff) ;
		fprintf (stdout, "   Z        X        Y        MAX     Z-SCORE    SIGNIFICANCE\n");
		fprintf (stdout, "                                                    LEVEL\n");
		for (j = 0; j < zcount; j++)
			fprintf (stdout, "%6.1f   %6.1f   %6.1f   %7.2f   %7.3f    %9.3f\n",
				z_array[j].z, z_array[j].x, z_array[j].y, z_array[j].max,
				z_array[j].z_score, z_array[j].significance);
	}
}


/*____________________________________________________________________

Function:	z_test         H. Rebecca Kimmel          25 January 1989

Description:	This function performs a z-test on the af3d data. If the
		user requests it, the data is translated into sarp space.

Caled by:	data_analysis
Calls:		agauss

History:	Modified by Tom Yang to read .3sp and .3sn files.
		09/22/1992.
____________________________________________________________________*/

z_test (z_array, ar, n, mean, midpoint, sd, cutoff, sarp, zcount) 

	sig_numbers	z_array [ZPOINTS];	/* array holding z-test results */
	float		ar [4][MAXPOINTS],	/* array holding data points */
			sd [3],			/* standard deviation              */
			*cutoff,		/* cutoff point for significance   */
			*mean;			/* mean of data points             */
	int		n [3],			/* number of points                */
			*zcount,		/* number of values in z-array     */
			*sarp,			/* flag indicating sarp transform. */
			*midpoint;		/* flag indicating mean determin.  */

{
	int	i, j, k, count;		/* counters                        */
	float	temp,			/* temporary place holder          */
		mid_mean,		/* holder for mean * midpoint      */
		significance;		/* z-test significance             */

	/* 
	 * Sort values in array. 
	 */
	for (i = 0; i < n[1]; i++)
	{
		for (j = 1; j < n[1]; j++)
		{
			if (ar[3][j] > ar[3][j - 1])
				for (k = 0; k < 4; k++)
				{
					temp		= ar[k][j];
					ar[k][j]	= ar[k][j - 1];
					ar[k][j - 1]	= temp;
				}
		}
	}

	*zcount		= 0;
	mid_mean	= *mean * *midpoint;
	for (i = 0; i < n[1]; i++) 
	{
		significance	= 1.0 - (agauss(ar[3][i], mid_mean, sd[1])); 
		if (significance <= *cutoff) 
		{
			if (*sarp)
			{
				z_array [*zcount].z		= ar [0][i];
				z_array [*zcount].x		= ar[1][i];
				z_array [*zcount].y		= ar[2][i];
				z_array [*zcount].max		= ar[3][i];
				z_array [*zcount].z_score	= (ar[3][i] - mid_mean) / sd[1];
				z_array [*zcount].significance	= significance;
			}
			++*zcount;
		}
	}
}
@


1.10
log
@Deleted STREAM.
@
text
@d47 1
a47 1
 program:	gammaz         
d790 1
d880 17
a898 1

@


1.9
log
@Modified by Tom Yang to read the new af3d output file and write the output
in x, y, and z format.
@
text
@d1 1
a1 1
/*$Header: /home/petsun4/ty7777/src/gammaz/RCS/gammaz.c,v 1.8 1994/05/26 21:47:44 ty7777 Exp ty7777 $*/
d3 4
d43 2
d47 1
a47 1
 program:	gammaz         H. Rebecca Kimmel           25 January 1989
a789 1
	FILE	*af3dfp;
a878 16
	af3dfp	= fopen (filenames [0], "r");
	while (fgets (line, MAXLINE, af3dfp) != NULL)
	{
		if (strstr (line, "Processing Stream") != NULL 
		|| strstr (line, "PROCESSING STREAM") != NULL)
			break;
	}
	fprintf (fp, "\n%s", line);

	while (fgets (line, MAXLINE, af3dfp) != NULL)
	{
		fprintf (fp, "%s", line);
	}

	fclose (af3dfp); 

d881 1
@


1.9.1.1
log
@Same as 1.9
@
text
@d1 1
a1 1
/*$Id$*/
a2 4
 * Revision 1.9  1994/05/27  14:33:31  ty7777
 * Modified by Tom Yang to read the new af3d output file and write the output
 * in x, y, and z format.
 *
a38 2
static char rcsid [] = "$Header$";

d877 2
a878 1
		if (strstr (line, "af3d_par") != NULL)
@


1.8
log
@Modified to read the new af3d output.
@
text
@d1 1
a1 1
/*$Header: /home/petsun4/ty7777/src/gammaz/RCS/gammaz.c,v 1.7 1994/05/19 20:34:30 ty7777 Exp ty7777 $*/
d3 3
d867 1
a867 1
		fprintf (fp, "   z        x        y        max     z-score    significance level\n");
d870 1
a870 1
				z_array[j].z, z_array[j].x, z_array[j].y, z_array[j].max,
@


1.7
log
@The order of af3d output is changed.
@
text
@d1 1
a1 1
/*$Header: /home/petsun4/ty7777/src/gammaz/RCS/gammaz.c,v 1.6 1992/09/22 22:39:33 ty7777 Exp ty7777 $*/
d3 3
a20 1
#define HEADER_LINES_NUM	6	/* number of lines for .3sp and .3sn header */
d226 1
a226 2
		xx, yy,		/* counter for rows and columns */
		slice;		/* slice number */
d239 6
a244 2
	while (fgets (header, MAXLINE, fp) != NULL && ++i < HEADER_LINES_NUM)
		;
a245 1
	fscanf (fp, "%d, %d", &xx, &yy);
d260 4
d267 2
a268 5
			/*
			fscanf (fp, "%d %f %f %f %f", &slice, &ar[0][i], &ar[1][i], &ar[2][i], &ar[3][i]);
			*/
			fscanf (fp, "%f %f %f %d %f", 
				&ar [1][i], &ar [2][i], &ar [0][i], &slice, &ar [3][i]);
@


1.6
log
@Reading .3sp and .3sn files as input.
@
text
@d1 1
a1 1
/*$Header: /home/petsun4/ty7777/src/gammaz/RCS/gammaz.c,v 1.5 1992/09/17 14:56:20 ty7777 Exp ty7777 $*/
d3 3
d259 1
d261 3
@


1.5
log
@gammaz command line input working version.
@
text
@d1 1
a1 1
/*$Header: /usr/local/src/gammaz/RCS/gammaz.c,v 1.4 1992/09/17 14:05:19 ty7777 Exp $*/
d3 3
d10 6
a15 4
#define MAXPOINTS 100000         /* Maximum data points allowed   */
#define ZPOINTS   10000          /* Maximum z-test points allowed */
#define MAXFILES  50             /* Maximum input files allowed   */
#define VERSION   3.0            /* Program Version               */
d167 1
a167 1
/***********************************************************************
d169 1
a169 1
FUNCTION: YES_NO        H. Rebecca Kimmel            25 January 1989
d171 2
a172 2
INTENT   : This routine gets the answer from the user and sets the flag
           to either true or false.
d174 1
a174 2
CALLED BY: GET_DATA
           GET_INFO
d176 2
a177 2
HISTORY  :
***********************************************************************/
d180 1
a180 1
char *q       ; /* question                                 */
d182 3
a184 3
  char answ   , /* the actual answer from the user          */
       ans    ; /* the previous answer,since newline is read*/
  int  answer ; /* flag returned to calling routine         */
d186 10
a195 9
  answ = ' ' ;
  printf ("\n%s :  ",q) ;
  while ((ans=getchar()) != '\n')
     answ = ans ;
  if (answ == 'n'|| answ == 'N')
     answer =  0 ; 
  else
     answer = -1 ;
  return(answer) ;
d213 2
a214 2
	float	ar[4][MAXPOINTS];	/* array containing data points read in */
	char	filename[80];		/* name of file containing data points */
d216 1
a216 1
		n[3];			/* number of points:bottom, all, top */
d218 1
a218 1
	char	header[80];	/* header from file */
d221 2
a222 1
		xx, yy;		/* counter for rows and columns */
d234 5
a238 2
	fgets (header, 80, fp);
	fscanf (fp, "%d %d", &xx, &yy);
d256 1
a256 1
			fscanf (fp, "%f %f %f %f", &ar[0][i], &ar[1][i], &ar[2][i], &ar[3][i]);
d265 1
a265 1
		if (*split == -1 && ar [3][i] > 0) /* negate value in neg file*/
d267 1
a267 1
		if (ar[3][i] == 0)
d269 1
d277 1
a277 1
	n[1]	+= xx;
d284 1
a284 1
/**********************************************************************
d296 1
a297 2
**********************************************************************/

d301 1
a301 1
	sig_numbers	z_array[ZPOINTS];	/* array to hold ztest results */
d303 2
a304 2
	float		ar[4][MAXPOINTS],	/* array holding data points for analysis */
			prob[3],		/* probability of leptokurtosis */
d329 5
a333 3
      /* KURTOSIS TABLE      SAMPLE   0.1   0.5
                             SIZE     SIG   SIG                      */
  static float kurt[27][3] = {  50.0, 4.88, 3.99,
d361 5
a365 3
       /* SKEW TABLE        SAMPLE 0.01  0.05
                             SIZE  SIG.  SIG.               */
  static float skew[21][3] = {25.,1.061, .711,
d385 1
a385 1
                             500., .255, .179 } ;
d387 11
a397 11
  float moment[3][3], /* moment array                 */ 
        temp_moment , /* temporary moment buffer      */
        tdiv        , /* temp.divisor for skew diff   */
        tmp         , /* temp value                   */
        s1,s2       , /* place holders for kurt diff  */
        nn          , /* number of points             */
        jfloat      ; /* convert counter to float     */
  int   i           , /* counter                      */
        j           , /* counter                      */
        status      , /* error status code            */
        temp        ; /* temp value                   */
d399 6
a404 5
  /* initialize the moment array */
   
  for (i=0;i<3;i++)
    for (j=0;j<3;j++)
       moment[i][j] = 0 ;
d406 6
a411 1
  /* initialize probability array */
d413 6
a418 3
  prob[0] = -1. ;
  prob[1] = -1. ;
  prob[2] = -1. ;
d420 9
a428 1
/*calculate mean */
d430 18
a447 30
  *mean = 0 ;
  *npos = 0 ;
  *nneg = 0 ;
 

  for (i=0;i<n[1];i++)
    {*mean += ar[3][i] ;
     if (ar[3][i] > 0)
       ++*npos ;
     else
       {if (ar[3][i] < 0)
         ++*nneg ;
       }
    }
  *mean = *mean/n[1] ;

 /* calculate moment  */
  for (i=0; i<n[1]; i++)
    {if ((ar[3][i]-*midpoint* *mean) >= 0)
        temp = 2 ;
     else
        temp = 0 ;
     ++n[temp] ;
     for (j=0;j<3;j++)
       {jfloat      = j        ;
	temp_moment = pow((ar[3][i]-*midpoint* *mean),(jfloat+2.));
        moment[1][j]    += temp_moment ;
        moment[temp][j] += temp_moment ;
       }
    }
d449 6
a454 5
  for (i=0;i<3;i++)
    {nn = n[i]       ;
     for (j=0;j<3;j++)
       moment[i][j] = moment[i][j]/nn ;
    }
d456 10
a465 8
  for (i=0;i<3;i++)
    {sd[i] = sqrt(moment[i][0]);
     g2[i] = (moment[i][2]/(pow(sd[i],4.0))) - 3.0 ;
     tmp   = 24.0*n[i]*pow((n[i]-1.),2.0) ;
     tmp   = tmp/((n[i]-3.)*(n[i]-2.)*(n[i]+3.)*(n[i]+5.));
     tmp   = sqrt(tmp) ;
     t2[i] = g2[i]/tmp ;
    }
d520 2
a521 3
 if (*ztest)
    z_test (z_array,ar,n,mean,midpoint,sd,cutoff,sarp,zcount); 

d616 1
d618 1
a618 1
/**********************************************************************
d620 1
a620 1
FUNCTION : WRITE_INFO         H. Rebecca Kimmel    25 January 1989
d622 3
a624 3
INTENT   : This function writes out the results to the output locations
           specified by the user.  This includes the terminal, the
           line printer and a file on a hard disk.
d626 3
a628 3
CALLED BY: MAIN
CALLS    : SCREEN_OUTPUT
           FILE_OUTPUT 
d630 2
a631 6
HISTORY  :
**********************************************************************/
char tmp_file[80] = {'t','m','p','f','i','l','e'} ; /*tmpfilename */
write_info (n,npos,nneg,mean,sd,g1,t1,midpoint,qrob,nskew,q1,q2,g2,t2,
            prob,nkurt,p1,p2,filenames,filenum,outfile,output_list,
            z_array,cutoff,ztest,zcount)
d633 29
a661 28
sig_numbers z_array[ZPOINTS] ; /* array containing z test values     */

char  filenames[MAXFILES][80], /* array containing input filenames   */
      outfile[80]               ; /* name of output file-user specified */
float sd[3]  ,                 /* standard deviations                */
      g2[3]  ,                 /* gamma 2 statistics                 */
      t2[3]  ,                 /* t-statistics                       */
      p1[3]  ,                 /* 0.01 significance leptokurtosis    */
      p2[3]  ,                 /* 0.05 significance leptokurtosis    */
      g1     ,                 /* gamma 1 statistic of all points    */
      t1     ,                 /* gamma 1 t-statistic of all points  */
      q1     ,                 /* 0.01 significance of skew          */
      q2     ,                 /* 0.05 significance of skew          */
      mean   ,                 /* mean value of all points           */
      qrob   ,                 /* indication of skew                 */
      cutoff ,                 /* cutoff value used for z test       */
      prob[3];                 /* indication of kurtosis             */

int   midpoint      ,          /* flag indicating how mean calc'd    */
      npos          ,          /* number of positive data points     */
      nneg          ,          /* number of negative data points     */
      nskew         ,          /* number of points used for skew     */
      ztest         ,          /* flag indicating z test determin.   */
      nkurt[3]      ,          /* number of points used for kurtosis */
      output_list[4],          /* types of output desired by user    */
      filenum       ,          /* number of input filenames          */
      n[3]          ;          /* number of data points              */

d663 3
a665 3
 int  done   ,    /* flag indicating done with output     */
      output ,    /* value from output file               */
      index  ;    /* pointer into output array            */
a666 1

a672 6
			/*
			screen_output (n,npos,nneg,mean,sd,g1,t1,midpoint,
                            qrob,nskew,q1,q2,g2,t2,prob,nkurt,p1,
                            p2,z_array,cutoff,ztest,zcount,
                            filenames,filenum) ;
			*/
d675 6
a680 6
    /* send the output to the disk file-user specified */
    case 2:  file_output (n,npos,nneg,mean,sd,g1,t1,midpoint,
                          qrob,nskew,q1,q2,g2,t2,prob,nkurt,p1,
                          p2,outfile,z_array,cutoff,ztest,zcount,
                          filenames,filenum) ;
             break ;
d682 43
a724 36
    /* send the output to the printer-user requested */
    case 3:  file_output (n,npos,nneg,mean,sd,g1,t1,midpoint,
                          qrob,nskew,q1,q2,g2,t2,prob,nkurt,p1,
                          p2,tmp_file,z_array,cutoff,ztest,zcount,
                          filenames,filenum) ;
             system ("pr tmpfile | lp") ;
             system ("rm tmpfile")      ;
             break                      ;
    case -1: done = -1;
             break ;
   }
 while (!done)
   {index++ ;
    output = output_list[index] ;
    switch (output)
      {case 1:  screen_output (n,npos,nneg,mean,sd,g1,t1,midpoint,
                               qrob,nskew,q1,q2,g2,t2,prob,nkurt,p1,
                               p2,z_array,cutoff,ztest,zcount,
                               filenames,filenum) ;
                break ;
       case 2:  file_output (n,npos,nneg,mean,sd,g1,t1,midpoint,
                             qrob,nskew,q1,q2,g2,t2,prob,nkurt,p1,
                             p2,outfile,z_array,cutoff,ztest,zcount,
                             filenames,filenum) ;
                break ;
       case 3:  file_output (n,npos,nneg,mean,sd,g1,t1,midpoint,
                             qrob,nskew,q1,q2,g2,t2,prob,nkurt,p1,
                             p2,tmp_file,z_array,cutoff,ztest,zcount,
                             filenames,filenum) ;
                system ("pr tmpfile | lp") ;
                system ("rm tmpfile")      ;
                break                      ;
       case -1: done = -1;
                break ;
      }
   }
d741 25
a765 31

sig_numbers z_array [ZPOINTS] ;  /* ALL VARIABLES DEFN IN WRITE_INFO */

char  filenames[MAXFILES][80],
      outfile[80]            ;
      

float sd[3]   ,
      g2[3]   ,
      t2[3]   ,
      p1[3]   ,
      p2[3]   ,
      g1      ,
      t1      ,
      q1      ,
      q2      ,
      mean    ,
      qrob    ,
      cutoff  ,
      prob[3] ;

int   midpoint  ,
      npos      ,
      nneg      ,
      nskew     ,
      ztest     ,
      zcount    ,
      filenum   ,
      nkurt[3]  ,
      n[3]      ;

d769 2
a772 1
	fprintf (fp, "\n\n                           GammaZ  %.1f\n\n\n", VERSION);
d774 1
a774 1
	fprintf (fp, "Input filenames are:\n\n");
d776 3
a778 3
		fprintf (fp,"   %s\n", filenames [j]);
	fprintf (fp, "\n");
	fprintf (fp, "Number of data points    : %8d\n", n[1]);
d781 1
a781 1
	fprintf (fp, "                     Mean: %8.4f\n\n", mean);
d791 3
a793 3
	fprintf (fp, "Standard deviation of all points             : %8.4f\n", sd[1]);
	fprintf (fp, "Standard deviation at the top of the curve   : %8.4f\n", sd[2]);
	fprintf (fp, "Standard deviation at the bottom of the curve: %8.4f\n\n", sd[0]);
d795 1
a795 1
	fprintf (fp, "Gamma 1 statistic of all points   : %8.4f\n", g1);
d806 1
a806 1
		fprintf (fp, "For %d points significance levels are:\n", nskew);
d811 1
a811 1
		fprintf (fp, "    0.01: %8.4f     0.05:   %8.4f\n", q1, q2);
d814 9
a822 8
	fprintf (fp, "\nGamma 2 statistic of all points      : %8.4f\n", g2[1]);
	fprintf (fp, "Gamma 2 of the top of the curve      : %8.4f\n", g2[2]);
	fprintf (fp, "Gamma 2 of the bottom of the curve   : %8.4f\n\n", g2[0]);
	fprintf (fp, "Gamma 2 t-statistic for all points   : %8.4f\n", t2[1]);
	fprintf (fp, "Gamma 2 t-statistic for top points   : %8.4f\n", t2[2]);
	fprintf (fp, "Gamma 2 t-statistic for bottom points: %8.4f\n", t2[0]);
	fprintf (fp, "\nNota bene: Do NOT use the t-statistic for less than 2000 points.\n\n");
	fprintf (fp, "Kurtosis:\n\n") ;
d834 1
a834 1
			fprintf (fp, "Too many points to test kurtosis,please use t-statistic\n");
d837 1
a837 1
				fprintf (fp, "There is no significant leptokurtosis\n");
d839 1
a839 1
		fprintf (fp, "There is a better than %.2f %% significance of leptokurtosis\n", prob[j]);
d841 1
a841 1
		fprintf (fp, "For %d points, significance levels are:\n", nkurt [j]);
d846 1
a846 1
		fprintf (fp, "0.01: %8.4f   0.05: %8.4f\n\n", p1[j], p2[j]);
d851 2
a852 4
		fprintf (fp, "                        Results of Z Test\n\n");
		fprintf (fp, "Cutoff at: %f\n\n", cutoff) ;
		fprintf (fp, "   Z        X        Y        MAX     Z-SCORE    SIGNIFICANCE\n");
		fprintf (fp, "                                                    LEVEL\n");
d854 1
a854 1
			fprintf (fp, "%6.1f   %6.1f   %6.1f   %7.2f   %7.3f    %9.3f\n",
d859 16
d997 1
d999 1
a999 1
/**********************************************************************
d1001 1
a1001 1
FUNCTION : Z_TEST         H. Rebecca Kimmel          25 January 1989
d1003 2
a1004 2
INTENT   : This function performs a z-test on the af3d data. If the
           user requests it, the data is translated into sarp space.
d1006 2
a1007 2
CALLED BY: DATA_ANALYSIS
CALLS      AGAUSS
d1009 3
a1011 1
HISTORY  :
a1012 2
*********************************************************************/

d1015 3
a1017 3
	sig_numbers	z_array[ZPOINTS];	/* array holding z-test results */
	float		ar[4][MAXPOINTS],	/* array holding data points */
			sd[3],			/* standard deviation              */
d1020 1
a1020 1
	int		n[3],			/* number of points                */
a1055 9
			{
				z_array [*zcount].z		= 2 * (31.0 - ar [0][i]);
				z_array [*zcount].x		= -2 * (ar [1][i] - 50.5);
				z_array [*zcount].y		= -2 * (ar [2][i] - 50.5);
				z_array [*zcount].max		= ar[3][i];
				z_array [*zcount].z_score	= (ar[3][i] - mid_mean) / sd[1];
				z_array [*zcount].significance	= significance;
			}
			else
@


1.4
log
@Command line input, before 3dp and 3dn files worked.
@
text
@d1 5
a5 2
/*$Header$*/
/*$Log$*/
d131 1
a131 2
Description:	This routine gets all of the pertinent information from the 
		user.
a133 1
		get_data
d139 2
a140 1
History:
d149 2
a150 6
	char	*pos_string	= "Enter positive filename [RETURN if done]: ",
		*neg_string	= "Enter negative filename: ";
	int	status,		/* error status */
		files,		/* flag that a file has been read in */
		read_files,	/* flag that no more files to read in */
		split;		/* flag indicating files data is in */
d152 2
a153 3
	read_files = -1 ;     /* intialize flags */
	status     =  0 ;
	files      =  0 ;
d155 2
a156 22
	/* 
	 * Read in data files 
	 */
	*filenum	= 0;
	while (read_files && status == 0)
	{
		read_files	= 0;
		split		= 1;
		status		= get_data (pos_string, filenames, filenum, ar, n,
					&read_files, &split, &files);
		if (read_files && status == 0 && files)
		{
			split	= -1;
			status	= get_data (neg_string, filenames, filenum, ar, n,
						&read_files, &split, &files);
		}
		else  if (!files)
		{
			status	= error_msg (5);
			return (status);
		}
	}
a161 77
/*_____________________________________________________________________

Function:	get_data       H. Rebecca Kimmel       25 January 1989

Description:	This function read in af3d data. 

Calls:		rfile

Called by:	data_analysis

History:	Rewritten for command line input by Tom Yang on
		09/16/1992.
_____________________________________________________________________*/

get_data (file_string, filenames, filenum, ar, n, read_files, split, files)

	char	filenames [MAXFILES][80],	/* array holding input filenames */
		*file_string;			/* prompt for user */
	int	n [3],				/* num. of points@@bottom, all, top */
		*filenum,			/* number of files read in */
		*split,				/* flag for method to calc. mean */
		*files,				/* flag indicating files read in */
		*read_files;			/* flag indicating no more files */
		float ar [4][MAXPOINTS];		/* array for holding data */

{
	char	*q;		/* question to user */
	char	datafile [80];	/* filename entered by user */
	int	answer,		/* answer from user */
		status;		/* error status of program */

	if (*filenum == MAXFILES)     /* check for file input limits */
		status = error_msg(7);
	else
	{
		answer	= -1;
		while (answer)              /* while filename needs to be read */
		{
			printf ("%s", file_string);
			gets (datafile);
			if (datafile[0] != '\0') 
			{
				status	= rfile (split, datafile, n, ar);
				if (status == -2)     /* file not found */
				{
					q	= "Do you want to re-enter the filename? y/n <y>";
					answer	= yes_no (q);
					if (!answer && !files)       /* no files read in */
					{
						status	= error_msg (5) ;
						return (status);
					}
				}
				else    /* copy filename into file array */
				{
					strcpy (filenames [*filenum], datafile);
					++*filenum;
					answer		= 0;
					*files		= -1;
					*read_files	= -1;
				}
			}
			else
				if (*read_files)        /* no files read in */
					status	= error_msg (6);
				else
				{
					*read_files	= 0;
					answer		= 0;
					status		= 0;
				}
		}
	}

	return (status);
}

d202 1
a202 1
Called by:	get_data
@


1.3
log
@Version Not working.
@
text
@d1 1
a2 1
/*Header*/
d20 1
d23 1
a23 1
/*_____________________________________________________________________
d25 1
a25 1
 Program: gammaz         H. Rebecca Kimmel           25 January 1989
d27 1
a27 1
 Description:	This program is based on the original gammaz program written
d30 1
a30 1
		Gammaz uses data output from af3d and calculates the mean,
d40 2
d44 3
a46 1
main ()
d48 31
a78 1
	sig_numbers	z_array [ZPOINTS] ; /* array holding z-test results */
d80 8
a87 28
	float		p1[3]           , /* .01 significance prob. of leptokurt */
			p2[3]           , /* .05 significance prob. of leptokurt.*/
			prob[3]         , /* probability of leptokurtosis        */
			cutoff          , /* cutoff for z-test                   */
			mean            , /* mean value for data points          */
			ar[4][MAXPOINTS], /* array holding af3d data points      */
			qrob            , /* Indicates skew                      */
			q1              , /* .01 signif. level for skew          */
			q2              , /* .05 signif. level for skew          */
			g2[3]           , /* gamma 2 - bottom,all,top curve      */
			t2[3]           , /* tscore 2 - bottom, all, top curve   */
			sd[3]           , /* standard deviation -bottom,all,top  */
			g1, t1          ; /* gamma 1 and t-stat. for all points  */
	int		zcount          , /* number of values in the z-test array*/
			npos, nneg      , /* number of pos/neg data points       */
			n[3]            , /* number of data points@@bottom,all,top*/
			nkurt[3]        , /* nkurt[1] = sample size nkurt[2] = 1% */
					  /* significance nkurt[3]= 5% significance */
			nskew           , /* number of points used for skew      */
			filenum         , /* number of input files read in       */
			sarp            , /* flag indicating sarp is/not wanted  */
			ztest           , /* flag indicating ztest desired       */
			output_list [4]  , /* array holding types of output wanted*/
			status          , /* error status                        */
			midpoint        ; /* flag specifying mean or at 0        */
        
	char		outfile[80]	, /* name of output file                 */
			filenames[MAXFILES][80]; /* array holding input filename*/
d90 1
a90 1
	 * Version and date.
d92 6
a97 3
	printf ("\n");
	printf ("                    GammaZ Version %.1f\n", VERSION);
	printf ("                       {14-Sep-92}\n\n\n");
d109 2
a110 2
	status	= get_info (&sarp, &midpoint, n, ar, output_list, filenames, 
				&filenum, outfile,&cutoff,&ztest); 
d124 1
a124 1
/*_____________________________________________________________________
d131 1
a131 1
Calls:		yes-no
d141 4
a144 15
get_info (sarp, midpoint, n, ar, output_list, filenames, filenum, outfile,
	cutoff, ztest) 

	char	filenames [MAXFILES][80],	/* array holding input filenames */
		outfile [80];			/* output filename */
	float	ar [4][MAXPOINTS],		/* array containing af3d data */
		*cutoff;			/* cutoff value for z-test */
	int	*sarp,				/* flag for sarp transformation */
		*midpoint,			/* flag for determining data split */
		*ztest,				/* flag indicating z-test evaluation */
		*filenum,			/* number of input filenames read in */
		output_list [4],		/* types of output desired */
						/* [0] is console-this happens always */
						/* [1] is to an output file */
						/* [2] is to the printer */
d147 6
a152 11
	char	buffer [20];			/* buffer for reading in cutoff value */
	char	*q,				/* question string */
		*pos_string	= "Enter positive filename [RETURN if done]: ",
		*neg_string	= "Enter negative filename: ",
		*both_string	= "Enter the data filename [RETURN if done]: ";
	int	status,				/* error status */
		lpt,				/* flag for printer output */
		dsk,				/* flag for file output to disk */
		files,				/* flag that a file has been read in */
		read_files,			/* flag that no more files to read in */
		split;				/* flag indicating files data is in */
d154 3
a156 3
	read_files	= -1;			/* intialize flags */
	status		= 0;
	files		= 0;
a157 31
	output_list [0] = -1;
	output_list [1]	= 2;
	output_list [2] = -1;
	printf ("Enter the filename where you want to put the data: ");
	gets (outfile);
	/*
	*midpoint	= 0;
	*sarp		= -1;
	*/

	q	= "Do you wish to split the data at 0 (i.e. not at the mean?) y/n <y>";
	*midpoint	= yes_no (q);
	if (*midpoint)
		*midpoint	= 0;
	else
		*midpoint	= 1;

	q	= "Do you wish to transform from sarp to atlas coordinates in the output? y/n <y>";
	*sarp	= yes_no (q); 

	q	= "Do you want to do a z test on the data? y/n <y>";
	*ztest	= yes_no (q);
	if (*ztest)
	{
		printf ("Enter significance level for data output cutoff: ");
		gets (buffer);
		sscanf (buffer, "%f", cutoff)                                  ;
	}
	q	= "Are the positive and negative searches in separate files? y/n <y>"; 
	split	= yes_no (q); 

d159 1
a159 1
	 * Read in data files. 
d162 1
a162 1
	if (split) 
d164 5
a168 1
		while (read_files && status == 0)
d170 3
a172 15
			read_files	= 0;
			split		= 1;
			status		= get_data (pos_string, filenames, filenum, ar, n,
							&read_files, &split, &files);
			if (read_files && status == 0 && files)
			{
				split	= -1;
				status	= get_data (neg_string, filenames, filenum, ar, n,
							&read_files, &split, &files);
			}
			else  if (!files)
			{
				status	= error_msg (5);
				return (status);
			}
d174 1
a174 5
	}
	else
	{
		split	= 1;
		while (read_files && status == 0)
a175 6
			read_files	= 0;
			status		= get_data (both_string, filenames, filenum, ar, n,
							&read_files, &split, &files);
		}
		if (!files)
		{
d179 1
a179 1
	}    
a180 1
	output_list [3]	= -1;
d185 1
a185 1
/**********************************************************************   
d187 1
a187 1
FUNCTION: GET_DATA       H. Rebecca Kimmel       25 January 1989
d189 1
a189 7
INTENT   : This function requests the user to enter a filename.  
           The filename is checked for validity. If there is an error,
           the user is requested to reenter the name of the datafile,
           otherwise, the data is read in.  If no files are read in the
           program is terminated. If the data is split into positive 
           and negative files, then a negative filename must be 
           entered for each positive filename entered.
d191 1
a191 5
CALLS    : RFILE
           ERROR_MSG
           YES_NO
           STRCPY
CALLED BY: DATA_ANALYSIS
d193 1
a193 1
HISTORY  :
d195 4
a198 1
**********************************************************************/
d201 1
a201 1
	char	filenames[MAXFILES][80],	/* array holding input filenames */
d203 1
a203 1
	int	n[3],				/* num. of points@@bottom, all, top */
d208 1
a208 1
		float ar[4][MAXPOINTS];		/* array for holding data */
d212 1
a212 1
	char	datafile[80];	/* filename entered by user */
a260 1

d262 1
a262 1
/*_____________________________________________________________________
d264 1
a264 1
Function:	yes_no        H. Rebecca Kimmel            25 January 1989
d266 2
a267 2
Description:	This routine gets the answer from the user and sets the flag
		to either true or false.
d269 2
a270 2
Called by:	get_data
		get_info
d272 2
a273 2
History:
______________________________________________________________________*/
d276 1
a276 1
	char	*q;	/* question */
d278 3
a280 3
	char	answ,	/* the actual answer from the user */
		ans;	/* the previous answer, since newline is read */
	int	answer;	/* flag returned to calling routine */
d282 9
a290 10
	answ	= ' ' ;
	printf ("\n%s :  ", q);
	while ((ans = getchar()) != '\n')
		answ	= ans;
	if (answ == 'n'|| answ == 'N')
		answer	=  0; 
	else
		answer	= -1;

	return (answer);
d750 8
a757 7
 done   = 0 ;  
 index  = 0 ;
 output = output_list[index] ;
 switch (output)

    /* send the output to the terminal console */
   {case 1:  screen_output (n,npos,nneg,mean,sd,g1,t1,midpoint,
d761 2
a762 1
             break ;
@


1.2
log
@Interactive version.
@
text
@d1 3
d22 1
a22 1
/***********************************************************************
d24 1
a24 1
 PROGRAM: GAMMAZ         H. Rebecca Kimmel           25 January 1989
d26 6
a31 6
 INTENT : This program is based on the original Gammaz program written
          by Lewis Greer and Peter Fox. The original program was 
          written in Fortran for the Current Computers used by PET.
          GammaZ uses data output from AF3D and calculates the mean,
          standard deviation, gamma 1 and gamma 2 t-statistic, 
          t-statistic, skew, kurtosis, and z-test.
d33 3
a35 3
 CALLS  : GET_INFO 
          DATA_ANALYSIS
          WRITE_INFO
d37 3
a39 1
 HISTORY: Ported to the Sun Unix environment by Tom Yang on Sep. 14, 1992.
a40 1
***********************************************************************/
d67 1
a67 1
			output_list[4]  , /* array holding types of output wanted*/
d106 1
a106 1
/***********************************************************************
d108 1
a108 1
FUNCTION : GET_INFO    H. Rebecca Kimmel           25 January 1989
d110 2
a111 2
INTENT   : This routine gets all of the pertinent information from the 
           user.
d113 4
a116 5
CALLS    : YES_NO
           GET_DATA
           ERROR_MSG
           GETS
CALLED BY: main
d118 1
a118 4
HISTORY  :
***********************************************************************/
get_info (sarp,midpoint,n,ar,output_list,filenames,filenum,outfile,
          cutoff,ztest) 
d120 2
a121 4
char  filenames[MAXFILES][80] , /* array holding input filenames */
      outfile[80]             ; /* output filename               */
float ar[4][MAXPOINTS] ,        /* array containing af3d data    */
      *cutoff          ;        /* cutoff value for z-test       */
d123 16
a138 10
int   *sarp            , /* flag for sarp transformation         */
      *midpoint        , /* flag for determining data split      */
      *ztest           , /* flag indicating z-test evaluation    */
      *filenum         , /* number of input filenames read in    */
      output_list[4]   , /* types of output desired              */
                         /* [0]  is console-this happens always  */
                         /* [1]  is to an output file            */
                         /* [2]  is to the printer               */
      n[3]             ; /* number of points@@bottom,top,all      */
 
d140 11
a150 5
  char buffer[20]     ; /* buffer for reading in cutoff value    */
  char *q             , /* question string                       */
       *pos_string = "Enter positive filename [RETURN if done]: " ,
       *neg_string = "Enter negative filename: "                  ,
       *both_string = "Enter the data filename [RETURN if done]: " ;
d152 3
a154 6
  int  status         , /* error status                          */
       lpt            , /* flag for printer output               */
       dsk            , /* flag for file output to disk          */
       files          , /* flag that a file has been read in     */
       read_files     , /* flag that no more files to read in    */
       split          ; /* flag indicating files data is in      */
d156 9
d166 6
a171 3
  read_files = -1 ;     /* intialize flags                       */
  status     =  0 ;
  files      =  0 ;
d173 2
a174 29
  output_list[0] = 1 ;
  q   = "Do you wish to print out the results to the printer? y/n <y>";
  lpt = yes_no (q) ;
  if (lpt)
     output_list[2] = 3 ;
  q   = "Do you wish to put the output in a file? y/n <y>" ;
  dsk = yes_no (q) ;
  if (dsk)     
    { printf ("Enter the filename where you want to put the data: ") ;
      gets (outfile)     ;
      output_list[1] = 2 ;
    }
  q = "Do you wish to split the data at 0 (i.e. not at the mean?) y/n <y>";
  *midpoint = yes_no (q) ;
  if (*midpoint)
    *midpoint = 0 ;
  else
    *midpoint = 1 ;
  q      = "Do you wish to transform from sarp to atlas coordinates in the output? y/n <y>";
  *sarp  = yes_no (q)  ; 
  q      = "Do you want to do a z test on the data? y/n <y>" ;
  *ztest = yes_no(q) ;
  if (*ztest)
    {printf ("Enter significance level for data output cutoff: ") ;
     gets (buffer)                                                ;
     sscanf (buffer,"%f",cutoff)                                  ;
    }
  q      = "Are the positive and negative searches in separate files? y/n <y>"; 
  split  = yes_no (q) ; 
d176 10
a185 1
                    /* READ IN DATA FILES */
d187 43
a229 33
  *filenum = 0 ;
  if (split) 
    {while (read_files && status == 0)
       {read_files = 0 ;
        split      = 1 ;
        status = get_data (pos_string,filenames,filenum,ar,n,
                           &read_files,&split,&files) ;
        if (read_files && status == 0 && files)
          {split = -1                                   ;
           status = get_data(neg_string,filenames,filenum,ar,n,
                             &read_files,&split,&files) ;
          }
        else  
          if (!files)
            {status = error_msg (5) ;
             return (status)        ;
            }
       }
    }
  else
    {split = 1 ;
     while (read_files && status == 0)
       {read_files = 0                                    ;
        status     = get_data (both_string,filenames,filenum,ar,n,
                               &read_files,&split,&files) ;
       }
     if (!files)
       {status = error_msg(5) ;
        return (status)       ;
       }
    }    
  output_list[3] = -1 ;
  return (status)     ;
d316 1
d318 1
a318 1
/***********************************************************************
d320 1
a320 1
FUNCTION: YES_NO        H. Rebecca Kimmel            25 January 1989
d322 2
a323 2
INTENT   : This routine gets the answer from the user and sets the flag
           to either true or false.
d325 2
a326 2
CALLED BY: GET_DATA
           GET_INFO
d328 2
a329 2
HISTORY  :
***********************************************************************/
d332 1
a332 1
char *q       ; /* question                                 */
d334 3
a336 3
  char answ   , /* the actual answer from the user          */
       ans    ; /* the previous answer,since newline is read*/
  int  answer ; /* flag returned to calling routine         */
d338 10
a347 9
  answ = ' ' ;
  printf ("\n%s :  ",q) ;
  while ((ans=getchar()) != '\n')
     answ = ans ;
  if (answ == 'n'|| answ == 'N')
     answer =  0 ; 
  else
     answer = -1 ;
  return(answer) ;
@


1.1
log
@Initial revision
@
text
@d220 1
d243 1
a243 1
get_data (file_string,filenames,filenum,ar,n,read_files,split,files)
d245 8
a252 8
char   filenames[MAXFILES][80], /* array holding input filenames     */
       *file_string           ; /* prompt for user                   */
int    n[3]            ,        /* num. of points@@bottom,all,top     */
       *filenum        ,        /* number of files read in           */
       *split          ,        /* flag for method to calc. mean     */
       *files          ,        /* flag indicating files read in     */
       *read_files     ;        /* flag indicating no more files     */
float ar[4][MAXPOINTS] ;        /* array for holding data            */
d255 4
a258 5
  char *q           ;           /* question to user                  */
  char datafile[80] ;           /* filename entered by user          */
       
  int  answer    ,              /* answer from user                  */
       status    ;              /* error status of program           */
d260 44
a303 36
  if (*filenum == MAXFILES)     /* check for file input limits       */
    status = error_msg(7) ;
  else
   {answer = -1 ;
    while (answer)              /* while filename needs to be read   */
      {printf ("%s",file_string) ;
       gets (datafile)           ;
       if (datafile[0] != '\0') 
         {status = rfile (split,datafile,n,ar) ;
          if (status == -2)     /* file not found   */
            {q = "Do you want to re-enter the filename? y/n <y>" ;
             answer = yes_no(q)                                  ;
             if (!answer && !files)       /* no files read in */
               {status = error_msg(5) ;
                return (status)       ;
               }
            }
          else    /* copy filename into file array */
            {strcpy (filenames[*filenum] , datafile);
             ++*filenum       ;
             answer      =  0 ;
             *files      = -1 ;
             *read_files = -1 ;
            }
         }
       else
         if (*read_files)        /* no files read in */
           status = error_msg (6) ;
         else
           {*read_files = 0 ;
            answer      = 0 ;
            status      = 0 ;
           }
      }
   }
 return (status) ;
d336 1
d338 1
a338 1
/*********************************************************************
d340 1
a340 1
  FUNCTION: RFILE         H. Rebecca Kimmel          25 January 1989
d342 3
a344 3
  INTENT   : This routine opens a file and reads in the data.  If an 
             error is encountered, an error message is sent and the 
             routine terminates. The input file is in SPED format.
d346 1
a346 1
  CALLED BY: GET_DATA
d348 8
a355 8
  HISTORY  :
*********************************************************************/
rfile (split,filename,n,ar)

float ar[4][MAXPOINTS]; /* array containing data points read in     */
char  filename[80]    ; /* name of file containing data points      */
int   *split          , /* indicates if pos and neg files to be read*/
      n[3]            ; /* number of points:bottom,all,top          */
d357 6
a362 6
  char header[80] ; /* header from file             */
  int  status     , /* error status flag            */
       i          , /* counter                      */
       xx,yy      ; /* counter for rows and columns */
  FILE *fp        , /* file pointer to input file   */
       *fopen()   ; /* C function for opening files */
d364 51
a414 41
  status = 0                ;   
  fp = fopen (filename,"r") ;
  if (fp==NULL)                /* see if file exists are readable */
    {status = error_msg(0);
     return(status)       ;
    }
  fgets (header,80,fp)       ;
  fscanf(fp,"%d,%d",&xx,&yy) ;
  if (yy != 4 && yy != 1)
    {status = error_msg (1) ;
     fclose(fp)             ;
     return (status)        ;
    }
  if ((n[1]+xx) > MAXPOINTS)  /* don't read more than array can hold*/
    {status = error_msg (2) ;
     fclose(fp)             ;
     return (status)        ;
    }
  for (i=n[1];i<(n[1]+xx);i++)
    {if (yy != 1)
       fscanf (fp,"%f,%f,%f,%f",&ar[0][i],&ar[1][i],&ar[2][i],&ar[3][i]);
     else
       {
        fscanf (fp,"%f",&ar[3][i]) ;
        ar[0][i] = 0.             ;
        ar[1][i] = 0.             ;
        ar[2][i] = 0.             ;
       }
     if (*split == -1 && ar[3][i] > 0) /* negate value in neg file*/
       ar[3][i] = ar[3][i] * -1.0 ;
     if (ar[3][i] == 0)
       {
        status = error_msg(3) ;
        status = error_msg(1) ;
        fclose(fp)            ;
        return(status)        ;
       }
    } 
  n[1] += xx ;
  fclose (fp)      ;
  return(status)   ;
d416 1
@
