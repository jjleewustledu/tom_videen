head	1.27;
access;
symbols;
locks; strict;
comment	@# @;


1.27
date	96.01.04.21.21.32;	author ty7777;	state Exp;
branches;
next	1.26;

1.26
date	95.06.27.16.36.02;	author ty7777;	state Exp;
branches;
next	1.25;

1.25
date	95.02.08.15.32.20;	author ty7777;	state Exp;
branches;
next	1.24;

1.24
date	94.12.22.20.10.32;	author ty7777;	state Exp;
branches;
next	1.23;

1.23
date	94.11.02.15.37.16;	author ty7777;	state Exp;
branches;
next	1.22;

1.22
date	94.09.20.16.02.27;	author ty7777;	state Exp;
branches;
next	1.21;

1.21
date	94.09.06.22.06.04;	author ty7777;	state Exp;
branches;
next	1.20;

1.20
date	94.09.02.21.27.48;	author ty7777;	state Exp;
branches;
next	1.19;

1.19
date	94.09.02.19.02.38;	author ty7777;	state Exp;
branches;
next	1.18;

1.18
date	94.09.01.21.03.58;	author ty7777;	state Exp;
branches;
next	1.17;

1.17
date	94.08.31.20.30.49;	author ty7777;	state Exp;
branches;
next	1.16;

1.16
date	94.06.15.21.22.43;	author ty7777;	state Exp;
branches;
next	1.15;

1.15
date	93.12.20.21.27.59;	author ty7777;	state Exp;
branches;
next	1.14;

1.14
date	93.11.01.22.29.59;	author ty7777;	state Exp;
branches;
next	1.13;

1.13
date	93.10.06.14.57.04;	author ty7777;	state Exp;
branches;
next	1.12;

1.12
date	93.09.14.16.17.36;	author ty7777;	state Exp;
branches;
next	1.11;

1.11
date	93.09.09.20.23.34;	author ty7777;	state Exp;
branches;
next	1.10;

1.10
date	93.08.31.20.05.55;	author ty7777;	state Exp;
branches;
next	1.9;

1.9
date	93.03.05.20.44.04;	author ty7777;	state Exp;
branches;
next	1.8;

1.8
date	93.03.02.22.08.41;	author ty7777;	state Exp;
branches;
next	1.7;

1.7
date	93.02.19.16.51.35;	author ty7777;	state Exp;
branches;
next	1.6;

1.6
date	93.02.17.20.42.41;	author ty7777;	state Exp;
branches;
next	1.5;

1.5
date	93.02.16.17.32.47;	author ty7777;	state Exp;
branches;
next	1.4;

1.4
date	93.02.09.18.22.23;	author ty7777;	state Exp;
branches;
next	1.3;

1.3
date	93.01.27.22.08.18;	author ty7777;	state Exp;
branches;
next	1.2;

1.2
date	93.01.27.20.45.25;	author ty7777;	state Exp;
branches;
next	1.1;

1.1
date	93.01.26.21.02.13;	author ty7777;	state Exp;
branches;
next	;


desc
@xray.callbacks initial checking in.
@


1.27
log
@Same as the last version.
@
text
@/*$Id: xray.callbacks,v 1.26 1995/06/27 16:36:02 ty7777 Exp ty7777 $*/
/*$Log: xray.callbacks,v $
# Revision 1.26  1995/06/27  16:36:02  ty7777
# Same as the last version, checked in so others can have access the code.
#
# Revision 1.25  1995/02/08  15:32:20  ty7777
# Changed the decimal places to 4 for magnification factor.
#
# Revision 1.24  1994/12/22  20:10:32  ty7777
# Updated to regenerate the PETT6 .sxr files.
#
# Revision 1.23  1994/11/02  15:37:16  ty7777
# Added processing for ecat_offset.
#
# Revision 1.22  1994/09/20  16:02:27  ty7777
# Updated for peakslice processing.
#
# Revision 1.21  1994/09/06  22:06:04  ty7777
# Added processing for the list widgets.
#
# Revision 1.20  1994/09/02  21:27:48  ty7777
# Friday version.
#
# Revision 1.19  1994/09/02  19:02:38  ty7777
# Updated to incorporated new algorithm for setting the default reference slice.
#
# Revision 1.18  1994/09/01  21:03:58  ty7777
# Use the algorithm proposed by Randy.
#
# Revision 1.17  1994/08/31  20:30:49  ty7777
# Same as the last version.
#
# Revision 1.16  1994/06/15  21:22:43  ty7777
# Display the slice numbers at the correct position even if
# the slice has no data in it.
#
# Revision 1.15  1993/12/20  21:27:59  ty7777
# Added processing for recompute.
#
# Revision 1.14  1993/11/01  22:29:59  ty7777
# Debugging.
#
# Revision 1.13  1993/10/06  14:57:04  ty7777
# Change PROGRAM_XRAY30 to PROGRAM_XRAY31.
#
# Revision 1.12  1993/09/14  16:17:36  ty7777
# libhp.a changes.
#
# Revision 1.11  1993/09/09  20:23:34  ty7777
# Changed SaveSXRData to savesxr.
#
# Revision 1.10  1993/08/31  20:05:55  ty7777
# Before changing cursor shape.
#
# Revision 1.9  1993/03/05  20:44:04  ty7777
# Before removing Sunview related libraries.
#
# Revision 1.8  1993/03/02  22:08:41  ty7777
# Before using magnification factor to compute slice lengths.
#
# Revision 1.7  1993/02/19  16:51:35  ty7777
# Before adding film position, scan position, and offset.
#
# Revision 1.6  1993/02/17  20:42:41  ty7777
# Before changing xray slices lengths computation order.
#
# Revision 1.5  1993/02/16  17:32:47  ty7777
# Before adding slice dimension lines.
#
# Revision 1.4  1993/02/09  18:22:23  ty7777
# Release checking in.
#
# Revision 1.3  1993/01/27  22:08:18  ty7777
# Adding GetPetParameters after menu selection.
#
# Revision 1.2  1993/01/27  20:45:25  ty7777
# After adding PET image width and skull X ray width.
#
# Revision 1.1  1993/01/26  21:02:13  ty7777
# Initial revision
#*/

/*_________________________________________________________________________________	
	Procedure:
		QuitCallback
	Parameters:
		w: Widget, widget where callback was triggered.
		clientData: caddr_t, client data.
		call_data: caddr_t, callback data.
	Description:
		Callback function for quiting the program.
		Author: Tom Yang 
		(11/16/92)
_________________________________________________________________________________*/
void QuitCallback (w, clientData, callData)
	Widget	w;
	caddr_t	clientData;
	caddr_t	callData;
{
	QUIT_DATA	*quit_data	= (QUIT_DATA *) clientData;
	PET_SLICE_DATA	*slice;
	int		i;
	llist		pet_list	= quit_data->petlist;

	free (quit_data->xray_tracing);
	free (quit_data->rlslicedim);
	free (quit_data->rlpetdim);
	free (quit_data->rlcenter);
	free (quit_data->vertical_petdim);

	for (i = 0; i < MESSAGE_NUM; i++)
	{
		XmStringFree (quit_data->xm_message + i);		
	}

	/* 
	 * Clear memory corresponding to list.
	 */
	llhead (pet_list);			/* step through the list */
	while (llsize (pet_list) > 0)
	{
		/* 
		 * Get a slice. 
		 */
		slice = (PET_SLICE_DATA *) llretrieve (pet_list);

		free (slice->input);

		free (slice);
		lldelete (pet_list);
	}

	exit (0);
}

void ShowMenuCallback (w, clientData, callData)
Widget w;
caddr_t clientData;
caddr_t callData;
{
	Widget dialog = (Widget) clientData;
	XtManageChild (dialog);
}

void CancelCallback (w, clientData, callData)
Widget w;
caddr_t clientData;
caddr_t callData;
{
	Widget dialog = (Widget) clientData;
	XtUnmanageChild (dialog);
}

/*_________________________________________________________________________________	
	Procedure:
		ShowMenuParmCallback
	Parameters:
		w: Widget, widget where callback was triggered.
		clientData: caddr_t, client data.
		call_data: caddr_t, callback data.
	Description:
		Callback function for activate the parameter menu.
		Author: Tom Yang 
		(11/16/92)
_________________________________________________________________________________*/
void ShowParmMenuCallback (w, clientData, callData)
	Widget	w;
	caddr_t	clientData;
	caddr_t	callData;
{
	PARAMETER_MENU	*menu	= (PARAMETER_MENU *) clientData;
	SXR_OUTPUT	*sxr_output	= menu->sxr_output;
	char		szBuffer [MAXLINE];

	/*
	 * Set all the text fields in the parameters menu.
	 */
	sprintf (szBuffer, "%.4f", sxr_output->magnification_factor);
	XmTextSetString (*menu->textMagnificationFactor, szBuffer);

	sprintf (szBuffer, "%.1f", sxr_output->film_position);
	XmTextSetString (*menu->textFilmPosition, szBuffer);

	sprintf (szBuffer, "%.1f", sxr_output->scan_position);
	XmTextSetString (*menu->textScanPosition, szBuffer);

	sprintf (szBuffer, "%.1f", sxr_output->reference_offset);
	XmTextSetString (*menu->textOffset, szBuffer);

	sprintf (szBuffer, "%.3f", sxr_output->pixel_size);
	XmTextSetString (*menu->textPixelSize, szBuffer);

	sprintf (szBuffer, "%.3f", sxr_output->slice_separation);
	XmTextSetString (*menu->textSliceSpacing, szBuffer);

	sprintf (szBuffer, "%d", sxr_output->reference_slice);
	XmTextSetString (*menu->textReferenceSlice, szBuffer);

	sprintf (szBuffer, "%d", sxr_output->number_slices);
	XmTextSetString (*menu->textNumberOfSlices, szBuffer);

	sprintf (szBuffer, "%d", sxr_output->threshold);
	XmTextSetString (*menu->textThreshold, szBuffer);

	XtManageChild (*menu->frameParameters);
}

/*_________________________________________________________________________________	
	Procedure:
		SelectParametersCallback
	Parameters:
		w: Widget, widget where callback was triggered.
		clientData: caddr_t, client data.
		call_data: caddr_t, callback data.
	Description:
		Callback function for selecting parameters.
		Author: Tom Yang 
		(11/16/92)
_________________________________________________________________________________*/
void SelectParametersCallback (w, clientData, callData)
	Widget	w;
	caddr_t	clientData;
	caddr_t	callData;
{
	PARAMETER_DATA	*parameter_data	= (PARAMETER_DATA *) clientData;

	GRAPHICS_DATA	*graphics_data	= parameter_data->graphics_data;
	PARAMETER_MENU	*menu		= parameter_data->parameter_menu;
	SXR_OUTPUT	*sxr_output	= menu->sxr_output;
	char		*string;
	char		string_buffer [MAXLINE];
	float		offset;

	if (parameter_data->node != CANCEL)
	{
		string	= XmTextGetString (*menu->textMagnificationFactor);
		sxr_output->magnification_factor	= atof (string);
		XtFree (string);

		if (menu->pettnum == ECAT_SCANNER)
		{
			offset	= menu->ecat_offset;
		}
		else
		{
			offset	= 0.0;
		}

		string	= XmTextGetString (*menu->textFilmPosition);
		sxr_output->film_position	= atof (string);
		XtFree (string);

		string	= XmTextGetString (*menu->textScanPosition);
		sxr_output->scan_position	= atof (string);
		XtFree (string);

		sxr_output->reference_offset	= sxr_output->scan_position 
						- sxr_output->film_position 
						- offset;
		sprintf (string_buffer, "%.3f", sxr_output->reference_offset);
		XmTextSetString (*menu->textOffset, string_buffer);

		string	= XmTextGetString (*menu->textPixelSize);
		sxr_output->pixel_size	= atof (string);
		XtFree (string);

		string	= XmTextGetString (*menu->textSliceSpacing);
		sxr_output->slice_separation	= atof (string);
		XtFree (string);

		string	= XmTextGetString (*menu->textReferenceSlice);
		sxr_output->reference_slice	= atoi (string);
		XtFree (string);

		string	= XmTextGetString (*menu->textNumberOfSlices);
		sxr_output->number_slices	= atoi (string);
		XtFree (string);

		string	= XmTextGetString (*menu->textThreshold);
		sxr_output->threshold	= atoi (string);
		XtFree (string);

		GetPetParameters (menu->petfile, menu->trim, menu->pettnum, menu->encoded, 
			sxr_output, menu->petlist);
	}
	else
	{
		/*
	 	 * Set all the text fields in the parameters menu.
	 	 */
		sprintf (string_buffer, "%.4f", sxr_output->magnification_factor);
		XmTextSetString (*menu->textMagnificationFactor, string_buffer);

		sprintf (string_buffer, "%.1f", sxr_output->film_position);
		XmTextSetString (*menu->textFilmPosition, string_buffer);

		sprintf (string_buffer, "%.1f", sxr_output->scan_position);
		XmTextSetString (*menu->textScanPosition, string_buffer);

		sprintf (string_buffer, "%.1f", sxr_output->reference_offset);
		XmTextSetString (*menu->textOffset, string_buffer);

		sprintf (string_buffer, "%.3f", sxr_output->pixel_size);
		XmTextSetString (*menu->textPixelSize, string_buffer);

		sprintf (string_buffer, "%.3f", sxr_output->slice_separation);
		XmTextSetString (*menu->textSliceSpacing, string_buffer);

		sprintf (string_buffer, "%d", sxr_output->reference_slice);
		XmTextSetString (*menu->textReferenceSlice, string_buffer);

		sprintf (string_buffer, "%d", sxr_output->number_slices);
		XmTextSetString (*menu->textNumberOfSlices, string_buffer);

		sprintf (string_buffer, "%d", sxr_output->threshold);
		XmTextSetString (*menu->textThreshold, string_buffer);
	}

	XtUnmanageChild (*menu->frameParameters);

	if (parameter_data->node == REDRAW)
	{
		GetXRayParameters (graphics_data->cols, 
			graphics_data->rows, 
			graphics_data->xray_tracing, 
			*(graphics_data->defining_points), 
			graphics_data->drawing_points, 
			graphics_data->sxr_output);
		GetRotationAngles (graphics_data->sxr_output);
		drawxray (graphics_data);
	}
	else if (parameter_data->node == SELECT)
	{
		sxr_output->init_offset	= sxr_output->reference_offset;
		sxr_output->init_slice	= sxr_output->reference_slice;
	}
}

/*_________________________________________________________________________________	
	Procedure:
		DisplayXRayCallback
	Parameters:
		w: Widget, widget where callback was triggered.
		clientData: caddr_t, client data.
		call_data: caddr_t, callback data.
	Description:
		Callback function for displaying X ray tracing.
		Author: Tom Yang 
		(11/17/92)
_________________________________________________________________________________*/
void DisplayXRayCallback (w, clientData, callData)
	Widget	w;
	caddr_t	clientData;
	caddr_t	callData;
{
	Arg		arglist [MAX_ARGS];
	XRAY_DATA	*xray_data	= (XRAY_DATA *) clientData;
	DRAW_DATA	*draw_data	= xray_data->draw_data;
	Display		*display	= draw_data->display;
	Window		window		= draw_data->window;
	GC		gc		= draw_data->gc;
	int		screen;
	int		i;
	int		j;
	int		n;
	int		rows		= xray_data->rows;
	int		cols		= xray_data->cols;

	XClearArea (display, window, 0, 0, DRAW_AREA_WIDTH, DRAW_AREA_HEIGHT, FALSE);
	XSetForeground (display, gc, xray_data->xray_color);
	for (j = 0; j < rows; j++) 
	{
		for (i = 0; i < cols; i++) 
		{
			if (xray_data->xray_tracing [j * cols + i] > 0)
			{
				XDrawPoint (display, window, gc, 
					DISPLAY_MARGIN_WIDTH + i, DISPLAY_MARGIN_HEIGHT + j);
			}
		}
	}

	XDefineCursor (display, window, xray_data->cursor);

	n	= 0;
	XtSetArg (arglist [n], XmNlabelString, *(xray_data->xm_message + GlabellaState)); n++;
	XtSetValues (xray_data->message, arglist, n);
	cPointerState	= GlabellaState;
}


/*_________________________________________________________________________________	
	Procedure:
		SaveWinDumpCallback
	Parameters:
		Widget	w;
		caddr_t clientData;
		caddr_t callData;
	Description:
		Callback function for processing defaults parameters.
		Author: Tom (Tongzeng) Yang 
		(09/02/94)
___________________________________________________________________________________*/
void SaveWinDumpCallback (w, clientData, callData)
Widget	w;
caddr_t clientData;
caddr_t callData;
{
	DATA_FILE_SELECTION	*selectFileData	= (DATA_FILE_SELECTION *) clientData;

	Display			*display	= selectFileData->draw_data->display;
	GC			gc		= selectFileData->draw_data->gc;
	Widget			dialog		= selectFileData->dialog;
	Window			window		= selectFileData->draw_data->window;
	Widget			file_list;
	Widget			text_file;
	XmString		item;
	XmString		*strlist;
	char			*file_name;
	char			*string;
	char			szBuffer [MAXLINE];
	char			*extension;
	int			l_bound	= 0;
	int			u_bound;

	text_file	= XmSelectionBoxGetChild (dialog, XmDIALOG_TEXT);
	file_name	= XmTextGetString (text_file);
	file_list	= XmSelectionBoxGetChild (dialog, XmDIALOG_LIST);

	/*
	 * Make sure there is a file.
	 */
	extension	= strrchr (file_name, '/');
	if (strlen (file_name) == 0 || (extension != NULL && strcmp (extension, "/") == 0)) 
	{
		/*
		XtManageChild (errorMessageBox);
		*/
		return;
	}

	strcpy (szBuffer, file_name);
	string	= strstr (file_name, ".xwd");
	if (string == NULL || strcmp (string, ".xwd") != 0)
		strcat (szBuffer, ".xwd");
	XtFree (file_name);

	/*
	 * Perform binary search.
	 */
	XtVaGetValues (file_list, 
		XmNitemCount,	&u_bound,
		XmNitems,	&strlist,
		NULL);
	u_bound--;

	while (u_bound >= l_bound)
	{
		int	i	= l_bound + (u_bound - l_bound) / 2;
		if (!XmStringGetLtoR (strlist [i], "", &string))
			break;
		if (strcmp (string, szBuffer) > 0)
			u_bound	= i - 1;
		else
			l_bound	= i + 1;
		XtFree (string);
	}

	item	= XmStringCreate (szBuffer, XmSTRING_DEFAULT_CHARSET);
	if (!XmListItemExists (file_list, item))
	{
		XmListAddItemUnselected (file_list, item, l_bound + 1);
		XmListSelectItem (file_list, item, True);
	}

	XtFree (item);

	XtUnmanageChild (dialog);

	WindowDump (display, window, FALSE, 0, 0, 0, 0, szBuffer);
}

/*_________________________________________________________________________________	
	Procedure:
		DisplayPetCallback
	Parameters:
		w: Widget, widget where callback was triggered.
		clientData: caddr_t, client data.
		call_data: caddr_t, callback data.
	Description:
		Callback function for displaying PET slices.
		Author: Tom Yang 
		(11/18/92)
_________________________________________________________________________________*/
void DisplayPetCallback (w, clientData, callData)
	Widget	w;
	caddr_t	clientData;
	caddr_t	callData;
{
	DISPLAY_PET_DATA	*display_pet_data	= (DISPLAY_PET_DATA *) clientData;
	SXR_OUTPUT		*sxr_output		= display_pet_data->sxr_output;
	char			string_buffer [MAXLINE];

	drawpet (display_pet_data);

	sprintf (string_buffer, "%d", sxr_output->peakslice);
	XmTextSetString (*(display_pet_data->text_peak_slice), string_buffer);

	XtManageChild (*(display_pet_data->dialog));
}

/*_________________________________________________________________________________	
	Procedure:
		PeakSliceChangedCallback
	Parameters:
		w: Widget, widget where callback was triggered.
		clientData: caddr_t, client data.
		call_data: caddr_t, callback data.
	Description:
		Callback function for processing changed peak slice.
		Author: Tom Yang 
		(09/19/94)
_________________________________________________________________________________*/
void PeakSliceChangedCallback (w, clientData, callData)
	Widget	w;
	caddr_t	clientData;
	caddr_t	callData;
{
	PEAK_SLICE_CHANGED_DATA	*peak_slice_data	= (PEAK_SLICE_CHANGED_DATA *) clientData;
	DISPLAY_PET_DATA	*display_pet_data	= peak_slice_data->display_pet_data;
	PARAMETER_MENU		*menu			= peak_slice_data->parameter_menu;
	SXR_OUTPUT		*sxr_output		= menu->sxr_output;
	char			*string;

	if (peak_slice_data->node == REDRAW)
	{
		string	= XmTextGetString (*display_pet_data->text_peak_slice);
		sxr_output->peakslice	= atoi (string);
		XtFree (string);

		if (sxr_output->peakslice >= 1 &&
		sxr_output->peakslice <= sxr_output->number_slices) 
		{
			XtUnmanageChild (*(display_pet_data->dialog));
			GetPetParameters (menu->petfile, menu->trim, menu->pettnum, 
				menu->encoded, sxr_output, menu->petlist);

			drawpet (display_pet_data);
			XtManageChild (*(display_pet_data->dialog));
		}
	}
	else
	{
		XtUnmanageChild (*(display_pet_data->dialog));
	}
}

/*_________________________________________________________________________________	
	Procedure:
		SaveSXRCallback
	Parameters:
		w: Widget, widget where callback was triggered.
		clientData: caddr_t, client data.
		call_data: caddr_t, callback data.
	Description:
		Callback function for saving .sxr file.
		Author: Tom Yang 
		(11/18/92)
_________________________________________________________________________________*/
void SaveSXRCallback (w, clientData, callData)
	Widget	w;
	caddr_t	clientData;
	caddr_t	callData;
{
	SAVESXR_DATA	*savesxr_data	= (SAVESXR_DATA *) clientData;

	if (savesxr (savesxr_data->sxr_name, savesxr_data->petfile, 
	savesxr_data->sxr_root, PROGRAM_XRAY32, TRUE, savesxr_data->incorrect_delta_z,
	savesxr_data->sxr_output) == FAIL)
	{
		fprintf (stderr, "Error in savesxr ().\n");
	}
}


/*________________________________________________________________________________________________	
	Procedure:
		ButtonDownEventHandler
	Parameters:
		w: Widget, widget where callback was triggered.
		clientData: caddr_t, client data.
		event: XEvent, callback data.
	Description:
		Event handling function to for button down.
		Author: Tom (Tongzeng) Yang 
		(11/17/92)
________________________________________________________________________________________________*/
void ButtonDownEventHandler (w, clientData, event)
	Widget	w;
	caddr_t	clientData;
	XEvent	*event;
{
	GRAPHICS_DATA	*graphics_data	= (GRAPHICS_DATA *) clientData;
	Display		*display	= graphics_data->draw_data->display;
	Window		window		= graphics_data->draw_data->window;
	GC		xorgc		= graphics_data->xorgc;
	PointerStatus	*pointer_state	= &cPointerState;

	graphics_data->last_x = graphics_data->start_x = event->xbutton.x;
	graphics_data->last_y = graphics_data->start_y = event->xbutton.y;

	switch (*pointer_state)
	{
		case	GlabellaState:
		case	InionState:
		case	LeftRefPointState:
		case	RightRefPointState:
		case	LeftEarMarkerState:
		case	RightEarMarkerState:
				DrawSymbol (display, window, xorgc, 
					graphics_data->start_x, graphics_data->start_y, 
					CROSSHAIR_SIZE, CROSSHAIR_SIZE, CROSSHAIR);
			graphics_data->button_down_first	= TRUE;

			break;
		default:
			break;
	}
}


/*________________________________________________________________________________________________	
	Procedure:
		ButtonMoveEventHandler
	Parameters:
		w: Widget, widget where callback was triggered.
		clientData: caddr_t, client data.
		event: XEvent, callback data.
	Description:
		Event handling function to for button move.
		Author: Tom (Tongzeng) Yang 
		(11/17/92)
________________________________________________________________________________________________*/
void ButtonMoveEventHandler (w, clientData, event)
	Widget	w;
	caddr_t	clientData;
	XEvent	*event;
{
	GRAPHICS_DATA	*graphics_data	= (GRAPHICS_DATA *) clientData;
	Display		*display	= graphics_data->draw_data->display;
	Window		window		= graphics_data->draw_data->window;
	GC		xorgc		= graphics_data->xorgc;
	PointerStatus	*pointer_state	= &cPointerState;

	if (graphics_data->button_down_first)
	{
		switch (*pointer_state)
		{
			case	GlabellaState:
			case	InionState:
			case	LeftRefPointState:
			case	RightRefPointState:
			case	LeftEarMarkerState:
			case	RightEarMarkerState:
					DrawSymbol (display, window, xorgc, 
						graphics_data->last_x, graphics_data->last_y, 
						CROSSHAIR_SIZE, CROSSHAIR_SIZE, CROSSHAIR);

					graphics_data->last_x	= event->xbutton.x,
					graphics_data->last_y	= event->xbutton.y,

					DrawSymbol (display, window, xorgc, 
						graphics_data->last_x, graphics_data->last_y, 
						CROSSHAIR_SIZE, CROSSHAIR_SIZE, CROSSHAIR);
				break;
			default:
				break;
		}
	}
}


/*________________________________________________________________________________________________	
	Procedure:
		ButtonReleaseEventHandler
	Parameters:
		w: Widget, widget where callback was triggered.
		clientData: caddr_t, client data.
		event: XEvent, callback data.
	Description:
		Event handling function to for button release.
		Author: Tom (Tongzeng) Yang 
		(11/17/92)
________________________________________________________________________________________________*/
void ButtonReleaseEventHandler (w, clientData, event)
	Widget	w;
	caddr_t	clientData;
	XEvent	*event;
{
	GRAPHICS_DATA	*graphics_data		= (GRAPHICS_DATA *) clientData;

	Arg		arglist [MAX_ARGS];
	DEFINING_POINTS	*defining_points	= graphics_data->defining_points;
	Display		*display		= graphics_data->draw_data->display;
	DRAWING_POINTS	*drawing_points		= graphics_data->drawing_points;
	GC		gc			= graphics_data->draw_data->gc;
	GC		xorgc			= graphics_data->xorgc;
	PointerStatus	*pointer_state		= &cPointerState;
	SXR_OUTPUT	*sxr_output		= graphics_data->sxr_output;
	Window		window			= graphics_data->draw_data->window;
	float		maxlength;
	int		i;
	int		*max_indexes;
	int		n;

	if (graphics_data->button_down_first)
	{
		DrawSymbol (display, window, xorgc, graphics_data->last_x, graphics_data->last_y, 
					CROSSHAIR_SIZE, CROSSHAIR_SIZE, CROSSHAIR);
		graphics_data->last_x	= event->xbutton.x,
		graphics_data->last_y	= event->xbutton.y,
		DrawSymbol (display, window, gc, graphics_data->last_x, graphics_data->last_y, 
					CROSSHAIR_SIZE, CROSSHAIR_SIZE, CROSSHAIR);

		switch (*pointer_state)
		{
			case GlabellaState:
				defining_points->glabella.x	= graphics_data->last_x
								- DISPLAY_MARGIN_WIDTH;
				defining_points->glabella.y	= graphics_data->last_y
								- DISPLAY_MARGIN_HEIGHT;

				n	= 0;
				XtSetArg (arglist [n], XmNlabelString, 
					*(graphics_data->xm_message + InionState)); n++;
				XtSetValues (graphics_data->message, arglist, n);
				*pointer_state	= InionState;

				break;
			case InionState:
				defining_points->inion.x	= graphics_data->last_x
								- DISPLAY_MARGIN_WIDTH;
				defining_points->inion.y	= graphics_data->last_y
								- DISPLAY_MARGIN_HEIGHT;

				n	= 0;
				XtSetArg (arglist [n], XmNlabelString, 
					*(graphics_data->xm_message + LeftRefPointState)); n++;
				XtSetValues (graphics_data->message, arglist, n);
				*pointer_state	= LeftRefPointState;

				break;
			case LeftRefPointState:
				defining_points->slice_lpoint.x	= graphics_data->last_x
								- DISPLAY_MARGIN_WIDTH;
				defining_points->slice_lpoint.y	= graphics_data->last_y
								- DISPLAY_MARGIN_HEIGHT;

				n	= 0;
				XtSetArg (arglist [n], XmNlabelString, 
					*(graphics_data->xm_message + RightRefPointState)); n++;
				XtSetValues (graphics_data->message, arglist, n);
				*pointer_state	= RightRefPointState;

				break;
			case RightRefPointState:
				defining_points->slice_rpoint.x	= graphics_data->last_x
								- DISPLAY_MARGIN_WIDTH;
				defining_points->slice_rpoint.y	= graphics_data->last_y
								- DISPLAY_MARGIN_HEIGHT;

				n	= 0;
				XtSetArg (arglist [n], XmNlabelString, 
					*(graphics_data->xm_message + LeftEarMarkerState)); n++;
				XtSetValues (graphics_data->message, arglist, n);
				*pointer_state	= LeftEarMarkerState;

				break;
			case LeftEarMarkerState:
				defining_points->left_ear_marker.x	
					= graphics_data->last_x - DISPLAY_MARGIN_WIDTH;
				defining_points->left_ear_marker.y	
					= graphics_data->last_y - DISPLAY_MARGIN_HEIGHT;

				n	= 0;
				XtSetArg (arglist [n], XmNlabelString, 
					*(graphics_data->xm_message + RightEarMarkerState)); n++;
				XtSetValues (graphics_data->message, arglist, n);
				*pointer_state	= RightEarMarkerState;

				break;
			case RightEarMarkerState:
				XSetForeground (display, gc, graphics_data->xray_color);
				XUndefineCursor (display, window);

				defining_points->right_ear_marker.x	
					= graphics_data->last_x - DISPLAY_MARGIN_WIDTH;
				defining_points->right_ear_marker.y	
					= graphics_data->last_y - DISPLAY_MARGIN_HEIGHT;

				n	= 0;
				XtSetArg (arglist [n], XmNlabelString, 
					*(graphics_data->xm_message + NoState)); n++;
				XtSetValues (graphics_data->message, arglist, n);
				*pointer_state	= NoState;

				GetXRayParameters (graphics_data->cols, 
						graphics_data->rows, 
						graphics_data->xray_tracing, *defining_points, 
						drawing_points, sxr_output);

				GetRotationAngles (sxr_output);

				/*
				 * Select the reference slcie. The algorithm is as follows.
				 * Pick Max.
				 * If multiple, pick center slice.
				 * if > 28, use slice 28.
				 * if < 4, use slice 4.
				 */
				maxlength	= sxr_output->rlslicedim [0];
				for (i = 1; i < sxr_output->number_slices; i++)
				{
					if (sxr_output->rlslicedim [i] > maxlength)
						maxlength	= sxr_output->rlslicedim [i];
				}

				n	= 0;
				for (i = 0; i < sxr_output->number_slices; i++)
				{
					if (pkg_abs (sxr_output->rlslicedim [i] - maxlength) < 0.05)
						n++;
				}

				max_indexes	= (int *) pkg_malloc (n * sizeof (int), 
						"ButtonReleaseEventHandler", "max_indexes"); 

				n	= 0;
				for (i = 0; i < sxr_output->number_slices; i++)
				{
					if (pkg_abs (sxr_output->rlslicedim [i] - maxlength) < 0.05)
						max_indexes [n++]	= i + 1;
				}

				i	= (n - 1) / 2;
				if (max_indexes [i] < 1 + NUM_BOUNDARY_SLICES)
					sxr_output->reference_slice	
						= 1 + NUM_BOUNDARY_SLICES;
				else if (max_indexes [i] > 
				sxr_output->number_slices - NUM_BOUNDARY_SLICES)
					sxr_output->reference_slice	
						= sxr_output->number_slices - NUM_BOUNDARY_SLICES;
				else
					sxr_output->reference_slice	= max_indexes [i];

				free (max_indexes);

				GetXRayParameters (graphics_data->cols, 
						graphics_data->rows, 
						graphics_data->xray_tracing, *defining_points, 
						drawing_points, sxr_output);

				drawxray (graphics_data);

				XtSetSensitive (graphics_data->recompute, True);

				break;
			default:
				break;
		}
	}

	graphics_data->button_down_first	= FALSE;
}


/*_________________________________________________________________________________	
	Procedure:
		PrintCallback
	Parameters:
		Widget	w;
		caddr_t clientData;
		caddr_t callData;
	Description:
		Callback function for saving window in window dump file and then print.
		Author: Tom (Tongzeng) Yang 
		(11/23/92)
___________________________________________________________________________________*/
#define PRINT_SEL	"qms"
Widget PrintCallback (w, clientData, callData)
Widget	w;
caddr_t clientData;
caddr_t callData;
{
	PRINT_DATA	*print_data	= (PRINT_DATA *) clientData;
	Display		*display	= print_data->draw_data->display;
	Window		window		= print_data->draw_data->window;
	GC		gc		= print_data->draw_data->gc;
	DRAWING_POINTS	*drawing_points	= print_data->drawing_points;
	FILE		*psfp;
	char		*enlarged_xray_data;
	char		printer [MAXLINE];
	char		*psxray;
	int		cols		= print_data->cols;
	int		current_nrows;
	int		current_rows;
	int		dimension;
	int		i;
	int		j;
	int		upper_bound;
	int		ncols;
	int		nrows;
	int		rows		= print_data->rows;
	short int	*xray_tracing	= print_data->xray_tracing;

	/*
	sprintf (printer, "xwd -id %d | xpr -device ps | lpr -P%s", window, PRINT_SEL);
	system (printer);

	XDefineCursor (display, window, print_data->cursor);
	*/

	WindowDump (display, window, FALSE, 0, 0, 0, 0, "/tmp/xray_tracing.xwd");

	/*
	WindowDump (display, window, TRUE, 20, 20, 1100, 870, "/tmp/xray_tracing.xwd");
	ncols	= cols;
	nrows	= rows;

	if (cols % 2 != 0)
		ncols	+= 1;

	if (rows % 2 != 0)
		nrows	+= 1;

	dimension		= ncols * nrows;
	enlarged_xray_data	= (char *) calloc (dimension, sizeof (char));
	if (enlarged_xray_data == (char *) NULL)
	{
		pkg_message (PKG_ERROR, "xray", "Generate PostScript File", "calloc",
					"Error: Can't allocate enlarged_xray_data.\n");
		return;
	}

	for (j = 0; j < rows; j++) 
	{
		current_nrows	= j * ncols;
		current_rows	= j * cols;

		for (i = 0; i < cols; i++) 
		{
			if (xray_tracing [current_rows + i] > 0)
			{
				enlarged_xray_data [current_nrows + i]
				= SIGN (xray_tracing [current_rows + i]);
			}
		}
	}

XClearArea (display, window, 0, 0, DRAW_AREA_WIDTH, DRAW_AREA_HEIGHT, FALSE);
	for (j = 0; j < nrows; j++) 
	{
		current_nrows	= j * ncols;
		for (i = 0; i < ncols; i++) 
		{
			if (enlarged_xray_data [current_nrows + i] == 1)
			{
				XDrawPoint (display, window, gc, 
						DISPLAY_MARGIN_WIDTH + i, 
						DISPLAY_MARGIN_HEIGHT + j);
			}
		}
	}

	dimension	/= BITS_PER_HEX;
	psxray		= (char *) calloc (dimension, sizeof (char));
	if (psxray == (char *) NULL)
	{
		pkg_message (PKG_ERROR, "xray", "Generate PostScript File", "calloc",
					"Error: Can't allocate psxray.\n");
		return;
	}

	for (i = 0; i < dimension; i++)
	{
		j		= BITS_PER_HEX * i;
		psxray [i]	= 8 * (1 - enlarged_xray_data [j]) 
				+ 4 * (1 - enlarged_xray_data [j + 1])
				+ 2 * (1 - enlarged_xray_data [j + 2]) 
				+ (1 - enlarged_xray_data [j + 3]);
	}

	free (enlarged_xray_data);

	psfp	= fopen (print_data->postscript_file, "w");
	*/

	/*
	 * Generate EPS file header.
	 */
/*
	fprintf (psfp, "%%!PS-Adobe-2.0\n");
	fprintf (psfp, "%%%%Creator: Tom Yang\n");
	fprintf (psfp, "%%%%Title: Skull X Ray Tracing\n");
	fprintf (psfp, "%%%%Pages: 1\n");
	fprintf (psfp, "%%%%EndComments\n");
	fprintf (psfp, "%%%%EndProlog\n\n");
*/

	/*
	 * Translation and scaling.
	 */
/*
	fprintf (psfp, "592 10 translate\n");
	fprintf (psfp, "90 rotate\n");
	fprintf (psfp, "%d %d scale\n\n", ncols, nrows);
	fprintf (psfp, "/DataString %d string def\n", nrows);
	fprintf (psfp, "%d %d 1 [%d 0 0 -%d 0 %d]\n", ncols, nrows, ncols, nrows, nrows); 
	fprintf (psfp, "{\n");
	fprintf (psfp, "  currentfile DataString readhexstring pop\n");
	fprintf (psfp, "} bind image\n\n");
*/

	/*
	 * Write out image data.
	 */
/*
	for (i = 0; i < dimension; i += PS_ROW_LEN)
	{
		upper_bound	= pkg_min (i + PS_ROW_LEN, dimension);
		for (j = i; j < upper_bound; j++)
		{
			fprintf (psfp, "%x", psxray [j]);
		}
		fprintf (psfp, "\n");
	}
	free (psxray);
*/

	/*
	 * Draw Lines. 
	 */
/*
	fprintf (psfp, "\n%f %f scale\n", 1.0 / ncols, 1.0 / nrows);
	fprintf (psfp, "\n-90 rotate\n");
	fprintf (psfp, "-592 0 translate\n");

	fprintf (psfp, "\n%d %d moveto\n", 592, 10);
	fprintf (psfp, "%d %d lineto\n", 592 - nrows, 10);
	fprintf (psfp, "%d %d lineto\n", 592 - nrows, ncols + 10);
	fprintf (psfp, "%d %d lineto\n", 592, ncols + 10);
	fprintf (psfp, "%d %d lineto stroke\n", 592, 10);
*/

	/*
	 * Generate EPS file tail.
	 */
/*
	fprintf (psfp, "showpage\n\n");
	fprintf (psfp, "%%%%Trailer\n");

	fclose (psfp);

	XUndefineCursor (display, window);
*/
}
@


1.26
log
@Same as the last version, checked in so others can have access the code.
@
text
@d1 1
a1 1
/*$Id: xray.callbacks,v 1.25 1995/02/08 15:32:20 ty7777 Exp ty7777 $*/
d3 3
@


1.25
log
@Changed the decimal places to 4 for magnification factor.
@
text
@d1 1
a1 1
/*$Id: xray.callbacks,v 1.24 1994/12/22 20:10:32 ty7777 Exp ty7777 $*/
d3 3
@


1.24
log
@Updated to regenerate the PETT6 .sxr files.
@
text
@d1 1
a1 1
/*$Id: xray.callbacks,v 1.23 1994/11/02 15:37:16 ty7777 Exp ty7777 $*/
d3 3
d172 1
a172 1
	sprintf (szBuffer, "%.3f", sxr_output->magnification_factor);
d285 1
a285 1
		sprintf (string_buffer, "%.3f", sxr_output->magnification_factor);
@


1.23
log
@Added processing for ecat_offset.
@
text
@d1 1
a1 1
/*$Id: xray.callbacks,v 1.22 1994/09/20 16:02:27 ty7777 Exp ty7777 $*/
d3 3
d223 1
d233 1
a233 13
			string	= XmTextGetString (*menu->textFilmPosition);
			sxr_output->film_position	= atof (string);
			XtFree (string);

			string	= XmTextGetString (*menu->textScanPosition);
			sxr_output->scan_position	= atof (string);
			XtFree (string);

			sxr_output->reference_offset	= sxr_output->scan_position 
							- sxr_output->film_position 
							- menu->ecat_offset;
			sprintf (string_buffer, "%.3f", sxr_output->reference_offset);
			XmTextSetString (*menu->textOffset, string_buffer);
d237 1
a237 3
			string	= XmTextGetString (*menu->textOffset);
			sxr_output->reference_offset	= atof (string);
			XtFree (string);
d240 14
d569 3
a571 1
	savesxr_data->sxr_root, PROGRAM_XRAY32, TRUE, savesxr_data->sxr_output) == FAIL)
d573 1
@


1.22
log
@Updated for peakslice processing.
@
text
@d1 1
a1 1
/*$Id: xray.callbacks,v 1.21 1994/09/06 22:06:04 ty7777 Exp ty7777 $*/
d3 3
d239 1
a239 1
							- ECAT_OFFSET;
@


1.21
log
@Added processing for the list widgets.
@
text
@d1 1
a1 1
/*$Id: xray.callbacks,v 1.20 1994/09/02 21:27:48 ty7777 Exp ty7777 $*/
d3 3
d466 1
d485 2
a486 32
	llist		petlist	= display_pet_data->petlist;
	DRAW_DATA	*draw_data	= display_pet_data->draw_data;
	Display		*display	= draw_data->display;
	Window		window		= draw_data->window;
	GC		gc		= draw_data->gc;
	PET_SLICE_DATA	*slice;
	POINT2D		bottom;
	POINT2D		left;
	POINT2D		right;
	POINT2D		top;
	XFontStruct	*font_struct;
	XPoint		points [5];
	char		stringbuf [MAXLINE];
	float		scale;
	int		cx;
	int		cy;
	int		font_height;
	int		height;
	int		i;
	int		j;
	int		list_size;
	int		n;
	int		pettnum		= display_pet_data->pettnum;
	int		string_width;
	int		width;
	int		xinc;
	int		xoffset;
	int		xstart;
	int		yinc;
	int		yoffset;
	int		ystart;
	short		*databuf;
d488 1
a488 2
	XClearArea (display, window, 0, 0, DRAW_AREA_WIDTH, DRAW_AREA_HEIGHT, FALSE);
	list_size	= llsize (petlist);
d490 2
a491 16
	if (pettnum == ECAT_SCANNER)
	{
		scale	= ECAT_SCALE;
		xinc	= ECAT_XINC;	
		yinc	= ECAT_YINC;	
		xstart	= ECAT_XSTART;
		ystart	= ECAT_YSTART;
	}
	else
	{
		scale	= PETT6_SCALE;
		xinc	= PETT6_XINC;	
		yinc	= PETT6_YINC;	
		xstart	= PETT6_XSTART;
		ystart	= PETT6_YSTART;
	}
d493 2
a494 8
	/* 
	 * Load text font. 
	 */
	font_struct	= XLoadQueryFont (display, PET_LABEL_FONT);
	if (font_struct == 0)
		fprintf (stderr, "Can Not Find Font %s\n", PET_LABEL_FONT);
	else
		XSetFont (display, gc, font_struct->fid);
d496 24
a519 2
	llhead (petlist);
	for (n = 1; n <= list_size; n++)
d521 3
a523 5
		/*
		 * Desired center of slice.
		 */
		cx	= xstart + ((n - 1) % 7) * xinc;
		cy	= ystart + ((n - 1) / 7) * yinc; 
d525 2
a526 20
		slice = llretrieve (petlist);

		/* 
		 * Compute pet image offset. 
		 */
		Transformation (scale, CX_IMAGE, CY_IMAGE, slice->xstart, slice->ystart,
				cx, cy, &xoffset, &yoffset);
		Transformation (scale, CX_IMAGE, CY_IMAGE, slice->bottom.x, slice->bottom.y,
				cx, cy, &bottom.x, &bottom.y);
		Transformation (scale, CX_IMAGE, CY_IMAGE, slice->left.x, slice->left.y,
				cx, cy, &left.x, &left.y);
		Transformation (scale, CX_IMAGE, CY_IMAGE, slice->right.x, slice->right.y,
				cx, cy, &right.x, &right.y);
		Transformation (scale, CX_IMAGE, CY_IMAGE, slice->top.x, slice->top.y,
				cx, cy, &top.x, &top.y);

		/* 
		 * Resize pet image. 
		 */
		if (left.x < right.x && top.y < bottom.y)
d528 3
a530 6
			XSetForeground (display, gc, display_pet_data->pet_color);
			width	= ROUND (slice->width * scale);
			height	= ROUND (slice->height * scale);
			databuf	= (short *) pkg_malloc (width * height * sizeof (short), 
						"DisplayPetCalback", "databuf"); 
			interp (slice->input, slice->width, slice->height, databuf, width, height);
d532 2
a533 31
			for (j = 0; j < height; j++) 
			{
				for (i = 0; i < width; i++) 
				{
					if (databuf [j * width + i] > 0)
						XDrawPoint (display, window, gc, xoffset + i, yoffset + j);
				}
			}
			free (databuf);

			/*
		 	 * Draw bounding rectangle lines.
		 	 */
			XSetForeground (display, gc, display_pet_data->xray_color);

			points [0].x	= left.x;
			points [0].y	= top.y;

			points [1].x	= left.x;
			points [1].y	= bottom.y;

			points [2].x	= right.x;
			points [2].y	= bottom.y;

			points [3].x	= right.x;
			points [3].y	= top.y;

			points [4].x	= left.x;
			points [4].y	= top.y;

			XDrawLines (display, window, gc, points, 5, CoordModeOrigin);
a534 17
		else
		{
			left.x		= cx;
			right.x		= cx;
			bottom.y	= cy;
		}

		/*
		 * Draw text.
		 */
		sprintf (stringbuf, "%d", slice->slice_index);
		font_height	= font_struct->ascent + font_struct->descent;
		string_width	= XTextWidth (font_struct, stringbuf, strlen (stringbuf));
		XDrawString (display, window, gc, (left.x + right.x - string_width) / 2, 
			bottom.y + font_height, stringbuf, strlen (stringbuf));

		llnext (petlist);
d536 4
a539 2

	XFreeFont (display, font_struct);
d562 1
a562 1
	savesxr_data->sxr_root, PROGRAM_XRAY31, TRUE, savesxr_data->sxr_output) == FAIL)
@


1.20
log
@Friday version.
@
text
@d1 1
a1 1
/*$Id: xray.callbacks,v 1.19 1994/09/02 19:02:38 ty7777 Exp ty7777 $*/
d3 3
d399 1
d404 2
d429 21
d453 1
a453 1
		XmListAddItem (file_list, item, 1);
@


1.19
log
@Updated to incorporated new algorithm for setting the default reference slice.
@
text
@d1 1
a1 1
/*$Id: xray.callbacks,v 1.18 1994/09/01 21:03:58 ty7777 Exp ty7777 $*/
d3 3
d423 1
a423 1
	item	= XmStringCreate (file_name, XmSTRING_DEFAULT_CHARSET);
a428 2
	else
		XtFree (item);
d430 2
d510 1
a510 1
	font_struct	= XLoadQueryFont (display, FONT);
d512 1
a512 1
		fprintf (stderr, "Can Not Find Font %s\n", FONT);
@


1.18
log
@Use the algorithm proposed by Randy.
@
text
@d1 1
a1 1
/*$Id: xray.callbacks,v 1.17 1994/08/31 20:30:49 ty7777 Exp ty7777 $*/
d3 3
d112 18
d132 1
a132 1
		ShowMenuCallback
d138 1
a138 1
		Callback function for activate a frame.
d142 1
a142 1
void ShowMenuCallback (w, clientData, callData)
d366 1
d369 66
d964 1
d967 3
@


1.17
log
@Same as the last version.
@
text
@d1 1
a1 1
/*$Id: xray.callbacks,v 1.16 1994/06/15 21:22:43 ty7777 Exp ty7777 $*/
d3 3
d664 1
d666 1
d668 1
a668 1
	int		j;
d765 1
a765 1
						drawing_points, graphics_data->sxr_output);
d767 1
a767 1
				GetRotationAngles (graphics_data->sxr_output);
d769 49
d819 1
@


1.16
log
@Display the slice numbers at the correct position even if
the slice has no data in it.
@
text
@d1 1
a1 1
/*$Id: xray.callbacks,v 1.15 1993/12/20 21:27:59 ty7777 Exp ty7777 $*/
d3 4
@


1.15
log
@Added processing for recompute.
@
text
@d1 1
a1 1
/*$Id: xray.callbacks,v 1.14 1993/11/01 22:29:59 ty7777 Exp ty7777 $*/
d3 3
a428 5
		width	= ROUND (slice->width * scale);
		height	= ROUND (slice->height * scale);
		databuf	= (short *) pkg_malloc (width * height * sizeof (short), 
						"DisplayPetCalback", "databuf"); 
		 
d446 8
a453 2
		XSetForeground (display, gc, display_pet_data->pet_color);
		interp (slice->input, slice->width, slice->height, databuf, width, height);
d455 1
a455 3
		for (j = 0; j < height; j++) 
		{
			for (i = 0; i < width; i++) 
d457 5
a461 2
				if (databuf [j * width + i] > 0)
					XDrawPoint (display, window, gc, xoffset + i, yoffset + j);
d463 1
a463 2
		}
		free (databuf);
d465 4
a468 4
		/*
		 * Draw bounding rectangle lines.
		 */
		XSetForeground (display, gc, display_pet_data->xray_color);
d470 2
a471 2
		points [0].x	= left.x;
		points [0].y	= top.y;
d473 2
a474 2
		points [1].x	= left.x;
		points [1].y	= bottom.y;
d476 2
a477 2
		points [2].x	= right.x;
		points [2].y	= bottom.y;
d479 2
a480 2
		points [3].x	= right.x;
		points [3].y	= top.y;
d482 2
a483 2
		points [4].x	= left.x;
		points [4].y	= top.y;
a484 1
		if (left.x < right.x && top.y < bottom.y)
d486 7
@


1.14
log
@Debugging.
@
text
@d1 1
a1 1
/*$Id: xray.callbacks,v 1.13 1993/10/06 14:57:04 ty7777 Exp ty7777 $*/
d3 3
d170 4
a173 1
	PARAMETER_MENU	*menu		= (PARAMETER_MENU *) clientData;
d178 1
a178 5
	string					= XmTextGetString (*menu->textMagnificationFactor);
	sxr_output->magnification_factor	= atof (string);
	XtFree (string);

	if (menu->pettnum == ECAT_SCANNER)
d180 2
a181 2
		string	= XmTextGetString (*menu->textFilmPosition);
		sxr_output->film_position	= atof (string);
d184 25
a208 2
		string	= XmTextGetString (*menu->textScanPosition);
		sxr_output->scan_position	= atof (string);
d211 18
a228 4
		sxr_output->reference_offset	= sxr_output->scan_position - sxr_output->film_position 
							- ECAT_OFFSET;
		sprintf (string_buffer, "%.3f", sxr_output->reference_offset);
		XmTextSetString (*menu->textOffset, string_buffer);
d232 5
a236 4
		string				= XmTextGetString (*menu->textOffset);
		sxr_output->reference_offset	= atof (string);
		XtFree (string);
	}
d238 2
a239 3
	string			= XmTextGetString (*menu->textPixelSize);
	sxr_output->pixel_size	= atof (string);
	XtFree (string);
d241 2
a242 3
	string				= XmTextGetString (*menu->textSliceSpacing);
	sxr_output->slice_separation	= atof (string);
	XtFree (string);
d244 2
a245 3
	string				= XmTextGetString (*menu->textReferenceSlice);
	sxr_output->reference_slice	= atoi (string);
	XtFree (string);
d247 2
a248 3
	string				= XmTextGetString (*menu->textNumberOfSlices);
	sxr_output->number_slices	= atoi (string);
	XtFree (string);
d250 2
a251 3
	string			= XmTextGetString (*menu->textThreshold);
	sxr_output->threshold	= atoi (string);
	XtFree (string);
d253 10
d265 16
a280 2
	GetPetParameters (menu->petfile, menu->trim, menu->pettnum, menu->encoded, 
			sxr_output, menu->petlist);
d314 1
a314 1
	XSetForeground (display, gc, xray_color.pixel);
d448 1
a448 1
		XSetForeground (display, gc, pet_color.pixel);
d464 1
a464 1
		XSetForeground (display, gc, xray_color.pixel);
d638 2
a640 1
	GRAPHICS_DATA	*graphics_data		= (GRAPHICS_DATA *) clientData;
d642 1
a643 2
	Display		*display		= graphics_data->draw_data->display;
	Window		window			= graphics_data->draw_data->window;
d647 1
a647 1
	SXR_OUTPUT	*sxr_output		= graphics_data->sxr_output;
a650 3
	int		cols			= graphics_data->cols;
	int		rows			= graphics_data->rows;
	short int	*xray_tracing		= graphics_data->xray_tracing;
d729 1
a729 1
				XSetForeground (display, gc, xray_color.pixel);
d743 4
a746 2
				GetXRayParameters (cols, rows, xray_tracing, *defining_points, 
						drawing_points, sxr_output);
d748 1
a748 1
				GetRotationAngles (sxr_output);
d750 2
a751 104
				XClearArea (display, window, 0, 0, DRAW_AREA_WIDTH, DRAW_AREA_HEIGHT, FALSE);

				for (j = 0; j < rows; j++) 
				{
					for (i = 0; i < cols; i++) 
					{
						if (xray_tracing [j * cols + i] > 0)
						{
							XDrawPoint (display, window, gc, 
								DISPLAY_MARGIN_WIDTH + i, 
								DISPLAY_MARGIN_HEIGHT + j);
						}
					}
				}

				XSetForeground (display, gc, xray_color.pixel);
				XDrawLine (display, window, gc, 
					drawing_points->glabella.x + DISPLAY_MARGIN_WIDTH,
					drawing_points->glabella.y + DISPLAY_MARGIN_HEIGHT,
					drawing_points->inion.x + DISPLAY_MARGIN_WIDTH,
					drawing_points->inion.y + DISPLAY_MARGIN_HEIGHT);
				XDrawLine (display, window, gc, 
					drawing_points->acpc_anterior.x + DISPLAY_MARGIN_WIDTH,
					drawing_points->acpc_anterior.y + DISPLAY_MARGIN_HEIGHT,
					drawing_points->acpc_posterior.x + DISPLAY_MARGIN_WIDTH,
					drawing_points->acpc_posterior.y + DISPLAY_MARGIN_HEIGHT);
				XDrawLine (display, window, gc, 
					drawing_points->slice_anterior.x + DISPLAY_MARGIN_WIDTH,
					drawing_points->slice_anterior.y + DISPLAY_MARGIN_HEIGHT,
					drawing_points->slice_posterior.x + DISPLAY_MARGIN_WIDTH,
					drawing_points->slice_posterior.y + DISPLAY_MARGIN_HEIGHT);
				XDrawLine (display, window, gc, 
					drawing_points->acpc_center.x + DISPLAY_MARGIN_WIDTH,
					drawing_points->acpc_center.y + DISPLAY_MARGIN_HEIGHT,
					drawing_points->zvertex.x + DISPLAY_MARGIN_WIDTH,
					drawing_points->zvertex.y + DISPLAY_MARGIN_HEIGHT);
				XDrawLine (display, window, gc, 
					drawing_points->acpc_center.x + DISPLAY_MARGIN_WIDTH,
					drawing_points->acpc_center.y + DISPLAY_MARGIN_HEIGHT,
					drawing_points->ref_normalref.x + DISPLAY_MARGIN_WIDTH,
					drawing_points->ref_normalref.y + DISPLAY_MARGIN_HEIGHT);

				XSetForeground (display, gc, marker_color.pixel);
				DrawSymbol (display, window, gc, 
					drawing_points->glabella.x + DISPLAY_MARGIN_WIDTH, 
					drawing_points->glabella.y + DISPLAY_MARGIN_HEIGHT, 
					CROSSHAIR_SIZE, CROSSHAIR_SIZE, CROSSHAIR);
				DrawSymbol (display, window, gc, 
					drawing_points->inion.x + DISPLAY_MARGIN_WIDTH, 
					drawing_points->inion.y + DISPLAY_MARGIN_HEIGHT, 
					CROSSHAIR_SIZE, CROSSHAIR_SIZE, CROSSHAIR);

				DrawSymbol (display, window, gc, 
					drawing_points->acpc_anterior.x + DISPLAY_MARGIN_WIDTH, 
					drawing_points->acpc_anterior.y + DISPLAY_MARGIN_HEIGHT, 
					CROSSHAIR_SIZE, CROSSHAIR_SIZE, CROSSHAIR);
				DrawSymbol (display, window, gc, 
					drawing_points->acpc_posterior.x + DISPLAY_MARGIN_WIDTH, 
					drawing_points->acpc_posterior.y + DISPLAY_MARGIN_HEIGHT, 
					CROSSHAIR_SIZE, CROSSHAIR_SIZE, CROSSHAIR);
				DrawSymbol (display, window, gc, 
					drawing_points->slice_anterior.x + DISPLAY_MARGIN_WIDTH, 
					drawing_points->slice_anterior.y + DISPLAY_MARGIN_HEIGHT, 
					CROSSHAIR_SIZE, CROSSHAIR_SIZE, CROSSHAIR);
				DrawSymbol (display, window, gc, 
					drawing_points->slice_posterior.x + DISPLAY_MARGIN_WIDTH, 
					drawing_points->slice_posterior.y + DISPLAY_MARGIN_HEIGHT, 
					CROSSHAIR_SIZE, CROSSHAIR_SIZE, CROSSHAIR);
				DrawSymbol (display, window, gc, 
					(drawing_points->slice_anterior.x 
					+ drawing_points->slice_posterior.x) / 2 + DISPLAY_MARGIN_WIDTH, 
					(drawing_points->slice_anterior.y +
					drawing_points->slice_posterior.y) / 2 + DISPLAY_MARGIN_HEIGHT, 
					CROSSHAIR_SIZE, CROSSHAIR_SIZE, CROSSHAIR);
				DrawSymbol (display, window, gc, 
					drawing_points->zvertex.x + DISPLAY_MARGIN_WIDTH, 
					drawing_points->zvertex.y + DISPLAY_MARGIN_HEIGHT, 
					CROSSHAIR_SIZE, CROSSHAIR_SIZE, CROSSHAIR);

				XSetForeground (display, gc, pet_color.pixel);
				DrawSymbol (display, window, gc, 
					drawing_points->vertex_zmax.x + DISPLAY_MARGIN_WIDTH, 
					drawing_points->vertex_zmax.y + DISPLAY_MARGIN_HEIGHT, 
					CROSSHAIR_SIZE, CROSSHAIR_SIZE, CROSSHAIR);

				XSetForeground (display, gc, xray_color.pixel);

				/*
				for (i = 0; i < sxr_output->number_slices; i++)
				{
					if (sxr_output->rlslicedim [i - 1] >= 1.0)
					{
						XDrawLine (display, window, gc, 
							drawing_points->slices_ap [2 * i].x 
								+ DISPLAY_MARGIN_WIDTH,
							drawing_points->slices_ap [2 * i].y 
								+ DISPLAY_MARGIN_HEIGHT,
							drawing_points->slices_ap [2 * i + 1].x 
								+ DISPLAY_MARGIN_WIDTH,
							drawing_points->slices_ap [2 * i + 1].y 
								+ DISPLAY_MARGIN_HEIGHT);
					}
				}
				*/
@


1.13
log
@Change PROGRAM_XRAY30 to PROGRAM_XRAY31.
@
text
@d1 1
a1 1
/*$Id: xray.callbacks,v 1.12 1993/09/14 16:17:36 ty7777 Exp ty7777 $*/
d3 3
d707 1
d734 1
d743 1
d767 6
d776 2
@


1.12
log
@libhp.a changes.
@
text
@d1 1
a1 1
/*$Id: xray.callbacks,v 1.11 1993/09/09 20:23:34 ty7777 Exp ty7777 $*/
d3 3
d457 1
a457 1
	savesxr_data->sxr_root, PROGRAM_XRAY30, TRUE, savesxr_data->sxr_output) == FAIL)
@


1.11
log
@Changed SaveSXRData to savesxr.
@
text
@d1 1
a1 1
/*$Id: xray.callbacks,v 1.10 1993/08/31 20:05:55 ty7777 Exp ty7777 $*/
d3 3
d214 2
a215 2
	GetPetParameters (menu->petfile, menu->petimagetype, sxr_output->threshold, menu->peaktype, 
			menu->trim, sxr_output->number_slices, menu->pettnum, menu->encoded, sxr_output);
d288 1
d453 2
a454 2
	if (savesxr (savesxr_data->sxr_name, savesxr_data->peaktype, savesxr_data->petfile, 
	savesxr_data->sxr_root, PROGRAM_XRAY30, savesxr_data->sxr_output) == FAIL)
@


1.10
log
@Before changing cursor shape.
@
text
@d1 1
a1 1
/*$Id: xray.callbacks,v 1.9 1993/03/05 20:44:04 ty7777 Exp $*/
d3 3
d449 3
a451 2
	SaveSXRData (savesxr_data->sxr_name, savesxr_data->peaktype, savesxr_data->petfile, 
		savesxr_data->sxr_root, savesxr_data->sxr_output);
@


1.9
log
@Before removing Sunview related libraries.
@
text
@d1 1
a1 1
/*$Id: xray.callbacks,v 1.8 1993/03/02 22:08:41 ty7777 Exp ty7777 $*/
d3 3
d794 1
d807 1
d822 3
a825 1
	*/
a826 1
	/*
a827 1
	*/
d897 1
d902 1
d909 1
d914 1
d923 1
d928 1
a934 3
			/*
			fprintf (psfp, "%x", 0);
			*/
d939 1
d944 1
d954 1
d959 1
a964 1
	/*
d966 1
a966 1
	*/
@


1.8
log
@Before using magnification factor to compute slice lengths.
@
text
@d1 1
a1 1
/*$Id: xray.callbacks,v 1.7 1993/02/19 16:51:35 ty7777 Exp ty7777 $*/
d3 3
@


1.7
log
@Before adding film position, scan position, and offset.
@
text
@d1 1
a1 1
/*$Id: xray.callbacks,v 1.6 1993/02/17 20:42:41 ty7777 Exp ty7777 $*/
d3 3
d748 1
a748 1
			/*
d764 1
a764 1
			*/
@


1.6
log
@Before changing xray slices lengths computation order.
@
text
@d1 1
a1 1
/*$Id: xray.callbacks,v 1.5 1993/02/16 17:32:47 ty7777 Exp ty7777 $*/
d3 3
d745 1
d748 12
a759 5
					XDrawLine (display, window, gc, 
					drawing_points->slices_ap [2 * i].x + DISPLAY_MARGIN_WIDTH,
					drawing_points->slices_ap [2 * i].y + DISPLAY_MARGIN_HEIGHT,
					drawing_points->slices_ap [2 * i + 1].x + DISPLAY_MARGIN_WIDTH,
					drawing_points->slices_ap [2 * i + 1].y + DISPLAY_MARGIN_HEIGHT);
d761 1
d885 1
a885 1
	psfp	= fopen ("yih-wen.ps", "w");
@


1.5
log
@Before adding slice dimension lines.
@
text
@d1 1
a1 1
/*$Id: xray.callbacks,v 1.4 1993/02/09 18:22:23 ty7777 Exp ty7777 $*/
d3 3
d664 1
a664 1
				GetRotationAngles (graphics_data->sxr_output);
d741 9
@


1.4
log
@Release checking in.
@
text
@d1 1
a1 1
/*$Id: xray.callbacks,v 1.3 1993/01/27 22:08:18 ty7777 Exp $*/
d3 3
d86 3
a88 1
	Widget	dialog = (Widget) clientData;
d90 31
a120 1
	XtManageChild (dialog);
d143 1
a143 2
	float		film_position;
	float		scan_position;
d152 1
a152 1
		film_position	= atof (string);
d156 1
a156 1
		scan_position	= atof (string);
d159 4
a162 1
		sxr_output->reference_offset	= scan_position - film_position;
d188 1
a188 1
	*menu->threshold	= atoi (string);
d193 2
a194 3
	GetPetParameters (menu->petfile, menu->petimagetype, *menu->threshold, menu->peaktype, 
			menu->trim, sxr_output->number_slices, menu->pettnum, menu->encoded, 
			sxr_output);
d394 2
a395 1
		XDrawLines (display, window, gc, points, 5, CoordModeOrigin);
d431 1
a431 2
	SaveSXRData (savesxr_data->sxr_name, savesxr_data->threshold, 
		savesxr_data->peaktype, savesxr_data->petfile, 
a657 5
				defining_points->slice_lpoint.y	+= ROUND (sxr_output->reference_offset
					/  (MMS_PER_CM * sxr_output->pixel_size));
				defining_points->slice_rpoint.y	+= ROUND (sxr_output->reference_offset
					/  (MMS_PER_CM * sxr_output->pixel_size));

d703 35
@


1.3
log
@Adding GetPetParameters after menu selection.
@
text
@d1 1
a1 1
/*$Id: xray.callbacks,v 1.2 1993/01/27 20:45:25 ty7777 Exp ty7777 $*/
d3 3
d108 2
d115 5
a119 3
	string				= XmTextGetString (*menu->textOffset);
	sxr_output->reference_offset	= atof (string);
	XtFree (string);
d121 13
d150 1
a150 1
	string		= XmTextGetString (*menu->textThreshold);
@


1.2
log
@After adding PET image width and skull X ray width.
@
text
@d1 1
a1 1
/*$Id: xray.callbacks,v 1.1 1993/01/26 21:02:13 ty7777 Exp ty7777 $*/
d3 3
d135 4
@


1.1
log
@Initial revision
@
text
@d1 5
a5 2
/*$Id$*/
/*$Log$*/
d30 1
d33 1
@
