head	1.33;
access;
symbols;
locks; strict;
comment	@ * @;


1.33
date	2010.07.16.22.06.12;	author tom;	state Exp;
branches;
next	1.32;

1.32
date	2010.03.18.15.17.39;	author tom;	state Exp;
branches;
next	1.31;

1.31
date	2009.04.08.14.29.06;	author tom;	state Exp;
branches;
next	1.30;

1.30
date	2008.10.30.15.46.41;	author tom;	state Exp;
branches;
next	1.29;

1.29
date	2008.10.30.15.30.07;	author tom;	state Exp;
branches;
next	1.28;

1.28
date	2007.10.24.21.24.32;	author tom;	state Exp;
branches;
next	1.27;

1.27
date	2007.07.02.17.04.29;	author tom;	state Exp;
branches;
next	1.26;

1.26
date	2006.06.26.16.52.05;	author tom;	state Exp;
branches;
next	1.25;

1.25
date	2006.06.26.15.51.53;	author tom;	state Exp;
branches;
next	1.23;

1.23
date	2006.06.06.18.59.02;	author tom;	state Exp;
branches;
next	1.22;

1.22
date	2006.01.10.18.30.31;	author tom;	state Exp;
branches;
next	1.21;

1.21
date	2005.05.18.20.04.52;	author tom;	state Exp;
branches;
next	1.20;

1.20
date	2005.05.18.16.48.05;	author tom;	state Exp;
branches;
next	1.19;

1.19
date	2005.05.03.20.58.58;	author tom;	state Exp;
branches;
next	1.18;

1.18
date	2005.04.19.18.54.29;	author tom;	state Exp;
branches;
next	1.17;

1.17
date	2005.04.19.16.23.41;	author tom;	state Exp;
branches;
next	1.16;

1.16
date	2005.04.14.17.41.10;	author tom;	state Exp;
branches;
next	1.15;

1.15
date	2005.04.14.15.39.10;	author tom;	state Exp;
branches;
next	1.14;

1.14
date	2005.04.14.14.17.56;	author tom;	state Exp;
branches;
next	1.13;

1.13
date	2005.04.14.14.15.57;	author tom;	state Exp;
branches;
next	1.12;

1.12
date	2005.04.12.15.29.34;	author tom;	state Exp;
branches;
next	1.11;

1.11
date	2004.02.13.21.48.38;	author tom;	state Exp;
branches;
next	1.8;

1.8
date	2003.02.25.14.38.12;	author tom;	state Exp;
branches;
next	1.7;

1.7
date	2002.01.18.21.26.45;	author tom;	state Exp;
branches;
next	1.6;

1.6
date	2002.01.17.15.51.30;	author tom;	state Exp;
branches;
next	1.5;

1.5
date	2002.01.11.16.07.18;	author tom;	state Exp;
branches;
next	1.4;

1.4
date	2001.09.17.14.59.19;	author tom;	state Exp;
branches;
next	1.3;

1.3
date	2001.09.14.19.21.35;	author tom;	state Exp;
branches;
next	1.2;

1.2
date	2001.09.14.18.19.42;	author tom;	state Exp;
branches;
next	1.1;

1.1
date	2001.09.13.13.35.05;	author tom;	state Exp;
branches;
next	;


desc
@@


1.33
log
@change max array from 512 to 1024
@
text
@/* $Id: dcm2analyze.c,v 1.32 2010/03/18 15:17:39 tom Exp tom $ */
/* $Log: dcm2analyze.c,v $
 * Revision 1.32  2010/03/18  15:17:39  tom
 * add orientation
 *
 * Revision 1.31  2009/04/08  14:29:06  tom
 * get slice separation from locations of first and last slices
 *
 * Revision 1.30  2008/10/30  15:46:41  tom
 * omit use of originator key as SPM5 uses it for the origin
 *
 * Revision 1.29  2008/10/30  15:30:07  tom
 * update to use dbh.h
 *
 * Revision 1.28  2007/10/24  21:24:32  tom
 * add option for order Transverse [xry] (-1,0,0/0,1,0)
 *
 * Revision 1.27  2007/07/02  17:04:29  tom
 * added 't' flag and yzm orientation to deal with a Trio scan on Al
 *
 * Revision 1.26  2006/06/26  16:52:05  tom
 * flip left/right in monkey coronal
 *
 * Revision 1.25  2006/06/26  15:51:53  tom
 * reorient monkey transverse to coronal reversed
 *
 * Revision 1.23  2006/06/06  18:59:02  tom
 * add flags to use first instance of some header fields
 *
 * Revision 1.22  2006/01/10  18:30:31  tom
 * correct Sagittal [yz] (0,1,0/0,0,-1)
 * for monkey (flag = 1)
 *
 * Revision 1.21  2005/05/18  20:04:52  tom
 * put back kludge for CT orientation
 *
 * Revision 1.20  2005/05/18  16:48:05  tom
 * since dcm_slice_reorder is now run routinely,
 * fix transverse orientation for MR
 *
 * Revision 1.19  2005/05/03  20:58:58  tom
 * fix order for transverse CT images
 *
 * Revision 1.18  2005/04/19  18:54:29  tom
 * reverse coronal orientation
 *
 * Revision 1.17  2005/04/19  16:23:41  tom
 * yet another fix for the xy/xyr orientations
 *
 * Revision 1.16  2005/04/14  17:41:10  tom
 * revised CT keys
 *
 * Revision 1.15  2005/04/14  15:39:10  tom
 * add CT keys to ifh file
 *
 * Revision 1.14  2005/04/14  14:17:56  tom
 * *** empty log message ***
 *
 * Revision 1.13  2005/04/14  14:15:57  tom
 * add CT orientation
 * keys specific for CT and MR
 *
 * Revision 1.12  2005/04/12  15:29:34  tom
 * read coronal images
 *
 * Revision 1.11  2004/02/13  21:48:38  tom
 * Feb 2004
 *
 * Revision 1.8  2003/02/25  14:38:12  tom
 * fix coronal bug
 *
 * Revision 1.7  2002/01/18  21:26:45  tom
 * fix Transverse conversion to orient TSE correctly
 *
 * Revision 1.6  2002/01/17  15:51:30  tom
 * read 00001.dcm filenames
 *
 * Revision 1.5  2002/01/11  16:07:18  tom
 * *** empty log message ***
 *
 * Revision 1.4  2001/09/17  14:59:19  tom
 * *** empty log message ***
 *
 * Revision 1.3  2001/09/14  19:21:35  tom
 * *** empty log message ***
 *
 * Revision 1.2  2001/09/14  18:19:42  tom
 * *** empty log message ***
 *
 * Revision 1.1  2001/09/13  13:35:05  tom
 * Initial revision
 * */
/*  ===============================================================================
 *  Module:         dcm2analyze.c
 *  Date:           Sept 2001
 *  Author:         Tom Videen
 *  Description:    Transform Siemens DICOM MRI images into Analyze format.
 *      Output images will be displayed by Analyze with left brain on the left
 *      and with the lower slices first.  This allows the 3D volume rendered
 *      brains to appear upright.
 *		An Interfile Format header file is created.
 *  ===============================================================================
 */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <math.h>
#include <values.h>
#include <matrixlib.h>
#include <image.h>
#include <imgutil.h>
#include <nrutil.h>
#include <dbh.h>

#define U_SHORT unsigned short
#define MAXSTR 256
#define TRANSVERSE '\000'
#define CORONAL    '\001'
#define SAGITTAL   '\002'

static char     rcsid[] = "$Header: /home/npggw/tom/src/dcm2analyze/RCS/dcm2analyze.c,v 1.32 2010/03/18 15:17:39 tom Exp tom $";

/*  ----------------------------
 *  Function:   dcm2analyze
 *  ----------------------------
 */
int             main (argc, argv)
	int             argc;
	char           *argv[];
{

	union temp_short {
		short           s[1024 * 1024];
		char            c[1024 * 1024 * 2];
	}               tmp;

	char            fname[MAXSTR];		 /* input file name */

	FILE           *fdcm;			 /* input DICOM file */
	FILE           *fhdr;			 /* output ANALYZE hdr */
	FILE           *fimg;			 /* output ANALYZE image  */
	FILE           *fifh;			 /* output Interfile Format header */
	struct dsr      hdr;			 /* header for ANALYZE */
	char           *ptr, *ptr2;
	char           *ptr_end;
	char            str[MAXSTR];
	char            orientation[12];
	char           *order;
	char           *dcmhdr;			 /* dcm_dump_file output */
	char            ANALYZE_hdr[MAXSTR];	 /* output Analyze header filename */
	char            ANALYZE_img[MAXSTR];	 /* output Analyze image filename */
	char            IF_hdr[MAXSTR];		 /* output Interfile Format header filename */
	char            version[5];
	char            program_date[12];
	char            modality[12];
	char            study_date[12];
	char            institution[MAXSTR];
	char            model[MAXSTR];
	char            subject_id[MAXSTR];
	char            StudyDescription[MAXSTR];
	char            SequenceName[MAXSTR];
	char            ProtocolName[MAXSTR];
	float           GantryTilt = 0;

	int             KVP = 0;
	int             ExposureTime = 0;
	int             TubeCurrent = 0;
	int             Exposure = 0;

	long            dsize = 0;
	long            offset;
	int             bitsperpix = 16;	 /* short integer */
	float           datum;
	int             global_max;		 /* global maximum */
	int             global_min;		 /* global minimum */
	int             vec1[3], vec2[3];	 /* Image Orientation */
	float           t1, t2, t3, t4, t5, t6;	 /* input for sscanf */
	float           slc1, slc2;		 /* first and last slice relative locations */
	float           slicesep;
	int             first, last;		 /* first and last file numbers to convert */
	int             scn;			 /* file number to convert */
	int             flag;			 /* 1 -> animal rotated from file orientation */
	/* 2 -> animal rotated in Trio */
	int             pln;
	int             i, j, k, n;
	int             d0 = 0;			 /* some DICOM headers had duplicate */
	int             d1 = 0;			 /* and incorrect information */
	int             d2 = 0;			 /* These flags are used to take the first instance */
	int             d3 = 0;

	short        ***img;			 /* output Analyze image */
	short           ddim[3];		 /* input DICOM image dimensions */
	float           dpix[3];		 /* input DICOM pixel sizes (mm) */
	short           dim[3];			 /* output Analyze image dimensions */
	float           pix[3];			 /* output Analyze pixel sizes (mm) */

	ptr = strstr (rcsid, "v ");
	ptr += 2;
	(void) strncpy (version, ptr, 4);
	ptr_end = strchr (version, ' ');
	if (ptr_end != NULL)
		*ptr_end = '\0';
	ptr = strstr (ptr, " ");
	ptr++;
	if (ptr != NULL)
		(void) strncpy (program_date, ptr, 10);
	ptr = strchr (program_date, '/');
	*ptr = ':';
	ptr = strchr (program_date, '/');
	*ptr = ':';
	*(ptr + 3) = '\0';
	order = (char *) calloc (3, sizeof (char));
	if (order == NULL)
		return (ERROR);

/*
 *  Get command line arguments and initialize filenames:
 */
	if (argc != 8) {
		printf ("Usage: dcm2analyze first last dicom_hdr output flag slc1 slc2\n");
		return (ERROR);
	}
	first = atoi (argv[1]);
	last = atoi (argv[2]);
	dcmhdr = argv[3];
	ddim[2] = last - first + 1;
	(void) strcpy (ANALYZE_img, argv[4]);
	(void) strcat (ANALYZE_img, ".img");
	(void) strcpy (ANALYZE_hdr, argv[4]);
	(void) strcat (ANALYZE_hdr, ".hdr");
	(void) strcpy (IF_hdr, argv[4]);
	(void) strcat (IF_hdr, ".ifh");
	flag = atoi (argv[5]);
	slc1 = atof (argv[6]);
	slc2 = atof (argv[7]);

/* lint free */

	vec1[0] = 0;
	vec1[1] = 0;
	vec1[2] = 0;
	vec2[0] = 0;
	vec2[1] = 0;
	vec2[2] = 0;
	dpix[0] = 0;
	dpix[1] = 0;
	dpix[2] = 0;

/*
 *	Get DICOM header info and orientation
 */

	ptr_end = strchr (dcmhdr, '\n');
	if (ptr_end != NULL)
		*ptr_end = '\0';
	if (ptr_end != NULL)
		*ptr_end = '\0';
	if ((fdcm = fopen (dcmhdr, "r")) == 0) {
		printf ("ERROR [dcm2analyze]: Unable to open %s\n", dcmhdr);
		return (ERROR);
	}
	if (fgets (str, sizeof (str), fdcm) == NULL) {
		printf ("ERROR [dcm2analyze]: reading %s\n", dcmhdr);
		return (ERROR);
	}
	if (strncmp (str, "DICOM", 5) != 0) {
		printf ("ERROR [dcm2analyze]: %s is not a DICOM file\n", dcmhdr);
		return (ERROR);
	}
	while (fgets (str, sizeof (str), fdcm) != NULL) {
		if (strlen (str) >= 55) {
			ptr = strrchr (str, '/');
			if (ptr != NULL) {
				ptr += 1;
				if (strncmp (str, "0008 0022", 9) == 0) {
					ptr_end = strchr (ptr, '\n');
					if (ptr_end != NULL)
						*ptr_end = '\0';
					(void) strcpy (study_date, ptr);
					continue;
				}
				if (strncmp (str, "0008 0060", 9) == 0) {
					ptr_end = strchr (ptr, '\n');
					if (ptr_end != NULL)
						*ptr_end = '\0';
					(void) strcpy (modality, ptr);
					continue;
				}
				if (strncmp (str, "0008 1030", 9) == 0) {
					ptr_end = strchr (ptr, '\n');
					if (ptr_end != NULL)
						*ptr_end = '\0';
					(void) strcpy (StudyDescription, ptr);
					continue;
				}
				if (strncmp (str, "0008 1090", 9) == 0) {
					ptr_end = strchr (ptr, '\n');
					if (ptr_end != NULL)
						*ptr_end = '\0';
					(void) strcpy (model, ptr);
					continue;
				}
				if (strncmp (str, "0010 0010", 9) == 0) {
					ptr_end = strchr (ptr, '\n');
					if (ptr_end != NULL)
						*ptr_end = '\0';
					(void) strcpy (subject_id, ptr);
					continue;
				}
				if (strncmp (str, "0018 0024", 9) == 0) {
					ptr_end = strchr (ptr, '\n');
					if (ptr_end != NULL)
						*ptr_end = '\0';
					(void) strcpy (SequenceName, ptr);
					continue;
				}
				if (strncmp (str, "0018 0050", 9) == 0) {
					dpix[2] = atof (ptr);
					continue;
				}
				if (strncmp (str, "0018 1030", 9) == 0) {
					ptr_end = strchr (ptr, '\n');
					if (ptr_end != NULL)
						*ptr_end = '\0';
					(void) strcpy (ProtocolName, ptr);
					continue;
				}
				if (strncmp (str, "0018 1120", 9) == 0) {
					GantryTilt = atof (ptr);
					continue;
				}
				if (strncmp (str, "0018 0060", 9) == 0) {
					KVP = atoi (ptr);
					continue;
				}
				if (strncmp (str, "0018 1150", 9) == 0) {
					ExposureTime = atoi (ptr);
					continue;
				}
				if (strncmp (str, "0018 1151", 9) == 0) {
					TubeCurrent = atoi (ptr);
					continue;
				}
				if (strncmp (str, "0018 1152", 9) == 0) {
					Exposure = atoi (ptr);
					continue;
				}
				if (strncmp (str, "0020 0037", 9) == 0) {
					(void) sscanf (ptr, "%f\\%f\\%f\\%f\\%f\\%f", &t1, &t2, &t3, &t4, &t5, &t6);
					vec1[0] = ROUND (t1);
					vec1[1] = ROUND (t2);
					vec1[2] = ROUND (t3);
					vec2[0] = ROUND (t4);
					vec2[1] = ROUND (t5);
					vec2[2] = ROUND (t6);
					continue;
				}
				if (strncmp (str, "0028 0010", 9) == 0) {
					if (d0 == 0) {
						d0 = 1;
						ddim[1] = atoi (ptr + 4);
					}
					continue;
				}
				if (strncmp (str, "0028 0011", 9) == 0) {
					if (d1 == 0) {
						d1 = 1;
						ddim[0] = atoi (ptr + 4);
					}
					continue;
				}
				if (strncmp (str, "0028 0030", 9) == 0) {
					if (d2 == 0) {
						d2 = 1;
						ptr2 = strrchr (ptr, '\\');
						dpix[0] = atof (ptr2 + 1);
						dpix[1] = atof (ptr2 + 1);
					}
					continue;
				}
				if (strncmp (str, "0028 0100", 9) == 0) {
					if (d3 == 0) {
						d3 = 1;
						bitsperpix = atoi (ptr + 4);
					}
					continue;
				}
				if (strncmp (str, "7fe0 0010", 9) == 0) {
					ptr_end = strchr (str, '/');
					if (ptr_end != NULL)
						*ptr_end = '\0';
					dsize = atoi (str + 10);
					continue;
				}
			}
		}
	}
	(void) fclose (fdcm);
	(void) strcpy (institution, "Washington University");
	if (dsize > 1024 * 1024 * 2) {
		printf ("Image frame size too large (%d)\n", (int) dsize);
		return (ERROR);
	}
	offset = -dsize;

	slicesep = fabs (slc1 - slc2) / (ddim[2] - 1);
	printf ("Slice Thickness = %.4f mm\n", dpix[2]);
	printf ("Slice Spacing   = %.4f mm\n", slicesep);
	if (slicesep > dpix[2])
		dpix[2] = slicesep;

/*
 *	Determine input orientation and output image dimensions & pixel size
 */

	if (strncmp (ProtocolName, "localizer", 9) == 0) {
		(void) strcpy (orientation, "Localizer");
		(void) strcpy (order, "xy0");
		dim[0] = ddim[0];
		dim[1] = ddim[1];
		dim[2] = ddim[2];
		pix[0] = dpix[0];
		pix[1] = dpix[1];
		pix[2] = dpix[2];
	} else if (vec1[0] == 1 && vec1[1] == 0 && vec1[2] == 0
		   && vec2[0] == 0 && vec2[1] == 1 && vec2[2] == 0) {
		if (flag == 0) {
			(void) strcpy (orientation, "Transverse");
			(void) strcpy (order, "xy");
			dim[0] = ddim[0];
			dim[1] = ddim[1];
			dim[2] = ddim[2];
			pix[0] = dpix[0];
			pix[1] = dpix[1];
			pix[2] = dpix[2];
		} else {
			(void) strcpy (orientation, "Monkey Coronal");
			(void) strcpy (order, "xzm");
			dim[0] = ddim[0];
			dim[1] = ddim[2];
			dim[2] = ddim[1];
			pix[0] = dpix[0];
			pix[1] = dpix[2];
			pix[2] = dpix[1];
		}
	} else if (vec1[0] == 1 && vec1[1] == 0 && vec1[2] == 0
		   && vec2[0] == 0 && vec2[1] == 1 && vec2[2] == 1) {
		(void) strcpy (orientation, "Transverse");
		(void) strcpy (order, "xy");
		dim[0] = ddim[0];
		dim[1] = ddim[1];
		dim[2] = ddim[2];
		pix[0] = dpix[0];
		pix[1] = dpix[1];
		pix[2] = dpix[2];
	} else if (vec1[0] == 1 && vec1[1] == 0 && vec1[2] == 0
		   && vec2[0] == 0 && vec2[1] == 1 && vec2[2] == -1) {
		(void) strcpy (orientation, "Transverse");
		(void) strcpy (order, "xyr");
		dim[0] = ddim[0];
		dim[1] = ddim[1];
		dim[2] = ddim[2];
		pix[0] = dpix[0];
		pix[1] = dpix[1];
		pix[2] = dpix[2];
	} else if (vec1[0] == -1 && vec1[1] == 0 && vec1[2] == 0
		   && vec2[0] == 0 && vec2[1] == 1 && vec2[2] == 0) {
		if (flag == 0) {
			(void) strcpy (orientation, "Transverse");
			(void) strcpy (order, "xry");
			dim[0] = ddim[0];
			dim[1] = ddim[1];
			dim[2] = ddim[2];
			pix[0] = dpix[0];
			pix[1] = dpix[1];
			pix[2] = dpix[2];
		} else {
			(void) strcpy (orientation, "Monkey Coronal");
			(void) strcpy (order, "xrzm");
			dim[0] = ddim[0];
			dim[1] = ddim[2];
			dim[2] = ddim[1];
			pix[0] = dpix[0];
			pix[1] = dpix[2];
			pix[2] = dpix[1];
		}
	} else if (vec1[0] == 1 && vec1[1] == 0 && vec1[2] == 0
		   && vec2[0] == 0 && vec2[1] == 0 && vec2[2] == -1) {
		(void) strcpy (orientation, "Coronal");
		(void) strcpy (order, "xzr");
		dim[0] = ddim[0];
		dim[1] = ddim[2];
		dim[2] = ddim[1];
		pix[0] = dpix[0];
		pix[1] = dpix[2];
		pix[2] = dpix[1];
	} else if (vec1[0] == 1 && vec1[1] == 0 && vec1[2] == 0
		   && vec2[0] == 0 && vec2[1] == -1 && vec2[2] == -1) {
		(void) strcpy (orientation, "Coronal");
		(void) strcpy (order, "xz");
		dim[0] = ddim[0];
		dim[1] = ddim[2];
		dim[2] = ddim[1];
		pix[0] = dpix[0];
		pix[1] = dpix[2];
		pix[2] = dpix[1];
	} else if (vec1[0] == 0 && vec1[1] == 1 && vec1[2] == 0
		   && vec2[0] == 0 && vec2[1] == 0 && vec2[2] == -1) {
		if (flag == 0) {
			(void) strcpy (orientation, "Sagittal");
			(void) strcpy (order, "yz");
			dim[0] = ddim[2];
			dim[1] = ddim[0];
			dim[2] = ddim[1];
			pix[0] = dpix[2];
			pix[1] = dpix[0];
			pix[2] = dpix[1];
		} else if (flag == 1) {
			(void) strcpy (orientation, "Sagittal");
			(void) strcpy (order, "zy");
			dim[0] = ddim[2];
			dim[1] = ddim[1];
			dim[2] = ddim[0];
			pix[0] = dpix[2];
			pix[1] = dpix[1];
			pix[2] = dpix[0];
		} else if (flag == 2) {
			(void) strcpy (orientation, "Sagittal");
			(void) strcpy (order, "zym");
			dim[0] = ddim[2];
			dim[1] = ddim[1];
			dim[2] = ddim[0];
			pix[0] = dpix[2];
			pix[1] = dpix[1];
			pix[2] = dpix[0];
		}
	} else if (vec1[0] == 0 && vec1[1] == 1 && vec1[2] == -1
		   && vec2[0] == 0 && vec2[1] == -1 && vec2[2] == -1) {
		if (flag == 0) {
			(void) strcpy (orientation, "Sagittal");
			(void) strcpy (order, "yz");
			dim[0] = ddim[2];
			dim[1] = ddim[0];
			dim[2] = ddim[1];
			pix[0] = dpix[2];
			pix[1] = dpix[0];
			pix[2] = dpix[1];
		} else if (flag == 1) {
			(void) strcpy (orientation, "Sagittal");
			(void) strcpy (order, "zy");
			dim[0] = ddim[2];
			dim[1] = ddim[1];
			dim[2] = ddim[0];
			pix[0] = dpix[2];
			pix[1] = dpix[1];
			pix[2] = dpix[0];
		} else if (flag == 2) {
			(void) strcpy (orientation, "Sagittal");
			(void) strcpy (order, "zym");
			dim[0] = ddim[2];
			dim[1] = ddim[1];
			dim[2] = ddim[0];
			pix[0] = dpix[2];
			pix[1] = dpix[1];
			pix[2] = dpix[0];
		}
	} else {
		printf ("Unusual Orientation (%d,%d,%d) (%d,%d,%d)\n", vec1[0], vec1[1], vec1[2], vec2[0], vec2[1], vec2[2]);
		return (ERROR);
	}

/*  Kludges for CT images */

	if (strcmp (modality, "CT") == 0 && strncmp (order, "xy", 2) == 0)
		(void) strcpy (order, "xyr");

	printf ("%s [%s] (%d,%d,%d/%d,%d,%d)\n", orientation, order, vec1[0], vec1[1], vec1[2], vec2[0], vec2[1], vec2[2]);
	printf ("In:  x = %d   y = %d   z = %d\n", ddim[0], ddim[1], ddim[2]);
	printf ("Out: x = %d (%f mm)  y = %d (%f mm)  z = %d (%f mm)\n",
		dim[0], pix[0], dim[1], pix[1], dim[2], pix[2]);

	if ((img = s3tensor (0, dim[2] - 1, 0, dim[1] - 1, 0, dim[0] - 1)) == NULL) {
		fprintf (stderr, "ERROR [dcm2analyze]: malloc img\n");
		return (ERROR);
	}
/*
 *	Open other files
 */

	if ((fhdr = fopen (ANALYZE_hdr, "w")) == 0) {
		printf ("ERROR [dcm2analyze]: Unable to create ANALYZE header %s\n", ANALYZE_hdr);
		return (ERROR);
	}
	if ((fimg = fopen (ANALYZE_img, "w")) == 0) {
		printf ("ERROR [dcm2analyze]: Unable to create ANALYZE image %s\n", ANALYZE_img);
		return (ERROR);
	}
	if ((fifh = fopen (IF_hdr, "w")) == 0) {
		printf ("ERROR [dcm2analyze]: Unable to create Interfile Format header %s\n", IF_hdr);
		return (ERROR);
	}
	global_max = 0;
	global_min = MAXINT;
	printf ("offset = %ld\n", offset);

/*
 *	Read all input image planes
 */

	for (pln = 0, scn = first; pln < ddim[2]; pln++, scn++) {
		(void) sprintf (fname, "%05d.dcm", scn);
		if ((fdcm = fopen (fname, "r")) == 0) {
			printf ("ERROR [dcm2analyze]: opening DICOM file %s\n", fname);
			return (ERROR);
		}
		if (fseek (fdcm, offset, SEEK_END) != 0) {
			printf ("ERROR [dcm2analyze]: fseek eof %s\n", fname);
			return (ERROR);
		}
		if (fread ((char *) tmp.s, dsize, 1, fdcm) != 1) {
			printf ("ERROR [dcm2analyze]: fread %ld bytes %s\n", dsize, fname);
			return (ERROR);
		}
		(void) fclose (fdcm);
		swab (tmp.c, tmp.c, dsize);

		n = 0;
		if (strncmp (order, "xy0", 3) == 0) {
			for (j = dim[1] - 1; j >= 0; j--) {
				for (i = dim[0] - 1; i >= 0; i--) {
					datum = tmp.s[n];
					img[pln][j][i] = datum;
					if (datum > global_max)
						global_max = datum;
					if (datum < global_min)
						global_min = datum;
					n++;
				}
			}

		} else if (strncmp (order, "xyr", 3) == 0) {
			for (j = dim[1] - 1; j >= 0; j--) {
				for (i = 0; i < dim[0]; i++) {
					datum = tmp.s[n];
					img[pln][j][i] = datum;
					if (datum > global_max)
						global_max = datum;
					if (datum < global_min)
						global_min = datum;
					n++;
				}
			}

		} else if (strncmp (order, "xry", 3) == 0) {
			for (j = dim[1] - 1; j >= 0; j--) {
				for (i = 0; i < dim[0]; i++) {
					datum = tmp.s[n];
					img[ddim[2] - pln - 1][j][dim[0] - i] = datum;
					if (datum > global_max)
						global_max = datum;
					if (datum < global_min)
						global_min = datum;
					n++;
				}
			}

		} else if (strncmp (order, "xy", 2) == 0) {
			for (j = dim[1] - 1; j >= 0; j--) {
				for (i = 0; i < dim[0]; i++) {
					datum = tmp.s[n];
					img[ddim[2] - pln - 1][j][i] = datum;
					if (datum > global_max)
						global_max = datum;
					if (datum < global_min)
						global_min = datum;
					n++;
				}
			}

		} else if (strncmp (order, "xzr", 3) == 0) {
			for (k = dim[2] - 1; k >= 0; k--) {
				for (i = 0; i < dim[0]; i++) {
					datum = tmp.s[n];
					img[k][pln][i] = datum;
					if (datum > global_max)
						global_max = datum;
					if (datum < global_min)
						global_min = datum;
					n++;
				}
			}

		} else if (strncmp (order, "xzm", 3) == 0) {
			for (k = dim[2] - 1; k >= 0; k--) {
				for (i = dim[0] - 1; i >= 0; i--) {
					datum = tmp.s[n];
					img[k][pln][i] = datum;
					if (datum > global_max)
						global_max = datum;
					if (datum < global_min)
						global_min = datum;
					n++;
				}
			}

		} else if (strncmp (order, "xz", 2) == 0) {
			for (k = dim[2] - 1; k >= 0; k--) {
				for (i = 0; i < dim[0]; i++) {
					datum = tmp.s[n];
					img[k][ddim[2] - pln - 1][i] = datum;
					if (datum > global_max)
						global_max = datum;
					if (datum < global_min)
						global_min = datum;
					n++;
				}
			}

		} else if (strncmp (order, "yz", 2) == 0) {
			for (k = dim[2] - 1; k >= 0; k--) {
				for (j = dim[1] - 1; j >= 0; j--) {
					datum = tmp.s[n];
					img[k][j][pln] = datum;
					if (datum > global_max)
						global_max = datum;
					if (datum < global_min)
						global_min = datum;
					n++;
				}
			}

		} else if (strncmp (order, "zym", 3) == 0) {
			for (j = dim[1] - 1; j >= 0; j--) {
				for (k = 0; k < dim[2]; k++) {
					datum = tmp.s[n];
					img[k][j][ddim[2] - pln - 1] = datum;
					if (datum > global_max)
						global_max = datum;
					if (datum < global_min)
						global_min = datum;
					n++;
				}
			}

		} else if (strncmp (order, "zy", 2) == 0) {
			for (j = dim[1] - 1; j >= 0; j--) {
				for (k = dim[2] - 1; k >= 0; k--) {
					datum = tmp.s[n];
					img[k][j][ddim[2] - pln - 1] = datum;
					if (datum > global_max)
						global_max = datum;
					if (datum < global_min)
						global_min = datum;
					n++;
				}
			}

		} else {
			printf ("ERROR [dcm2analyze]: Incompatible Order: %s\n", order);
			return (ERROR);
		}

	}

/*
 * Write to output file
 */

	for (k = 0; k < dim[2]; k++) {
		for (j = 0; j < dim[1]; j++) {
			if ((fwrite (img[k][j], sizeof (short), dim[0], fimg)) != dim[0]) {
				printf ("ERROR [dcm2analyze]: writing to: %s\n", ANALYZE_img);
				return (ERROR);
			}
		}
	}

/*
 * Create Analyze hdr file
 */

	(void) memset (&hdr, 0, sizeof (struct dsr));
	(void) strncpy (hdr.hk.db_name, fname, 17);
	hdr.hk.sizeof_hdr = sizeof (struct dsr);
	hdr.hk.extents = 16384;
	hdr.hk.regular = 'r';
	hdr.dime.dim[0] = 4;			 /* all Analyze images are taken as 4 dimensional */
	hdr.dime.dim[1] = dim[0];
	hdr.dime.dim[2] = dim[1];
	hdr.dime.dim[3] = dim[2];
	hdr.dime.dim[4] = 1;			 /* one volume */

	hdr.dime.datatype = DT_SIGNED_SHORT;
	hdr.dime.bitpix = bitsperpix;
	hdr.dime.pixdim[0] = 1.0;
	hdr.dime.pixdim[1] = pix[0];
	hdr.dime.pixdim[2] = pix[1];
	hdr.dime.pixdim[3] = pix[2];
	hdr.dime.roi_scale = 1.0;

	hdr.dime.glmax = global_max;
	hdr.dime.glmin = global_min;
	(void) strncpy (hdr.hist.descrip, fname, 79);
	(void) strncpy (hdr.hist.patient_id, version, 4);
	hdr.hist.orient = TRANSVERSE;

	if ((fwrite (&hdr, sizeof (struct dsr), 1, fhdr)) != 1) {
		printf ("ERROR [dcm2analyze]: writing to: %s\n", ANALYZE_hdr);
		return (ERROR);
	}
/*
 * Create Interfile Format header file
 */

	fprintf (fifh, "INTERFILE :=\n");
	fprintf (fifh, "version of keys	:= 3.3\n");
	fprintf (fifh, "image modality	:= %s\n", modality);
	fprintf (fifh, "originating system	:= %s\n", model);
	fprintf (fifh, "conversion program	:= dcm2analyze\n");
	fprintf (fifh, "program author	:= Tom Videen\n");
	fprintf (fifh, "program version	:= %s\n", version);
	fprintf (fifh, "program date	:= %s\n", program_date);
	fprintf (fifh, "original institution	:= %s\n", institution);
	fprintf (fifh, "name of data file	:= %s\n", ANALYZE_img);
	fprintf (fifh, "subject ID	:= %s\n", subject_id);
	fprintf (fifh, "study date	:= %s\n", study_date);

	fprintf (fifh, "number format	:= signed integer\n");
	fprintf (fifh, "number of bytes per pixel	:= %d\n", bitsperpix / 8);
	fprintf (fifh, "number of dimensions	:= 3\n");
	fprintf (fifh, "matrix size [1]	:= %d\n", dim[0]);
	fprintf (fifh, "matrix size [2]	:= %d\n", dim[1]);
	fprintf (fifh, "matrix size [3]	:= %d\n", dim[2]);
	fprintf (fifh, "scaling factor (mm/pixel) [1]	:= %f\n", pix[0]);
	fprintf (fifh, "scaling factor (mm/pixel) [2]	:= %f\n", pix[1]);
	fprintf (fifh, "scaling factor (mm/pixel) [3]	:= %f\n", pix[2]);
	fprintf (fifh, "matrix initial element [1]	:= right\n");
	fprintf (fifh, "matrix initial element [2]	:= posterior\n");
	fprintf (fifh, "matrix initial element [3]	:= inferior\n");
	if (strcmp (modality, "MR") == 0) {
		fprintf (fifh, "study description 	:= %s\n", StudyDescription);
		fprintf (fifh, "sequence name	:= %s\n", SequenceName);
		fprintf (fifh, "protocol description	:= %s\n", ProtocolName);
	} else if (strcmp (modality, "CT") == 0) {
		fprintf (fifh, "gantry tilt := %.2f\n", GantryTilt);
		fprintf (fifh, "tube voltage (kV)	:= %i\n", KVP);
		fprintf (fifh, "tube current (mA)	:= %i\n", TubeCurrent);
		fprintf (fifh, "exposure time (ms)	:= %i\n", ExposureTime);
		fprintf (fifh, "exposure (mAs)	:= %i\n", Exposure);
	}
/* free and exit */

	printf ("Completed [dcm2analyze]: creating %s\n", ANALYZE_img);
	printf ("Tilt = %.2f\n", GantryTilt);
	(void) fclose (fhdr);
	(void) fclose (fimg);
	(void) fclose (fifh);
	return (OK);
}
@


1.32
log
@add orientation
@
text
@d1 1
a1 1
/* $Id: dcm2analyze.c,v 1.31 2009/04/08 14:29:06 tom Exp tom $ */
d3 3
d122 1
a122 1
static char     rcsid[] = "$Header: /home/npggw/tom/src/dcm2analyze/RCS/dcm2analyze.c,v 1.31 2009/04/08 14:29:06 tom Exp tom $";
d134 2
a135 2
		short           s[512 * 512];
		char            c[512 * 512 * 2];
d401 1
a401 1
	if (dsize > 512 * 512 * 2) {
@


1.31
log
@get slice separation from locations of first and last slices
@
text
@d1 1
a1 1
/* $Id: dcm2analyze.c,v 1.30 2008/10/30 15:46:41 tom Exp tom $ */
d3 3
d119 1
a119 1
static char     rcsid[] = "$Header: /home/npggw/tom/src/dcm2analyze/RCS/dcm2analyze.c,v 1.30 2008/10/30 15:46:41 tom Exp tom $";
d509 30
@


1.30
log
@omit use of originator key as SPM5 uses it for the origin
@
text
@d1 1
a1 1
/* $Id: dcm2analyze.c,v 1.29 2008/10/30 15:30:07 tom Exp tom $ */
d3 3
d102 1
d116 1
a116 1
static char     rcsid[] = "$Header: /home/npggw/tom/src/dcm2analyze/RCS/dcm2analyze.c,v 1.29 2008/10/30 15:30:07 tom Exp tom $";
d122 1
a122 1
int main (argc, argv)
d167 1
a167 1
	int             bitsperpix = 16;	/* short integer */
d173 2
d178 1
a178 1
									 /* 2 -> animal rotated in Trio */
d214 2
a215 2
	if (argc != 6) {
		printf ("Usage: dcm2analyze <first> <last> <dicom_hdr> <output> <flag>\n");
d229 2
d401 6
d569 1
a569 1
	printf ("offset = %ld\n", offset); 
d660 1
a660 1
				for (i = dim[0]-1; i >= 0; i--) {
d747 1
a747 1
	(void) memset (&hdr,0,sizeof(struct dsr));
d819 1
@


1.29
log
@update to use dbh.h
@
text
@d1 1
a1 1
/* $Id: dcm2analyze.c,v 1.28 2007/10/24 21:24:32 tom Exp tom $ */
d3 3
d112 1
a112 1
static char     rcsid[] = "$Header: /home/npggw/tom/src/dcm2analyze/RCS/dcm2analyze.c,v 1.28 2007/10/24 21:24:32 tom Exp tom $";
a754 1
	(void) strncpy (hdr.hist.originator, "dcm2analy",9);
@


1.28
log
@add option for order Transverse [xry] (-1,0,0/0,1,0)
@
text
@d1 1
a1 1
/* $Id: dcm2analyze.c,v 1.27 2007/07/02 17:04:29 tom Exp $ */
d3 3
d101 1
a101 1
#include <ANALYZE.h>
d109 1
a109 1
static char     rcsid[] = "$Header: /home/npggw/tom/src/dcm2analyze/RCS/dcm2analyze.c,v 1.27 2007/07/02 17:04:29 tom Exp $";
d115 1
a115 1
main (argc, argv)
d160 1
a160 1
	int             bitsperpix = 16;
d730 1
d732 4
a735 4
	hdr.hk.sizeof_hdr = sizeof (struct dsr); /* required by developers */
	hdr.hk.extents = 16384;			 /* recommended by developers  */
	hdr.hk.regular = 'r';			 /* required by developers */
	hdr.dime.dim[0] = 4;			 /* 4 dimensions  */
d740 2
a741 8
	hdr.dime.unused8 = 0;			 /* despite the label, some of this is used */
	hdr.dime.unused9 = 0;
	hdr.dime.unused10 = 0;
	hdr.dime.unused11 = 0;
	hdr.dime.unused12 = 0;
	hdr.dime.unused13 = 0;
	hdr.dime.unused14 = 0;
	hdr.dime.datatype = 4;			 /* 16 bit signed integer  */
d743 1
d747 2
a748 6
	hdr.dime.funused8 = 0;
	hdr.dime.funused9 = 0;
	hdr.dime.funused10 = 0;
	hdr.dime.funused11 = 0;
	hdr.dime.funused12 = 0;
	hdr.dime.funused13 = 0;
d752 1
a752 1
	(void) strcpy (hdr.hist.originator, "dcm2analy");
@


1.27
log
@added 't' flag and yzm orientation to deal with a Trio scan on Al
@
text
@d1 1
a1 1
/* $Id: dcm2analyze.c,v 1.26 2006/06/26 16:52:05 tom Exp tom $ */
d3 3
d106 1
a106 1
static char     rcsid[] = "$Header: /home/npggw/tom/src/dcm2analyze/RCS/dcm2analyze.c,v 1.26 2006/06/26 16:52:05 tom Exp tom $";
d441 21
d517 1
a517 1
/*  Kludge for CT images */
d593 13
@


1.26
log
@flip left/right in monkey coronal
@
text
@d1 1
a1 1
/* $Id: dcm2analyze.c,v 1.25 2006/06/26 15:51:53 tom Exp tom $ */
d3 3
d103 1
a103 1
static char     rcsid[] = "$Header: /home/npggw/tom/src/dcm2analyze/RCS/dcm2analyze.c,v 1.25 2006/06/26 15:51:53 tom Exp tom $";
d163 1
d469 1
a469 1
		} else {
d478 9
d634 13
@


1.25
log
@reorient monkey transverse to coronal reversed
@
text
@d1 1
a1 1
/* $Id: dcm2analyze.c,v 1.23 2006/06/06 18:59:02 tom Exp tom $ */
d3 3
d100 1
a100 1
static char     rcsid[] = "$Header: /home/npggw/tom/src/dcm2analyze/RCS/dcm2analyze.c,v 1.23 2006/06/06 18:59:02 tom Exp tom $";
d406 1
a406 1
			(void) strcpy (order, "xzr");
d580 13
@


1.23
log
@add flags to use first instance of some header fields
@
text
@d1 1
a1 1
/* $Id: dcm2analyze.c,v 1.22 2006/01/10 18:30:31 tom Exp tom $ */
d3 3
d97 1
a97 1
static char     rcsid[] = "$Header: /home/npggw/tom/src/dcm2analyze/RCS/dcm2analyze.c,v 1.22 2006/01/10 18:30:31 tom Exp tom $";
d392 19
a410 8
		(void) strcpy (orientation, "Transverse");
		(void) strcpy (order, "xy");
		dim[0] = ddim[0];
		dim[1] = ddim[1];
		dim[2] = ddim[2];
		pix[0] = dpix[0];
		pix[1] = dpix[1];
		pix[2] = dpix[2];
d509 1
d613 1
a613 1
				for (k = dim[2]-1; k >= 0; k--) {
@


1.22
log
@correct Sagittal [yz] (0,1,0/0,0,-1)
for monkey (flag = 1)
@
text
@d1 1
a1 1
/* $Id: dcm2analyze.c,v 1.21 2005/05/18 20:04:52 tom Exp tom $ */
d3 4
d94 1
a94 1
static char     rcsid[] = "$Header: /home/npggw/tom/src/dcm2analyze/RCS/dcm2analyze.c,v 1.21 2005/05/18 20:04:52 tom Exp tom $";
d156 4
d327 4
a330 1
					ddim[1] = atoi (ptr + 4);
d334 4
a337 1
					ddim[0] = atoi (ptr + 4);
d341 6
a346 3
					ptr2 = strrchr (ptr, '\\');
					dpix[0] = atof (ptr2 + 1);
					dpix[1] = atof (ptr2 + 1);
d350 4
a353 1
					bitsperpix = atoi (ptr + 4);
@


1.21
log
@put back kludge for CT orientation
@
text
@d1 1
a1 1
/* $Id: dcm2analyze.c,v 1.20 2005/05/18 16:48:05 tom Exp tom $ */
d3 3
d90 1
a90 1
static char     rcsid[] = "$Header: /home/npggw/tom/src/dcm2analyze/RCS/dcm2analyze.c,v 1.20 2005/05/18 16:48:05 tom Exp tom $";
d578 1
a578 1
				for (k = 0; k < dim[2]; k++) {
d580 1
a580 1
					img[k][j][pln] = datum;
@


1.20
log
@since dcm_slice_reorder is now run routinely,
fix transverse orientation for MR
@
text
@d1 1
a1 1
/* $Id: dcm2analyze.c,v 1.19 2005/05/03 20:58:58 tom Exp tom $ */
d3 4
d87 1
a87 1
static char     rcsid[] = "$Header: /home/npggw/tom/src/dcm2analyze/RCS/dcm2analyze.c,v 1.19 2005/05/03 20:58:58 tom Exp tom $";
d440 5
@


1.19
log
@fix order for transverse CT images
@
text
@d1 1
a1 1
/* $Id: dcm2analyze.c,v 1.18 2005/04/19 18:54:29 tom Exp tom $ */
d3 3
d83 1
a83 1
static char     rcsid[] = "$Header: /home/npggw/tom/src/dcm2analyze/RCS/dcm2analyze.c,v 1.18 2005/04/19 18:54:29 tom Exp tom $";
d363 1
a363 1
		(void) strcpy (order, "xyr");
a435 7
/*	Kludge for CT images 

	if (strcmp (modality, "CT") == 0 && strncmp (order, "xyr", 3) == 0)
		(void) strcpy (order, "xy");
*/


@


1.18
log
@reverse coronal orientation
@
text
@d1 1
a1 1
/* $Id: dcm2analyze.c,v 1.17 2005/04/19 16:23:41 tom Exp tom $ */
d3 3
d80 1
a80 1
static char     rcsid[] = "$Header: /home/npggw/tom/src/dcm2analyze/RCS/dcm2analyze.c,v 1.17 2005/04/19 16:23:41 tom Exp tom $";
d432 8
@


1.17
log
@yet another fix for the xy/xyr orientations
@
text
@d1 1
a1 1
/* $Id: dcm2analyze.c,v 1.16 2005/04/14 17:41:10 tom Exp tom $ */
d3 3
d77 1
a77 1
static char     rcsid[] = "$Header: /home/npggw/tom/src/dcm2analyze/RCS/dcm2analyze.c,v 1.16 2005/04/14 17:41:10 tom Exp tom $";
d121 4
a124 4
	int				KVP = 0;
	int				ExposureTime = 0;
	int				TubeCurrent = 0;
	int				Exposure = 0;
d385 10
d518 13
a671 1

@


1.16
log
@revised CT keys
@
text
@d1 1
a1 1
/* $Id: dcm2analyze.c,v 1.15 2005/04/14 15:39:10 tom Exp tom $ */
d3 3
d74 1
a74 1
static char     rcsid[] = "$Header: /home/npggw/tom/src/dcm2analyze/RCS/dcm2analyze.c,v 1.15 2005/04/14 15:39:10 tom Exp tom $";
d354 10
d479 1
a479 1
		} else if (strncmp (order, "xy", 2) == 0) {
d483 1
a483 1
					img[ddim[2] - pln - 1][j][i] = datum;
d492 1
a492 1
		} else if (strncmp (order, "xyr", 3) == 0) {
d496 1
a496 1
					img[pln][j][i] = datum;
@


1.15
log
@add CT keys to ifh file
@
text
@d1 1
a1 1
/* $Id: dcm2analyze.c,v 1.14 2005/04/14 14:17:56 tom Exp tom $ */
d3 3
d71 1
a71 1
static char     rcsid[] = "$Header: /home/npggw/tom/src/dcm2analyze/RCS/dcm2analyze.c,v 1.14 2005/04/14 14:17:56 tom Exp tom $";
d628 4
a631 4
		fprintf (fifh, "exposure time	:= %i\n", ExposureTime);
		fprintf (fifh, "tube current	:= %i\n", TubeCurrent);
		fprintf (fifh, "kV	:= %i\n", KVP);
		fprintf (fifh, "mAs	:= %i\n", Exposure);
@


1.14
log
@*** empty log message ***
@
text
@d1 1
a1 1
/* $Id: dcm2analyze.c,v 1.13 2005/04/14 14:15:57 tom Exp tom $ */
d3 3
d68 1
a68 1
static char     rcsid[] = "$Header: /home/npggw/tom/src/dcm2analyze/RCS/dcm2analyze.c,v 1.13 2005/04/14 14:15:57 tom Exp tom $";
d112 5
d270 16
d625 4
d630 1
@


1.13
log
@add CT orientation
keys specific for CT and MR
@
text
@d1 1
a1 1
/* $Id: dcm2analyze.c,v 1.12 2005/04/12 15:29:34 tom Exp tom $ */
d3 4
d65 1
a65 1
static char     rcsid[] = "$Header: /home/npggw/tom/src/dcm2analyze/RCS/dcm2analyze.c,v 1.12 2005/04/12 15:29:34 tom Exp tom $";
d107 1
a107 1
	float           GantryTilt;
@


1.12
log
@read coronal images
@
text
@d1 1
a1 1
/* $Id: dcm2analyze.c,v 1.11 2004/02/13 21:48:38 tom Exp $ */
d3 3
d61 1
a61 1
static char     rcsid[] = "$Header: /home/npggw/tom/src/dcm2analyze/RCS/dcm2analyze.c,v 1.11 2004/02/13 21:48:38 tom Exp $";
d95 1
d100 4
a103 3
	char            ParameterFileName[MAXSTR];
	char            SequenceFileName[MAXSTR];
	char            SequenceDescription[MAXSTR];
d208 7
d219 1
a219 1
					(void) strcpy (ParameterFileName, ptr);
d240 1
a240 1
					(void) strcpy (SequenceFileName, ptr);
d251 1
a251 1
					(void) strcpy (SequenceDescription, ptr);
d254 4
d308 1
a308 1
	if (strncmp (SequenceDescription, "localizer", 9) == 0) {
d310 1
a310 1
		(void) strcpy (order, "xy");
d328 10
d422 10
a431 12
		if (strncmp (order, "xy", 2) == 0) {
			if (strcmp (orientation, "Transverse") == 0) {
				for (j = dim[1] - 1; j >= 0; j--) {
					for (i = 0; i < dim[0]; i++) {
						datum = tmp.s[n];
						img[ddim[2] - pln - 1][j][i] = datum;
						if (datum > global_max)
							global_max = datum;
						if (datum < global_min)
							global_min = datum;
						n++;
					}
d433 12
a444 11
			} else {
				for (j = dim[1] - 1; j >= 0; j--) {
					for (i = dim[0] - 1; i >= 0; i--) {
						datum = tmp.s[n];
						img[pln][j][i] = datum;
						if (datum > global_max)
							global_max = datum;
						if (datum < global_min)
							global_min = datum;
						n++;
					}
d448 12
d568 1
a568 1
	fprintf (fifh, "image modality	:= mri\n");
d591 7
a597 4
	fprintf (fifh, "mri parameter file name	:= %s\n", ParameterFileName);
	fprintf (fifh, "mri sequence file name	:= %s\n", SequenceFileName);
	fprintf (fifh, "mri sequence description	:= %s\n", SequenceDescription);

@


1.11
log
@Feb 2004
@
text
@d1 1
a1 1
/* $Id: dcm2analyze.c,v 1.8 2003/02/25 14:38:12 tom Exp tom $ */
d3 3
d58 1
a58 1
static char     rcsid[] = "$Header: /home/npggw/tom/src/dcm2analyze/RCS/dcm2analyze.c,v 1.8 2003/02/25 14:38:12 tom Exp tom $";
d136 2
a137 1
	if (order == NULL) return (ERROR);
d301 2
a302 1
	} else if (abs (vec1[0]) == 1 && abs (vec2[1]) == 1) {
d311 2
a312 1
	} else if (abs (vec1[0]) == 1 && abs (vec2[2]) == 1) {
d321 2
a322 1
	} else if (abs (vec1[1]) == 1 && abs (vec2[2]) == 1) {
@


1.8
log
@fix coronal bug
@
text
@d1 1
a1 1
/* $Id: dcm2analyze.c,v 1.7 2002/01/18 21:26:45 tom Exp tom $ */
d3 3
d55 1
a55 1
static char     rcsid[] = "$Header: /home/npggw/tom/src/dcm2analyze/RCS/dcm2analyze.c,v 1.7 2002/01/18 21:26:45 tom Exp tom $";
d125 2
a126 1
	(void) strncpy (program_date, ptr, 10);
d133 1
@


1.7
log
@fix Transverse conversion to orient TSE correctly
@
text
@d1 1
a1 1
/* $Id: dcm2analyze.c,v 1.6 2002/01/17 15:51:30 tom Exp tom $ */
d3 3
d39 1
d52 1
a52 1
static char     rcsid[] = "$Header: /home/npggw/tom/src/dcm2analyze/RCS/dcm2analyze.c,v 1.6 2002/01/17 15:51:30 tom Exp tom $";
d116 1
a116 1
	strncpy (version, ptr, 4);
d122 1
a122 1
	strncpy (program_date, ptr, 10);
d191 1
a191 1
					strcpy (study_date, ptr);
d198 1
a198 1
					strcpy (ParameterFileName, ptr);
d205 1
a205 1
					strcpy (model, ptr);
d212 1
a212 1
					strcpy (subject_id, ptr);
d219 1
a219 1
					strcpy (SequenceFileName, ptr);
d230 1
a230 1
					strcpy (SequenceDescription, ptr);
d272 1
a272 1
	strcpy (institution, "Washington University");
d284 2
a285 2
		strcpy (orientation, "Localizer");
		strcpy (order, "xy");
d293 2
a294 2
		strcpy (orientation, "Transverse");
		strcpy (order, "xy");
d302 2
a303 2
		strcpy (orientation, "Coronal");
		strcpy (order, "xz");
d312 2
a313 2
			strcpy (orientation, "Sagittal");
			strcpy (order, "yz");
d321 2
a322 2
			strcpy (orientation, "Sagittal");
			strcpy (order, "zy");
d360 1
a360 1
	global_min = 32000;
d416 1
a416 1
					img[k][ddim[1] - pln - 1][i] = datum;
d475 1
a475 1
	strncpy (hdr.hk.db_name, fname, 17);
d504 3
a506 3
	strncpy (hdr.hist.descrip, fname, 79);
	strcpy (hdr.hist.originator, "dcm2analy");
	strncpy (hdr.hist.patient_id, version, 4);
@


1.6
log
@read 00001.dcm filenames
@
text
@d1 1
a1 1
/* $Id: dcm2analyze.c,v 1.5 2002/01/11 16:07:18 tom Exp tom $ */
d3 3
d48 1
a48 1
static char     rcsid[] = "$Header: /home/npggw/tom/src/dcm2analyze/RCS/dcm2analyze.c,v 1.5 2002/01/11 16:07:18 tom Exp tom $";
d381 11
a391 9
			for (j = dim[1] - 1; j >= 0; j--) {
				for (i = dim[0] - 1; i >= 0; i--) {
					datum = tmp.s[n];
					img[pln][j][i] = datum;
					if (datum > global_max)
						global_max = datum;
					if (datum < global_min)
						global_min = datum;
					n++;
d393 12
d407 1
@


1.5
log
@*** empty log message ***
@
text
@d1 1
a1 1
/* $Id: dcm2analyze.c,v 1.4 2001/09/17 14:59:19 tom Exp $ */
d3 3
d45 1
a45 1
static char     rcsid[] = "$Header: /home/npggw/tom/src/dcm2analyze/RCS/dcm2analyze.c,v 1.4 2001/09/17 14:59:19 tom Exp $";
a62 1
	FILE           *flst;			 /* input list */
a72 1
	char           *list;			 /* ordered list of input files */
d95 3
a97 1
	int             flag;			/* 1 -> animal rotated from file orientation */
d127 1
a127 1
		printf ("Usage: dcm2analyze <input> <dicom_hdr> <nslices> <output> <flag>\n");
d130 4
a133 3
	list = argv[1];
	dcmhdr = argv[2];
	ddim[2] = atoi (argv[3]);
d161 2
d228 6
a233 6
					vec1[0] = ROUND(t1);
					vec1[1] = ROUND(t2);
					vec1[2] = ROUND(t3);
					vec2[0] = ROUND(t4);
					vec2[1] = ROUND(t5);
					vec2[2] = ROUND(t6);
d266 1
a266 1
	if (dsize > 512*512*2) {
d332 4
a335 5
    if ((img = s3tensor (0, dim[2] - 1, 0, dim[1] - 1, 0, dim[0] - 1)) == NULL) {
        fprintf (stderr, "ERROR [dcm2analyze]: malloc img\n");
        return (ERROR);
    }

a339 4
	if ((flst = fopen (list, "r")) == 0) {
		printf ("ERROR [dcm2analyze]: Unable to open input file %s\n", list);
		return (ERROR);
	}
d359 2
a360 8
	for (pln = 0; pln < ddim[2]; pln++) {
		if (fgets (fname, sizeof (fname), flst) == NULL) {
			printf ("ERROR [dcm2analyze]: reading list %s\n", list);
			return (ERROR);
		}
		ptr_end = strchr (fname, '\n');
		if (ptr_end != NULL)
			*ptr_end = '\0';
d403 1
a403 1
		} else if (strncmp (order, "yz", 2) == 0) {	
d416 1
a416 1
		} else if (strncmp (order, "zy", 2) == 0) {	
@


1.4
log
@*** empty log message ***
@
text
@d1 1
a1 1
/* $Id: dcm2analyze.c,v 1.3 2001/09/14 19:21:35 tom Exp tom $ */
d3 3
d30 1
d42 1
a42 1
static char     rcsid[] = "$Header: /home/npggw/tom/src/dcm2analyze/RCS/dcm2analyze.c,v 1.3 2001/09/14 19:21:35 tom Exp tom $";
d130 6
a135 6
	strcpy (ANALYZE_img, argv[4]);
	strcat (ANALYZE_img, ".img");
	strcpy (ANALYZE_hdr, argv[4]);
	strcat (ANALYZE_hdr, ".hdr");
	strcpy (IF_hdr, argv[4]);
	strcat (IF_hdr, ".ifh");
d138 12
d221 1
a221 1
					sscanf (ptr, "%f\\%f\\%f\\%f\\%f\\%f", &t1, &t2, &t3, &t4, &t5, &t6);
d258 1
a258 1
	fclose (fdcm);
d261 1
a261 1
		printf ("Image frame size too large (%d)\n", dsize);
d326 4
a329 16
	if ((img = (short ***) calloc (dim[2], sizeof (short **))) == NULL) {
		printf ("ERROR [dcm2analyze]: Could not calloc memory for ***img\n");
		return (ERROR);
	}
	for (k = 0; k < dim[2]; k++) {
		if ((img[k] = (short **) calloc (dim[1], sizeof (short *))) == NULL) {
			printf ("ERROR [dcm2analyze]: Could not calloc memory for **img\n");
			return (ERROR);
		}
		for (j = 0; j < dim[1]; j++) {
			if ((img[k][j] = (short *) calloc (dim[0], sizeof (short))) == NULL) {
				printf ("ERROR [dcm2analyze]: Could not calloc memory for *img\n");
				return (ERROR);
			}
		}
	}
d378 1
a378 1
		fclose (fdcm);
d532 3
a534 3
	fclose (fhdr);
	fclose (fimg);
	fclose (fifh);
@


1.3
log
@*** empty log message ***
@
text
@d1 1
a1 1
/* $Id: dcm2analyze.c,v 1.2 2001/09/14 18:19:42 tom Exp tom $ */
d3 3
d38 1
a38 1
static char     rcsid[] = "$Header: /home/npggw/tom/src/dcm2analyze/RCS/dcm2analyze.c,v 1.2 2001/09/14 18:19:42 tom Exp tom $";
d90 1
d119 2
a120 2
	if (argc != 5) {
		printf ("Usage: dcm2analyze <input> <dicom_hdr> <nslices> <output>\n");
d132 1
d244 1
a244 1
	if (dsize > 512*512) {
d282 19
a300 8
		strcpy (orientation, "Sagittal");
		strcpy (order, "yz");
		dim[0] = ddim[2];
		dim[1] = ddim[0];
		dim[2] = ddim[1];
		pix[0] = dpix[2];
		pix[1] = dpix[0];
		pix[2] = dpix[1];
d409 13
@


1.2
log
@*** empty log message ***
@
text
@d1 1
a1 1
/* $Id: dcm2analyze.c,v 1.1 2001/09/13 13:35:05 tom Exp tom $ */
d3 3
d35 1
a35 1
static char     rcsid[] = "$Header: /home/npggw/tom/src/dcm2analyze/RCS/dcm2analyze.c,v 1.1 2001/09/13 13:35:05 tom Exp tom $";
d239 4
@


1.1
log
@Initial revision
@
text
@d1 5
a5 2
/* $Id$ */
/* $Log$ */
d22 1
d32 1
a32 1
static char     rcsid[] = "$Header: /home/mri2analyze.c,v 1.7 2000/08/18 19:16:41 tom Exp $";
d43 5
a48 2
	U_SHORT        *DataBuffer;		 /* pixel data buffer */
	long unsigned   StartOffset_ul;
d59 1
a65 1
	char            view[6][10];
d76 1
a76 2
	long            fsize;
	long            dsize;
d78 2
a79 2
	int             bitsperpix=16;
	short           datum;
d82 3
a84 2
	int             slc;
	int             x1, y1, z1, x2, y2, z2;
d88 4
a91 7
	short           nslc;			 /* number of slices or frames in MRI */
	short           xdim = 1;		 /* image dimensions */
	short           ydim = 1;
	short           zdim;
	float           xpix = 1;		 /* pixel sizes (mm) */
	float           ypix = 1;
	float           zpix = 1;
a92 6
	strcpy (view[1], "View_FEET");
	strcpy (view[2], "View_HEAD");
	strcpy (view[3], "View_AtoP");
	strcpy (view[4], "View_LtoR");
	strcpy (view[5], "View_PtoA");
	strcpy (view[6], "View_RtoL");
d96 3
d106 2
a107 1
	order = (char *) calloc (4, sizeof (char));
a110 1
 *  ---------------------------------------------------
d118 1
a118 1
	nslc = atoi (argv[3]);
d126 3
a128 1
/*	Get DICOM header info and orientation */
d130 3
a132 2
	ptr_end = strchr(dcmhdr,'\n');
	if (ptr_end != NULL) *ptr_end = '\0';
d151 3
a153 2
					ptr_end = strchr(ptr,'\n');
					if (ptr_end != NULL) *ptr_end = '\0';
d158 3
a160 2
					ptr_end = strchr(ptr,'\n');
					if (ptr_end != NULL) *ptr_end = '\0';
d165 3
a167 2
					ptr_end = strchr(ptr,'\n');
					if (ptr_end != NULL) *ptr_end = '\0';
d172 3
a174 2
					ptr_end = strchr(ptr,'\n');
					if (ptr_end != NULL) *ptr_end = '\0';
d179 3
a181 2
					ptr_end = strchr(ptr,'\n');
					if (ptr_end != NULL) *ptr_end = '\0';
d186 1
a186 1
					zpix = atof (ptr);
d190 3
a192 2
					ptr_end = strchr(ptr,'\n');
					if (ptr_end != NULL) *ptr_end = '\0';
d197 7
a203 1
					sscanf (ptr, "%d\\%d\\%d\\%d\\%d\\%d", &x1, &y1, &z1, &x2, &y2, &z2);
d207 1
a207 1
					ydim = atoi (ptr + 4);
d211 1
a211 1
					xdim = atoi (ptr + 4);
d216 2
a217 2
					xpix = atof (ptr2 + 1);
					ypix = atof (ptr2 + 1);
d225 4
a228 1
					dsize = atoi (ptr + 4);
d236 1
a236 2
	zdim = nslc;
	offset = fsize - dsize;
d238 3
a240 3
	printf ("x = %d (%f mm)  y = %d (%f mm)  z = %d (%f mm)\n",
		xdim, xpix, ydim, ypix, zdim, zpix);
	printf ("order = %d %d %d %d %d %d\n", x1, y1, z1, x2, y2, z2);
d242 38
a279 2
	if ((DataBuffer = (U_SHORT *) malloc (xdim * ydim * 2)) == 0) {
		printf ("ERROR [dcm2analyze]: Could not malloc memory for DataBuffer\n");
d282 7
a288 2
	if (NULL == (img = (short ***) malloc ((short) (zdim * sizeof (short **))))) {
		printf ("ERROR [dcm2analyze]: Could not malloc memory for ***img\n");
d291 3
a293 3
	for (i = 0; i < zdim; i++) {
		if (NULL == (img[i] = (short **) malloc ((short) (ydim * sizeof (short *))))) {
			printf ("ERROR [dcm2analyze]: Could not malloc memory for **img\n");
d296 3
a298 3
		for (j = 0; j < ydim; j++) {
			if (NULL == (img[i][j] = (short *) malloc ((short) (xdim * sizeof (short))))) {
				printf ("ERROR [dcm2analyze]: Could not malloc memory for *img\n");
d304 3
a306 1
/*	Open other files */
d327 3
a329 1
/*	Loop for all input images */
d331 1
a331 1
	for (slc = 1; slc <= nslc; slc++) {
d336 3
a338 1
		strcpy (fname, ".MR..2.1.2001.9.12.9.21.14.546000.3996885.IMA");
d343 8
a350 2
		fseek (fdcm, offset, SEEK_SET);
		fread (DataBuffer, dsize, 1, fdcm);
d352 1
d354 6
a359 8
		strcpy (order, "LAF");
		if (strncmp (order, "LAF", 3) == 0) {	/* View_FEET */
			n = 0;
			k = slc - 1;
			for (j = ydim - 1; j >= 0; j--) {
				for (i = xdim - 1; i >= 0; i--) {
					datum = DataBuffer[n];
					img[k][j][i] = datum;
d368 5
a372 7
		} else if (strncmp (order, "RAH", 3) == 0) {	/* View_HEAD */
			n = 0;
			k = slc;
			for (j = ydim - 1; j >= 0; j--) {
				for (i = 0; i < xdim; i++) {
					datum = DataBuffer[n];
					img[zdim - k][j][i] = datum;
d381 5
a385 7
		} else if (strncmp (order, "RHA", 3) == 0) {	/* View_AtoP */
			n = 0;
			j = slc;
			for (k = zdim - 1; k >= 0; k--) {
				for (i = 0; i < xdim; i++) {
					datum = DataBuffer[n];
					img[k][ydim - j][i] = datum;
a393 45
		} else if (strncmp (order, "RHP", 3) == 0) {	/* ? View_AtoP ? */
			n = 0;
			j = slc - 1;
			for (k = zdim - 1; k >= 0; k--) {
				for (i = 0; i < xdim; i++) {
					datum = DataBuffer[n];
					img[k][j][i] = datum;
					if (datum > global_max)
						global_max = datum;
					if (datum < global_min)
						global_min = datum;
					n++;
				}
			}

		} else if (strncmp (order, "RFA", 3) == 0) {	/* View_PtoA */
			n = 0;
			j = slc - 1;
			for (k = zdim - 1; k >= 0; k--) {
				for (i = xdim - 1; i >= 0; i--) {
					datum = DataBuffer[n];
					img[k][j][i] = datum;
					if (datum > global_max)
						global_max = datum;
					if (datum < global_min)
						global_min = datum;
					n++;
				}
			}

		} else if (strncmp (order, "AHR", 3) == 0) {	/* View_LtoR */
			n = 0;
			i = slc - 1;
			for (k = zdim - 1; k >= 0; k--) {
				for (j = ydim - 1; j >= 0; j--) {
					datum = DataBuffer[n];
					img[k][j][i] = datum;
					if (datum > global_max)
						global_max = datum;
					if (datum < global_min)
						global_min = datum;
					n++;
				}
			}

d395 1
a395 1
			printf ("ERROR [dcm2analyze]: Incompatible Order:  %s\n", order);
d405 3
a407 3
	for (k = 0; k < zdim; k++) {
		for (j = 0; j < ydim; j++) {
			if ((fwrite (img[k][j], sizeof (short), xdim, fimg)) != xdim) {
d423 3
a425 3
	hdr.dime.dim[1] = xdim;
	hdr.dime.dim[2] = ydim;
	hdr.dime.dim[3] = zdim;
d436 3
a438 3
	hdr.dime.pixdim[1] = xpix;
	hdr.dime.pixdim[2] = ypix;
	hdr.dime.pixdim[3] = zpix;
d465 1
d470 1
a470 1
	fprintf (fifh, "subject ID := %s\n", subject_id);
d476 6
a481 6
	fprintf (fifh, "matrix size [1]	:= %d\n", xdim);
	fprintf (fifh, "matrix size [2]	:= %d\n", ydim);
	fprintf (fifh, "matrix size [3]	:= %d\n", zdim);
	fprintf (fifh, "scaling factor (mm/pixel) [1]	:= %f\n", xpix);
	fprintf (fifh, "scaling factor (mm/pixel) [2]	:= %f\n", ypix);
	fprintf (fifh, "scaling factor (mm/pixel) [3]	:= %f\n", zpix);
d489 1
a489 1
/* free all buffers and exit */
a494 1
	free (DataBuffer);
@
