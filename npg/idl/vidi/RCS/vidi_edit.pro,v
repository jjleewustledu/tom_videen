head	2.3;
access;
symbols;
locks; strict;
comment	@# @;


2.3
date	2009.05.26.15.06.53;	author tom;	state Exp;
branches;
next	2.2;

2.2
date	2009.01.05.18.58.28;	author tom;	state Exp;
branches;
next	2.1;

2.1
date	2006.03.10.16.39.45;	author tom;	state Exp;
branches;
next	2.0;

2.0
date	2004.02.03.16.33.49;	author tom;	state Exp;
branches;
next	1.22;

1.22
date	2004.02.03.16.31.10;	author tom;	state Exp;
branches;
next	1.21;

1.21
date	2003.05.13.13.13.13;	author tom;	state Exp;
branches;
next	1.20;

1.20
date	2003.05.06.20.21.47;	author tom;	state Exp;
branches;
next	1.19;

1.19
date	2002.09.17.21.27.03;	author tom;	state Exp;
branches;
next	1.18;

1.18
date	2002.09.17.14.43.49;	author tom;	state Exp;
branches;
next	1.17;

1.17
date	2002.02.11.20.28.14;	author tom;	state Exp;
branches;
next	1.16;

1.16
date	2002.02.07.16.00.01;	author tom;	state Exp;
branches;
next	1.15;

1.15
date	2002.01.28.19.28.07;	author tom;	state Exp;
branches;
next	1.14;

1.14
date	2002.01.25.18.19.00;	author tom;	state Exp;
branches;
next	1.13;

1.13
date	2001.08.17.16.39.08;	author tom;	state Exp;
branches;
next	1.12;

1.12
date	2000.08.11.18.19.58;	author tom;	state Exp;
branches;
next	1.11;

1.11
date	2000.08.11.15.19.32;	author tom;	state Exp;
branches;
next	1.10;

1.10
date	2000.08.11.15.17.26;	author tom;	state Exp;
branches;
next	1.9;

1.9
date	2000.04.21.20.32.05;	author tom;	state Exp;
branches;
next	1.8;

1.8
date	2000.04.18.20.51.03;	author tom;	state Exp;
branches;
next	1.7;

1.7
date	99.07.01.17.21.29;	author tom;	state Exp;
branches;
next	1.6;

1.6
date	99.03.17.15.43.45;	author tom;	state Exp;
branches;
next	1.5;

1.5
date	99.03.17.15.33.25;	author tom;	state Exp;
branches;
next	1.4;

1.4
date	99.03.09.15.46.40;	author tom;	state Exp;
branches;
next	1.3;

1.3
date	99.02.12.17.13.27;	author tom;	state Exp;
branches;
next	1.2;

1.2
date	99.02.05.17.17.30;	author tom;	state Exp;
branches;
next	1.1;

1.1
date	99.02.04.18.32.04;	author tom;	state Exp;
branches;
next	;


desc
@@


2.3
log
@*** empty log message ***
@
text
@;+
; NAME:
;	VIDI_EDIT
; PURPOSE:
;	Widget to edit an image (by setting pixels in ROIs to 0)
; CATEGORY:
;	Image processing.
; CALLING SEQUENCE:
;	Result = VIDI_EDIT(uv,i,zoom)
; INPUTS:
;	Uv  = array of image structures
;	I = index to array
;	Zoom = zoom factor 
; OUTPUTS:
;	Modified image.
; RESTRICTIONS:
;	This is a MODAL widget.  No other widget applications will be
;	responsive while this widget is in use.
; MODIFICATION HISTORY:
;	Tom Videen, Feb 1999.
;-

PRO VIDI_EDIT_DRAW, s, i, xdim, ydim, xzoom, yzoom, FILL= fill
; Draw outline (or fill if FILL is set) of ROI
;	or the ith segment of a polygon if i < 0.
; Image coordinates are tranposed to screen coordinates before drawing.
; Fill is used to restore.
; Parameters:
;	s = state structure
;	i = segment number
   
   COMMON VIDI

   n = (*s.roi).num
   IF (n LT 1) THEN RETURN
   
   WSET, s.win
   DEVICE, SET_GRAPHICS_FUNCTION=3 ; source
   
   xsave = !x.s & ysave = !y.s  ; Set scaling to pixel coords
   !x.s = [0, xzoom/float(!d.x_size)]
   !y.s = [0, yzoom/float(!d.y_size)]
   
   IF (n GE 2) THEN BEGIN       ; Draw
      xy = (*(*s.roi).loc)[*,0:n-1]
      ;xy = VOI_TRANSPOSE(xy, ydim, /DISPLAY)
      xy = VOI_TRANSPOSE(xy, ydim)
      IF KEYWORD_SET(FILL) THEN polyfill, xy, color=label $
      ELSE IF (i GE 0) THEN plots,xy[*, i:i+1], color=label $ ; One segment
      ELSE plots, xy, color=label ; All of it
   ENDIF    
   !x.s = xsave & !y.s = ysave  ; Restore scaling
END   

  
PRO VIDI_EDIT_EVENT, ev, s, xdim, ydim, xzoom, yzoom
; Called from the VIDI_EDIT event loop.
; Parameters:
;	ev = event structure
;	s = state structure
   
   s.button = s.button OR ev.press XOR ev.release ; New button state   
   n = (*s.roi).num
   x = (ev.x - s.offset[0]) / xzoom ; Screen coordinates (0,0 is lower left)
   y = (ev.y - s.offset[1]) / yzoom
   ;xy = [fix(x)-1,fix(y)-1]
   xy = [fix(x),fix(y)]
   xy = VOI_TRANSPOSE(xy, ydim) ; Image coordinates (0,0 is upper left)
   WIDGET_CONTROL, s.pos_w, SET_VALUE=string(xy+1, format='("Cursor Position: ",i,", ",i)')

   IF (xy[0] LT 0) OR (xy[1] LT 0) OR $ ; Check if cursor is within image
      (xy[0] GT xdim) OR (xy[1] GT ydim) THEN RETURN
   IF ev.press NE 0 THEN s.drag = [x,y] ; Start of drag operation
   
   IF (s.button EQ 1) THEN BEGIN ; Create
      s.clear = 0
      IF NOT ptr_valid((*s.roi).loc) THEN BEGIN
         (*s.roi).type = 2
         (*s.roi).num = 0
         (*s.roi).loc = ptr_new(lonarr(2,100))
         n = 0
      ENDIF
      IF (n GT 0) THEN $        ; Check for duplicates
         IF(xy[0] EQ (*(*s.roi).loc)[0,n-1] AND xy[1] EQ (*(*s.roi).loc)[1,n-1]) THEN RETURN
      IF ((n+1) GE N_ELEMENTS(*(*s.roi).loc)/2) THEN BEGIN ; Extend array
         new = ptr_new(lonarr(2,2*(n+1)))
         (*new)[*,0:n-1] = (*(*s.roi).loc)[*,0:n-1]
         ptr_free, (*s.roi).loc
         (*s.roi).loc = new
      ENDIF
      IF (n EQ 0) THEN BEGIN 
         (*(*s.roi).loc)[*,n] = xy ; then add the point to the trace
         n = n + 1
         (*s.roi).num = n    
         IF ((*s.roi).type EQ 2 AND n GE 2) THEN VIDI_EDIT_DRAW, s, n-2, xdim, ydim, xzoom, yzoom
      ENDIF ELSE BEGIN          ; make certain trace is 4-connected
         lastx = (*(*s.roi).loc)[0,n-1]
         lasty = (*(*s.roi).loc)[1,n-1]
         dx = abs(xy[0]-lastx)
         dy = abs(xy[1]-lasty)
         IF (dx GT dy) THEN BEGIN
            dir = 0
            IF (dy GT 0) THEN slope = dx/dy ELSE slope = 1
         ENDIF ELSE BEGIN
            dir = 1
            IF (dx GT 0) THEN slope = dy/dx ELSE slope = 1
         ENDELSE
         WHILE (xy[0] NE lastx OR xy[1] NE lasty) DO BEGIN
            IF ((n+1) GE N_ELEMENTS(*(*s.roi).loc)/2) THEN BEGIN ; Extend array
               new = ptr_new(lonarr(2,2*(n+1)))
               (*new)[*,0:n-1] = (*(*s.roi).loc)[*,0:n-1]
               ptr_free, (*s.roi).loc
               (*s.roi).loc = new
            ENDIF
            IF (dir EQ 0) THEN BEGIN
               IF (xy[1] EQ lasty) THEN slope = 1 $
               ELSE slope = abs(xy[0]-lastx)/abs(xy[1]-lasty)
               FOR k=1,slope DO BEGIN
                  IF ((n+1) GE N_ELEMENTS(*(*s.roi).loc)/2) THEN BEGIN ; Extend array
                     new = ptr_new(lonarr(2,2*(n+1)))
                     (*new)[*,0:n-1] = (*(*s.roi).loc)[*,0:n-1]
                     ptr_free, (*s.roi).loc
                     (*s.roi).loc = new
                  ENDIF
                  IF (xy[0] NE lastx) THEN BEGIN
                     dx = xy[0]-lastx
                     nextx = lastx + dx/abs(dx)
                     (*(*s.roi).loc)[0,n] = nextx
                     (*(*s.roi).loc)[1,n] = lasty
                     lastx = nextx
                     n = n + 1
                     (*s.roi).num = n
                     IF ((*s.roi).type EQ 2 AND n GE 2) THEN VIDI_EDIT_DRAW, s, n-2, xdim, ydim, xzoom, yzoom
                  ENDIF
               ENDFOR
               IF (xy[1] NE lasty) THEN BEGIN
                  dy = xy[1]-lasty
                  nexty = lasty + dy/abs(dy)
                  (*(*s.roi).loc)[0,n] = lastx
                  (*(*s.roi).loc)[1,n] = nexty
                  lasty = nexty
                  n = n + 1
                  (*s.roi).num = n
                  IF ((*s.roi).type EQ 2 AND n GE 2) THEN VIDI_EDIT_DRAW, s, n-2, xdim, ydim, xzoom, yzoom
               ENDIF
            ENDIF ELSE BEGIN
               IF (xy[0] EQ lastx) THEN slope = 1 $
               ELSE slope = abs(xy[1]-lasty)/abs(xy[0]-lastx)
               FOR k=1,slope DO BEGIN
                  IF ((n+1) GE N_ELEMENTS(*(*s.roi).loc)/2) THEN BEGIN ; Extend array
                     new = ptr_new(lonarr(2,2*(n+1)))
                     (*new)[*,0:n-1] = (*(*s.roi).loc)[*,0:n-1]
                     ptr_free, (*s.roi).loc
                     (*s.roi).loc = new
                  ENDIF
                  IF (xy[1] NE lasty) THEN BEGIN
                     dy = xy[1]-lasty
                     nexty = lasty + dy/abs(dy)
                     (*(*s.roi).loc)[0,n] = lastx
                     (*(*s.roi).loc)[1,n] = nexty
                     lasty = nexty
                     n = n + 1
                     (*s.roi).num = n
                     IF ((*s.roi).type EQ 2 AND n GE 2) THEN VIDI_EDIT_DRAW, s, n-2, xdim, ydim, xzoom, yzoom
                  ENDIF
               ENDFOR
               IF (xy[0] NE lastx) THEN BEGIN
                  dx = xy[0]-lastx
                  nextx = lastx + dx/abs(dx)
                  (*(*s.roi).loc)[0,n] = nextx
                  (*(*s.roi).loc)[1,n] = lasty
                  lastx = nextx
                  n = n + 1
                  (*s.roi).num = n
                  IF ((*s.roi).type EQ 2 AND n GE 2) THEN VIDI_EDIT_DRAW, s, n-2, xdim, ydim, xzoom, yzoom
               ENDIF
            ENDELSE
         ENDWHILE 
      ENDELSE 
   ENDIF 
   RETURN
END   
   

PRO VIDI_EDIT, uv, i, zoom
   COMMON VIDI
   COMMON IMAGE_UTILS
   
   draw = uv.wid.win[i]
   i = i < 1                    ; if img[2] is selected, edit img[1] in win[2]
   img = uv.img[i]
   base = WIDGET_BASE(title='Image Edit', group_leader=uv.wid.base, /COLUMN)   
   
   base1 =  WIDGET_BASE(base,/ROW)
   val = CW_FIELD(base1, title='Fill Value', value=uv.wid.editval, $
                  xsize=8, /INTEGER, /RETURN_EVENTS)
   fill = WIDGET_BUTTON(base1, value='Fill')
   restore = WIDGET_BUTTON(base1, value='Restore')
   up = WIDGET_BUTTON(base1, value='<- Up  ')
   down = WIDGET_BUTTON(base1, value=' Down ->')  
   exit = WIDGET_BUTTON(base1, value='Exit')
   
   base2 = WIDGET_BASE(base,/ROW)
   replace = WIDGET_BUTTON(base2, value='Replace (this plane) Only If')
   rsign = CW_BGROUP(base2, ['>=','=','<='],/ROW, /EXCLUSIVE, set_value=uv.wid.rsign)
   rthresh = CW_FIELD(base2, title=' ', value=uv.wid.rthresh, $
                      xsize=8, /INTEGER, /RETURN_EVENTS)

   base3 = WIDGET_BASE(base,/ROW)
   rplanes = CW_BGROUP(base3, ['Current','All Above','All Below','All', $
                               'Slab Above', 'Slab Below', 'Slab Up&Down'], $
                       LABEL_LEFT='Remove from Planes:', /ROW, /EXCLUSIVE, set_value=uv.wid.rplanes)
   
   base4 = WIDGET_BASE(base,/ROW)
   rmode = CW_BGROUP(base4, ['Inside','Outside','Erase'], $
                     LABEL_LEFT='Removal Area:', /ROW, /EXCLUSIVE, set_value=uv.wid.rmode)
   rerase = CW_FIELD(base4, title='Eraser Size', value=uv.wid.rerase, $
                     xsize=4, /INTEGER, /RETURN_EVENTS)
   rslab = CW_FIELD(base4, title='Slab Planes', value=uv.wid.rslab, $
                    xsize=4, /INTEGER, /RETURN_EVENTS)

   pos_w = WIDGET_TEXT(base, YSIZE=1, XSIZE=45, /FRAME, $
                       VALUE='Cursor Position:    0,    0')
   msg = widget_text(base, YSIZE=3)
   
   voi = ptr_new({VOI})
   (*voi).id = 'VOI'
   roi = VOI_APPEND(voi)        ; position pointer to free element at end of list
   WIDGET_CONTROL, draw, GET_VALUE=win
   WSET, win
   
   image_size = [!d.x_size, !d.y_size] / [zoom, zoom]
   offset = [0,0]
   p  = offset + image_size /2
   TVCRS, p[0], p[1], /DEVICE
   WINDOW, /PIXMAP, /FREE, xs = !d.x_size, ys=!d.y_size ; Save window
   backing = !d.window
   DEVICE, copy = [0,0, !d.x_size, !d.y_size, 0, 0, win]
   
   s = {EDIT_STATE, $           ; Structure containing state
        base: base, $           ; Main base widget
        pos_w : pos_w, $        ; Position text widget
        msg : msg, $            ; Message window
        win:  win, $            ; draw widget window #
        button: 0, $            ; button state
        drag: [0,0], $          ; Beginning of drag motion
        clear: 1, $             ; 1=last roi has been erased
        image_size : long(image_size), $ ; Image array size
        offset: fix(offset), $  ; offset of array within window
        zoom : zoom, $          ; zoom factor
        img : img, $            ; pointer to image data
        voi : voi, $            ; linked list
        roi : roi, $            ; pointer to current ROI in linked list
        last : ptr_new() $      ; pointer to last ROI entered in linked list
       }
   
   WIDGET_CONTROL, base, /REALIZE, xoffset=0, yoffset=0
   WSHOW, win
   draw_msg = string(format='(A,/,A,/,A)', $
                     "Press left mouse button to trace or select sequential boundary points.", $
                     "Then use Fill to complete or Restore to cancel current outline.", $
                     "Restore will restore all points within the last tracing.")
   erase_msg = string(format='(A,/,A,/,A)', $
                      "Press left mouse button to erase pixels.", $
                      "Erasures are limited to current plane.", "Restore is inactivated!")
   IF (uv.wid.rmode EQ 2) THEN widget_control, s.msg, set_value=erase_msg $
   ELSE widget_control, s.msg, set_value=draw_msg

   CASE orient OF
      0: BEGIN
         x0 = 0
         y0 = 1
         fp = img.fp
         lp = img.lp
      END
      1: BEGIN
         x0 = 0
         y0 = 2
         fp = 1
         lp = img.dim[1]
      END
      2: BEGIN
         x0 = 1
         y0 = 2
         fp = 1
         lp = img.dim[0]
      END
   ENDCASE
   slice = img.p - img.fp
   frame = img.f - img.ff
   xdim = img.dim[x0]
   ydim = img.dim[y0]
   xzoom = float (zoom)
   yzoom = float (zoom)
   IF (img.pdim[y0] GT img.pdim[x0]) THEN BEGIN 
      yzoom = (img.pdim[y0])/(img.pdim[x0]) * zoom
   ENDIF ELSE IF (img.pdim[y0] LT img.pdim[x0]) THEN BEGIN 
      xzoom = (img.pdim[x0])/(img.pdim[y0]) * zoom
   ENDIF
   image0 = reform((*img.data)[*,*,*,frame])
   erase = 0

   WHILE 1 DO BEGIN             ; Internal event loop   
      CASE uv.wid.rplanes OF
         0: BEGIN
            pln1 = img.p
            pln2 = img.p
         ENDCASE
         1: BEGIN
            pln1 = fp
            pln2 = img.p
         ENDCASE
         2: BEGIN
            pln1 = img.p
            pln2 = lp
         ENDCASE
         3: BEGIN
            pln1 = fp 
            pln2 = lp
         ENDCASE
         4: BEGIN
            pln1 = img.p-uv.wid.rslab
            pln2 = img.p
            IF (pln1 LT fp) THEN pln1 = fp
         ENDCASE
         5: BEGIN
            pln1 = img.p
            pln2 = img.p+uv.wid.rslab
            IF (pln2 GT lp) THEN pln2 = lp
         ENDCASE
         6: BEGIN
            pln1 = img.p-uv.wid.rslab
            pln2 = img.p+uv.wid.rslab
            IF (pln1 LT fp) THEN pln1 = fp
            IF (pln2 GT lp) THEN pln2 = lp
         ENDCASE
      ENDCASE
      CASE orient OF
         0: image = reform((*img.data)[*,*,slice,frame])
         1: image = reform((*img.data)[*,slice,*,frame])
         2: image = reform((*img.data)[slice,*,*,frame])
      ENDCASE

      ev = WIDGET_EVENT([base, draw])
      n = (*s.roi).num
      IF ev.id EQ draw THEN BEGIN
         IF (uv.wid.rmode EQ 2) THEN BEGIN
            d0 = -(uv.wid.rerase)/2 ; eraser dimensions
            d1 = d0 + uv.wid.rerase-1
            IF (ev.press EQ 1) THEN erase = 1 $
            ELSE IF (ev.release EQ 1) THEN erase = 0
            IF (erase EQ 1) THEN BEGIN
               xp = (ev.x - s.offset[0]) / xzoom + 1 ; pixel coordinate
               yp = ydim - (ev.y - s.offset[1]) / yzoom
               xmin = 0 > xp+d0
               ymin = 0 > yp+d0
               xmax = xdim-1 < xp+d1
               ymax = ydim-1 < yp+d1
               image[xmin:xmax,ymin:ymax] = uv.wid.editval
               CASE orient OF
                  0: (*img.data)[*,*,slice,frame] = image
                  1: (*img.data)[*,slice,*,frame] = image
                  2: (*img.data)[slice,*,*,frame] = image
               ENDCASE
               VIDI_DISPLAY, uv
            ENDIF
         ENDIF ELSE BEGIN
            VIDI_EDIT_EVENT, ev, s, xdim, ydim, xzoom, yzoom
         ENDELSE
      ENDIF ELSE IF ev.id EQ val THEN uv.wid.editval = ev.value $
      ELSE CASE ev.id of 
         
         fill:  BEGIN   
            widget_control, /hourglass
            n = (*s.roi).num
            IF (n GE 2 AND s.clear EQ 0) THEN BEGIN 
               xy = (*(*s.roi).loc)[*,0:n-1]
               pts = polyfillv(xy[0,*],xy[1,*], xdim, ydim)
               IF ((size(pts))[0] GT 0) THEN BEGIN
                  IF (uv.wid.rmode EQ 1) THEN BEGIN
                     timage = image
                     xval = max(timage)+1
                     if (xval EQ -32768) then xval = 32767
                     timage[pts] = xval
                     pts = where (timage LT xval)
                  ENDIF
                  IF (pln1 EQ pln2) THEN msg = "Fill applied in plane "+strtrim(string(pln1),2) $
                  ELSE msg = "Fill applied in planes "+strtrim(string(pln1),2)+" to "+strtrim(string(pln2),2)
                  FOR pln=pln1-1,pln2-1 DO BEGIN
                     CASE orient OF
                        0: image = reform((*img.data)[*,*,pln,frame])
                        1: image = reform((*img.data)[*,pln,*,frame])
                        2: image = reform((*img.data)[pln,*,*,frame])
                     ENDCASE
                     IF ((size(pts))[0] GT 0) THEN image[pts] = uv.wid.editval
                     CASE orient OF
                        0: (*img.data)[*,*,pln,frame] = image
                        1: (*img.data)[*,pln,*,frame] = image
                        2: (*img.data)[pln,*,*,frame] = image
                     ENDCASE
                  ENDFOR
               ENDIF ELSE msg = "No pixels filled"
               VIDI_DISPLAY, uv
               s.clear = 1
               (*s.roi).num = 0  
            ENDIF ELSE msg = "No defined region to fill"
            widget_control, s.msg, set_value=msg
         ENDCASE
         
         restore:  BEGIN 
            n = (*s.roi).num
            IF (s.clear GT 0 AND n GT 0) THEN VIDI_EDIT_DRAW, s, -1, xdim, ydim, xzoom, yzoom, /fill
            msg = "Nothing to Restore"
            IF ((size(pts))[0] GT 0) THEN BEGIN
               IF (pln1 EQ pln2) THEN msg = "Restored last edit of plane "+strtrim(string(pln1),2) $
               ELSE msg = "Restored last edit of planes "+strtrim(string(pln1),2)+" to "+strtrim(string(pln2),2)
               FOR pln=pln1-1,pln2-1 DO BEGIN
                  CASE orient OF
                     0: image = reform((*img.data)[*,*,pln,frame])
                     1: image = reform((*img.data)[*,pln,*,frame])
                     2: image = reform((*img.data)[pln,*,*,frame])
                  ENDCASE
                  CASE orient OF
                     0: timage = reform(image0[*,*,pln])
                     1: timage = reform(image0[*,pln,*])
                     2: timage = reform(image0[pln,*,*])
                  ENDCASE
                  image[pts] = timage[pts]
                  CASE orient OF
                     0: (*img.data)[*,*,pln,frame] = image
                     1: (*img.data)[*,pln,*,frame] = image
                     2: (*img.data)[pln,*,*,frame] = image
                  ENDCASE
               ENDFOR
            ENDIF
            widget_control, s.msg, set_value=msg
            s.clear = 1
            (*s.roi).num = 0 
            VIDI_DISPLAY, uv
         ENDCASE
         
         up: BEGIN
            IF (img.p GT fp) THEN BEGIN
               img.p = img.p-1
               slice = img.p - img.fp
               uv.img[0].p = img.p
               uv.img[1].p = img.p
               widget_control, uv.wid.slider, set_value=img.p
               VIDI_DISPLAY, uv
            ENDIF 
         ENDCASE

         down: BEGIN
            IF (img.p LT lp) THEN BEGIN
               img.p = img.p+1
               slice = img.p - img.fp
               uv.img[0].p = img.p
               uv.img[1].p = img.p
               widget_control, uv.wid.slider, set_value=img.p
               VIDI_DISPLAY, uv
            ENDIF 
         ENDCASE 

         exit:  BEGIN
            WIDGET_CONTROL, base, /DESTROY
            RETURN
         ENDCASE 
         
         replace:  BEGIN   
            n = (*s.roi).num
            IF (n GE 2 AND s.clear EQ 0) THEN BEGIN 
               xy = (*(*s.roi).loc)[*,0:n-1]
               pts = polyfillv(xy[0,*],xy[1,*], xdim, ydim)
               IF ((size(pts))[0] GT 0) THEN BEGIN 
                  CASE uv.wid.rsign OF
                     0: ix = where (image[pts] GE uv.wid.rthresh)
                     1: ix = where (image[pts] EQ uv.wid.rthresh)
                     2: ix = where (image[pts] LE uv.wid.rthresh)
                  ENDCASE 
                  IF ((size(ix))[0] GT 0) THEN BEGIN 
                     npts = (size(ix))[1]
                     pts = pts[ix]
                     image[pts] = uv.wid.editval
                     msg = "Replaced "+strtrim(string(npts),2)+" pixels"
                  ENDIF ELSE msg = "No points replaced"
               ENDIF 
               CASE orient OF
                  0: (*img.data)[*,*,slice,frame] = image
                  1: (*img.data)[*,slice,*,frame] = image
                  2: (*img.data)[slice,*,*,frame] = image
               ENDCASE
               pln1 = img.p
               pln2 = img.p
               VIDI_DISPLAY, uv
               s.clear = 1
               (*s.roi).num = 0  
            ENDIF ELSE msg = "No defined region to Fill"
            widget_control, s.msg, set_value=msg
         ENDCASE
         
         rsign: uv.wid.rsign = ev.value

         rthresh: uv.wid.rthresh = ev.value

         rplanes: uv.wid.rplanes = ev.value

         rmode: BEGIN
            uv.wid.rmode = ev.value
            IF (uv.wid.rmode EQ 2) THEN widget_control, s.msg, set_value=erase_msg $
            ELSE widget_control, s.msg, set_value=draw_msg
         ENDCASE

         rerase: uv.wid.rerase = ev.value

         rslab: uv.wid.rslab = ev.value
         
         ELSE:
      ENDCASE   
   ENDWHILE
END   
@


2.2
log
@fix Outside mask for byte arrays where max val may be greater than max allowed
@
text
@d383 1
@


2.1
log
@make edit boundaries more precise
@
text
@a256 1
   xval = max(*img.data) + 1
d382 1
d384 1
a384 1
                     pts = where (timage NE xval)
d394 1
a394 1
                     image[pts] = uv.wid.editval
@


2.0
log
@03 Feb 2004
@
text
@d46 2
a47 1
      xy = VOI_TRANSPOSE(xy, ydim, /DISPLAY)
d66 1
@


1.22
log
@3 Feb 2004
@
text
@@


1.21
log
@change edit color to 'label'
@
text
@@


1.20
log
@fix atlas display on 24-bit color
@
text
@d32 2
a38 2
   col = 1
   WHILE col LT !d.table_size DO col = col + col
d47 3
a49 3
      IF KEYWORD_SET(FILL) THEN polyfill, xy, color=col $
      ELSE IF (i GE 0) THEN plots,xy[*, i:i+1], color=col $ ; One segment
      ELSE plots, xy, color=col ; All of it
@


1.19
log
@fix bug in slab removal
@
text
@a364 1
               IF (atlas[0] OR atlas[1]) THEN VIDI_ATLAS, uv
a400 1
               IF (atlas[0] OR atlas[1]) THEN VIDI_ATLAS, uv
a436 1
            IF (atlas[0] OR atlas[1]) THEN VIDI_ATLAS, uv
a446 1
               IF (atlas[0] OR atlas[1]) THEN VIDI_ATLAS, uv
a457 1
               IF (atlas[0] OR atlas[1]) THEN VIDI_ATLAS, uv
a491 1
               IF (atlas[0] OR atlas[1]) THEN VIDI_ATLAS, uv
@


1.18
log
@fix erase bugs
@
text
@a300 1
   newslab = 1
d303 4
a306 34
      IF (newslab EQ 1) THEN BEGIN
         CASE uv.wid.rplanes OF
            0: BEGIN
               pln1 = img.p
               pln2 = img.p
            ENDCASE
            1: BEGIN
               pln1 = fp
               pln2 = img.p
            ENDCASE
            2: BEGIN
               pln1 = img.p
               pln2 = lp
            ENDCASE
            3: BEGIN
               pln1 = fp 
               pln2 = lp
            ENDCASE
            4: BEGIN
               pln1 = img.p-uv.wid.rslab
               pln2 = img.p
               IF (pln1 LT fp) THEN pln1 = fp
            ENDCASE
            5: BEGIN
               pln1 = img.p
               pln2 = img.p+uv.wid.rslab
               IF (pln2 GT lp) THEN pln2 = lp
            ENDCASE
            6: BEGIN
               pln1 = img.p-uv.wid.rslab
               pln2 = img.p+uv.wid.rslab
               IF (pln1 LT fp) THEN pln1 = fp
               IF (pln2 GT lp) THEN pln2 = lp
            ENDCASE
d308 29
a336 2
         newslab = 0
      ENDIF
d508 1
a508 4
         rplanes: BEGIN
            uv.wid.rplanes = ev.value
            newslab = 1
         ENDCASE
d518 1
a518 4
         rslab: BEGIN
            uv.wid.rslab = ev.value
            newslab = 1
         ENDCASE
@


1.17
log
@draw atlas
@
text
@a267 1
   frame = img.f - img.ff
d288 11
d301 1
d304 37
a340 1
      slice = img.p - img.fp
a345 10
      xdim = img.dim[x0]
      ydim = img.dim[y0]
      psize = xdim*ydim
      xzoom = float (zoom)
      yzoom = float (zoom)
      IF (img.pdim[y0] GT img.pdim[x0]) THEN BEGIN 
         yzoom = (img.pdim[y0])/(img.pdim[x0]) * zoom
      ENDIF ELSE IF (img.pdim[y0] LT img.pdim[x0]) THEN BEGIN 
         xzoom = (img.pdim[x0])/(img.pdim[y0]) * zoom
      ENDIF
d351 17
a367 19
            pix0 = -(uv.wid.rerase)/2
            pix1 = pix0 + uv.wid.rerase-1
            IF (ev.press NE 0) THEN erase = 1 $
            ELSE IF (ev.release NE 0) THEN erase = 0
            IF (erase NE 0) THEN BEGIN
               xp = (ev.x - s.offset[0]) / xzoom
               yp = (ev.y - s.offset[1]) / yzoom
               FOR m=pix0,pix1 DO BEGIN
                  xt = fix(xp+m)
                  IF (xt GE 0 AND xt LT xdim) THEN BEGIN
                     FOR n=pix0,pix1 DO BEGIN
                        yt = ydim-fix(yp+n)
                        IF (yt GE 0 AND yt LT ydim) THEN BEGIN
                           loc = xt + yt*xdim + slice*psize
                           (*img.data)[loc] = uv.wid.editval
                        ENDIF
                     ENDFOR
                  ENDIF
               ENDFOR
d369 1
a369 1
               VIDI_ATLAS, uv
a388 34
                  CASE uv.wid.rplanes OF
                     0: BEGIN
                        pln1 = img.p
                        pln2 = img.p
                     ENDCASE
                     1: BEGIN
                        pln1 = fp
                        pln2 = img.p
                     ENDCASE
                     2: BEGIN
                        pln1 = img.p
                        pln2 = lp
                     ENDCASE
                     3: BEGIN
                        pln1 = fp 
                        pln2 = lp
                     ENDCASE
                     4: BEGIN
                        pln1 = img.p-uv.wid.rslab
                        pln2 = img.p
                        IF (pln1 LT fp) THEN pln1 = fp
                     ENDCASE
                     5: BEGIN
                        pln1 = img.p
                        pln2 = img.p+uv.wid.rslab
                        IF (pln2 GT lp) THEN pln2 = lp
                     ENDCASE
                     6: BEGIN
                        pln1 = img.p-uv.wid.rslab
                        pln2 = img.p+uv.wid.rslab
                        IF (pln1 LT fp) THEN pln1 = fp
                        IF (pln2 GT lp) THEN pln2 = lp
                     ENDCASE
                  ENDCASE
d406 1
a406 1
               VIDI_ATLAS, uv
d443 1
a443 1
            VIDI_ATLAS, uv
d449 1
d454 1
a454 1
               VIDI_ATLAS, uv
d461 1
d466 1
a466 1
               VIDI_ATLAS, uv
d501 1
a501 1
               VIDI_ATLAS, uv
d512 4
a515 1
         rplanes: uv.wid.rplanes = ev.value
d525 4
a528 1
         rslab: uv.wid.rslab = ev.value
@


1.16
log
@change pixel definition for erase
@
text
@d334 1
d405 1
d442 1
d452 1
d463 1
d498 1
@


1.15
log
@add erase to vidi_edit
@
text
@d258 7
a264 6
   draw_msg = string(format='(A,/,A)', $
                     "Use left mouse button to trace or select sequential boundary points.", $
                     "Then use Fill to complete or Restore to cancel current outline or restore the last.")
   erase_msg = string(format='(A,/,A)', $
                      "Use left mouse button to erase pixels.", $
                      "Only this plane is affected and restore is inactivated.")
d314 2
d321 1
a321 1
               FOR m=0,uv.wid.rerase-1 DO BEGIN
d324 1
a324 1
                     FOR n=0,uv.wid.rerase-1 DO BEGIN
@


1.14
log
@add slab above and slab below
@
text
@d70 1
a70 1
     (xy[0] GT xdim) OR (xy[1] GT ydim) THEN RETURN
d209 2
a210 2
   		'Slab Above', 'Slab Below', 'Slab Up&Down'], $
       LABEL_LEFT='Remove from Planes:', /ROW, /EXCLUSIVE, set_value=uv.wid.rplanes)
d213 6
a218 4
   rmode = CW_BGROUP(base4, ['Inside','Outside'], $
       LABEL_LEFT='Removal Area:', /ROW, /EXCLUSIVE, set_value=uv.wid.rmode)
   rslab = CW_FIELD(base4, title='                   Slab Planes', value=uv.wid.rslab, $
                      xsize=4, /INTEGER, /RETURN_EVENTS)
d241 1
a241 1
        msg : msg, $			; Message window
d245 1
a245 1
        clear: 1, $				; 1=last roi has been erased
d249 2
a250 2
        img : img, $			; pointer to image data
        voi : voi, $			; linked list
d258 8
a265 3
   msg = string(format='(A,/,A)', $
                "Use left mouse button to trace or select sequential boundary points.", $
                "Then use Fill to complete or Restore to cancel current outline or restore the last.")
a266 2
   widget_control, s.msg, set_value=msg

d289 1
d300 1
d311 25
a335 2
      IF ev.id EQ draw THEN VIDI_EDIT_EVENT, ev, s, xdim, ydim, xzoom, yzoom $
      ELSE IF ev.id EQ val THEN uv.wid.editval = ev.value $
d502 5
a506 1
         rmode: uv.wid.rmode = ev.value
d508 2
d512 1
@


1.13
log
@connecting points uses best approximation to straight line
@
text
@d27 1
d208 2
a209 1
   rplanes = CW_BGROUP(base3, ['Current','All Above','All Below','All','Slab'], $
d215 1
a215 1
   rslab = CW_FIELD(base4, title='Planes on either side of Slab ', value=uv.wid.rslab, $
d256 3
a258 4
   msg = string(format='(A,/,A,/,A)', $
                "Use left mouse button to trace or select sequential", $
                "boundary points.  Then use Fill to complete or", $
                "Restore to cancel current outline or restore the last.")
d339 5
d345 5
@


1.12
log
@restore now works for multiple planes
@
text
@d96 9
d112 63
a174 20
            IF (xy[0] NE lastx) THEN BEGIN
               dx = xy[0]-lastx
               nextx = lastx + dx/abs(dx)
               (*(*s.roi).loc)[0,n] = nextx
               (*(*s.roi).loc)[1,n] = lasty
               lastx = nextx
               n = n + 1
               (*s.roi).num = n    
               IF ((*s.roi).type EQ 2 AND n GE 2) THEN VIDI_EDIT_DRAW, s, n-2, xdim, ydim, xzoom, yzoom
            ENDIF 
            IF (xy[1] NE lasty) THEN BEGIN
               dy = xy[1]-lasty
               nexty = lasty + dy/abs(dy)
               (*(*s.roi).loc)[0,n] = lastx
               (*(*s.roi).loc)[1,n] = nexty
               lasty = nexty
               n = n + 1
               (*s.roi).num = n    
               IF ((*s.roi).type EQ 2 AND n GE 2) THEN VIDI_EDIT_DRAW, s, n-2, xdim, ydim, xzoom, yzoom
            ENDIF
@


1.11
log
@elim debug line
@
text
@d155 1
a155 1
   rplanes = CW_BGROUP(base3, ['Current','All Above','All Below','All'], $
d161 3
a163 1
   
d209 23
a233 1
      frame = img.f - img.ff
d235 3
a237 21
         0: BEGIN
            x0 = 0
            y0 = 1
            fp = img.fp
            lp = img.lp
            image = reform((*img.data)[*,*,slice,frame])
         END
         1: BEGIN
            x0 = 0
            y0 = 2
            fp = 1
            lp = img.dim[1]
            image = reform((*img.data)[*,slice,*,frame])
         END
         2: BEGIN
            x0 = 1
            y0 = 2
            fp = 1
            lp = img.dim[0]
            image = reform((*img.data)[slice,*,*,frame])
         END
d261 1
a261 1
               IF ((size(pts))[0] GT 0) THEN BEGIN 
d267 32
a298 2
                  oldvalues = image[pts]
                  IF (uv.wid.rplanes EQ 0) THEN BEGIN
a299 1
                     msg = strtrim(string((size(pts))[1]),2)+" pixels filled"
d301 3
a303 3
                        0: (*img.data)[*,*,slice,frame] = image
                        1: (*img.data)[*,slice,*,frame] = image
                        2: (*img.data)[slice,*,*,frame] = image
d305 2
a306 33
                  ENDIF ELSE BEGIN
                     CASE uv.wid.rplanes OF
                        1: BEGIN
                           pln1 = fp
                           pln2 = img.p
                        ENDCASE
                        2: BEGIN
                           pln1 = img.p
                           pln2 = lp
                        ENDCASE
                        3: BEGIN
                           pln1 = fp 
                           pln2 = lp
                        ENDCASE
                     ENDCASE
                     FOR pln=pln1-1,pln2-1 DO BEGIN
                        CASE orient OF
                           0: image = reform((*img.data)[*,*,pln,frame])
                           1: image = reform((*img.data)[*,pln,*,frame])
                           2: image = reform((*img.data)[pln,*,*,frame])
                        ENDCASE
                        image[pts] = uv.wid.editval
                        CASE orient OF
                           0: (*img.data)[*,*,pln,frame] = image
                           1: (*img.data)[*,pln,*,frame] = image
                           2: (*img.data)[pln,*,*,frame] = image
                        ENDCASE
                     ENDFOR
                  ENDELSE
               ENDIF ELSE BEGIN
                  oldvalues = 0
                  msg = "No pixels filled"
               ENDELSE 
d317 23
a339 10
            npts = (size(oldvalues))[0]
            IF (npts GT 0) THEN BEGIN
               image[pts] = oldvalues
               msg = "Restored last fill"
               CASE orient OF
                  0: (*img.data)[*,*,slice,frame] = image
                  1: (*img.data)[*,slice,*,frame] = image
                  2: (*img.data)[slice,*,*,frame] = image
               ENDCASE
            ENDIF ELSE msg = "Nothing to Restore"
a384 1
                     oldvalues = image[pts]
d387 1
a387 4
                  ENDIF ELSE BEGIN
                     oldvalues = 0
                     msg = "No points replaced" 
                  ENDELSE 
d394 2
d410 2
@


1.10
log
@add inside/outside region fill option
@
text
@a197 1
   print,'XVAL = ',xval
@


1.9
log
@edit several slices at once
@
text
@d158 4
d197 2
d257 5
d394 2
@


1.8
log
@add vidi_segment, vidi_outline, vidi_viewer, vidi_viewer_display
vidi_edit in all 3 orientations
@
text
@d149 1
a149 1
   replace = WIDGET_BUTTON(base2, value='Replace Only If')
d153 4
d209 2
d216 2
d223 2
d245 1
d252 37
a288 7
                  image[pts] = uv.wid.editval
                  msg = strtrim(string((size(pts))[1]),2)+" pixels filled"
                  CASE orient OF
                     0: (*img.data)[*,*,slice,frame] = image
                     1: (*img.data)[*,slice,*,frame] = image
                     2: (*img.data)[slice,*,*,frame] = image
                  ENDCASE
d320 1
a320 1
            IF (img.p GT img.fp) THEN BEGIN
d330 1
a330 1
            IF (img.p LT img.lp) THEN BEGIN
d379 1
a379 1
         
d382 2
@


1.7
log
@get edges of image (GT)
@
text
@d132 1
d165 2
a166 2
   offset = [0,0]   
   p  = offset + image_size /2   
d175 1
a175 1
        msg : msg, $		; Message window
d179 1
a179 1
        clear: 1, $		; 1=last roi has been erased
d183 2
a184 2
        img : img, $		; pointer to image data
        voi : voi, $		; linked list
a197 15
   xdim = img.dim[0]
   ydim = img.dim[1]
   zdim = img.dim[2]
   wdim = img.dim[3]
   arraysize = xdim*ydim*zdim*wdim
   
   xzoom = float(zoom)
   yzoom = float(zoom)
   
   ;; Adjust for unequal pixel size
   xpdim = img.pdim[0]
   ypdim = img.pdim[1]
   IF (xpdim GT ypdim) THEN xzoom = (xpdim/ypdim) * zoom $
   ELSE IF (xpdim LT ypdim) THEN yzoom = (ypdim/xpdim) * zoom
   
d199 29
a227 1
      offset = (uv.img[i].p - uv.img[i].fp)*xdim*ydim
a238 2
               *img.data = reform(*img.data,arraysize,/overwrite)
               pts = pts+offset
d240 2
a241 2
                  oldvalues = (*img.data)[pts]
                  (*img.data)[pts] = uv.wid.editval
d243 5
a251 1
               *img.data = reform(*img.data,xdim,ydim,zdim,wdim,/overwrite)
d264 1
a264 1
               (*img.data)[pts] = oldvalues
d266 5
d279 5
a283 6
            p = uv.img[i].p
            IF (p GT uv.img[i].fp) THEN BEGIN
               p = p-1
               uv.img[0].p = p
               uv.img[1].p = p
               widget_control, uv.wid.slider, set_value=p
d289 5
a293 6
            p = uv.img[i].p
            IF (p LT uv.img[i].lp) THEN BEGIN
               p = p+1
               uv.img[0].p = p
               uv.img[1].p = p
               widget_control, uv.wid.slider, set_value=p
a308 2
                  pts = pts+offset
                  *img.data = reform(*img.data,arraysize,/overwrite)
d310 3
a312 3
                     0: ix = where ((*img.data)[pts] GE uv.wid.rthresh)
                     1: ix = where ((*img.data)[pts] EQ uv.wid.rthresh)
                     2: ix = where ((*img.data)[pts] LE uv.wid.rthresh)
d317 2
a318 2
                     oldvalues = (*img.data)[pts]
                     (*img.data)[pts] = uv.wid.editval
d325 5
a329 1
               *img.data = reform(*img.data,xdim,ydim,zdim,wdim,/overwrite)
d340 1
a340 1
                 
@


1.6
log
@edit image 2 in window 3
@
text
@d69 1
a69 1
     (xy[0] GE xdim) OR (xy[1] GE ydim) THEN RETURN
@


1.5
log
@check size of arrays pts and oldvalues
@
text
@d133 2
a135 1
   draw = uv.wid.win[i]
@


1.4
log
@add selective replacement
@
text
@d221 1
a221 1
            IF (n GT 0 AND s.clear EQ 0) THEN BEGIN 
d226 8
a233 2
               oldvalues = (*img.data)[pts]
               (*img.data)[pts] = uv.wid.editval
d238 1
a238 2
               msg = "Filled ROI"
            ENDIF ELSE msg = "No defined region to Fill"
d245 2
a246 1
            IF ((size(oldvalues))[1] GT 0) THEN BEGIN
d285 1
a285 1
            IF (n GT 0 AND s.clear EQ 0) THEN BEGIN 
d288 19
a306 9
               *img.data = reform(*img.data,arraysize,/overwrite)
               pts = pts+offset
               CASE uv.wid.rsign OF
                  0: pts = pts[where ((*img.data)[pts] GE uv.wid.rthresh)]
                  1: pts = pts[where ((*img.data)[pts] EQ uv.wid.rthresh)]
                  2: pts = pts[where ((*img.data)[pts] LE uv.wid.rthresh)]
               ENDCASE 
               oldvalues = (*img.data)[pts]
               (*img.data)[pts] = uv.wid.editval
a310 1
               msg = "Replaced selected pixels in ROI"
@


1.3
log
@*** empty log message ***
@
text
@d146 6
d277 27
@


1.2
log
@*** empty log message ***
@
text
@d69 1
a69 1
      (xy[0] GE xdim) OR (xy[1] GE ydim) THEN RETURN
d140 5
a144 3
   temp1 = CW_BGROUP(base1, /ROW, /NO_RELEASE, /RETURN_NAME, ['Fill'])
   temp2 = CW_BGROUP(base1, /ROW, /NO_RELEASE, /RETURN_NAME, ['Restore'])
   temp3 = CW_BGROUP(base1, /ROW, /NO_RELEASE, /RETURN_NAME, ['Exit'])
a194 1
   offset = (img.p - img.fp)*xdim*ydim
d206 1
d211 1
a211 1
      ELSE CASE ev.value of 
d213 1
a213 1
         'Fill':  BEGIN   
d231 1
a231 1
         'Restore':  BEGIN 
d244 23
a266 6
         'Exit':  BEGIN
            IF KEYWORD_SET(restore) THEN BEGIN ; Restore image in draw
               WSET, win
               DEVICE, copy = [0,0, !d.x_size, !d.y_size, 0, 0, backing]
            ENDIF
            WDELETE, backing
@


1.1
log
@Initial revision
@
text
@d23 1
a23 1
PRO VIDI_EDIT_DRAW, s, i, FILL= fill
d33 1
d35 1
d38 1
d40 3
a42 3
   !x.s = [0, s.zoom/float(!d.x_size)]
   !y.s = [0, s.zoom/float(!d.y_size)]
   ydim = s.img.dim[1]
d50 1
a50 1
   !x.s = xsave & !y.s = ysave
d54 1
a54 1
PRO VIDI_EDIT_EVENT, ev, s
d62 3
a64 5
   x = (ev.x - s.offset[0]) / s.zoom ; Screen coordinates (0,0 is lower left)
   y = (ev.y - s.offset[1]) / s.zoom
   xdim = s.img.dim[0]
   ydim = s.img.dim[1]
   xy = [x,y]
d92 1
a92 1
         IF ((*s.roi).type EQ 2 AND n GE 2) THEN VIDI_EDIT_DRAW, s, n-2
d111 1
a111 1
               IF ((*s.roi).type EQ 2 AND n GE 2) THEN VIDI_EDIT_DRAW, s, n-2
d121 1
a121 1
               IF ((*s.roi).type EQ 2 AND n GE 2) THEN VIDI_EDIT_DRAW, s, n-2
a124 11
      
   ENDIF ELSE IF (s.button EQ 2 AND (NOT s.clear OR ptr_valid(s.last))) THEN BEGIN ; Move
      IF (s.clear) THEN BEGIN
         s.clear = 0
         (*s.roi).num = 0  
      ENDIF ELSE VIDI_EDIT_DRAW, s, -1 ; Remove old
      xy0 = xy - (*(*s.roi).loc)[*,0]
      (*(*s.roi).loc)[*,0] = xy
      FOR i=1,n DO (*(*s.roi).loc)[*,i] = (*(*s.roi).loc)[*,i] + xy0
      VIDI_EDIT_DRAW, s, -1
      
a172 1
        color : 6, $		; 3 -> color=white; 6 -> color=XOR
a187 1
   
d192 1
a192 1
   dsize = xdim*ydim*zdim*wdim
d195 9
d207 1
a207 1
      IF ev.id EQ draw THEN VIDI_EDIT_EVENT, ev, s $
d215 2
a216 2
               pts = polyfillv(xy[0,*],xy[1,*], 512, 512)
               *img.data = reform(*img.data,dsize,/overwrite)
d225 1
a225 1
            ENDIF ELSE msg = "No defined ROI to Fill"
d231 1
a231 1
            IF (s.clear GT 0 AND n GT 0) THEN VIDI_EDIT_DRAW, s, -1, /fill
@
