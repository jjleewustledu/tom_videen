


User Commands                                         XKeyCaps(1)



NAME
     xkeycaps - graphically display and edit the X keyboard  map-
     ping

SYNOPSIS
     xkeycaps [-_t_o_o_l_k_i_t_o_p_t_i_o_n ...] [-_o_p_t_i_o_n ...]

DESCRIPTION
     The _x_k_e_y_c_a_p_s program displays a keyboard.  Moving the  mouse
     over a key describes the keysyms and modifiers that that key
     generates.  Clicking left on  a  key  simulates  a  KeyPress
     event.   Clicking  right on a key brings up a menu of opera-
     tions, including a command to change the  keysyms  that  the
     key  generates.   This  program  is,  in  part,  a graphical
     front-end to xmodmap(1).

OPTIONS
     _x_k_e_y_c_a_p_s accepts all of the standard  toolkit  options,  and
     also accepts the following options:

     -keyboard _k_e_y_b_o_a_r_d-_n_a_m_e or -kbd _k_e_y_b_o_a_r_d-_n_a_m_e
         Specifies the type of keyboard to  display.   There  are
         many  different  computer  keyboards  in  the world, and
         _x_k_e_y_c_a_p_s must know which one you are using in  order  to
         function  correctly.  Case does not matter when specify-
         ing a keyboard name.

         If you're running on the console display of a Sun or HP,
         then  _x_k_e_y_c_a_p_s  will  interrogate  the attached keyboard
         hardware directly  to  determine  what  keyboard  you're
         using.   But  if  you're running remotely, or on another
         type of  machine,  then  you  must  specify  a  keyboard
         somehow.

     -help
         Lists the recognized values for the -keyboard option.

     -gutterwidth _n_u_m_b_e_r or -gw _n_u_m_b_e_r
         Specifies the number of pixels of space to leave between
         each key.

     -font _f_o_n_t_n_a_m_e
         Specifies the font to use to display the keycaps.


     The following standard X Toolkit command line arguments  are
     commonly used with _x_k_e_y_c_a_p_s:

     -display _h_o_s_t:_d_p_y
         This option specifies the X server to contact.

     -geometry _g_e_o_m_e_t_r_y



X Version 11         Last change: 16-Aug-98                     1






User Commands                                         XKeyCaps(1)



         This option specifies the preferred size and position of
         the window.

     -bg _c_o_l_o_r
         This option specifies the color to  use  for  the  back-
         ground of the window.  The default is light gray.

     -fg _c_o_l_o_r
         This option specifies the color to  use  for  the  fore-
         ground of the window.  The default is black.

     -bw _n_u_m_b_e_r
         This option specifies the width in pixels of the  border
         surrounding the window.

     -xrm _r_e_s_o_u_r_c_e_s_t_r_i_n_g
         This option specifies a  resource  string  to  be  used.
         This  is especially useful for setting resources that do
         not have separate command line options.

DISPLAY
     The bottom part of the window is a drawing  of  a  keyboard.
     In  the  top  left  of  each key is printed the string which
     actually appears on the surface of the key.  In  the  bottom
     right  of the key is the (hexadecimal) keycode that this key
     generates.

     At the top of the screen are several lines of text  describ-
     ing  the  key  under  the  mouse (or the most recently typed
     key.)  These lines are:

     KeyCode:    This displays the text printed on  the  physical
                 key,  and  the  keycode generated by that key in
                 hex, decimal, and octal.

     KeySym:     This displays the set of KeySyms that  this  key
                 currently generates.

     ASCII:      This displays the ASCII equivalent of this  key,
                 taking  into  account  the current modifier keys
                 which are down.

     Modifiers:  this displays the modifier bits which  this  key
                 generates.   If a key generates modifiers, it is
                 a chord-key like _S_h_i_f_t or _C_o_n_t_r_o_l.

     AutoRepeat: Whether  the  X  server  claims  that  this  key
                 autorepeats.    I  say  ``_c_l_a_i_m_s''  because  the
                 OpenWindows X server is  the  only  one  I  have
                 encountered  for which this information is accu-
                 rate.  The per-key autorepeat flag seems  to  be
                 almost-universally ignored.



X Version 11         Last change: 16-Aug-98                     2






User Commands                                         XKeyCaps(1)



COMMANDS
     There are several buttons in the upper left  corner  of  the
     window.  They are:

     Quit
         Exits the program.

     Select Keyboard
         Pops up a dialog box from which  you  can  change  which
         keyboard  is displayed.  The left column lists the known
         types of keyboards, and the right column lists the known
         layouts (mappings) of those keyboards.

     Type At Window
         After selecting this, you are asked  to  click  on  some
         other window.  After doing this, clicking on keys on the
         keyboard display will simulate key events on the  window
         you selected.  Selecting the root window or the _x_k_e_y_c_a_p_s
         window turns this off.

         If you are using a window manager (for example,  twm(1))
         in which you can lock the keyboard focus on a window and
         still click on other windows without  having  the  focus
         change, then you can accomplish the same thing merely by
         focusing on another window and clicking on the  keys  in
         the _x_k_e_y_c_a_p_s window.

     Restore Default Map
         This command restores the keyboard to its default state.
         If  you execute this command while displaying a keyboard
         which is not the type of keyboard you are really  using,
         your keymap will be in a nonsensical state.  There is no
         way for _x_k_e_y_c_a_p_s to tell what  keyboard  you  are  using
         except by taking your word for it, so don't lie.

     Write Output
         This command writes an _x_m_o_d_m_a_p input  file  representing
         the current state of the keyboard (including all of your
         changes) to a file in your home directory.

         The file will be called .xmodmap-_h_o_s_t_n_a_m_e,  where  _h_o_s_t_-
         _n_a_m_e  is  the name of the machine you're running on.  It
         will warn you if the file already exists.

         It prompts you with a dialog box: you can  either  write
         an  _x_m_o_d_m_a_p file representing the state of every key, or
         you can write a smaller file which  describes  only  the
         changes.

         The idea is that in the appropriate startup script,  you





X Version 11         Last change: 16-Aug-98                     3






User Commands                                         XKeyCaps(1)



         would add a line like

              xmodmap ~/.xmodmap-`uname -n`

         in the appropriate init file,  so  that  those  keyboard
         modifications are made each time you log in.  (If you're
         not sure where this command should go, ask  your  system
         administrator, as that tends to vary from site to site.)

     Clicking left on a key simulates a KeyPress event.   Releas-
     ing  the  button simulates a KeyRelease event.  If you click
     left on a key and move the mouse while the button  is  down,
     KeyPress  and  KeyRelease  events will be simulated on every
     key you move the mouse over.  Think of  the  mouse  as  your
     finger:  if  you drag the mouse over several keys, they will
     go down and up in turn.

     Clicking left on a key which  is  associated  with  modifier
     bits  (such as Shift or Control) causes that key to ``lock''
     down.  Clicking left again releases the key.  In  this  way,
     you  can  generate  key-chords  with the mouse:  to generate
     _C_o_n_t_r_o_l-_C, click left on the _C_o_n_t_r_o_l key, and then click  on
     the  _C  key.   Click  on  _C_o_n_t_r_o_l  again to turn the control
     modifier off.

     Typing  a   key   on   the   _r_e_a_l   keyboard   simulates   a
     KeyPress/KeyRelease event pair in the same way that clicking
     on a key does.

     You can also combine mouse and keyboard input: for  example,
     if  you  use  the  mouse to select the _S_h_i_f_t key, and type a
     character, the event that is simulated will have  the  _S_h_i_f_t
     modifier  set.   And  if you hold down the real _C_o_n_t_r_o_l key,
     and click on the _C key in the window, a _C_o_n_t_r_o_l-_C event will
     be  generated.  (Assuming, that is, that your window manager
     does not intercept  control-left-button  for  its  own  pur-
     poses.)

     Clicking right on a key pops up a menu of commands  for  the
     given key.  They are:

     Exchange Keys
         After selecting this menu item, you are asked  to  click
         on  another  key.   That  key  and  the key on which you
         brought up the menu will be exchanged.  This changes the
         keyboard mapping immediately.

     Duplicate Key
         After selecting this menu item, you are asked  to  click
         on another key.  That key will be made a copy of the key
         on which you brought up the menu.  That is, the two keys
         will  generate  the  same  set of keysyms and modifiers.



X Version 11         Last change: 16-Aug-98                     4






User Commands                                         XKeyCaps(1)



         This changes the keyboard mapping immediately.

     Disable Key
         The key on which you brought up the menu will be made to
         generate  no keysyms and no modifiers.  This changes the
         keyboard mapping immediately.

     Restore Key To Default
         The key on  which  you  brought  up  the  menu  will  be
         restored  to  its  default  state;  no other key will be
         altered.  This actually  changes  the  current  keyboard
         mapping.

     Edit KeySyms of Key
         This pops up the "Edit Key" window, which allows you  to
         arbitrarily  change which keysyms and modifiers this key
         generates.

         On the left side of  the  window  is  the  list  of  the
         keysyms  that  this key currently generates.  (A key may
         generate up to  eight  keysyms;  the  interpretation  of
         these  keysyms  is described in the X protocol document,
         and is summarized later in the KEYSYMS AND KEYCODES sec-
         tion of this man page.)

         The second column is a multiple-choice list of the eight
         modifier  bits that this key may generate.  For example,
         if you want a key to behave as a  ``control''  key,  you
         should select the Control modifier.

         The third and fourth column (the  scrolling  lists)  are
         for  changing  the keysym associated with the key.  When
         you select a keysym-position from the first column,  the
         character set and keysym will be displayed in the scrol-
         ling lists.  Clicking on  a  keysym  in  the  ``KeySym''
         column  will install that keysym in the highlighted slot
         in the first column.

         To select a keysym from a different character set, click
         on  the  character  set name in the second column.  (The
         Latin1 and Keyboard character sets are the most commonly
         used.)

         At the bottom of the window  are  three  buttons:  Undo,
         Abort,  and  Ok.   Clicking on Undo reverts the Edit Key
         window to the current state  of  the  key  in  question.
         Abort  closes  the  Edit  Key  window without making any
         changes.  Ok closes the Edit  Key  window  and  installs
         your changes (the current keyboard mapping is modified.)

KEYSYMS AND KEYCODES
     To effectively edit your keyboard mapping,  there  are  some



X Version 11         Last change: 16-Aug-98                     5






User Commands                                         XKeyCaps(1)



     terms you need to be familiar with:

     _K_e_y_C_o_d_e   This is a raw scan-code that is read from the key-
               board;  each  physical  key  on the keyboard has a
               different number associated with it; this  mapping
               cannot be changed (but that's ok.)

               Generally, every keyboard has its own set of  Key-
               Codes, which is why you will probably need to have
               a different keymap for every system you use.

     _K_e_y_S_y_m    This is a symbol which can be generated by a  sin-
               gle press of one key on the keyboard: for example,
               all letters, numbers, and punctuation are keysyms,
               and so are more abstract things like ``shift'' and
               ``control''.

               Each KeyCode (that is, key  on  the  keyboard)  is
               associated  with certain KeySyms.  The KeySyms are
               what give the keys their semantics (and makes  the
               A key generate an A), not the KeyCodes.

               Usually  keys  are  associated  with  one  or  two
               keysyms, which correspond to the symbols generated
               when the key is pressed, and when  it  is  pressed
               while the shift key is held down.  There is a spe-
               cial case, which is that if the key contains  only
               one KeySym, and it is a letter, then the Shift key
               does the obvious thing that one does to letters.

     _K_e_y_C_a_p    Not to be confused with KeySyms,  this  refers  to
               the text which is printed on the physical keys: it
               is immutable (unless you repaint your keyboard...)

     _C_h_o_r_d     This term refers to a set of two or more keys held
               down  simultaniously  (by  analogy with piano key-
               boards.)  All but one of the keys  will  generally
               be Modifier Keys.  Sometimes _C_o_n_s_t_e_l_l_a_t_i_o_n is used
               to mean the same thing.

     _M_o_d_i_f_i_e_r _K_e_y
               This is a key like shift or control, which is used
               to  alter  the  interpretation of other keys which
               are held down at the same time.  Generally, press-
               ing  a  modifier  key without also pressing a non-
               modifier key does nothing.

               A key is a modifier  key  if  it  has  a  Modifier
               KeySym  on it.  (More specifically, if the KeyCode
               of that key is associated with a Modifier KeySym.)

     _M_o_d_i_f_i_e_r _K_e_y_S_y_m



X Version 11         Last change: 16-Aug-98                     6






User Commands                                         XKeyCaps(1)



               A KeySym is a modifier keysym if it has a Modifier
               Bit associated with it.  But, the rules are a lit-
               tle more complicated than that.   It's  easier  to
               describe by example:

               For a key to behave as one expects a shift key  to
               behave, the keycode should have the Shift modifier
               bit set; and the key should generate  one  of  the
               keysyms  Shift_L  and Shift_R.  If either of these
               is not true, the key will not behave  as  a  shift
               key.

               Analogously, a control key must have  the  Control
               modifier set, and use one of the keysyms Control_L
               or Control_R.

               This implies that if you wanted to swap your shift
               and control keys, it would not be enough to simply
               swap their modifier  bits:  you  must  swap  their
               keysyms  as  well.   If you only swap the modifier
               bits, it might appear to work at first, but  other
               things would malfunction.

               Keys like Meta (and Super, Hyper, etc.) are a  bit
               more complicated (see below.)

     _M_o_d_i_f_i_e_r _B_i_t
               Modifier bits are attributes which certain keysyms
               can  have.   Some  modifier  bits  have predefined
               semantics: Shift, Lock, and Control.  The  remain-
               ing  modifier bits (Mod1 through Mod5) have seman-
               tics which are defined by the keys with which they
               are associated.

               That is, the Control modifier means Control if  it
               is  attached  to  Control_L  or  Control_R, and is
               illegal elsewhere.

               But Mod1 means Meta if it is attached to Meta_L or
               Meta_R;  but it would mean Alt if it were attached
               to Alt_L  or  Alt_R;  or  Hyper  with  Hyper_L  or
               Hyper_R;  and  so  on.  (It could not, however, be
               attached to Control_L, since the Control  modifier
               has already spoken for those keysyms.)

               If you're thinking that this  is  all  senselessly
               complicated... you're right.

X PROTOCOL DOCUMENT ON KEYMAPS
     The following is a more precise technical explanation of how
     keymapping  works.   This description is from the X Protocol
     document, and is reprinted here for your convenience:



X Version 11         Last change: 16-Aug-98                     7






User Commands                                         XKeyCaps(1)



         A list of KeySyms is associated with each  KeyCode.   If
         that list (ignoring trailing NoSymbol entries) is a sin-
         gle KeySym ``K'', then the list is treated as if it were
         the  list ``K NoSymbol K NoSymbol''. If the list (ignor-
         ing trailing NoSymbol entries) is a pair of KeySyms ``K1
         K2'',  then  the  list is treated as if it were the list
         ``K1 K2 K1 K2''.  If the list (ignoring trailing  NoSym-
         bol  entries)  is a triple of KeySyms ``K1 K2 K3'', then
         the list is treated as if it were the list  ``K1  K2  K3
         NoSymbol''.

         The first four elements of the list are split  into  two
         groups  of  KeySyms.   Group  1  contains  the first and
         second  KeySyms,  Group  2  contains  third  and  fourth
         KeySyms.   Within  each  group, if the second element of
         the group is NoSymbol, then the group should be  treated
         as if the second element were the same as the first ele-
         ment, except when the first  element  is  an  alphabetic
         KeySym  ``K''  for  which  both  lowercase and uppercase
         forms are defined.  In that case, the  group  should  be
         treated  as if the first element were the lowercase form
         of ``K'' and the second element were the uppercase  form
         of ``K''.

         The  standard  rules  for  obtaining  a  KeySym  from  a
         KeyPress  event make use of only the Group 1 and Group 2
         KeySyms; no interpretation of other KeySyms in the  list
         is  given  here.   (That  is,  the last four KeySyms are
         unused.)

         Which group to use  is  determined  by  modifier  state.
         Switching  between  groups  is  controlled by the KeySym
         named Mode_switch.

         By attaching that KeySym to some KeyCode  and  attaching
         that  KeyCode  to  any one of the modifiers Mod1 through
         Mod5.  This modifier is called the  ``group  modifier''.
         For any KeyCode, Group 1 is used when the group modifier
         is off, and Group 2 is used when the group  modifier  is
         on.

         Within a group, which KeySym to use is  also  determined
         by  modifier  state.   The first KeySym is used when the
         Shift and Lock modifiers are off.  The second KeySym  is
         used  when  the  Shift  modifier is on, or when the Lock
         modifier is on and the second KeySym is uppercase alpha-
         betic,  or  when  the  Lock modifier is on and is inter-
         preted as ShiftLock.  Otherwise, when the Lock  modifier
         is  on  and is interpreted as CapsLock, the state of the
         Shift modifier is applied first to select a KeySym,  but
         if   that  KeySym  is  lowercase  alphabetic,  then  the
         corresponding uppercase KeySym is used instead.



X Version 11         Last change: 16-Aug-98                     8






User Commands                                         XKeyCaps(1)



ICCCM ON THE MODIFIER MAPPING
     The following is a more precise technical explanation of how
     modifier keys are interpreted.  This description is from the
     Inter-Client  Communications  Conventions  Manual,  and   is
     reprinted here for your convenience:

         X11 supports 8 modifier  bits,   of  which  3  are  pre-
         assigned  to Shift, Lock and Control.  Each modifier bit
         is controlled by the state of a set of keys,  and  these
         sets  are  specified in a table accessed by GetModifier-
         Mapping() and SetModifierMapping().

         A client needing to use one of the  pre-assigned  modif-
         iers  should assume that the modifier table has been set
         up correctly  to  control  these  modifiers.   The  _L_o_c_k
         modifier  should  be  interpreted  as _C_a_p_s _L_o_c_k or _S_h_i_f_t
         _L_o_c_k according as the keycodes in  its  controlling  set
         include XK_Caps_Lock or XK_Shift_Lock.

         Clients should determine the meaning of a  modifier  bit
         from the keysyms being used to control it.

         A client needing to use an extra modifier,  for  example
         _M_e_t_a,  should:

           Scan the existing modifier mappings.  If  it  finds  a
           modifier  that contains a keycode whose set of keysyms
           includes XK_Meta_L or XK_Meta_R, it  should  use  that
           modifier bit.

           If  there  is  no  existing  modifier  controlled   by
           XK_Meta_L  or  XK_Meta_R,  it  should select an unused
           modifier bit (one with an empty controlling set) and:

             If there is a keycode with XL_Meta_L in its  set  of
             keysyms,  add that keycode to the set for the chosen
             modifier, then

             if there is a keycode with XL_Meta_R in its  set  of
             keysyms,  add that keycode to the set for the chosen
             modifier, then

             if the controlling set  is  still  empty,   interact
             with the user to select one or more keys to be Meta.

           If there are no unused modifier bits, ask the user  to
           take corrective action.

     The above means that the Mod1 modifier does not  necessarily
     mean _M_e_t_a, although some applications (such as _t_w_m and _e_m_a_c_s
     _1_8) assume that.  Any of the five unassigned  modifier  bits
     could  mean  Meta;  what  matters  is that a modifier bit is



X Version 11         Last change: 16-Aug-98                     9






User Commands                                         XKeyCaps(1)



     generated by a keycode which is bound to the  keysym  Meta_L
     or Meta_R.

     Therefore, if you want to make a ``meta'' key, the right way
     is  to  make  the  keycode  in question generate both a Meta
     keysym, and some previously-unassigned modifier bit.

THE MODE_SWITCH KEYSYM
     In case the above didn't make sense,  what  the  Mode_switch
     keysym  does  is,  basically,  act  as an additional kind of
     shift key.  If you have four keysyms attached to the A  key,
     then  those  four keysyms will be accessed by the chords: A;
     Shift-A,  Mode_Switch-A;  and  Mode_Switch-Shift-A,  respec-
     tively.

     Like any Modifier Key, for Mode_switch to function, it  must
     have  a  modifier bit attached to it.  So, select one of the
     bits Mod1 through Mod5 (whichever is unused) and attach that
     to the Mode_switch key.

THE MULTI_KEY KEYSYM
     Not to be confused with Mode_switch,  Multi_key  allows  the
     input  of multiple character sequences that represent a sin-
     gle character (keysym.)  A more traditional  name  for  this
     keysym might have been _C_o_m_p_o_s_e.

     The Multi_key keysym is _n_o_t a modifier keysym.  That is, for
     it  to  function  properly,  it should not have any modifier
     bits associated with it.   This  is  because  it  is  not  a
     ``chording''  key:  you do not hold it down along with other
     keys.  Rather, you press Multi_key, then  release  it,  then
     press  and release another key, and the two together yield a
     new character.

     For example, one traditional binding would be for _M_u_l_t_i__k_e_y,
     followed  by  _s_i_n_g_l_e-_q_u_o_t_e,  followed  by  _A  to produce the
     _A_a_c_u_t_e keysym.

     Not all vendors support the use of the Multi_key keysym;  in
     particular,  Digital, Sun, and HP support it, but the X Con-
     sortium does not.  (The reason for this, I am told, is  that
     ``Compose''  sequences  are  considered  obsolete; the party
     line is that you should be using Input Methods to do this.)

     Whether Multi_key works is a property of the Xt library (not
     the  X  server)  so  it's  possible that on a single system,
     Multi_key might work with some applications and  not  others
     (depending  on  how  those  applications  were  compiled and
     linked.)

     If you use Lucid Emacs or XEmacs, then you can  take  advan-
     tage  of  Multi_key  sequences  even  if  your version of Xt



X Version 11         Last change: 16-Aug-98                    10






User Commands                                         XKeyCaps(1)



     doesn't support it, by loading the _x-_c_o_m_p_o_s_e library,  which
     simulates  the  traditional Xt behavior. For more info, read
     the    commentary    at    the    top    of     the     file
     "/usr/local/lib/xemacs-*/lisp/x11/x-compose.el".

DEAD KEYSYMS
     Dead keys  work  similarly  Multi_key,  but  they  are  two-
     keystroke  commands instead of three.  For example, pressing
     the Dead_tilde key, releasing it, then pressing  the  _A  key
     would  generate  the single keysym _A_t_i_l_d_e.  (They are called
     ``dead'' keys because they do  not,  by  themselves,  insert
     characters,  but  instead  modify  the  following  character
     typed.  But HP  likes  to  call  them  ``mute''  instead  of
     ``dead,'' no doubt to avoid frightening the children.)

     Again, these are not supported by all  versions  of  the  Xt
     library (but can be simulated by XEmacs.)

     Also note that different vendors have  different  names  for
     the  dead keysyms.  For example: depending on your vendor, X
     server version, and the phase of the moon,  you  might  find
     that  the  name  of  ``dead-tilde''  is  Dead_Tilde, Dtilde,
     SunFA_Tilde,  SunXK_FA_Tilde,  DXK_tilde,  DXK_tilde_accent,
     hpmute_asciitilde,     hpXK_mute_asciitilde,     or     even
     XK_mute_asciitilde.  It's a mess!  You'll have to  just  try
     it and see what works, if anything.

THINGS YOU CAN'T DO
     People often ask if xkeycaps or xmodmap can be used to  make
     one  key  generate a sequence of characters.  Unfortunately,
     no: you can't do this sort  of  thing  by  manipulating  the
     server's  keymaps.   The  X keyboard model just doesn't work
     that way.

     The way to do such things is to set translation resources on
     particular  widgets.   It  has to be done on an application-
     by-application basis.  For example,  here's  how  you  would
     convince  xterm(1)  to  insert  the string _n_e_x_t when you hit
     F17:

          xterm*VT100.Translations: #override \
              <Key>F17: string("next")

     Other applications may have different mechanisms for  accom-
     plishing  the  same  thing,  and some applications might not
     support it at all.  Check the relevant man pages for specif-
     ics.

     Likewise, you can't convince one key to generate another key
     with  modifiers  (for example, you can't make F1 behave like
     Ctrl-A except by using translations, as above.)




X Version 11         Last change: 16-Aug-98                    11






User Commands                                         XKeyCaps(1)



     It is also not possible to make a keyboard key behave  as  a
     mouse button.

LOSER VENDORS
     Both HP and S.u.S.E. ship their systems with broken keyboard
     settings  by  default.   They really should know better, but
     they don't.

     As explained above, it is _u_n_d_e_f_i_n_e_d _b_e_h_a_v_i_o_r for one  modif-
     ier bit to be shared between two keys with dissimilar seman-
     tics.

     By default, HP uses _M_o_d_1  for  both  _M_e_t_a  and  _M_o_d_e__s_w_i_t_c_h.
     This  means  that  it's impossible for a program to tell the
     difference between, for example, Meta-X and Mode_switch-X.

     So, to repair this mess, you need to  give  the  Mode_switch
     key  a  different modifier bit (_m_o_d_2, for example.)  Or, you
     could just remove it from the keymap entirely.

     S.u.S.E. Linux is even more screwed up than HP: whereas HP's
     default keymap contains only one bug, S.u.S.E.'s default map
     contains three completely different errors!

     First,  their  default  keymap  has  the  _C_o_n_t_r_o_l   modifier
     attached to both the _C_o_n_t_r_o_l key and the _M_u_l_t_i__k_e_y.  This is
     completely crazy, because not only is _M_u_l_t_i__k_e_y not  a  con-
     trol key, it's not even a _c_h_o_r_d_i_n_g key!  It mustn't have any
     modifier bits attached to it at all.

     Second, they attach _M_o_d_1 to _M_e_t_a__L and also to _A_l_t__R.   Some
     people think that ``meta'' and ``alt'' are synonyms, but the
     fact is that the X Window System does not agree.   Those are
     distinct  keys.   It's  possible  to  have both ``meta'' and
     ``alt'' keys on the keyboard at the same time, and  to  have
     programs  interpret  them distinctly.  But of course only if
     they don't bogusly share the same modifier bit,  making  the
     interpretation of that bit be ambiguous.

     Third, they attach _M_o_d_5 to both _S_c_r_o_l_l__L_o_c_k and to  _H_y_p_e_r__R,
     which is wrong for reasons that should by now be obvious.

     The easiest way to fix your S.u.S.E.  configuration  is  to:
     remove  _c_o_n_t_r_o_l  from  _M_u_l_t_i__k_e_y; change the left Alt key to
     generate _A_l_t__L instead of _M_e_t_a__L;  and  delete  the  _H_y_p_e_r__R
     keysym from the keyboard.

     If you have any pull with these vendors, I encourage you  to
     encourage them to get their act together.

X RESOURCES
     _X_K_e_y_C_a_p_s understands all of  the  core  resource  names  and



X Version 11         Last change: 16-Aug-98                    12






User Commands                                         XKeyCaps(1)



     classes as well as:

     *Keyboard.keyboard (class Keyboard)
         Which keyboard to display; this is the same as the -key-
         board  command-line  option.   If this is not specified,
         the default keyboard is guessed, based on  the  server's
         vendor identification string.

     *Keyboard.Keyboard.selectCursor (class Cursor)
         The cursor to use when selecting a key  or  window  with
         the mouse.  The default is the _c_r_o_s_s_h_a_i_r cursor.

     *Keyboard.Key.highlight (class Background)
         The  color  to  use  to  highlight  a  key  when  it  is
         depressed.   If this is the same as the background color
         of the key, it is highlighted  with  a  stipple  pattern
         instead.

     *Keyboard.Key.keycapColor (class Foreground)
         The color to paint the keycap string.

     *Keyboard.Key.keycodeColor (class Foreground)
         The color to paint the keycode number.

     *Keyboard.Key.borderColor (class Color)
         The color of the box around each key.

     *Keyboard.Key.keycapFont (class Font)
         The font to use to draw the keycap string.

     *Keyboard.Key.keycodeFont (class Font)
         The font to use to draw the keycode number.

     *Keyboard.Key.borderWidth (class Int)
         The thickness of the box around each key.

     *Keyboard.Key.gutterWidth (class Int)
         How many pixels to  leave  between  this  key  and  it's
         neighbors to the right and bottom.

     The class of each key widget is ``Key,'' as you  see  above.
     The  name  of each key is the string(s) printed on its face.
     So if you wanted (for example) the Shift keys to have  wider
     borders, you could specify that with

          xkeycaps*Keyboard.Shift.borderWidth: 2


ACTIONS
     It is possible to rebind the actions which happen when a key
     or  mouse  button is pressed or released.  These actions are
     available on the Keyboard widget:



X Version 11         Last change: 16-Aug-98                    13






User Commands                                         XKeyCaps(1)



     HighlightKey(_c_o_n_d_i_t_i_o_n, _a_r_g)
         This places the  key  in  question  in  the  highlighted
         state.

         If no _a_r_g_u_m_e_n_t is passed to this action, then the key is
         determined  by  the event which invoked this action.  If
         this action is  invoked  by  a  KeyPress  or  KeyRelease
         event,  the  key-widget  is the key corresponding to the
         key that the event represents.  If it is a  ButtonPress,
         ButtonRelease,  or  PointerMotion  event,  then the key-
         widget is the one under the mouse.

         The _a_r_g_u_m_e_n_t may be one of the words _m_o_u_s_e, _h_i_g_h_l_i_g_h_t_e_d,
         or  _d_i_s_p_l_a_y_e_d,  meaning the key under the mouse, the key
         most recently highlighted, or the  key  currently  being
         described in the ``Info'' area at the top of the window,
         respectively.

         The _c_o_n_d_i_t_i_o_n may be one of the words _i_f_m_o_d,  _u_n_l_e_s_s_m_o_d,
         _i_f_t_r_a_c_k_i_n_g,     _u_n_l_e_s_s_t_r_a_c_k_i_n_g,     _i_f_h_i_g_h_l_i_g_h_t_e_d,    or
         _u_n_l_e_s_s_h_i_g_h_l_i_g_h_t_e_d.  If _i_f_m_o_d was specified and  the  key
         in  question  (as  determined  by the _a_r_g_u_m_e_n_t or by the
         invoking event) is not a modifier key, then this  action
         is  not  executed.  The _u_n_l_e_s_s_m_o_d condition is the oppo-
         site.   The  _i_f_t_r_a_c_k_i_n_g  and  _u_n_l_e_s_s_t_r_a_c_k_i_n_g  conditions
         allow you to do some actions only if (or unless) the key
         is being ``tracked'' with the mouse  (see  below.)   The
         _i_f_h_i_g_h_l_i_g_h_t_e_d and _u_n_l_e_s_s_h_i_g_h_l_i_g_h_t_e_d actions allow you to
         do some things only if (or unless) the key  in  question
         is currently in the highlighted state.

     UnhighlightKey(_c_o_n_d_i_t_i_o_n, _a_r_g)
         This places the key in  question  in  the  unhighlighted
         state.  Arguments are as above.

     ToggleKey(_c_o_n_d_i_t_i_o_n, _a_r_g)
         This  makes  the   key   be   highlighted   if   it   is
         unhighlighted,  or  unhighlighted  if it is highlighted.
         Arguments are as above.

     SimulateKeyPress(_c_o_n_d_i_t_i_o_n, _a_r_g)
         This action makes a KeyPress event corresponding to  the
         key  be  synthesized on the focus window.  Arguments are
         as above.

     SimulateKeyRelease(_c_o_n_d_i_t_i_o_n, _a_r_g)
         This action makes a KeyRelease  event  corresponding  to
         the  key  be synthesized on the focus window.  Arguments
         are as above.

     TrackKey(_c_o_n_d_i_t_i_o_n, _a_r_g)
         This makes the key in question begin being  ``tracked'',



X Version 11         Last change: 16-Aug-98                    14






User Commands                                         XKeyCaps(1)



         which  means  that moving the mouse off of it will simu-
         late a button-release action, and then will  simulate  a
         button-press  action on the key that the mouse has moved
         on to.  This action may only  be  invoked  from  a  But-
         tonPress or ButtonRelease event.

     UntrackKey(_c_o_n_d_i_t_i_o_n, _a_r_g)
         This makes the key in question no longer be ``tracked.''

     DescribeKey(_c_o_n_d_i_t_i_o_n, _a_r_g)
         This action causes  the  key  and  its  bindings  to  be
         displayed in the ``Info'' section at the top of the win-
         dow, if it is not already described there.

     The default actions for the Keyboard widget are:

          <Motion>:   DescribeKey(mouse,unlessTracking)      \n\
          \
          <KeyDown>:  HighlightKey()                         \
                      DescribeKey(unlessMod)                 \
                      DescribeKey(displayed)                 \
                      SimulateKeyPress()                     \n\
          \
          <KeyUp>:    UnhighlightKey()                       \
                      DescribeKey(displayed)                 \
                      SimulateKeyRelease()                   \n\
          \
          <Btn1Down>: HighlightKey(unlessMod)                \
                      ToggleKey(ifMod)                       \
                      TrackKey(unlessMod)                    \
                      SimulateKeyPress(ifHighlighted)        \
                      SimulateKeyRelease(unlessHighlighted)  \n\
          \
          <Btn1Up>:   UntrackKey(highlighted)                \
                      SimulateKeyRelease(highlighted,unlessMod) \
                      UnhighlightKey(highlighted,unlessMod)  \n\
          \
          <Btn3Down>: XawPositionSimpleMenu(keyMenu)         \
                      MenuPopup(keyMenu)                     \n

     If you don't want a key to be described each time the  mouse
     moves  over it, you can remove the <Motion> action.  In that
     case,  you  should  probably  add   DescribeKey()   to   the
     <Btn1Down> and <KeyDown> actions.

     If you want the key under the mouse  to  be  described  even
     while  the  mouse  is moving with a button down, then remove
     the _u_n_l_e_s_s_T_r_a_c_k_i_n_g parameter  from  the  DescribeKey  action
     bound to <Motion>.

     If you don't want the modifier keys to toggle,  then  change




X Version 11         Last change: 16-Aug-98                    15






User Commands                                         XKeyCaps(1)



     the Button1 actions to

          xkeycaps*Keyboard.actions:  #override               \
                  <Btn1Down>: HighlightKey()                  \
                              TrackKey(unlessmod)             \
                              SimulateKeyPress()              \n\
                  <Btn1Up>:   UntrackKey(highlighted)         \
                              SimulateKeyRelease(highlighted) \
                              UnhighlightKey(highlighted)     \n

     Remember that these actions exist on  the  _K_e_y_b_o_a_r_d  widget,
     not on the _K_e_y widgets.  If you add actions to the _K_e_y widg-
     ets, things will malfunction.

ENVIRONMENT
     DISPLAY
         to get the default host and display number.

     XENVIRONMENT
         to get the name of a resource file  that  overrides  the
         global  resources  stored  in  the RESOURCE_MANAGER pro-
         perty.

     XKEYSYMDB
         to get the location of the XKeysymDB file,  which  lists
         the vendor-specific keysyms.

UPGRADES
     The   latest   version    can    always    be    found    at
     http://www.jwz.org/xkeycaps/

SEE ALSO
     X(1), xmodmap(1), xset(1), xdpyinfo(1)

BUGS
     Because this program has default colors that aren't  "black"
     and  "white", the -rv command-line option doesn't work.  But
     the incantation

          % xkeycaps -fg white -bg black -bd white

     will do what you want on a monochrome screen.

     The NeXT default map is believed to  be  incorrect;  someone
     with access to a NeXT will need to debug this.

     There is no portable way to be sure what keyboard  is  being
     used;  this  means  it will often not default to the correct
     one, and if the user  makes  changes  to  the  keymap  while
     displaying  a  keyboard which is not the right one, very bad
     things can happen.




X Version 11         Last change: 16-Aug-98                    16






User Commands                                         XKeyCaps(1)



     If you depress more than a dozen keys  at  a  time,  many  X
     servers  get  confused, and don't transmit enough KeyRelease
     events; the result of this is that the  _x_k_e_y_c_a_p_s  keys  will
     get  ``stuck'' until they are pressed again.  (Don't go like
     that.)

     The AutoRepeat flag is apparently useless on all  X  servers
     except  the  OpenWindows one (I've never seen another server
     that didn't ignore it.)

     You don't get to select  from  the  set  of  Vendor  keysyms
     (those  keysyms  which  are  defined  in the XKeysymDB file)
     unless you're running X11r5 or newer.

     NCD's non-US keyboards do not use the standard R4/R5 mechan-
     ism  for attaching more than two keysyms to one key; instead
     of simply having three or four keysyms attached to the  key-
     code in question, the Compose key changes the actual keycode
     of the key (it turns its high bit on.)  The xkeycaps program
     doesn't  really  understand  this.  Someone from NCD support
     told me that in future releases  they  will  do  things  the
     R4/R5  way instead of the way they do things now, so hacking
     xkeycaps to understand the current behavior is probably  not
     worth the effort.

     The _T_y_p_e _a_t _W_i_n_d_o_w command  doesn't  seem  to  work  on  the
     WreckStation  version  of XTerm.  I assume some variation of
     the normal XTerm's _A_l_l_o_w _S_e_n_d_E_v_e_n_t_s command is necessary.

     If you can't select anything  from  the  right-button  popup
     menu, it might be because you have NumLock or CapsLock down.
     I'm not sure how to fix this, it seems to be  some  dumb  Xt
     thing.

     If  the  popup  menu  is  always  greyed  out,  or   doesn't
     correspond  to  the  key  that  you  clicked on, it might be
     because you're running _x_s_w_a_r_m, an old version of  _x_a_u_t_o_l_o_c_k,
     or  some  other  program  that  antisocially interferes with
     event-propagation.  (Don't go like that.)

     Because of the nonlinear way  in  which  this  program  uses
     XLookupString,  there's no sensible way for it to do compose
     processing, and show you the  results  of  ``dead''  key  or
     Multi_key sequences.

     It needs to know about more keyboard  types  (and  no  doubt
     always will...)

     L-shaped keys aren't drawn accurately.  We  should  use  the
     Shape extension for that.

     In addition to displaying the ASCII  version  of  the  given



X Version 11         Last change: 16-Aug-98                    17






User Commands                                         XKeyCaps(1)



     character,  it should display the corresponding character in
     the character set (Latin2, Kana, Greek,  etc.)   This  would
     require  having  fonts  for  all  of  those  character sets,
     though, and as far as I can tell, they don't all come  stan-
     dard.

     When running on a Sun and talking to an OpenWindows  server,
     we     should    parse    the    appropriate    file    from
     $OPENWINHOME/etc/keytables/ to determine the default keymap.
     No  doubt  there  are  system-specific ways of doing this in
     other environments as well.

     The HP C compiler complains about "invalid pointer initiali-
     zation"  in  the  header  files.  This is a bug in that com-
     piler, not in xkeycaps.  This compiler bug goes away if  you
     invoke HP's cc with the the -Aa (ANSI) option.

     The _x_m_o_d_m_a_p program still sucks.  Since its _A_D_D  and  _R_E_M_O_V_E
     directives  take  keysyms  as arguments instead of keycodes,
     there are things that you can  do  with  _X_K_e_y_C_a_p_s  that  you
     can't  represent in an _x_m_o_d_m_a_p script (at least, not without
     great pain.)

     The  _x_m_o_d_m_a_p  program  has  no  commands  for  changing  the
     autorepeat  status of keys, so that information is not writ-
     ten in the output.  Perhaps we could write out an  appropri-
     ate   _x_s_e_t  command  instead.   (For  example,  to  turn  on
     autorepeat on PgUp (which happens to have key code  103)  on
     Solaris, you would do: "xset r 103".)

     Some versions of OpenWound use a nonstandard  mechanism  for
     specifying  which  keys  have  toggle  (lock-like)  behavior
     (whereas most other X servers  base  this  behavior  on  the
     keysym:  if  Caps_Lock  or  Shift_Lock is generated, the key
     locks, otherwise it does not.)  _X_K_e_y_C_a_p_s doesn't know how to
     change  the lock status on these servers.  This is because I
     don't know how, either.  If you know what system  calls  are
     necessary to hack this behavior, tell me.

     The _X_K_B interface of X11R6 looks  to  provide  most  of  the
     information  which xkeycaps needs to know, but I haven't had
     time to investigate this yet.

COPYRIGHT
     Copyright cO 1991-1999 by Jamie Zawinski.  Permission to use,
     copy,  modify,  distribute,  and  sell this software and its
     documentation for any purpose is hereby granted without fee,
     provided  that  the  above  copyright  notice  appear in all
     copies and that both that copyright notice and this  permis-
     sion   notice   appear   in  supporting  documentation.   No
     representations are  made  about  the  suitability  of  this
     software  for  any  purpose.  It is provided "as is" without



X Version 11         Last change: 16-Aug-98                    18






User Commands                                         XKeyCaps(1)



     express or implied warranty.

AUTHOR
     Jamie Zawinski <jwz@jwz.org>, 10-nov-91.

     Please send me any changes you make!   Especially  new  key-
     boards.   The strength of this program lies in the fact that
     it knows about so many different keyboards,  thanks  to  the
     hundreds contributions I've received over the years.  If you
     have to make your own modifications, please  do  your  part!
     Send  the  changes back to me so that I can incorporate them
     into a future release.

     Thanks to:
         Jonathan Abbey, Alon  Albert,  Vladimir  Alexiev,  David
         Arnold,  David Axmark, Ruediger Back, Pedro Bayon, Corne
         Beerse, Eric  Benson,  Christoph  Berg,  Markus  Berndt,
         Roger Binns, Stefan Bj|rnelund, black@westford.ccur.com,
         Mark Borges,  Volker  Bosch,  Dave  Brooks,  Lorenzo  M.
         Catucci, Michel Catudal, Francois Regis Colin, John Cop-
         pens, Cesar Crusius, Bart  Van  Cutsem,  Matthew  Davey,
         Christopher  Davis,  Albrecht  Dress,  Kristian  Ejvind,
         Michael  Elbel,  Joe  English,  Eric   Fischer,   Morgan
         Fletcher,   Olivier   Galibert,   Carson  Gaspar,  Andre
         Gerhard, Daniel Glastonbury, Christian F. Goetze, Dan R.
         Greening,  Edgar Greuter, John Gotts, Berthold Gunreben,
         Jens Hafsteinsson, Adam Hamilton, Magnus Hammerin,  Ken-
         neth  Harker,  Ben  Harris,  Mikael Hedin, Tom Ivar Hel-
         bekkmo, Mick Hellstrom, Neil Hendin, Andre Heynatz, Mike
         Hicks,  Alan  Ho,  Hide Horiuchi, Dirk Jablonowski, Alan
         Jaffray, Anders  Wegge  Jakobsen,  Chris  Jones,  Jorgen
         Jonsson,  Peter  Kaiser, Heikki Kantola, Tufan Karadere,
         Benedikt Kessler, Philippe Kipfer, Edwin  Klement,  John
         Knox,  Haavard  Kvaalen, Frederic Leguern, Simon Leinen,
         Michael Lemke, Tor Lillqvist,  Torbj|rn  Lindgren,  Tony
         Lindstrom, Richard Lloyd, Ulric Longyear, Ulf Magnusson,
         Cliff Marcellus, John A. Martin,  Tom  McConnell,  Grant
         McDorman, Hein Meling, Jason Merrill, Aleksandar Milivo-
         jevic, Manuel Moreno, Ken Nakata, Pekka  Nikander,  Todd
         Nix,  Leif  Nixon,  Christian Nybo, Antoni Pamies Olive,
         Edgar Bonet Orozco,  Steven  W.  Orr,  Martin  Ouwehand,
         Daniel  Packman,  John  Palmieri,  Chris  Paulson-Ellis,
         Eduardo  Perez,  Michael  Piotrowski,  Andrej   Presern,
         Jeremy Prior, Dominique Quatravaux, Matthias Rabe, Garst
         R. Reese, Peter Remmers, Todd Richmond, Ken Rose,  Pavel
         Rosendorf,   Gael  Roualland,  Lucien  Saviot,  Johannes
         Schmidt-Fischer, Andreas Schuch,  Larry  Schwimmer,  Joe
         Siegrist,  Jarrod Smith, Tom Spindler, Robin Stephenson,
         Joerg Stippa,  D.  Stolte,  A.  A.  Stoorvogel,  Juergen
         Stuber,  Markus  Stumpf,  Jeffrey  Templon,  Jay Thorne,
         Anthony Thyssen, Christoph Tietz,  tkil@scrye.com,  Juha
         Vainikka,  Poonlap  Veeratanabutr,  Ivo  Vollrath,  Gord



X Version 11         Last change: 16-Aug-98                    19






User Commands                                         XKeyCaps(1)



         Vreugdenhil, Ronan Waide, Jan Wedekind, Bj|rn  Wennberg,
         Mats  Wichmann,  Stephen  Williams, Barry Warsaw, Steven
         Winikoff, Carl Witty, Stephen Wray, Endre Witzoe,  Kazu-
         taka Yokota, Yair Zadik, and Robert Zwickenpflug.



















































X Version 11         Last change: 16-Aug-98                    20



